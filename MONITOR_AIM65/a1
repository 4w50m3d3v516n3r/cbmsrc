
; E=ENTER EDITOR
; T=RE-ENTER EDITOR TO RE-EDIT SOURCE
; R=SHOW REGISTERS
; M=DISPLAY MEMORY
;  =SHOW NEXT 4 ADDRESSES
; G=GO AT CURENT P.C. (COUNT)
; /=ALTER CURRENT MEMORY
; L=LOAD OBJECT
; D=DUMP OBJECT
; N=ASSEMBLE
; *=ALTER P.C.
; A=ALTER ACCUMULATOR
; X=ALTER X REGISTER
; Y=ALTER Y REGISTER
; P=ALTER PROCESSOR STATUS
; G=ALTER STACK POINTER
; B=SET BREAK ADDR
; ?=SHOW BREAK ADDRESSES
; $=CLEAR BREAK ADDRESSES
; H=SHOW TRACE HISTORY STACK
; V=TOGGLE REGISTER PRINT WITH DIS
; Z=TOGGLE DISASSEMBLER TRACE
; \=TURN ON/OFF PRINTER
;  =ADV PAPER
; I=MNEMNOIC ENTER
; K=DISASSEMBLE MEMORY
; 1=TOGGLE TAPE 1 CONTROL (ON OR OFF)
; 2=TOGGLE TAPE 2 CONTROL
; 3=VERIFY CKSUM FOR TAPES
; 4=ENABLE BREAKS
; 5=BASIC ENTRY (COLD)
; 6=BASIC REENTRY (WARM)
;
;FOLLOWING KEYS ARE UNUSED BUT 'HOOKS"
;ARE PROVIDED IN LOCATIONS 010C-0114
;
; KEYF1,KEYF2,KEYF3

	*=$E000
;ALL MSGS HAVE MSB=1 OF LAST CHAR TO END IT
M1	.BYT 'FROM',EQS
M3	.BYT 'TO',EQS
M4	.BYT ' **** PS AA XX YY S',$D3
M5	.BYT 'MORE',$BF
M6	.BYT 'ON',$A0    ;'ON '
M7	.BYT 'OF',$C6    ;'OFF'
M8	.BYT 'BR',$CB    ;'BRK'
M9	.BYT 'IN',EQS
M10	.BYT 'OUT',EQS
M11	.BYT ' MEM FAIL',$A0
M12	.BYT ' PRINTER DOW',$CE
TMSG0	.BYT ' SRCH'
TMSG1	.BYT ' F',EQS
TMSG2	.BYT 'T',EQS
TMSG3	.BYT $A0,$C5,$D2,$D2     ;PRINT ' ERROR' ,MSB=1
	.BYT $CF,$D2,$A0,$A0,$A0,$A0,$A0,$A0,';'
TMSG5	.BYT 'A',EQS
TMSG6	.BYT 'BLK=',$A0
TMSG7	.BYT $A0,$CC,$CF,$C1,$C4,';'
EMSG1	.BYT 'EDITO',$D2         ;EDITOR MESSAGES
EMSG2	.BYT 'EN',$C4
.PAGE 'INTERRUPT HANDLING'
;VECTORS COME HERE FIRST AFTER JUMP THRU FFFA-FFFF
NMIV1	JMP (NMIV2)      ;NMIV2 IS A VECTOR TO NMIV3
IRQV1	JMP (IRQV2)      ;IRQV2 IS A VECTOR TO IRQV3

;SINGLE STEP ENTRY POINT (NMI)
NMIV3	STA SAVA         ;SAVE ACCUM
	PLA
	STA SAVPS        ;SAVE PROCESSOR STATUS
	CLD
	STX SAVX         ;SAVE X
	STY SAVY
	PLA
	STA SAVPC        ;PROGRAM COUNTER
	PLA
	STA SAVPC+1
	TSX              ;GET STACK POINTER & SAVE IT
	STX SAVS
;TRACE THE ADDRESS
	LDY HISTP        ;GET POINTER TO HISTORY STACK
	LDA SAVPC+1      ;SAVE HALT ADDR IN HISTORY STACK
	STA HIST,Y
	LDA SAVPC
	STA HIST+1,Y
	JSR NHIS         ;UPDATE POINTER
	LDA BKFLG        ;SOFT BRAKS ON?
	BEQ NMI5         ;NO, DON'T CHCK BRKPOINT LIST
	JSR CKB          ;CHECK BREAKPOINT LIST
	BCC NMI5
NMI4	JMP IRQ2         ;HIT A BREAK-TRAP TO MONITOR
NMI5	JSR DONE         ;COUNT =0?
	BEQ NMI4         ;YES, TRAP TO MONITOR
	JSR RCHEK        ;CHK IF HE WANTS TO ITNERR
	JMP GOBK         ;NOT DONE-RESUME EXECUTION

;POWER UP AND REST ENTRY POINT (RST TRANSFERS HERE)
RSET	CLD              ;CLEAR DEC MODE
	SEI              ;DISBALE INTERRUPT
	LDX #$FF         ;INIT STACK POINTER
	TXS
	STX SAVS         ;ALSO INIT SAVED STACK PTR
;INITIALIZE 6522
	LDX #14
RS1	LDA INTAB1,X     ;PB1-PB0,PA7-PA0 FOR PRNTR
	STA DRB,X        ;PB2=TTO,PB6=TTI
	DEX              ;PB4-PB5=TAPE CONTROL,PB7=DATA
	BPL RS1          ;PB3=SWITCH KB/TTY
;INITIALIZE 6532
	LDX #3           ;PORTS USED FOR KB
RS2	LDA INTAB2,X     ;PA0-PA7 AS OUTPUT
	STA DRA2,X       ;PB0-PB7 AS INPUT
	DEX
	BPL RS2
;INITIALIZE MONITOR RAM (6532)
	LDA INTAB3       ;CHECK IF NMIV2 HAS BEEN CHANGED
	CMP NMIV2        ;IF IT HAS THEN ASSUME A COLD
	BNE RS3A         ;START AND INITIALZE EVERYTHING
	LDA INTAB3+1
	CMP NMIV2+1
	BNE RS3A
	LDX #16          ;THEY ARE EQUAL ,IT'S A WARM RESET
	BNE RS3
RS3A	LDX #0           ;INIT EVERYTHING (POWER UP)
RS3	LDA INTAB3,X
	STA NMIV2,X
	INX
	CPX #21
	BCC RS3
;INITIALIZE DISPLAY (6520)
	LDA #0           ;SET CONTR REG FOR DATA DIR REG
	LDX #1
	JSR SETREG
	LDA #$FF         ;SET DATA DIR REG FOR OUTPUT
	DEX
	JSR SETREG
	LDA #$04         ;SET CONTR REG FOR PORTS
	INX
	JSR SETREG
	BNE RS3B
SETREG	STA RA,X
	STA RB,X
	RTS
RS3B	CLI              ;CLEAR INTRERRUPT

;KB/TTY SWITCH TEST AND BIT RATE MEASUREMENT
	LDA #$08         ;PB3=SWITCH KB/TTY
RS4	BIT DRB          ;A^M ,PB6-> V (OVERFLOW FLG)
	BNE RS7          ;BRANCH ON KB
	BVS RS4          ;START BIT=PB6=0?
	LDA #$FF         ;YES ,INITIALIZE TIMER T2
	STA T2H
RS5	BIT DRB          ;END OF START BIT ?
	BVC RS5          ;NO ,WAIT UNTIL PB6 BACK TO 1
	LDA T2H          ;STORE TIMING
	EOR #$FF         ;COMPLEMENT
	STA CNTH30
	LDA T2L
	EOR #$FF
	JSR PATCH1       ;ADJUST IT
RS6	JSR CRLOW        ;CLEAR DISPLAY
	JMP PAT21
RS7	LDX #19          ;CLEAR HARDARE CURSORS
RS8	TXA
	PHA
	LDA #0
	JSR OUTDD1
	PLA
	TAX
	DEX
	BPL RS8
	BMI RS6

;BRK INSTR (00) OR IRQ ENTRY POINT
IRQV3	STA SAVA
	PLA
	PHA              ;GET STATUS
	AND #$10         ;SEE IF 'BRK' , ISOLATE B FLAG
	BNE IRQ1         ;TRAP WAS CAUSED BY 'BRK' INSTRUC
	LDA SAVA         ;TRAP CAUSED BY IRQ SO TRANSFER
	JMP (IRQV4)      ;CONTROL TO USER THRU VECTOR
;IS 'BRK' INSTR ,SHOW PC & DATA
;PC IS OFF BY ONE , SO ADJUST IT
IRQ1	PLA
	STA SAVPS        ;SAVE PROCESSOR STATUS
	STX SAVX
	STY SAVY
	CLD
	PLA              ;PROG CNTR
	SEC              ;SUBTRACT ONE FROM RETURN ADDR
	SBC #1
	STA SAVPC
	PLA
	SBC #0
	STA SAVPC+1
	TSX              ;GET STACK PTR & SAVE IT
	STX SAVS
;SHOW PC AND DATA
IRQ2	JSR REGQ         ;SHOW NEXT INSTRUCTION & CONTINUE
.PAGE 'INTERPRET COMMANDS'
;THIS ROUTINE WILL GET A CHR WITH '( )' FROM
;KB/TTY & THEN WILL GO TO THE RESPECTIVE COMMAND
START	JMP PAT19        ;CLEAR DEC MODE & (CR)
STA1	LDA #$BC         ;'(' CHR WITH MRB=1 FRO DISP
	JSR OUTPUT
	JSR RED1         ;GET CHR & ECHO FROM KB/TTY
	PHA
	LDA #'>
	JSR OUTPUT
	PLA              ;SCAN LIST OF CMNDS FOR ENTERED CHR
	LDX #MCNT        ;COUNT OF COMMANDS
MCM2	CMP COMB,X       ;CHECK NEXT COMMAND IN LIST
	BEQ MCM3         ;MATHC , SO PROCESS THIS COMMAND
	DEX
	BPL MCM2
;IS BAD COMMAND
	JSR QM
COMIN	CLD
	JSR LL
	LDX SAVS
	TXS
	JMP START
;HAVE VALID COMMAND
MCM3	TXA              ;CONVERT TO WORD (MULT BY 2)
	ASL A            ;2 BYTES (ADDR)
	TAX
	LDA MONCOM,X     ;GET ADDRESS OF COMMAND PROCESSOR
	STA JUMP
	LDA MONCOM+1,X
	STA JUMP+1
	JSR JMPR         ;CMD PROOCESSORS CAN EXIT WITH 'RTS'
	JMP START
JMPR	JMP (JUMP)       ;GO TO COMMAND

;VALID COMMANDS
MCNT=32                  ;COUNT
COMB	.BYT 'ETRMG/LDN*AXYPS '
	.BYT 'B?#HVZIK123456[]',$5E

MONCOM	.WOR EDIT,REENTR,REG,MEM,GO
	.WOR CHNGG,LOAD,DUMP,ASSEM,CGPC,CGA
	.WOR CGX,CGY,CGPS,CGS,NXT5,BRKA
	.WOR SHOW,CLRBK,SHIS,REGT,TRACE
	.WOR MNEENT,KDISA,TOGTA1,TOGTA2,VECKSM
	.WORD BRKK,BASIEN,BASIRE
;USER DEFINED FUNCTIONS
	.WOR KEYF1,KEYF2,KEYF3
.PAGE 'COMMANDS'
;***** R COMMAND-DISPLAY REGISTERS *****
REG	JSR CRLOW        ;CLEAR DISPLAY IF KB
	LDY #M4-M1       ;MESSAG & (CR)
	JSR KEP
	JSR CRCK
REG1	JSR BLANK
	LDY #SAVPC-ADDR  ;OUTPUT PGR CNTR (SAVPC)
	JSR WRITAD
	LDA #<SAVPS      ;NOW THE OTEHR 5 REGS
	STA ADDR
	LDA #>SAVPS
	STA ADDR+1
	LDX #5           ;COUNT
	BNE MEM1         ;SHARE CODE

;***** M COMMAND-DISPLAY MEMORY *****
MEM	JSR ADDIN        ;GET START ADDRESS IN ADDR
	BCS MEM3
MEIN	LDX #4
MEM1	LDY #0
MEM2	JSR BLANK
	LDA #<ADDR
	JSR LDAY         ;LOAD CONTENTS OF CURR LOCATION
	JSR NUMA         ;AND DISPLAY IT AS 2 HEX DIGITS
	INY
	DEX              ;DECR COUNTER
	BNE MEM2
MEM3	RTS

;***** G COMMAND-RESTART PROCESSOR *****
GO	JSR PSL1         ;'/'
	JSR GCNT         ;GET COUNT
	JSR CRLF
	JMP GOBK1        ;RESUME EXECUTION
GOBK	LDA REGF         ;DISPLAY REGISTERS ?
	BEQ GOBK0        ;NO,BRANCH
	JSR REG1         ;SHOW THE SIZ REG
	JSR CRCK         ;(CR)
GOBK0	JSR RCHEK        ;SEE IF HE WANTS TO INTERRUPT
	LDA DISFLG       ;DISASSEMBLE CURRENT INSTR?
	BEQ GOBK1        ;NO,BRANCH
	JSR DISASM       ;DISASM THIS INSTRUCTION
	JSR CRLOW
GOBK1	LDX SAVS         ;RESTORE SAVED REGS FOR RTI
	TXS
	LDY SAVY
	LDX SAVX
	LDA SAVPC+1
	PHA              ;PUT PC ON STACK
	LDA SAVPC
	PHA
	LDA SAVPS        ;STATUS ALSO
	PHA
	LDA SAVA
	RTI              ;AND AWAY WE GO
;***** / COMMAND-ALTER MEMEORY *****
CHNGG	JSR BLANK
	JSR WRITAZ       ;WRITE ADDR
CHNG1	JSR BLANK
	JSR RD2          ;GET VALUE
	BCC CH2          ;ISN'T SKIP OR DONE
	CMP #' 
	BNE CH3          ;NOT BLANK SO MUST BE DONE
;SKIP THIS LOCATION
	JSR BLANK
	JMP CH4
;IS ALTER
CH2	JSR SADDR        ;STORE ENTERED VALUE INTO MEMORY
	BEQ CH4          ;NO ERROR IN STORE
	JMP MEMERR       ;MEMORY WRITE ERROR
CH4	INY
	CPY #4
	BNE CHNG1        ;GO AGAIN
;HAVE DONE LINE OR HAVE (CR)
CH3	JSR NXTADD       ;UPDATE THE ADDRESS
	LDA #CR          ;CLEAR DISPL
	JMP PATC10       ;ONLY ONE (CR) & BACK TO MONITOR

NXTADD	TYA              ;ADD Y TO ADDR+1,ADDR
	CLC
	ADC ADDR
	STA ADDR
	BCC NXTA1
	INC ADDR+1
NXTA1	RTS

;WRITE CURRENT VALUE OF ADDR
;PART OF / & SPACE COMM
WRITAZ	LDY #0
WRITAD	LDA ADDR+1,Y
	LDX ADDR,Y
	JMP WRAX


;***** L COMMAND-GENERAL LOAD *****
;LOAD OBJECT FROM TTY,USER,TAPE OR TAPE IN KIM-1 FORMAT
LOAD	JSR WHEREI       ;WHERE INPUT
;GET ':' , # OF BYTES AND SA
LOAD1	JSR INALL        ;GET FIRST CHAR
	CMP #';          ;LOOK FOR BEGINNING
	BNE LOAD1        ;IGNORE ALL CHARS BEFORE ';'
	JSR CLRCK        ;CLEAR CHECKSUM
	JSR CHEKAR       ;READ UPPER HALF OF ADDRESS
	TAX              ;SAVE IN X THE # BYTES
	JSR CHEKAR       ;READ UPPER HALF OF ADRESS
	STA ADDR+1
	JSR CHEKAR       ;READ LOWER HALF OF ADDRESS
	STA ADDR
	TXA
	BEQ LOAD4        ;LAST RECORD (RECORD LENGTH=0)
;GET DATA
LOAD2	JSR RBYTE        ;READ NEXT BYTE OF DATA
	JSR STBYTE       ;STORE AT LOC (ADDR+1,ADDR)
	DEX              ;DECR RECORD LENGTH
	BNE LOAD2
;COMPARE CKSUM
	JSR RBYTE        ;READ UPPER HALF OF CHCKSUM
	CMP CKSUM+1      ;COMPARE TO COMPUTED VALUE
	BNE CKERR
	JSR RBYTE        ;READ LOWER HALF OF CHECKSUM
	CMP CKSUM
	BNE CKERR
	BEQ LOAD1        ;UNTIL LAST RECORD
LOAD4	LDX #5           ;READ 4 MORE ZEROS
LOAD5	JSR RBYTE
	DEX
	BNE LOAD5
	JSR INALL        ;READ LAST (CR)
	JMP DU13         ;SET DEFAULT DEV & GO BACK

;LOAD ROUTINE FROM TAPE BY BLOCKS
;CHECK FOR RIGHT FILE & LAOD FIRST BLOCK
LOADTA	LDA #$00         ;CLEAR BLOCK COUNT
	STA BLK
	JSR TIBY1        ;LOAD BUFFER WITH BLOCK
	DEX              ;SET X=0
	STX CURPO2       ;CLEAR DISPLAY PTR
	LDA TABUFF,X     ;BLK COUNT SHOULD BE ZERO
	BNE LOADTA       ;NO, READ ANOTEHR BLOCK
	INX
;AFTER FIRST BLOCK OUTPUT FILE NAME
	INC PRIFLG       ;SO DO NOT GO TO PRINT
	LDY #TMSG0-M1    ;PRINT 'F='
	JSR KEP
LOAD1A	LDA TABUFF,X     ;OUTPUT FILE NAME
	JSR OUTPUT       ;ONLY TO DISPLAY
	INX
	CPX #6
	BNE LOAD1A
	JSR BLANK
	LDY #TMSG6-M1    ;PRINT 'BLK=  '
	JSR KEP
	DEC PRIFLG       ;RESTORE PRINTR FLG
	JSR ADDBK1       ;JUST OUTPUT BLOCK COUNT
	LDX #1           ;RESTORE X
;CHECK IF FILE IS CORRECT
LOADT2	LDA TABUFF,X     ;NOW CHEK FILE NAME
	CMP NAME-1,X
	BNE LOADTA       ;IF NO FILENAME GET
	INX              ;ANOTHER BLOCK
	CPX #6           ;FILENAME=5 CHRS
	BNE LOADT2
	STX TAPTR        ;SAVE TAPE BUFF PTR
	INC PRIFLG       ;OUTPUT MS ONLY TO DISPLAY
	LDA #0           ;CLEAR DISPLAY POINTER
	STA CURPO2
	LDY #TMSG7-M1    ;PRINTF 'LOAD ' WITHOUT CLR DISPL
	JSR CKER1
	DEC PRIFLG
	RTS

;LINE CKSUM ERROR
CKERR	JSR CKERO        ;SUBR SO MNEM ENTRY CAN USE IT
	JSR WRITAZ       ;WRITE ADDR
	JMP COMIN
CKERO	JSR LL           ;SET DEFAULT DEVICES
	JSR CRCK         ;(CR)
CKERO0	LDY #TMSG3-M1    ;PRINT 'ERROR'
CKER1	LDA M1,Y         ;DONT CLR DISPLAY TO THE RIGHT
	CMP #';
	BEQ CKER2
	JSR OUTPUT       ;ONLY TO TERMINAL
	INY
	BNE CKER1
CKER2	RTS

;LOAD ROUTINE FROM TAPE WITH KIM-1 FORMAT
LOADKI	JSR CLRCK        ;CLEAR CKSUM
LOADK1	JSR TAISET       ;SET TAPE FOR INPUT
LOADK2	JSR GETTAP       ;READ CHARACTER FROM TAPE
	CMP #'*          ;BEGINNING OF FILE?
	BEQ LOADK3       ;YES,BRANCH
	CMP #$16         ;IF NOT * SHOULD BE SYN
	BNE LOADK1
	BEQ LOADK2
LOADK3	JSR RBYTE        ;READ ID FROM TAPE
	STA SAVA         ;SAVE ID
;NOW GET ADDR TO DISPLAY
;& COMPARE ID AFTERWARDS
	JSR CHEKAR       ;GET START ADDR LOW
	STA ADDR
	JSR CHEKAR       ;GET START ADDR HIGH
	STA ADDR+1
	JSR GETID        ;ID FROM HIM
	CMP SAVA         ;DO IDS MATCH?
	BNE LOADKI       ;NO ,GET ANOTHER FILE
LOADK5	LDX #$02         ;GET 2 CHARS
LOADK6	JSR GETTAP       ;1 CHAR FROM TAPE
	CMP #'/          ;LAST CHAR?
	BEQ LOADK7       ;YES,BRNCH
	JSR PACK         ;CONVERT TO HEX
	BCS CKERR        ;NOT HEX CHAR SO ERROR
	DEX
	BNE LOADK6
	JSR STBYTE       ;STORE & CHCK MEM FAIL
	JMP LOADK5       ;NEXT
LOADK7	JSR RBYTE        ;END OF DATA CMP CKSUM
	CMP CKSUM        ;LOW
	BNE CKERR
	JSR RBYTE
	CMP CKSUM+1      ;HIGH
	BNE CKERR
	PLA              ;CORRECT RTN INSTEAD OF WHEREI
	PLA
	JMP DU13         ;TELL HIM & GO BACK TO COMMAN

;GET 2 ASCII CHRS INTO 1 BYTE
;FRO TAPE (T) GET ONLY ONE HEX CHR
RBYTE	LDA INFLG        ;INPUT DEVICE
	CMP #'T
	BNE RBYT1
	JMP INALL        ;ONLY ONE BYTE FOR T (INPUT DEV)
RBYT1	JSR INALL
	JSR PACK
	JSR INALL
	JMP PACK

;STORE AND CHECK MEMORY FAIL
STBYTE	JSR CHEKA        ;ADD TO CHSUM
	LDY #0
	JSR SADDR        ;STORE AND CHCK
	BEQ *+5
	JMP MEMERR       ;MEMORY WRITE ERROR
	LDY #1           ;INC ADDR+1,ADDR BY 1
	JMP NXTADD

;GET ID FROM LAST 2 CHR OF FILNAM
GETID	LDX #4           ;SEE WHAT HE GAVE US
GID1	LDA NAME,X       ;GET LAST 2 CJHARD
	DEX
	CMP #$20         ;(SPACE) ?
	BEQ GID1
	LDA NAME,X       ;CONVERT TO BINARY
	JSR PACK
	LDA NAME+1,X
	JMP PACK         ;ID IS IN STY

;***** D COMMAND-GENERAL DUMP *****
;TO TTY,PRINTR,USER,X ,TAPE,TAKIM-1
DUMP	LDA BKFLG        ;SAVE IT TO USE IT
	PHA
	LDA #00
	STA BKFLG
DU1	JSR CRCK         ;(CR)
DU0	JSR FROM         ;GET START ADDR
	BCS DU0          ;IN CASE OF ERROR DO IT AGAIN
	JSR BLANK
	JSR ADDRS1       ;TRANSFER ADDR TO S1
DU1B	JSR TO           ;GET END ADDR
	BCS DU1B
	JSR CRLOW
	LDA BKFLG        ;EXECUTE WHEREO ONLY ONCE
	BNE DV1A
	JSR WHEREO       ;WHICH DEV (OUTFLG)
	LDA #0
	STA S2           ;CLEAR RECORD COUNT
	STA S2+1
	INC BKFLG        ;SET FLG
;CHCK OUTPUT DEV
DV1A	LDA OUTFLG
	CMP #'K          ;TAPE FOR KIM?
	BNE *+6
	PLA              ;PULL FLG
	JMP DUMPKI       ;YES, GO OUTPUT WHOLE FILE
	LDY #1           ;OUTPUT ONE MORE BYTE
	JSR NXTADD
DU2	JSR CRLF
	JSR RCHEK        ;SEE IF HE WANTS TO INTERRUPT
;CALCULATE # OF BYTES YET TO BE DUMPED
	JSR CLRCK        ;CLEAR CKSUM
	LDA ADDR         ;END ADDRESS-CURRENT ADDRESS
	SEC
	SBC S1
	PHA              ;# OF BYTES LOW
	LDA ADDR+1
	SBC S1+1
	BNE DU6          ;# OF BYTES HIGH
;SEE IF 24 OR MORE BYTES TO GO
	PLA              ;# BYTES HIGH WAS ZERO
	BEQ DU10         ;ARE DONE
	CMP #24          ;# BYTES > 24 ?
	BCC DU8          ;NO ,ONLY OUTPUT REMAINING BYTES
	BCS DU7          ;YES ,24 BYETS IN NEXT RECORD
DU6	PLA
DU7	LDA #24
;OUTPUT ";" ,# OF BYTES AND SA
DU8	PHA
	JSR SEMI         ;SEMICOLON
	PLA
	STA COUNT        ;SAVE # OF BYTES
	JSR OUTCK        ;OUTPUT # OF BYTES
	LDA S1+1         ;OUTPUT ADDRESS
	JSR OUTCK
	LDA S1
	JSR OUTCK
;OUTPUT DATA
DU9	JSR OUTCKS       ;GET CHAR SPEC BY S1 (NO PAG 0)
	LDA #0           ;CLEAR DISP PTR
	STA CURPO2
	JSR ADDS1        ;INCR S1+1,S1
	DEC COUNT        ;DECREMENT BYTE COUNT
	BNE DU9          ;NOT DONE WITH THIS RECORD
;OUTPUT CKSUM
	LDA CKSUM+1
	JSR OUTCK1       ;WITHOUT CHEKA
	LDA CKSUM
	JSR OUTCK1
	JSR INCS2        ;INC VERTICAL COUNT
	JMP DU2          ;NEXT RECORD
;ALL DONE
DU10	LDY #M5-M1       ;PRINT 'MORE ?#
	JSR KEPR         ;OUTPUT MESSAGE AND GET AN ANSWER
	CMP #'Y
	BNE *+5
	JMP DU1          ;DUMP MORE DATA
	PLA              ;RESTORE FLG
	STA BKFLG
;OUTPUT LAST RECORD
	JSR INCS2
	JSR SEMI         ;OUTPUT ';'
	LDX #2
	LDA #0           ;OUTPUT # OF BYTES (0=LAST RECORD)
	JSR OUTCK1
DU10A	LDA S2+1         ;OUTPUT RECORD COUNT
	JSR OUTCK1       ;CHECKCUM IS THE SAME
	LDA S2
	JSR OUTCK1
	DEX
	BNE DU10A
	JSR CRLF
;CLOSE TAPE BLOCK IF ACTIVE
DU11	LDA OUTFLG
	CMP #'T
	BNE DU13         ;NO ,BRANCH
DU12	LDA TAPTR2       ;TAP OUTPUT BUFF PTR
	CMP #1           ;BECAUSE FIRST ONE IS BLOCK COUNT
	BEQ DU13         ;NO DATA TO WRITE
	LDA #0           ;FILL REST BUFF ZEROS
	JSR TOBYTE       ;OUTPUT TO BUFF
	JMP DU12         ;FINISH THIS BLOCK
DU13	JSR CRLOW
	CLC              ;ENABL INTERR
	LDA #T1I         ;T1 FROM FREE RUNNING ONE SHOT
	STA ACR
DU14	LDA #$34         ;SET BOTH TAPES ON
	STA DRB
	JMP LL

;GET CHARACTER SPECIFIED BY START ADDR (S1)
OUTCKS	LDA #<S1
	LDY #0
	JSR LDAY

;ADD TO CHECKSUM AND PRINT
OUTCK	JSR CHEKA        ;CHCKSUM
OUTCK1	PHA
	LDA OUTFLG       ;IF TAPE DO NOT CNVRT
	CMP #'T          ;TO TWO ASCII CHRS
	BNE OUTCK2
	PLA
	JMP TOBYTE       ;OUTPUT TO TAP BUFF
OUTCK2	PLA
	JMP NUMA         ;TWO ASCII REPRE

CHEKAR	JSR RBYTE        ;TWO ASCI CHR---> 1 BYTE
CHEKA	PHA              ;ADD TO CHECKSUM
	CLC
	ADC CKSUM
	STA CKSUM
	BCC *+5
	INC CKSUM+1
	PLA
	RTS

;ADD ONE TO START ADDR (S1)
ADDS1	INC S1
	BNE ADD1
	INC S1+1
ADD1	RTS

INCS2	INC S2           ;INCR VERTICAL COUNT
	BNE *+5
	INC S2+1
	RTS

;OPEN A FILE FOR OUTPUT TO TAPE BY BLOCKS
;OUTPUT FILENAME GIVEN BY JSR WHEREO TO TAPE BUFF
DUMPTA	LDX #0           ;INITIALIZE TAPTR
	TXA              ;TO OUTPUT
	STX BLKO         ;BLOCK COUNTER
	STX TAPTR2       ;TAP OUTPUT BUFF PTR
	JSR TOBYTE       ;TWO START OF FILE CHRS
DUMPT1	LDA NAME,X       ;OUTPUT FILENAME
	JSR TOBYTE
	INX
	CPX #5           ;5 FILENAME CHRS ?
	BNE DUMPT1
	RTS

;DUMP ROUTINE TO TAPE WITH KIM-1 FORMAT
DUMPKI	JSR TAOSET       ;SET TAPE FOR OUTPUT
	LDA #'*          ;TO EITHER 1 OR 2
	JSR OUTTAP       ;DIRECTLY TO TAPE
;ID FROM LAST 2 CHRS OF FILENAME
	JSR GETID
	JSR OUTCK1
	JSR CLRCK
;STARTING ADDR
	LDA S1
	JSR OUTCK        ;WITH CHCKSUM
	LDA S1+1
	JSR OUTCK
;OUTPUT DATA
DUK2	JSR OUTCKS       ;OUTPUT CHR SPECIFIED BY S1+1,S1
	JSR ADDS1        ;INCREM S1+1,S1
	LDA S1           ;CHCK FOR LAST BYTE
	CMP ADDR         ;LSB OF END ADDR
	LDA S1+1
	SBC ADDR+1
	BCC DUK2         ;NEXT CHR
;NOW SEND END CHR '/'
	LDA #$2F
	JSR OUTTAP       ;DIRECTLY TO TAPE
;CHECKSUM
	LDA CKSUM
	JSR NUMA         ;ASCII REPRES
	LDA CKSUM+1
	JSR NUMA
;TWO EOT CHRS
	LDA #$04
	JSR OUTTAP
	JSR OUTTAP
;TURN TAPES ON
	JMP DU13

;***** * COMMAND-ALTER PROGRAM COUNTER *****
CGPC	JSR ADDIN        ;ADDR <=ADDRESS ENTERED FROM KB
CGPC0	JSR CGPC1        ;TRANSFER ADDR TO SAVPC
	JMP CRLOW
CGPC1	LDA ADDR+1       ;THIS WAY MNEMONICS CAN USE IT
	STA SAVPC+1
	LDA ADDR
	STA SAVPC
	RTS

;***** P COMMAND-ALTER PROCESSOR STATUS *****
CGPS	LDX #0
	BEQ CGALL

;***** A COMMAND-ALTER ACCUMULATOR *****
CGA	LDX #1
	BNE CGALL

;***** X COMMAND-ALTER X REGISTER *****
CGX	LDX #2
	BNE CGALL

;***** Y COMMAND-ALTER Y REGISTER *****
CGY	LDX #3
	BNE CGALL

;***** S COMMAND-ALTER STACK POINTER *****
CGS	LDX #4
CGALL	JSR EQUAL        ;PRINT PROMPT
	JSR RD2          ;GET VALUE FORM KEYBAORD
	BCS GOERR
	STA SAVPS,X
	RTS
GOERR	JSR QM
	BNE CGALL

;***** (SPACE) COMMAND-SHOW NEXT 5 MEMORY LOC *****
NXT5	JSR BLANK
	LDY #4           ;UPDATE ADDR FROM
	JSR NXTADD       ;(M)=XXXX
	JSR WRITAZ       ;OUTPUT ADDRESS
	JMP MEIN         ;DISPLAY CONTEXT OF NEXT 4 LOCS

;***** B COMMAND-SET BREAKPOINT ADDR *****
BRKA	LDY #M8-M1       ;PRINT 'BRK'
	JSR KEP
BRK1	JSR PSL1         ;PRINT '/'
	JSR REDOUT       ;GET BREAK NUMBER
	SEC
	SBC #$30         ;0 THRU 3
	BMI BKERR        ;CHARACTER < '0' - ILLEGAL
	CMP #4           ;FOUR BREAKPOINTS
	BMI BKOK         ;0 < CHARACTER < 4 -OK
BKERR	JSR QM           ;ERROR
	BNE BRK1         ;ALLOW REENTRY OF BREAK NUMBER
BKOK	ASL A            ;*2 TO FORM WORD OFFSET
	PHA              ;SAVE IT
	JSR ADDIN        ;GET ADDRESS FOR BREAKPOINT
	PLA
	BCS BK02         ;BAD ADDRESS ENTERED
	JSR PATC18       ;(CR) & CLR BUFFERS
	TAX              ;# OF BRK
	LDA ADDR         ;STORE ENTERED ADDR IN BRKPT LIST
	STA BKS,X
	LDA ADDR+1
	STA BKS+1,X
BK02	RTS              ;ALL DONE

;***** ? COMMAND-SHOW CURRENT BREAKPOINTS *****
SHOW	LDY #0
	JSR CRLOW
SH1	JSR BLANK
	LDX BKS,Y        ;ADDRESS OF NEXT BREAKPOINT
	LDA BKS+1,Y
	JSR WRAX         ;SHOW BREAKPOITN ADDRESS
	INY
	INY
	CPY #8
	BNE SH1
	RTS

;***** H COMMAND-SHOW TRACE STACK HISTORY *****
;LAST FIVE INSTR ADDRS
SHIS	LDX #5           ;NUMBER OF ENTRIES
	STX STIY+2
SHI1	LDY HISTP        ;POINTER TO LATETS ENTRY
	JSR CRLOW
	JSR BLANK
	LDA HIST,Y       ;OUTPUT ADDRESS OF ENTRY
	JSR NUMA
	LDA HIST+1,Y
	JSR NUMA
	JSR NHIS         ;UPDATE POINTER
	DEC STIY+2
	BNE SHI1
	RTS

;UPDATE HISTORY POINTER (PART OF H)
NHIS	INY
	INY
	CPY #10
	BNE NH1
	LDY #0           ;WRAPAROUND AT 10
NH1	STY HISTP
	RTS

;***** 3 COMMAND-VERIFY TAPES *****
;VERIFY CKSUM OF BLOCKS
VECKSM	JSR WHEREI       ;GET THE FILE
	JSR INALL        ;CHK OBJ OR SOURCE
	CMP #CR          ;FIRST CHR IS (CR) IF OBJ
	BNE VECK2        ;ASSUME SOURCE CODE
VECK1	JSR INALL        ;OBJECT FILE
	CMP #';
	BNE VECK1        ;IGNORE ALL CHARS BEFORE ';'
	JSR INALL
	JMP PAT20
	NOP
VECK2	JSR INALL        ;IT IS TEXT
	CMP #CR
	BNE VECK2
	JSR INALL        ;NEED TWO (CR) TO FINISH
	CMP #CR
	BNE VECK2
	JMP DU13         ;CLOSE FILE, IT IS OK

;***** 1 COMMAND-TOGGLE TAPE 1 CONTROL *****
TOGTA1	LDA DRB
	EOR #$10         ;INVERT PB4
	STA DRB
	AND #$10
	BEQ BRK3         ;IF 0 TAPE CNTRL IS ON
	BNE BRK4         ;IF $10 TAPE CNTRL IS OFF

;***** 2 COMMAND-TOGGLE TAPE 2 CONTROL
TOGTA2	LDA DRB
	EOR #$20         ;INVERT PB5
	STA DRB
	AND #$20
	BEQ BRK3
	BNE BRK4

;***** V COMMAND-TOGGLE REGISTER DISP FLG *****
;DISPLAY REGIST BEFORE EXEC
REGT	LDX #<REGF
	BNE TOGL

;***** Z COMMMAND-TOGGLE DIS TRACE FLG *****
;DISPL NEXT INSTR BEFORE EXEC
TRACE	LDX #<DISFLG
	BNE TOGL

;***** \ COMMAND-TOGGLE PRINTER FLAG *****
PRITR	LDX #<PRIFLG
	BNE TOGL

;***** 4 COMMAND-TOGGLE SOFT BRK ENABL FLG *****
BRKK	LDX #<BKFLG

TOGL	LDA MONRAM,X     ;LOAD FLAG
	BEQ TOGL1        ;FLAG IS OFF ,SO TURN ON
	LDA #0           ;FLAG IS ON ,SO TURN OFF
	STA MONRAM,X
BRK3	LDY #M7-M1       ;PRINT 'OFF'
BRK2	JMP KEP
TOGL1	SEC              ;TURN FLAG ON BY SETTING NON-ZERO
	ROR MONRAM,X     ;FLAG IS ON MSB
BRK4	LDY #M6-M1       ;PRINT 'ON'
	BNE BRK2

;***** # COMMAND-CLEAR ALL BREAKS *****
CLRBK	LDA #0           ;STORE ZEROS INTO BRKPT LIST
	LDX #7
RS20	STA BKS,X
	DEX
	BPL RS20
	BMI BRK3         ;PRINT 'OFF'

;***** K COMMAND-DISASSEMBLE MEMORY *****
KDISA	LDA #'*          ;GET START ADDRESS
	JSR OUTPUT
	JSR ADDIN
	BCS KDISA        ;IF ERROR DO IT AGAIN
	JSR CGPC0        ;GET IT INTO PROG CNTR
	JSR PSL1         ;PRINT '/'
	JSR GCNT         ;GET COUNT
	JSR CRCK
	JMP JD2
JD1	JSR RCHEK        ;SEE IF HE WANTS TO INTERRUPT
	JSR DONE
	BEQ JD4
JD2	JSR DISASM       ;GO TO DISASSEMBLER
	LDA SAVPC        ;POINT TO NEXT INSTRUC LOCAT
	SEC              ;ONE MORE TO PROG CNTR
	ADC LENGTH
	STA SAVPC
	BCC JD3
	INC SAVPC+1
JD3	JSR CRCK         ;(CR)
	JMP JD1
JD4	RTS

;INITIALIZATION TABLE FOR 6522
INTAB1	.BYT $34,$00,$37,$FF,$25,$FF,$25,$FF
	.BYT $FF,$FF,$00,T1I+T2I
	.BYT MOFF+PRST+SP12,$FF,$7F
;INITIALIZATION TABLE FOR 6532
INTAB2	.BYT $FF,$FF,$00,$00
;INITIALIZATION TABLE FOR MONITOR RAM
INTAB3	.WORD NMIV3,IRQV3,OUTDIS
	.BYT $C7,$08,$02,$CA,$03,$80,$00,$00
	.BYT $00,$80,$0D,$0D,$00,$00,$00
;SEE IF WE HIT A SOFT BREAKPOINT (PART OF NMV3)
CKB	LDX #7           ;COMPARE BRKPT LIST TO TRAP ADDR
CKB2	LDA BKS,X        ;GET ADDRESS OF NEXT BREAKPOINT
	DEX
	CMP SAVPC+1      ;COMPARE TO SAVED PROGRAM COUNTER
	BNE CKB1
	LDA BKS,X
	CMP SAVPC
	BNE CKB1         ;NO MATCH SO TRY NEXT BREAKPOINT
	SEC              ;MATCH-SET MATCH FLAG
	RTS
CKB1	DEX
	BPL CKB2         ;MORE TO GO
	CLC              ;NO MATCH -RESET MATCH FLAG
	RTS
;GET # OF LINES COUNT FOR GO-COMMAND,LIST-COMM
GCNT	JSR RD2
	BCC GCN1
	EOR #$0C         ;(SPACE)---> $2C ,(CR)----> $01
GCN1	STA COUNT
	RTS

;CHECK IF COUNT HAS REACHED ZERO
;COUNT=$2C MEANS FOREVER
DONE	LDA COUNT        ;IF COUNT=0 WE ARE DONE
	CMP #$2C         ;THIS MEANS FOREVER
	BEQ DON1         ;SET ACC DIFF FROM ZERO
	SED              ;DECREMENT COUNT IN DECIMAL
	SEC
	SBC #1
	CLD
	STA COUNT
	RTS
DON1	LDA #$2C
	RTS

FROM	LDY #0           ;PRINT 'FR='
	BEQ TO1

TO	LDY #M3-M1       ;PRINT 'TO='
TO1	JSR KEP
	JMP ADDNE        ;GET ADDRESS

;PRINT MSG POINTED TO BY Y REG
KEP	LDA M1,Y
	PHA
	AND #$7F         ;STRIP OFF MSB
	JSR OUTPUT
	INY
	PLA
	BPL KEP          ;MSB =1 ?
	RTS


;PRINT '*' ,BUT NOT TO TAPE RECORDER, NOR LOADING....
;PAPER TAPE OR TO DISPLAY
PROMPT	LDA INFLG        ;WHICH DEV (FOR EDITOR)
	CMP #'T          ;NO PROMPT IF 'T' OR 'L'
	JMP PATC11
PROMP1	JSR TTYTST       ;PROMPT ONLY TO TTY
	BNE PR2          ;BRANCH ON KB
	LDA #'*
PR1	JMP OUTPUT       ;ONLY TO TERMIN
PR2	LDA #CR          ;CLR DISP
	JMP OUTDIS

QM	LDA #'?          ;PRINT '?'
	BNE PR1

EQUAL	LDA #'=          ;PRINT '='
	BNE PR1
;ON DELETE KEY OUTPUT SLASH IF TTY & ....
;BACK UP CURSOR IF KB (MAY NEED SCROLLING)
PSLS	JSR TTYTST       ;TTY OR KB ?
	BEQ PSL1         ;BRANCH ON TTY
	JSR PHXY         ;SAVE X,Y
	DEC CURPO2       ;DECR DISP PNTR
	LDX CURPO2
	CPX #20          ;IF MORE THAN 20 JUST SCROLL THEM
	BCS PSL0
	LDA #'           ;< 20 ,SO CLR CUR
	JSR OUTDP1
	DEC CURPO2
	JMP PSLO0
	NOP
	NOP
PSL0	JSR PATC12       ;CLR PRIFLG
	DEX              ;ONE CHR LESS
	JSR OUTD2A       ;SCROLL THEM
PSLO0	LDA CURPO2       ;DISBUFF---> PRIBUFF
	CMP #21
	BCC PSLOB
	CMP #41
	BCC PSLOA
	LDY #40          ;CHR 40-59
	SBC #40
	JMP PSLOC
PSLOA	LDY #20          ;CHR 20-39
	SEC
	SBC #20
	JMP PSLOC
PSLOB	LDY #0           ;CHR 00-19
PSLOC	STA CURPOS
	LDX #0
PSLOD	LDA DIBUFF,Y     ;TRANSFER THEM
	STA IBUFM,X
	INX
	INY
	CPX CURPOS       ;PRI PNTR
	BCC PSLOD
	JSR OUTPR        ;CLR PRI BUFF TO THE RIGHT
	JSR PLXY         ;RESTORE X,Y
	RTS
PSL1	LDA #'/          ;PRINT '/'
	BNE PR1

BLANK2	JSR BLANK        ;TWO SPACE
BLANK	LDA #' '
	BNE PR1


;CHECK TTY/KBD SWITCH (Z=1 FOR TTY)
TTYTST	LDA #$08         ;CHECK IF TTY OR KB
	BIT DRB          ;TTY OR KB SWITCH =PB3
	RTS

;WHERE IS INPUT COMING FROM?
;SET UP FOR INPUT ACTIVE DEVICE
WHEREI	LDY #M9-M1       ;PRINT 'IN'
	JSR KEPR         ;OUTPUT MESSAGE AND INPUT CHR
	STA INFLG
	CMP #'T
	BNE WHE1
	LDX #0           ;FOR INPUT FILE FLG
	JSR FNAM         ;OPEN FILE FOR TAPE (1 OR 2)
	JMP LOADTA       ;GET FILE
WHE1	CMP #'K          ;TAPE WITH KIM FORMAT
	BNE WHE2
	LDX #0           ;FOR INPUT FILE FLG
	JSR FNAM         ;OPEN FILE FOR TAP (1 OR 2)
	JMP LOADKI       ;THE WHOLE FILE
WHE2	CMP #'U          ;USER RTN?
	BNE WHE3
	CLC              ;SET FLAG FOR INITIALIZATION
	JMP (UIN)        ;USER INPUT SETUP
WHE3	RTS

;WHERE IS OUTPUT GOING TO?
;SET UP FOR OUTPUT ACTIVE DEVICE
WHEREO	LDY #M10-M1      ;PRINT 'OUT'
	JSR KEPR         ;OUTPUT MSG & INPUT CHR
	STA OUTFLG       ;DEVICE FLG
;TAPES
	CMP #'T
	BNE WHRO1
	LDX #1           ;FOR OUTPUT FILE FLG
	JSR FNAM         ;FILENAME & TAPE (1 OR 2)
	JMP DUMPTA       ;INITIALZE FILE
WHRO1	CMP #'K          ;TAPE WITH KIM FORMAT
	BNE WHRO2
	LDX #1           ;FOR OUTPUT FILE FLG
	JMP FNAM
;PRINTER
WHRO2	CMP #'P          ;PRINTER?
	BNE WHRO3
	LDA #CR          ;OUTPUT LAST LIEN IF ON
	JMP OUTPRI       ;& CLEAR PRINTER PTR
;USER SET UP
WHRO3	CMP #'U          ;USER RTN?
	BNE WHRO4
	CLC              ;CLR FLG FOR INITIALIZATION
	JMP (UOUT)       ;USER OUTPUT SETUP
;ANY OTHER
WHRO4	JMP CRLOW

;GET FILE NAME & TAPE UNIT
FNAM	JSR PHXY         ;SAVE IN/OUT FLG (X)
	JSR NAMO         ;GET NAME
WHICHT	LDY #TMSG2-M1    ;PRINT 'T='
	JSR KEPR         ;OUTPUT MSG & INPUT CHR
	CMP #CR
	BNE TAP1
	LDA #$31         ;(CR) ==> TAPE 1
TAP1	SEC
	SBC #$31         ;SUBTRACT 31
	BMI TAP2         ;ONLY 1,2 OK
	CMP #2
	BMI TAP3         ;OK
TAP2	JSR QM           ;ERROR
	JMP WHICHT
TAP3	JSR PLXY         ;IN/OUT FLG
	STA TAPIN,X      ;IF X=0 -->TAPIN (TAPE 1 OR 2)
	JSR CUREAD       ;GET ANYTHING
	JSR CRCK         ;(CR)
	RTS              ;IF X=1 -->TAPOUT (TAPE 1 OR 2)

;GET FILE NAME
NAMO	LDY #TMSG1-M1    ;PRINT 'F='
	JSR KEP          ;NO CRLF
	LDY #0
NAMO1	JSR RDRUB        ;GET CHAR
	CMP #CR          ;DONE?
	BEQ NAMO2
	CMP #' 
	BEQ NAMO2
	STA NAME,Y       ;STORE
	INY
	CPY #5
	BNE NAMO1
;BLANK REST OF NAME
NAMO2	LDA #' 
NAMO3	CPY #5
	BEQ NAMO4
	STA NAME,Y
	INY
	BNE NAMO3
NAMO4	JMP BLANK

;SET INPUT FROM TERMINAL (KB OR TTY)
INLOW	LDA #CR
	STA INFLG
	RTS

;SET I/O TO TERMINAL (KB & D/P ,OR TTY)
LL	JSR INLOW

;SET OUTPUT TO TERMINAL (D/P OR TTY)
OUTLOW	LDA #CR
	STA OUTFLG
OUTL1	RTS

;ON (ESCAPE) STOPS EXECUTION & BACK TO MONITOR
;ON (SPACE) STOPS EXECUTION & CONTINUE ON ANY OTHER KEY
RCHEK	JSR TTYTST       ;TTY OR KB ?
	BEQ RCHTTY
	JSR ROONEK       ;CKR MSK & GET A KEY
	DEY
	BMI RCH3         ;RTN ON NO KEY
	LDX #0
	JSR GETK2        ;GET THE KEY
	CMP #ESCAPE
	BEQ REA1         ;TO COMMAN & SET I/O TO TERMINAL
	CMP #'           ;WAIT KEY
	BNE RCH3         ;RTN, IGNORE OTHER KEYS
RCH2	JSR ROONEK       ;WAIT TILL HE RELEASES IT &
	DEY              ;QUIT WAITING ON NEXT KEY
	BMI RCH2
RCH3	RTS
RCHTTY	BVS RCHT1        ;TTI=PB6 ---> V (OVERFL FLG)
RCHT2	BIT DRB          ;WAIT TILL HE RELEASE IT
	BVC RCHT2
	JSR DELAY
	JSR GETTTY       ;GET A CHAR
	CMP #ESCAPE
	BEQ REA1         ;TO COMMAN
	CMP #' 
	BNE RCHT2
RCHT1	RTS              ;QUIT WAITING ON ANY KEY

;READ ONE CHAR FROM KB/TTY AND PRESERVE X,Y
READ	JSR PHXY         ;PUSH X & Y
	JSR TTYTST       ;TTY OR KB ?
	BNE READ1
	JSR GETTTY
	JMP READ2
READ1	JSR GETKEY
READ2	JSR PLXY         ;PULL X & Y
	AND #$7F         ;STRIP PARITY
	CMP #ESCAPE
	BNE RCHT1        ;RTN
REA1	JSR PATC18       ;(CR) AND CLR BUFFERS
	JMP COMIN        ;BOTH I/O TO TERMINAL

;READ WITH RUBOUT OR DELETE POSSIBLE
RB2	JSR PSLS         ;SLASH OR BACK SPACE
RDRUB	JSR CUREAD
	CMP #RUB         ;RUBOUT
	BEQ RDR1
	CMP #$7F         ;ALSO DELETE
	BNE RED2         ;ECHO IF NOT (CR)
;RUBOUT TO DELETE CHAR
RDR1	DEY
	BPL RB2
	INY
	BEQ RDRUB

;OUTPUT MESSAGE THEN INPUT CHR
KEPR	JSR KEP

;READ AND ECHO A CHAR FROM KB OR TTY
REDOUT	JSR CUREAD
RED2	CMP #CR
	BEQ RCHT1        ;DO NOT ECHO (CR)

;OUTPUTS A CHAR TO EITHER TTY OR D/P
OUTPUT	PHA              ;SAVE IT
OUT1	LDA PRIFLG       ;IF LSB=1 OUTPUT ONLT TO DISP
	AND #$01
	BEQ OUT1A
	PLA
	JMP OUTDP1       ;ONLY TO DISPL
OUT1A	JSR TTYTST       ;TTY OR KB ?
	BNE OUT2
	PLA
	JMP OUTTTY       ;TO TTY
OUT2	PLA
	JMP OUTDP        ;TO DISP & PRINTR

;GET A CHAR FORM CURRENT INPUT DEVICE (SET ON INFL)
INALL	LDA INFLG
	CMP #'T
	BNE *+5
	JMP TIBYTE       ;CHAR FROM BUFFER
	CMP #'K          ;WITH KIM FORMAT
	BNE *+5
	JMP GETTAP       ;DIRECTLY FROM TAPE
	CMP #'M          ;MEMORY FOR ASM?
	BNE *+5
	JMP MREAD
	CMP #'U          ;USER ROUTINE?
	BNE *+6
	SEC              ;SET FLG FOR NORMAL INPUT
	JMP (UIN)
	CMP #'L          ;TO LOAD PPR TAPE
	BNE RDRUB
	JMP GETTTY       ;FROM TTY

.FILE A2
