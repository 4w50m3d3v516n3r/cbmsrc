
C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 1
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                            1   	.nam  C128 BASIC  (318018,19-03 RELEASE:  11/18/85)
                            2   	.formln	 60
                            3   
                            4   	.include disclaim
                            5   ;  ****************************************************************** 
                            6   ;  *    		    C128 Basic				    *
                            7   ;  *                                                                * 
                            8   ;  *    COPYRIGHT (C)1984  BY   COMMODORE BUSINESS MACHINES, INC.   * 
                            9   ;  *                                                                * 
                           10   ;  ****************************************************************** 
                           11     
                           12     
                           13     
                           14   ;  ****************************************************************** 
                           15   ;  *                                                                * 
                           16   ;  *  THIS  SOFTWARE IS  FURNISHED FOR USE IN  COMMODORE  COMPUTER  * 
                           17   ;  *  SYSTEMS ONLY. COPIES MAY NOT BE MADE IN WHOLE OR IN PART FOR  * 
                           18   ;  *                   USE ON ANY OTHER SYSTEM.                     * 
                           19   ;  *                                                                * 
                           20   ;  *  THE  INFORMATION  IN  THIS  DOCUMENT  IS  SUBJECT  TO CHANGE  * 
                           21   ;  *                       WITHOUT NOTICE.                          * 
                           22   ;  *                                                                * 
                           23   ;  *  NO  RESPONSIBILITY  IS  ASSUMED  FOR THE RELIABILITY OF THIS  * 
                           24   ;  *                          SOFTWARE.                             * 
                           25   ;  *                                                                * 
                           26   ;  ****************************************************************** 
                           27     
                           28   ;end
                           29   
                           30   	.include basic.map

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 2
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                           32   ; a brief explanation of the pointer structure in basic:
                           33   ;
                           34   ;		   RAM bank 0			   RAM bank 1
                           35   ;	FFFF	|---------------|<=(MAX_MEM_0)*	|---------------|<=(MAX_MEM_1)
                           36   ;		|		|		|		|
                           37   ;		|		|		|		|
                           38   ;		|  Free RAM	|		|    Strings	|
                           39   ;		|		|		|		|
                           40   ;		|  		|		|		|
                           41   ;		|		|		|---------------|<===(FRETOP)
                           42   ;		|		|		|		|
                           43   ;		|---------------|<==(TEXT_TOP)	|		|
                           44   ;		|		|		|		|
                           45   ;		|		|		|		|
                           46   ;		|		|		|		|
                           47   ;		|   Text area	|		|   		|
                           48   ;		|		|		|---------------|<===(STREND)
                           49   ;		|  		|		|		|
                           50   ;		|		|		|		|
                           51   ;	4000===>|---------------|<=\		|    Arrays	|
                           52   ;		|		|   \		|		|
                           53   ;		| Bit Mapped	|    \		|		|
                           54   ;		|   Screen	| (TXTTAB)	|		|
                           55   ;		|  (Sometimes)	|    /		|---------------|<===(ARYTAB)
                           56   ;		|(and color RAM)|   /		|		|
                           57   ;	1C00===>|---------------|<=/		|		|
                           58   ;		|		|		|		|
                           59   ;		| Misc. Buffers |		|    		|
                           60   ;		|		|		|		|
                           61   ;	1000===>|---------------|		|		|
                           62   ;		|		|		|   Variables	|
                           63   ;		|  Misc. Var's	|		|		|
                           64   ;		|		|		|		|
                           65   ;	0800===>|---------------|		|  		|
                           66   ;		|		|		|		|
                           67   ;		|  Text Screen	|		| 		|
                           68   ;		|		|		|		|
                           69   ;	0400===>|---------------|<=============>|---------------|<===(VARTAB)
                           70   ;		|		|		|		|
                           71   ;		|  Common RAM	|		|  Common RAM	|
                           72   ;		|		|		|		|
                           73   ;	0000	|_______________|		|_______________|
                           74   ;
                           75   ;
                           76   ;	1.  * indicates a new pointer.
                           77   
                           78   	.include display.map

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 3
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                           80   ; "DISPLAY.MAP"
                           81   ;                     TEXT           HIRES          MULTI         HIRES          MULTI
                           82   ; 		      MODE        BIT-MAPPED     BIT-MAPPED       SPLIT          SPLIT
                           83   ; 	|	|
                           84   ; $DC00	|-------| ------------   ------------   ------------   ------------   ------------
                           85   ;   |	|	|  Text color                    Bit-mapped     Text color    Text color/ (*1)
                           86   ;   |	|	|    info.                       color info.      info.      BM color info.
                           87   ; $D800	|-------| ------------   ------------   ------------   ------------   ------------
                           88   ; 	|	|
                           89   ; 	|	|
                           90   ; 	~	~
                           91   ; 	|	|
                           92   ; 	|	|
                           93   ; $4000	|-------| ------------   ------------   ------------   ------------   ------------
                           94   ;   |	|	|
                           95   ;   |	|	|     Not            Bit            Bit            Bit            Bit     
                           96   ;   |	~	~                    map            map            map            map     
                           97   ;   |	|	|    used.          screen         screen         screen         screen   
                           98   ;   |	|	|
                           99   ; $2000	|-------| ------------   ------------   ------------   ------------   ------------
                          100   ;   |	|	|     Not         Bit-mapped     Bit-mapped     Bit-mapped     Bit-mapped 
                          101   ;   |	|	|    used.        color info.    color info.    color info.    color info.
                          102   ; $1C00	|-------| ------------   ------------   ------------   ------------   ------------
                          103   ; 	|	|
                          104   ; 	|	|
                          105   ; 	|	|
                          106   ; $0800	|-------| ------------   ------------   ------------   ------------   ------------
                          107   ;   |	|	|     Text           Not            Not            Text           Text
                          108   ;   |	|	|    screen       used. (*2)     used. (*2)       screen         screen
                          109   ; $0400	|-------| ------------   ------------   ------------   ------------   ------------
                          110   ; 	|	|
                          111   ; 	|	|
                          112   ; 
                          113   ;  (*1) There are actually 2 banks of RAM that can be mapped into this slot in the map. By
                          114   ;       selecting one bank during the BM portion of the screen (top), and the other during
                          115   ;       the TEXT portion of the screen (bottom), each mode will have unique RAM for it's
                          116   ;       own purposes.
                          117   ; 
                          118   ;  (*2) Although the information on the TEXT screen is not actually being displayed at this
                          119   ;       time, it is still being acessed and updated during any operation normally routed to
                          120   ;       the screen (such as default print statements, error messages, etc.) "Not used" is
                          121   ;       NOT meant to imply that during this mode, all print operations are going into the
                          122   ;       bit-bucket.
                          123   
                          124   
                          125   	.include sysdoc
                          126   	.subttl  C/128 SYSTEM MEMORY MAPS  (10/02/85)

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 4
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                          128   ;				     COMPOSITE  SYSTEM  MEMORY  MAP
                          129   ;
                          130   ;	  C64 Cartridges	       C64		     C128 ROMs		 RAM Banks (0-3)
                          131   ; $FFFF> _______________	 _______________	 _______________	 _______________
                          132   ;	|		|	|		|	|		|	|		|
                          133   ;	|     Game	|	|     KERNAL	|	|		|	|		|
                          134   ;	|		|	|	&	|	|     KERNAL	|	|		|
                          135   ;	|     Card	|	|     EDITOR	|	|		|	|		|
                          136   ;	|		|	|		|	|		|	|		|
                          137   ; $E000>|_______________|-------|_______________|-------|_______________|	|		|
                          138   ;				|		|	|      I/O	|	|		|
                          139   ;				| I/O and CHARs	|	| CHARs & CP/M	|	|		|
                          140   ; $D000>------------------------|_______________|-------|_______________|	|		|
                          141   ;							|		|	|		|
                          142   ;	 _______________	 _______________	|     EDITOR	|	|		|
                          143   ; $C000>|		|-------|		|-------|_______________|-------|		|
                          144   ;	|		|	|		|	|		|	|		|
                          145   ;	|  Application	|	|		|	|    MONITOR	|	|		|
                          146   ; $B000>|		|-------|     BASIC	|-------|_______________|	|		|
                          147   ;	|   Card - HI	|	|		|	|		|	|		|
                          148   ;	|		|	|		|	|		|	|	_	|
                          149   ; $A000>|_______________|-------|_______________|	|		|	|      | SYSTEM	|
                          150   ;	|		|				|     BASIC	|	| RAM0-| & BASIC|
                          151   ;	|  Application	|				|		|	|      |_  TEXT	|
                          152   ;	|		|				|       HI	|	|	_	|
                          153   ;	|   Card - LO	|				|		|	|      | BASIC	|
                          154   ;	|		|				|		|	| RAM1-|  VARs	|
                          155   ; $8000>|_______________|-------------------------------|_______________|-------|      |_	|
                          156   ;							|		|	|		|
                          157   ;							|		|	|	_	|
                          158   ;							|		|	| RAM2-| FUTURE |
                          159   ;							|     BASIC	|	| RAM3-|_EXPAND |
                          160   ;							|		|	|		|
                          161   ;							|       LO	|	|		|
                          162   ;							|		|	|		|
                          163   ;							|		|	|		|
                          164   ;							|		|	|		|
                          165   ;							|		|	|		|
                          166   ;							|		|	|		|
                          167   ; $4000>------------------------------------------------|_______________|-------|		|
                          168   ;										|		|
                          169   ;										|		|
                          170   ;										|		|
                          171   ;										|		|
                          172   ;										|		|
                          173   ;										|		|
                          174   ;										|		|
                          175   ;										|		|
                          176   ;										|		|
                          177   ; $0400>------------------------------------------------------------------------|_______________|
                          178   ;										|    COMMON	|
                          179   ; $0000>------------------------------------------------------------------------|_______________|
                          180   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 5
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                          182   ; $0A00>|---------------| $1300>|---------------| $1C00>|---------------| $FFFF>|---------------|
                          183   ;	|		|	|		|	|		| $FFFA>|  NMI RST IRQ  |
                          184   ;	|		|	|     Basic	|	|		| $FFD0>| CP/M RAM Code	|
                          185   ;	|		|	|    Absolute	|	|		|       | Krnl RAM Code |
                          186   ;	|    Basic	|	|   Variables	|	|		| $FF05>|---------------|
                          187   ;	|		|	|		|	|		|	|MMU Config Regs|
                          188   ; $0900>|   Run-Time	| $1200>|---------------| $1B00>|		| $FF00>|---------------|
                          189   ;	|		|	|     Basic	|	|		|	|		|
                          190   ;	|    Stack	|	|   DOS / VSP	|	|		|	|		|
                          191   ;	|		|	|   Variables	|	|		|	|		|
                          192   ;	|		| $1108>|---------------|	|		|	|		|
                          193   ;	|		|	|CP/M Reset Code|	|		|	|		|
                          194   ; $0800>|---------------| $1100>|---------------| $1A00>|		|	|		|
                          195   ;	|		|	|		|	|		|	|		|
                          196   ;	|		|	|    Function	|	|		|	|		|
                          197   ;	|		|	|      Key	|	|		|	|		|
                          198   ;	|		|	|     Buffer	|	|		|	|		|
                          199   ;	|      VIC	|	|		|	|		|	|		|
                          200   ;	|		| $1000>|---------------| $1900>|		|	|		|
                          201   ;	|     Text	|	|		|	|		|	|		|
                          202   ;	~		~	|		|	|   Reserved	|	|     Basic	|
                          203   ;	|    Screen	|	|		|	|		|	|		|
                          204   ;	|		|	|    Sprite	|	|      for	|	|		|
                          205   ;	|    (VM#1)	|	|		|	|		|	|		|
                          206   ;	|		| $0F00>|   Definition	| $1800>| Applications	|	~     Text	~
                          207   ;	|		|	|		|	|		|	|		|
                          208   ;	|		|	|     Area	|	|   Software	|	|		|
                          209   ;	|		|	|		|	|		|	|		|
                          210   ;	|		|	|		|	|		|	|     Area	|
                          211   ;	|		|	|		|	|		|	|		|
                          212   ; $0400>|---------------| $0E00>|---------------| $1700>|		|	|		|
                          213   ;	| Basic	RAM Code|	|		|	|		|	| (Basic Text	|
                          214   ; $0380>| - - - - - - - |	|    RS-232	|	|		|	|   begins at	|
                          215   ;	| Kernal Tables |	|    Output	|	|		|	|     $1C00	|
                          216   ; $033C>| - - - - - - - |	|    Buffer	|	|		|	|  if Bit-Map	|
                          217   ;	|   Indirects	|	|		|	|		|	|  unallocated)	|
                          218   ; $02FC>|---------------| $0D00>|---------------| $1600>|		| $4000>|---------------|
                          219   ;	|Kernal	RAM Code|	|		|	|		|	|		|
                          220   ; $02A2>| - - - - - - - |	|    RS-232	|	|		|	|		|
                          221   ;	|Basic & Monitor|	|    Input	|	|		|	|		|
                          222   ;	|     Input	|	|    Buffer	|	|		|	|      VIC	|
                          223   ;	|     Buffer	|	|		|	|		|	|		|
                          224   ; $0200>|---------------| $0C00>|---------------| $1500>|		|	~    Bit-Map	~
                          225   ;	| System Stack	|	|  (Disk Boot	|	|		|	|		|
                          226   ; $0149>| - - - - - - - |	|     Page)	|	|		|	|     Screen	|
                          227   ;	|Basic DOS,USING| $0BC0>| - - - - - - - |	|		|	|		|
                          228   ; $0110>| - - - - - - - |	|   Cassette	|	|		|	|		|
                          229   ;	|    FBUFFER	|	|    Buffer	|	|		|	|		|
                          230   ; $0100>|---------------| $0B00>|---------------| $1400>|		| $2000>| - - - - - - - |
                          231   ;	|		|	|   Monitor &	|	|		|	|		|
                          232   ;	|  Kernal Z.P.	|	|    Kernal	|	|		|	|      VIC	|
                          233   ; $0090>| - - - - - - - |	|   Absolute	|	|		|	~    Bit-Map	~
                          234   ;	|  Basic  Z.P.	|	|   Variables	|	|		|	|     Color	|
                          235   ; $0002>| _ _ _ _ _ _ _	|	|		|	|		|	|     (VM#2)	|
                          236   ; $0000>|_______________| $0A00>|---------------| $1300>|---------------| $1C00>|---------------|

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 5-1
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                          237   
                          238   
                          239   ;			  	C/128  SYSTEM  ROM  LAYOUT
                          240   ;
                          241   ;	$FFFF _  _______________
                          242   ;	$FF4D _	|_______________|__________ Kernal Jump Table & Hardware Vectors --------
                          243   ;		|		|							|
                          244   ;	$FF05 _ |_______________|__________ Kernal Interrupt Dispatch Code		|
                          245   ;	$FF00 _	|///////////////|__________ MMU Configuration Registers			|
                          246   ;		|		|							|
                          247   ;		|		|							|
                          248   ;	$FC80 _	|_______________|__________ ROM Reserved for Foreign Language Versions	|
                          249   ;		|		|							|
                          250   ;		|		|							|
                          251   ;	$FA80 _	|_______________|__________ Editor Tables				|
                          252   ;		|		|							|
                          253   ;		|		|							|
                          254   ;		/		/							-\  HIGH
                          255   ;		|		|							-/  ROM
                          256   ;	$E000 _ |_______________|__________ Kernal ROM Code				|
                          257   ;		|///////////////|							|
                          258   ;		|///////////////|							|
                          259   ;		/////////////////							|
                          260   ;		|///////////////|							|
                          261   ;	$D000 _	|///////////////|__________ I/O Space					|
                          262   ;		|		|							|
                          263   ;		|		|							|
                          264   ;		/		/							|
                          265   ;		|		|							|
                          266   ;	$C000 _ |_______________|__________ Editor ROM Code -----------------------------
                          267   ;		|		|							|
                          268   ;		|		|							|
                          269   ;		/		/							|
                          270   ;		|		|							|
                          271   ;	$B000 _ |_______________|__________ Monitor ROM Code				-\  MID
                          272   ;		|		|							-/  ROM
                          273   ;		|		|							|
                          274   ;		|		|							|
                          275   ;		|		|							|
                          276   ;		|		|							|
                          277   ;	$8000 -	/		/ ------------------------------------------------------|
                          278   ;		|		|							|
                          279   ;		|		|							-\  LOW
                          280   ;		|		|							-/  ROM
                          281   ;		|		|							|
                          282   ;	$4000 _	|_______________|---------- BASIC ROM Code -----------------------------|
                          283   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 6
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                          285   
                          286   ;	         I/O  BLOCK  MAP		6526  CIA  REGISTER MAP  (typical)
                          287   ;
                          288   ;	$DFFF _  _______________		REG#	FUNCTION
                          289   ;		|		|      ________
                          290   ;		|    I/O - 2	|     /		 F .... CRB   (control register B)
                          291   ;	$DF00 _ |_______________|    /		 E .... CRA   (control register A)
                          292   ;		|		|   /		 D .... ICR   (interrupt control register)
                          293   ;		|    I/O - 1	|  /		 C .... SDR   (serial data register)
                          294   ;	$DE00 _ |_______________|_/		 B .... TOD   (hours)
                          295   ;		|		|		 A .... TOD   (minutes)
                          296   ;		|    CIA - 2	|		 9 .... TOD   (seconds)
                          297   ;	$DD00 _ |_______________|		 8 .... TOD   (tenths)
                          298   ;		|		|		 7 .... TB-HI (timer B)
                          299   ;		|    CIA - 1	|		 6 .... TB-LO
                          300   ;	$DC00 _ |_______________|_		 5 .... TA-HI (timer A)
                          301   ;		|		| \		 4 .... TA-LO
                          302   ;		|      VIC	|  \		 3 .... DDRB  (data direction port B)
                          303   ;		/     COLOR	/   \		 2 .... DDRA  (data direction port A)
                          304   ;		|      RAM	|    \		 1 .... PRB   (port B)
                          305   ;	$D800 _ |_______________|     \________	 0 .... PRA   (port A)
                          306   ;		|		|
                          307   ;		|  (RESERVED)	|
                          308   ;	$D700 _ |_______________|
                          309   ;		|		|
                          310   ;		|   8563 VDC	| ..... (register map on following pages)
                          311   ;	$D600 _ |_______________|
                          312   ;		|		|
                          313   ;		|      MMU	| ..... (register map on following pages)
                          314   ;	$D500 _ |_______________|
                          315   ;		|		|
                          316   ;		|      SID	| ..... (register map on following pages)
                          317   ;	$D400 _ |_______________|
                          318   ;		|		|
                          319   ;		|		|
                          320   ;		/      VIC	/ ..... (register map on following pages)
                          321   ;		|		|
                          322   ;	$D000 _ |_______________|
                          323   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 7
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                          325   ;///////////////       T H E       C / 1 2 8       K E Y B O A R D       \\\\\\\\\\\\\\\
                          326   
                          327   ;	    -------------------------------------------------------------------     -------
                          328   ;	    | C0  | C1  | C2  | C3  | C4  | C5  | C6  | C7  | K0  | K1  | K2  |     | GND |
                          329   ;	    |PIN13|PIN19|PIN18|PIN17|PIN16|PIN15|PIN14|PIN20|PIN21|PIN22|PIN23|     |PIN-1|
                          330   ;	    ---|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|---     ---|---
                          331   ;	      \|/   \|/   \|/   \|/   \|/   \|/   \|/   \|/   \|/   \|/   \|/          |
                          332   ; -------   -------------------------------------------------------------------        |
                          333   ; | R0  |/__| INS |  #  |  %  |  '  |  )  |  +  | lb  |  !  | HELP| ESC | ALT |        |
                          334   ; |PIN12|\  | DEL |  3  |  5  |  7  |  9  |     |     |  1  |     |     |     |        |
                          335   ; -------   -------------------------------------------------------------------        |
                          336   ; | R1  |/__| RET |  W  |  R  |  Y  |  I  |  P  |  *  | <-- |  8  |  +  |  0  |        |
                          337   ; |PIN11|\  |     |     |     |     |     |     |     |     |     |     |     |        |
                          338   ; -------   -------------------------------------------------------------------        |
                          339   ; | R2  |/__| /_\ |  A  |  D  |  G  |  J  |  L  |  ]  | CTRL|  5  |  -  |  .  |        |
                          340   ; |PIN10|\  | \ / |     |     |     |     |     |  ;  |     |     |     |     |        |
                          341   ; -------   -------------------------------------------------------------------        |
                          342   ; | R3  |/__| F8  |  $  |  &  |  (  |  0  |  -  | CLR |  "  | TAB | LINE| /|\ |        |
                          343   ; |PIN-5|\  | F7  |  4  |  6  |  8  |     |     | HOM |  2  |     | FEED|  |  |        |
                          344   ; -------   -------------------------------------------------------------------        |
                          345   ; | R4  |/__| F2  |  Z  |  C  |  B  |  M  |  >  |RIGHT|SPACE|  2  |ENTER|  |  |        |
                          346   ; |PIN-8|\  | F1  |     |     |     |     |  .  |SHIFT| BAR |     |     | \|/ |        |
                          347   ; -------   -------------------------------------------------------------------        |
                          348   ; | R5  |/__| F4  |  S  |  F  |  H  |  K  |  [  |  =  | C=  |  4  |  6  | /__ |        |
                          349   ; |PIN-7|\  | F3  |     |     |     |     |  :  |     |     |     |     | \   |        |
                          350   ; -------   -------------------------------------------------------------------        |
                          351   ; | R6  |/__| F6  |  E  |  T  |  U  |  O  |  @  | pi  |  Q  |  7  |  9  | __\ |        |
                          352   ; |PIN-6|\  | F5  |     |     |     |     |     |  ^  |     |     |     |   / |        |
                          353   ; -------   -------------------------------------------------------------------        |
                          354   ; | R7  |/__| /|\ |LEFT |  X  |  V  |  N  |  <  |  ?  | RUN |  1  |  3  |  NO |_____   |
                          355   ; |PIN-9|\  | \|/ |SHIFT|     |     |     |  ,  |  /  | STOP|     |     | SCRL|    |   |
                          356   ; -------   -------------------------------------------------------------------    |   |
                          357   ;		     |								   |   |
                          358   ;		  -------   /  (LOCKING)					   |   |
                          359   ;		  |SHIFT|__o  o____________________________________________________|   |
                          360   ;		  | LOCK|							       |
                          361   ;		  -------							       |
                          362   ; -------         -------   /							       |
                          363   ; | NMI |/________|RESTR|__o  o________________________________________________________o
                          364   ; |PIN-3|\        |     |							       |
                          365   ; -------         -------							       |
                          366   ; -------         -------   /  (LOCKING)                                               |
                          367   ; |40/80|/________|40/80|__o  o________________________________________________________o
                          368   ; |PIN24|\        |DSPLY|							       |
                          369   ; -------         -------							       |
                          370   ; -------         -------   /  (LOCKING)                                               |
                          371   ; |P6510|/________|CAPS |__o  o________________________________________________________o
                          372   ; |PIN25|\        |LOCK |
                          373   ; -------         -------
                          374   
                          375   ;NOTES:	1/  THE 64 KEYS UNDER C0 THRU C7 ABOVE OCCUPY THE SAME MATRIX POSITION AS IN THE C/64,
                          376   ;	    AS DOES THE 'RESTORE' KEY. INCLUDING THE 'SHIFT LOCK' KEY, THERE ARE 66 SUCH KEYS.
                          377   ;	2/  THE 24 KEYS UNDER THE K0, K1 AND K2 OUTPUTS ARE PART  OF  THE  EXTENDED  KEYBOARD,
                          378   ;	    AS ARE THE '40/80 DSPLY' AND 'CAPS LOCK' KEYS.  THERE ARE 26 NEW KEYS.  THEY  WILL
                          379   ;	    NOT BE SCANNED IN C/64  MODE,  ALTHO THE USER MAY WRITE CODE TO SCAN THEM HIMSELF.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 8
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                          381   ;			8722  MMU  REGISTER  MAP
                          382   ;
                          383   ;	REGISTER		DESCRIPTION
                          384   ;				 _______
                          385   ;	 11  (VR) ............. | 7 - 4 | .....	BANK Version
                          386   ;	    Version Register	| 3 - 0 | .....	MMU  Version
                          387   ;				|-------|
                          388   ;				 _______               __
                          389   ;	 10  (PAGE-1 HI) ...... | 7 - 4 | .....	???	 |
                          390   ;	  8  (PAGE-0 HI)	| 3 | .........	A19	Swaps PAGE 0 and/or PAGE 1
                          391   ;				| 2 | .........	A18	with any other page in the
                          392   ;				| 1 | .........	A17	256K address space.
                          393   ;				| 0 | ......... A16	 |
                          394   ;				|---|			 |
                          395   ;				 ___			 |
                          396   ;	  9  (PAGE-1 LO) ......	| 7 | ......... A15	 |
                          397   ;	  7  (PAGE-0 LO)	| 6 | ......... A14	 |
                          398   ;				| 5 | ......... A13	 |
                          399   ;				| 4 | ......... A12	 |
                          400   ;				| 3 | ......... A11	 |
                          401   ;				| 2 | ......... A10	 |
                          402   ;				| 1 | ......... A9	 |
                          403   ;				| 0 | ......... A8     __|
                          404   ;				|---|
                          405   ;				 ___
                          406   ;	  6  (RCR)		| 7 | .........	VA17 \	VIC RAM Bank
                          407   ;				| 6 | .........	VA16 /
                          408   ;	    RAM Configuration	| 5 | .........	\	RAM Block     (for future expansion)
                          409   ;	      Register		| 4 | .........	/
                          410   ;				| 3 | .........	\	SHARE Status  (none,bot,top,both)
                          411   ;				| 2 | .........	/
                          412   ;				| 1 | .........	\	SHARE Amount  (1k,4k,8k,16k)
                          413   ;				| 0 | .........	/
                          414   ;				|---|
                          415   ;	  			 ___
                          416   ;	  5  (MCR)		| 7 | .........	40/80 Key Sense
                          417   ;				| 6 | .........	OS Mode      0 = 128,  1 = 64
                          418   ;	   Mode Configuration	| 5 | .........	/EXROM line sense
                          419   ;	     Register		| 4 | .........	/GAME  line sense
                          420   ;				| 3 | .........	FSDIR        0 = IN,   1 = OUT
                          421   ;				| 2 | .........	???
                          422   ;				| 1 | .........	???
                          423   ;				| 0 | .........	Processor:   0 = Z80,  1 = 85xx
                          424   ;				|---|
                          425   ;				 ___
                          426   ;	  4  (PCR-D)		| 7 | .........	A17 \	RAM BANK (0-3)
                          427   ;	  3  (PCR-C)		| 6 | .........	A16 /
                          428   ;	  2  (PCR-B)		| 5 | .........	\	ROM-HI	(system,int,ext,RAM)
                          429   ;	  1  (PCR-A)		| 4 | .........	/
                          430   ;	  0  (CR)		| 3 | .........	\	ROM-MID	(system,int,ext,RAM)
                          431   ;				| 2 | .........	/
                          432   ;	    Pre-configuration	| 1 | .................	ROM-LO	(system,RAM)
                          433   ;	      & Configuration	| 0 | ................. I/O	(I/O, else see ROM-HI)
                          434   ;	          Registers	|---|

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 9
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                          436   ;		8726 DMA CONTROLLER REGISTER  MAP	(10/85)
                          437   ;
                          438   ;
                          439   ; REG #	 _______________________________________________________
                          440   ;  0_	| PEND |  EOB | FAULT| SIZE | VER3 | VER2 | VER1 | VER0 |______ Status Register
                          441   ;  1_	| EXEC |  --  | LOAD | FF00 |  --  |  --  |    MODE     |______ Command Register
                          442   ;  2_	|  A7  |  A6  |  A5  |  A4  |  A3  |  A2  |  A1  |  A0  |______ Host Address lo
                          443   ;  3_	|  A15 |  A14 |  A13 |  A12 |  A11 |  A10 |  A9  |  A8  |______ Host Address hi
                          444   ;  4_	| EX7  | EX6  | EX5  | EX4  | EX3  | EX2  | EX1  | EX0  |______ Expansion Address lo
                          445   ;  5_	| EX15 | EX14 | EX13 | EX12 | EX11 | EX10 | EX9  | EX8  |______ Expansion Address hi
                          446   ;  6_	|  --  |  --  |  --  |  --  |  --  | BA2  | BA1  | BA0  |______ Expansion Bank pointer
                          447   ;  7_	|  L7  |  L6  |  L5  |  L4  |  L3  |  L2  |  L1  |  L0  |______ Transfer Length lo
                          448   ;  8_	|  L15 |  L14 |  L13 |  L12 |  L11 |  L10 |  L9  |  L8  |______ Transfer Length hi
                          449   ;  9_	| ENBL | IEOB |  VFY |  --  |  --  |  --  |  --  |  --  |______ Interrupt Mask
                          450   ; 10_   |  AC1 |  AC0 |  --  |  --  |  --  |  --  |  --  |  --  |______ Address Control
                          451   ;       |______|______|______|______|______|______|______|______|
                          452   
                          453   
                          454   
                          455   ;	MODE =>		00: Transfer FROM internal  TO  external
                          456   ;			01: Transfer  TO  internal FROM external
                          457   ;			10: Swap
                          458   ;			11: Verify
                          459   ;
                          460   ;       SIZE =>         0:  128KB
                          461   ;                       1:  512KB
                          462   ;
                          463   ;       Adr Contl =>    00: Increment both host & expansion addresses
                          464   ;                       01: Fix expansion address
                          465   ;                       10: Fix host address
                          466   ;                       11: Fix both host & expansion addresses
                          467   ;
                          468   ;
                          469   ;       NOTE:  Bits 7-5 of STATUS register are CLEARED when this register is READ
                          470   
                          471   
                          472   
                          473   ;	The  DMA  CONTROLLER  appears in the C/128 I/O memory map at IO2  ($DF00).
                          474   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 10
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                          476   ;			8564  VIC  REGISTER  MAP
                          477   ;
                          478   ; REG #	 _______________________________________________________
                          479   ;  0_	| S0x7 | S0x6 | S0x5 | S0x4 | S0x3 | S0x2 | S0x1 | S0x0 |______ Sprite 0  X location
                          480   ;  1_	|______|______|______|______|______|______|______|______|______ Sprite 0  Y location
                          481   ;  2_	|      |      |      |      |      |      |      |      |______ Sprite 1  X location
                          482   ;  3_	|______|______|______|______|______|______|______|______|______ Sprite 1  Y location
                          483   ;  4_	|      |      |      |      |      |      |      |      |______ Sprite 2  X location
                          484   ;  5_	|______|______|______|______|______|______|______|______|______ Sprite 2  Y location
                          485   ;  6_	|      |      |      |      |      |      |      |      |______ Sprite 3  X location
                          486   ;  7_	|______|______|______|______|______|______|______|______|______ Sprite 3  Y location
                          487   ;  8_	|      |      |      |      |      |      |      |      |______ Sprite 4  X location
                          488   ;  9_	|______|______|______|______|______|______|______|______|______ Sprite 4  Y location
                          489   ; 10_	|      |      |      |      |      |      |      |      |______ Sprite 5  X location
                          490   ; 11_	|______|______|______|______|______|______|______|______|______ Sprite 5  Y location
                          491   ; 12_	|      |      |      |      |      |      |      |      |______ Sprite 6  X location
                          492   ; 13_	|______|______|______|______|______|______|______|______|______ Sprite 6  Y location
                          493   ; 14_	|      |      |      |      |      |      |      |      |______ Sprite 7  X location
                          494   ; 15_	|______|______|______|______|______|______|______|______|______ Sprite 7  Y location
                          495   ; 16_	| S7x8 | S6x8 | S5x8 | S4x8 | S3x8 | S2x8 | S1x8 | S0x8 |______ MSB of Sprite X loctn
                          496   ; 17_	|  RC8 |  ECM |  BMM | Blank| ROWS |  Y2  |  Y1  |  Y0  |______ mode, #row, y-scroll
                          497   ; 18_	|  RC7 |  RC6 |  RC5 |  RC4 |  RC3 |  RC2 |  RC1 |  RC0 |______ Raster latch
                          498   ; 19_	| LPx8 | LPx7 | LPx6 | LPx5 | LPx4 | LPx3 | LPx2 | LPx1 |______ Lightpen X latch
                          499   ; 20_	| LPy7 | LPy6 | LPy5 | LPy4 | LPy3 | LPy2 | LPy1 | LPy0 |______ Lightpen Y latch
                          500   ; 21_	|  SD7 |  SD6 |  SD5 |  SD4 |  SD3 |  SD2 |  SD1 |  SD0 |______ Sprite Disable
                          501   ; 22_	|  --  |  --  | Reset|  MCM | COLS |  X2  |  X1  |  X0  |______ mode, #col, x-scroll
                          502   ; 23_	| S7Ey | S6Ey | S5Ey | S4Ey | S3Ey | S2Ey | S1Ey | S0Ey |______ Sprite Y expand
                          503   ; 24_	| VM13 | VM12 | VM11 | VM10 | CB13 | CB12 | CB11 |  --  |______ VM Base, CHR Base
                          504   ; 25_	|  IRQ |  --  |  --  |  --  |  LP  |  S/S |  S/B | RIRQ |______ IRQ source (wrt to clr)
                          505   ; 26_	|  --  |  --  |  --  |  --  | _LP  | _S/S | _S/B | _IRQ |______ IRQ enable (0=disable)
                          506   ; 27_	| BSP7 | BSP6 | BSP5 | BSP4 | BSP3 | BSP2 | BSP1 | BSP0 |______ Sprite/Bgnd Priority
                          507   ; 28_	| MCS7 | MCS6 | MCS5 | MCS4 | MCS3 | MCS2 | MCS1 | MCS0 |______ Multicolor Sprite Sel
                          508   ; 29_	| S7Ex | S6Ex | S5Ex | S4Ex | S3Ex | S2Ex | S1Ex | S0Ex |______ Sprite X expand
                          509   ; 30_	|  SS7 |  SS6 |  SS5 |  SS4 |  SS3 |  SS2 |  SS1 |  SS0 |______ S/S Collision latch
                          510   ; 31_	|  SB7 |  SB6 |  SB5 |  SB4 |  SB3 |  SB2 |  SB1 |  SB0 |______ S/B Collision latch
                          511   ; 32_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Border Color
                          512   ; 33_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Background Color #0
                          513   ; 34_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Background Color #1
                          514   ; 35_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Background Color #2
                          515   ; 36_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Background Color #3
                          516   ; 37_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Sprite Multicolor #0
                          517   ; 38_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Sprite Multicolor #1
                          518   ; 39_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Sprite 0 Color
                          519   ; 40_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Sprite 1 Color
                          520   ; 41_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Sprite 2 Color
                          521   ; 42_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Sprite 3 Color
                          522   ; 43_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Sprite 4 Color
                          523   ; 44_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Sprite 5 Color
                          524   ; 45_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Sprite 6 Color
                          525   ; 46_	|  --  |  --  |  --  |  --  |      |      |      |      |______ Sprite 7 Color
                          526   ; 47_	|  --  |  --  |  --  |  --  |  --  |  K2  |  K1  |  K0  |______ Keyboard lines (new)
                          527   ; 48_	|  --  |  --  |  --  |  --  |  --  |  --  | TEST | 2MHz |______ Clock speed
                          528   ;       |-------------------------------------------------------|

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 11
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                          530   ;			6581  SID  REGISTER  MAP
                          531   ;
                          532   ; REG #	 _______________________________________________________
                          533   ;  0_	|  F7  |  F6  |  F5  |  F4  |  F3  |  F2  |  F1  |  F0  |______ Frequency lo    Voice-1
                          534   ;  1_	|  F15 |  F14 |  F13 |  F12 |  F11 |  F10 |  F9  |  F8  |______ Frequency hi
                          535   ;  2_	|  PW7 |  PW6 |  PW5 |  PW4 |  PW3 |  PW2 |  PW1 |  PW0 |______ Pulse Width lo
                          536   ;  3_	|  --  |  --  |  --  |  --  | PW11 | PW10 |  PW9 |  PW8 |______ Pulse Width hi
                          537   ;  4_	| NOISE| PULSE|  SAW |  TRI | TEST | RING | SYNC | GATE |______ Control Register
                          538   ;  5_	| ATK3 | ATK2 | ATK1 | ATK0 | DCY3 | DCY2 | DCY1 | DCY0 |______ Attack/Decay
                          539   ;  6_	| STN3 | STN2 | STN1 | STN0 | RLS3 | RLS2 | RLS1 | RLS0 |______ Sustain/Release
                          540   ;	|------|------|------|------|------|------|------|------|
                          541   ;  7_	|  F7  |  F6  |  F5  |  F4  |  F3  |  F2  |  F1  |  F0  |______ Frequency lo    Voice-2
                          542   ;  8_	|  F15 |  F14 |  F13 |  F12 |  F11 |  F10 |  F9  |  F8  |______ Frequency hi
                          543   ;  9_	|  PW7 |  PW6 |  PW5 |  PW4 |  PW3 |  PW2 |  PW1 |  PW0 |______ Pulse Width lo
                          544   ; 10_	|  --  |  --  |  --  |  --  | PW11 | PW10 |  PW9 |  PW8 |______ Pulse Width hi
                          545   ; 11_	| NOISE| PULSE|  SAW |  TRI | TEST | RING | SYNC | GATE |______ Control Register
                          546   ; 12_	| ATK3 | ATK2 | ATK1 | ATK0 | DCY3 | DCY2 | DCY1 | DCY0 |______ Attack/Decay
                          547   ; 13_	| STN3 | STN2 | STN1 | STN0 | RLS3 | RLS2 | RLS1 | RLS0 |______ Sustain/Release
                          548   ;	|------|------|------|------|------|------|------|------|
                          549   ; 14_	|  F7  |  F6  |  F5  |  F4  |  F3  |  F2  |  F1  |  F0  |______ Frequency lo    Voice-3
                          550   ; 15_	|  F15 |  F14 |  F13 |  F12 |  F11 |  F10 |  F9  |  F8  |______ Frequency hi
                          551   ; 16_	|  PW7 |  PW6 |  PW5 |  PW4 |  PW3 |  PW2 |  PW1 |  PW0 |______ Pulse Width lo
                          552   ; 17_	|  --  |  --  |  --  |  --  | PW11 | PW10 |  PW9 |  PW8 |______ Pulse Width hi
                          553   ; 18_	| NOISE| PULSE|  SAW |  TRI | TEST | RING | SYNC | GATE |______ Control Register
                          554   ; 19_	| ATK3 | ATK2 | ATK1 | ATK0 | DCY3 | DCY2 | DCY1 | DCY0 |______ Attack/Decay
                          555   ; 20_	| STN3 | STN2 | STN1 | STN0 | RLS3 | RLS2 | RLS1 | RLS0 |______ Sustain/Release
                          556   ;	|------|------|------|------|------|------|------|------|
                          557   ; 21_	|  --  |  --  |  --  |  --  |  --  |  FC2 |  FC1 |  FC0 |______ Frequency lo    Filter
                          558   ; 22_	| FC10 |  FC9 |  FC8 |  FC7 |  FC6 |  FC5 |  FC4 |  FC3 |______ Frequency hi
                          559   ; 23_	| RES3 | RES2 | RES1 | RES0 |FILTEX| FILT3| FILT2| FILT0|______ Resonance/Filter
                          560   ; 24_	| 3 OFF|  HP  |  BP  |  LP  | VOL3 | VOL2 | VOL1 | VOL0 |______ Mode/Volume
                          561   ;	|------|------|------|------|------|------|------|------|
                          562   ; 25_	|  PX7 |  PX6 |  PX5 |  PX4 |  PX3 |  PX2 |  PX1 |  PX0 |______ Pot X           Misc.
                          563   ; 26_	|  PY7 |  PY6 |  PY5 |  PY4 |  PY3 |  PY2 |  PY1 |  PY0 |______ Pot Y
                          564   ; 27_	|  O7  |  O6  |  O5  |  O4  |  O3  |  O2  |  O1  |  O0  |______ Oscillator 3
                          565   ; 28_	|  E7  |  E6  |  E5  |  E4  |  E3  |  E2  |  E1  |  E0  |______ Envelope 3
                          566   ;	|-------------------------------------------------------|

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 12
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                          568   ;		8563  VDC  REGISTER  MAP	(also 8568,  10/85)
                          569   ;
                          570   ; REG #	 _______________________________________________________
                          571   ;  0_	|  HT7 |  HT6 |  HT5 |  HT4 |  HT3 |  HT2 |  HT1 |  HT0 |______ Horizontal Total
                          572   ;  1_	|  HD7 |  HD6 |  HD5 |  HD4 |  HD3 |  HD2 |  HD1 |  HD0 |______ Horizontal Displayed
                          573   ;  2_	|  HP7 |  HP6 |  HP5 |  HP4 |  HP3 |  HP2 |  HP1 |  HP0 |______ Horizontal Sync Position
                          574   ;  3_	|  VW3 |  VW2 |  VW1 |  VW0 |  HW3 |  HW2 |  HW1 |  HW0 |______ Vert/Horz Sync Width
                          575   ;  4_	|  VT7 |  VT6 |  VT5 |  VT4 |  VT3 |  VT2 |  VT1 |  VT0 |______ Vertical Total
                          576   ;  5_	|  --  |  --  |  --  |  VA4 |  VA3 |  VA2 |  VA1 |  VA0 |______ Vertical Total Adjust
                          577   ;  6_	|  VD7 |  VD6 |  VD5 |  VD4 |  VD3 |  VD2 |  VD1 |  VD0 |______ Vertical Displayed
                          578   ;  7_	|  VP7 |  VP6 |  VP5 |  VP4 |  VP3 |  VP2 |  VP1 |  VP0 |______ Vertical Sync Position
                          579   ;  8_	|  --  |  --  |  --  |  --  |  --  |  --  |  IM1 |  IM0 |______ Interlace Mode
                          580   ;  9_	|  --  |  --  |  --  | CTV4 | CTV3 | CTV2 | CTV1 | CTV0 |______ Character Total Vertical
                          581   ; 10_	|  --  |  CM1 |  CM0 |  CS4 |  CS3 |  CS2 |  CS1 |  CS0 |______ Cursor Mode, Start Scan
                          582   ; 11_	|  --  |  --  |  --  |  CE4 |  CE3 |  CE2 |  CE1 |  CE0 |______ Cursor End Scan Line
                          583   ; 12_	| DS15 | DS14 | DS13 | DS12 | DS11 | DS10 |  DS9 |  DS8 |______ Display Start Address hi
                          584   ; 13_	|  DS7 |  DS6 |  DS5 |  DS4 |  DS3 |  DS2 |  DS1 |  DS0 |______ Display Start Address lo
                          585   ; 14_	| CP15 | CP14 | CP13 | CP12 | CP11 | CP10 |  CP9 |  CP8 |______ Cursor Position hi
                          586   ; 15_	|  CP7 |  CP6 |  CP5 |  CP4 |  CP3 |  CP2 |  CP1 |  CP0 |______ Cursor Position lo
                          587   ; 16_	| LPV7 | LPV6 | LPV5 | LPV4 | LPV3 | LPV2 | LPV1 | LPV0 |______ Light Pen Vertical
                          588   ; 17_	| LPH7 | LPH6 | LPH5 | LPH4 | LPH3 | LPH2 | LPH1 | LPH0 |______ Light Pen Horizontal
                          589   ; 18_	| UA15 | UA14 | UA13 | UA12 | UA11 | UA10 |  UA9 |  UA8 |______ Update Address hi
                          590   ; 19_	|  UA7 |  UA6 |  UA5 |  UA4 |  UA3 |  UA2 |  UA1 |  UA0 |______ Update Address lo
                          591   ; 20_	| AA15 | AA14 | AA13 | AA12 | AA11 | AA10 |  AA9 |  AA8 |______ Attribute Start Adr hi
                          592   ; 21_	|  AA7 |  AA6 |  AA5 |  AA4 |  AA3 |  AA2 |  AA1 |  AA0 |______ Attribute Start Adr lo
                          593   ; 22_	| CTH3 | CTH2 | CTH1 | CTH0 | CDH3 | CDH2 | CDH1 | CDH0 |______ Character Tot(h), Dsp(v)
                          594   ; 23_	|  --  |  --  |  --  | CDV4 | CDV3 | CDV2 | CDV1 | CDV0 |______ Character Dsp(v)
                          595   ; 24_	| COPY |  RVS |CBRATE| VSS4 | VSS3 | VSS2 | VSS1 | VSS0 |______ Vertical smooth scroll
                          596   ; 25_	| TEXT |  ATR | SEMI |  DBL | HSS3 | HSS2 | HSS1 | HSS0 |______ Horizontal smooth scroll
                          597   ; 26_	|  FG3 |  FG2 |  FG1 |  FG0 |  BG3 |  BG2 |  BG1 |  BG0 |______ Foregnd/Bgnd Color
                          598   ; 27_	|  AI7 |  AI6 |  AI5 |  AI4 |  AI3 |  AI2 |  AI1 |  AI0 |______ Address Increment / Row
                          599   ; 28_	| CB15 | CB14 | CB13 |  RAM |  --  |  --  |  --  |  --  |______ Character Base Address
                          600   ; 29_	|  --  |  --  |  --  |  UL4 |  UL3 |  UL2 |  UL1 |  UL0 |______ Underline scan line
                          601   ; 30_	|  WC7 |  WC6 |  WC5 |  WC4 |  WC3 |  WC2 |  WC1 |  WC0 |______ Word Count
                          602   ; 31_	|  DA7 |  DA6 |  DA5 |  DA4 |  DA3 |  DA2 |  DA1 |  DA0 |______ Data
                          603   ; 32_	| BA15 | BA14 | BA13 | BA12 | BA11 | BA10 |  BA9 |  BA8 |______ Block Start Address hi
                          604   ; 33_	|  BA7 |  BA6 |  BA5 |  BA4 |  BA3 |  BA2 |  BA1 |  BA0 |______ Block Start Address lo
                          605   ; 34_	| DEB7 | DEB6 | DEB5 | DEB4 | DEB3 | DEB2 | DEB1 | DEB0 |______ Display Enable Begin
                          606   ; 35_	| DEE7 | DEE6 | DEE5 | DEE4 | DEE3 | DEE2 | DEE1 | DEE0 |______ Display Enable End
                          607   ; 36_	|  --  |  --  |  --  |  --  | DRR3 | DRR2 | DRR1 | DRR0 |______ DRAM Refresh rate
                          608   ; 37_	| HSYNC| VSYNC|  --  |  --  |  --  |  --  |  --  |  --  |______ Horz, Vert Sync Polarity
                          609   ;	|-------------------------------------------------------|
                          610   ;
                          611   ;	(Register 37 appears on device 8568 only)
                          612   ;
                          613   ;	Description of MAPPED registers:
                          614   ;					 _______________________________________________________
                          615   ; $D600 ->	address (write):	|  --  |  --  |  R5  |  R4  |  R3  |  R2  |  R1  |  R0  |
                          616   ;		status  (read) :	|STATUS|  LP  |VBLANK|  --  |  --  | VER2 | VER1 | VER0 |
                          617   ;					|      |      |      |      |      |      |      |      |
                          618   ; $D601 ->	data	(r/w)  :	|  D7  |  D6  |  D5  |  D4  |  D3  |  D3  |  D2  |  D0  |
                          619   ;					|-------------------------------------------------------|
                          620   ;					 _______________________________________________________
                          621   ; ATTRIBUTE byte layout			|  ALT |  RVS |  UL  | FLASH|   R  |   G  |   B  |   I  |
                          622   ;					|-------------------------------------------------------|

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 13
C/128 SYSTEM MEMORY MAPS  (10/02/85)   SYSDOC.SRC

Error Addr  Code          Seq   Source statement

                          624   ;	EXPLANATION OF VARIOUS KERNAL/EDITOR FLAG BYTES, ETC.
                          625   ;
                          626   ;	Symbol			       Description
                          627   ;		    7      6      5      4      3      2      1      0
                          628   ;		_________________________________________________________
                          629   ;	D6510	|  --  | (in) | (out)| (in) | (out)| (out)| (out)| (out)|
                          630   ;		|      |      |      |      |      |      |      |      |
                          631   ;	R6510	|  --  |CAPKEY|CASMTR|CASSEN|CASWRT|CHAREN| HIRAM| LORAM|
                          632   ;		|      |      |      |      |      |      |      |      |
                          633   ;	LOCKS	| CASE | CTL-S|  --  |  --  |  --  |  --  |  --  |  --  |
                          634   ;		|      |      |      |      |      |      |      |      |
                          635   ;	SCROLL	|  OFF |LINKER|      |      |      |      |      |      |
                          636   ;		|      |      |      |      |      |      |      |      |
                          637   ;	SHFLAG	|  --  |  --  |  --  |  ALT | ALPHA| CTRL |  C=  | SHIFT|
                          638   ;		|      |      |      |      |      |      |      |      |
                          639   ;	RPTFLG	|  ALL | NONE |  --  |  --  |  --  |  --  |  --  |  --  |
                          640   ;		|      |      |      |      |      |      |      |      |
                          641   ;	BLNON	|  ON  | BLNK |  --  |  --  |  --  |  --  |  --  |  --  |
                          642   ;		|      |      |      |      |      |      |      |      |
                          643   ;	BEEPER	|  ON  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |
                          644   ;		|      |      |      |      |      |      |      |      |
                          645   ;	GRAPHM	|  MCM | SPLIT|  BMM |  --  |  --  |  --  |  --  |  --  |
                          646   ;		|      |      |      |      |      |      |      |      |
                          647   ;	MODE	| 40/80|  --  |  --  |  --  |  --  |  --  |  --  |  --  |
                          648   ;		|      |      |      |      |      |      |      |      |
                          649   ;	INIT_	|CHRSET| CINT |  --  |  --  |  --  |  --  |  --  | BASIC|
                          650   ;	 STATUS	|-------------------------------------------------------|
                          651   
                          652   ;	The following SYMBOLS are used by the c/128 EDITOR. Note that the
                          653   ;	EDITOR irq VIC screen handler depends upon them. In most cases the
                          654   ;	contents of these locations will be placed directly into the appropriate
                          655   ;	register and should be used by the user instead of the actual register.
                          656   
                          657   ;	GRAPHM ....... See above. If = $FF then editor leaves VIC alone.
                          658   ;	CHAREN ....... Mask for R6510 /charen bit.
                          659   ;	VM1 .......... VIC text mode Video Matrix & Character Base pointer.
                          660   ;	VM2 .......... VIC graphic mode Video Matrix & Bit Map pointer.
                          661   ;	VM3 .......... 8563 text display base address.
                          662   ;	VM4 .......... 8563 attribute base address.
                          663   ;	SPLIT ........ If split screen mode, contains value for 'middle' raster IRQ.
                          664   ;	CURMOD ....... 8563 cursor mode.
                          665   ;	PAUSE ........ Control-S in effect flag. Is = $13 if so.
                          666   
                          667   ;	Some insight into KERNAL symbols:
                          668   
                          669   ;	INIT_STATUS .. See also above. Lets system know what has been initialized
                          670   ;			and what hasn't. Set to $00 by a reset but untouched by NMI.
                          671   ;	SYSTEM_VECTOR. Where the kernal goes when it has to go somewhere. It's set
                          672   ;			to BASIC COLD at reset. BASIC itself sets it to BASIC WARM
                          673   ;			after it has inited. The MONITOR respects it too.
                          674   ;	SYSTEM ....... Vector in RAM1 at $FFF8. Set at powerup to C128MODE, user may
                          675   ;			redirect it to his code. Taken at RESET always, providing
                          676   ;			user with control (protection) from reset.
                          677   	.include relnotes

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 14
RELEASE NOTES:   BETA-5   03/05/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                          679   	.subttl  RELEASE NOTES:   BETA-5   03/05/85
                          680   
                          681   ; THE FOLLOWING MODIFICATIONS HAVE BEEN MADE TO THE BETA-4 CODE TO CREATE THE
                          682   ; BETA-5 VERSION RELEASED ON 03/05/85. THE BETA-5 RELEASE IS A PRE-PRODUCTION
                          683   ; VERSION INTENDED FOR SYSTEM TEST AND EVALUATION AND PRELIMINARY APPLICATION
                          684   ; SOFTWARE DEVELOPMENT ONLY.
                          685   ;
                          686   ;
                          687   ; The following changes have been made to the MONITOR:
                          688   ;
                          689   ;	1/	The MONITOR now accepts binary, octal, decimal and hexidecimal
                          690   ;		values for any numeric field. This was accomplished by totally
                          691   ;		re-coding PARSE and portions of ASSEM, and installing a new
                          692   ;		routine called EVAL. Numbers prefixed by one of the characters
                          693   ;		$ + & % are interpreted by EVAL as base 16, 10, 8, or 2 values
                          694   ;		respectively. In the absence of a prefix, the base defaults to
                          695   ;		hexidecimal always. ASSEM will use the zero-page form wherever
                          696   ;		possible unless the value is preceeded by extra zeros to force
                          697   ;		the absolute form (except binary notation).
                          698   ;
                          699   ;	2/	The MONITOR now performs limited number conversion.  Additions
                          700   ;		were made to MAIN1 and CMDCHR and a new routine called CONVERT
                          701   ;		was installed to handle the conversions. Any of the characters
                          702   ;		$ + & % entered as a command and prefixing a numeric value are
                          703   ;		PARSEd (see #1 above) and the hexidecimal value printed.  Full
                          704   ;		conversion between bases may be added in a later release.
                          705   ;
                          706   ;
                          707   ;
                          708   ; The following changes have been made to the EDITOR:
                          709   ;
                          710   ;	1/	PLOT (SET)  now performs  range checking.  The cursor position
                          711   ;		sought must lie within the currently defined window. If it does,
                          712   ;		the position is changed and .C=0 returned, else NO CHANGE made
                          713   ;		and .C=1 returned.
                          714   ;
                          715   ;	2/	PLOT (READ) now returns the current cursor position within the
                          716   ;		current window  (with respect to the window's origin)  and NOT
                          717   ;		necessarily the screen origin.
                          718   ;
                          719   ;	3/	SCRORG was changed in a previous release to return the current
                          720   ;		window size in .X and .Y and NOT the screen size.  SCRORG will
                          721   ;		now return the maximum screen width (39 or 79) as well in .A.
                          722   ;
                          723   ;	4/	The entire data file, ED7.SRC, has been relocated to  $FA00 to
                          724   ;		allow a reserved area in ROM for foreign language systems. The
                          725   ;		reserved area shall be $FC80 thru $FEFF. This affects the MODE
                          726   ;		tables, COLor tables, BITS, local variable init table, and all
                          727   ;		PKY function key tables.
                          728   ;
                          729   ;	5/	The default screen colors for the  80-column  screen have been
                          730   ;		changed to BLACK background and CYAN characters. This was done
                          731   ;		to make a more presentable screen for systems using monochrome
                          732   ;		monitors and allow a full pallet of colors without  background
                          733   ;		interference for systems using RGBI monitors.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 14-1
RELEASE NOTES:   BETA-5   03/05/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                          734   ;
                          735   ;
                          736   ;
                          737   ; The following changes have been made to the KERNAL:
                          738   ;
                          739   ;	1/	IOINIT now initializes the 8563 chip from an updated table now
                          740   ;		that the tower has been removed. Also changed were the default
                          741   ;		screen colors (see #5 above) and adjustments for PAL systems.
                          742   ;
                          743   ;	2/	IOINIT now has a delay loop of approximately 300ms incorporated
                          744   ;		into it to allow older versions of the VIC-1541 disk drives to
                          745   ;		finish their reset sequence. The system previously hung in the
                          746   ;		auto-boot routine if in 40-column mode with old 1541's.
                          747   ;

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 15
RELEASE NOTES:   BETA-6   03/20/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                          749   	.subttl  RELEASE NOTES:   BETA-6   03/20/85
                          750   
                          751   ; THE FOLLOWING MODIFICATIONS HAVE BEEN MADE TO THE BETA-5 CODE TO CREATE THE
                          752   ; BETA-6 VERSION RELEASED ON 03/20/85. THE BETA-6 RELEASE IS A PRE-PRODUCTION
                          753   ; VERSION INTENDED FOR SYSTEM TEST AND EVALUATION AND PRELIMINARY APPLICATION
                          754   ; SOFTWARE DEVELOPMENT ONLY. NOTE THE CHANGE TO THE CHARACTER ROM ALSO.
                          755   ;
                          756   ;
                          757   ;
                          758   ; The following changes have been made to the MONITOR:
                          759   ;
                          760   ;	1/	Number conversion from/to all bases (hex,dec,oct,bin) fully
                          761   ;		functional. Display format different from beta-5 also.
                          762   ;
                          763   ;	2/	The monitor DOS parser now provides DIRECTORY display using
                          764   ;		the syntax:  @[unit#],$[drive:filespec]
                          765   ;
                          766   ;
                          767   ;
                          768   ; The following changes have been made to the EDITOR:
                          769   ;
                          770   ;	1/	The KEYSCAN routine was corrected to properly leave the COLM
                          771   ;		driver port energizing only PB7. (Previously if no keys were
                          772   ;		down all lines were left energized.) Also the scan of the
                          773   ;		CAPS LOCK key was moved to the beginning of the KEYSCAN loop
                          774   ;		where it will always be scanned and SHFLAG correctly updated.
                          775   ;		(Previously if no matrix keys were down it was not scanned.)
                          776   ;
                          777   ;	2/	The CLRLIN and MOVLIN routines have had all the 'kludge' code
                          778   ;		removed as it is no longer necessary using 8563R7 parts. Two
                          779   ;		absolute variables consequently have disappeared, SAV80C & D.
                          780   ;
                          781   ;	3/	The various tables used by the screen editor have been shifted
                          782   ;		around to allow better utilization of free ROM. The MODEx tables
                          783   ;		now start at $FA80. All other tables now float above editor code.
                          784   ;
                          785   ;
                          786   ;
                          787   ; The following changes have been made to the KERNAL:
                          788   ;
                          789   ;	1/	The interrupt handlers now clear decimal mode (via CLD). This
                          790   ;		is done AFTER the indirect jumps are made. The correct mode is
                          791   ;		restored upon return from the interrupt code as usual.
                          792   ;
                          793   ;	2/	The SERIAL & TAPE routines now work at either 1 or 2MHz speed.
                          794   ;		This was accomplished by replacing 'SEI' and 'CLI' opcodes in
                          795   ;		time sensitive routines with JSR's to new code which saves the
                          796   ;		current states & forces sprites off & 1MHz speed, and then re-
                          797   ;		stores them all when through. This required minor changes to the
                          798   ;		TAPE routines, but the serial ACPTR routine was totally re-coded.
                          799   ;		Several absolute variables to store the states have been added
                          800   ;		as well as one called HOLD_OFF which, if B7 is set, will cause
                          801   ;		these new SEI/CLI routines to be skipped & require the user to
                          802   ;		assume full responsibility for controlling system speed & sprites
                          803   ;		during tape or serial I/O operations.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 15-1
RELEASE NOTES:   BETA-6   03/20/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                          804   ;
                          805   ;	3/	The space key now correctly skips the current 'found' file during
                          806   ;		TAPE loads. (The C= key or <no> action will initiate program load.)
                          807   ;
                          808   ;	4/	The CLOSE routine now saves the CARRY status in SVXT and not VERCK.
                          809   ;		This corrects a conflict with the LOAD routine's use of VERCK.
                          810   ;
                          811   ;	5/	The BURST routine now correctly reports a 'device not present'. It
                          812   ;		previously reported 'illegal device number'.
                          813   ;
                          814   ;	6/	Improved TKSA (serial routine) turnaround by putting DEBPIA inline.
                          815   ;
                          816   ;	7/	The OPEN routine now JSR's to OPENI for serial operations. This
                          817   ;		corrects a problem that occurred when the device was not present.
                          818   ;		OPENI pops the return address and JMPs to ERROR5 at such time.
                          819   ;
                          820   ;	8/	The INSTALL routine now downloads to RAM the correct code for the
                          821   ;		DMA Controller. Previously the wrong subroutine was downloaded.
                          822   ;		Also, a NOP was added to the RAM code after the DMA request.
                          823   ;
                          824   ;
                          825   ;
                          826   ; The following changes have been made to the CHARACTER ROM:
                          827   ;
                          828   ;	1/	Part number 315010-02 has a minor error in the font definition
                          829   ;		for the lower case reverse field 'v'. This has been corrected in
                          830   ;		part number 315010-03.
                          831   ;
                          832   ;	2/	Part number 315010-03 also includes a modification to the lower
                          833   ;		case 'm' character (both normal & reverse fields) due to several
                          834   ;		complaints about its appearance.
                          835   ;

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 16
RELEASE NOTES:   BETA-7   04/08/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                          837   	.subttl  RELEASE NOTES:   BETA-7   04/08/85
                          838   
                          839   ; THE FOLLOWING MODIFICATIONS HAVE BEEN MADE TO THE BETA-6 CODE TO CREATE THE
                          840   ; BETA-7 VERSION RELEASED ON 04/08/85. THE BETA-7 RELEASE IS A PRE-PRODUCTION
                          841   ; VERSION INTENDED FOR SYSTEM TEST AND EVALUATION AND PRELIMINARY APPLICATION
                          842   ; SOFTWARE DEVELOPMENT ONLY. NOTE THE CHANGE TO THE CHARACTER ROM ALSO.
                          843   ;
                          844   ;
                          845   ;
                          846   ; The following changes have been made to the MONITOR:
                          847   ;
                          848   ;	1/	Previously the HUNT command treated <colon> and <question> in
                          849   ;		ASCII strings as terminators, hence they could not be  hunted
                          850   ;		for. This has been corrected.
                          851   ;
                          852   ; The following changes have been made to the KERNAL:
                          853   ;
                          854   ;	1/	Previously the GO64 routine redirected the soft  RESET vector
                          855   ;		back to itself thus providing a degree of protection to  C/64
                          856   ;		software as the system had to be powered down to  escape C/64
                          857   ;		mode. Unfortunately DRAM devices are not as  volatile as they
                          858   ;		used to be and many systems required as much as 30 seconds to
                          859   ;		elapse before they would power up into C/128 mode.  The RESET
                          860   ;		vector is still present but the GO64 code no longer redirects
                          861   ;		it. Applications using RESET should note the problem and pro-
                          862   ;		vide a friendly escape mechanism after protecting themselves.
                          863   ;
                          864   ;	2/	Previously it was possible to enter C64 mode running at 2MHz.
                          865   ;		This has been corrected. Note it is possible from C64 mode to
                          866   ;		access the 1-2MHz bit (VIC register 48) to speed  up  certain
                          867   ;		operations if so desired.
                          868   ;
                          869   ;	3/	Several minor changes to SERIAL code.  Some inaccessable code
                          870   ;		was removed from TALK/LISTEN routine.  TKSA now errors out if
                          871   ;		the SA could not be sent.
                          872   ;
                          873   ;	4/	Previously the BOOT routine returned  without  reporting  any
                          874   ;		errors.  BOOT now returns errors in the same manner as LOADs,
                          875   ;		with the carry set and error code in the accumulator.
                          876   ;
                          877   ;	5/	Previously the BURST load mechanism caused open disk channels
                          878   ;		to be flushed. This has been corrected and now preserves open
                          879   ;		user channels as the C/64 LOAD had  (e.g. chaining programs).
                          880   ;		Note however that  BOOT loads will cause all open  files  for
                          881   ;		the given device to be closed (see CLOSE_ALL note below).
                          882   ;
                          883   ;	6/	BURST must  UNLISTEN the  1571 when a break occurs (STOP key)
                          884   ;		to signal the drive to  abort the  operation.  Previously the
                          885   ;		drive stayed in its burst routine waiting to  send  the  next
                          886   ;		block of data. This fix will prompt the drive to abort too.
                          887   ;
                          888   ;	7/	The DMA controller routine (for RAMDISK) has been modified to
                          889   ;		meet the latest RAMDISK specification.
                          890   ;
                          891   ;	8/	A new Kernal JUMP TABLE entry has been created for an all new

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 16-1
RELEASE NOTES:   BETA-7   04/08/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                          892   ;		Kernal subroutine, CLOSE_ALL.   Unlike  CLALL,  which  simply
                          893   ;		cleared the LAT, FAT, SAT tables and restored the default I/O
                          894   ;		devices without properly closing files, CLOSE_ALL is passed a
                          895   ;		device number (fa) and properly closes ALL open files on that
                          896   ;		device. If that device was the current I/O device,  only then
                          897   ;		will CLOSE_ALL restore the  appropriate default device.  This
                          898   ;		new jump vector is located at $FF4A.
                          899   ;
                          900   ;	9/	The Kernal IOINIT routine will recognize 8563-R8 & initialize
                          901   ;		register #25 (horz. smooth scroll) to $47 per 8563 spec mods.
                          902   ;		Previously this register was  initialized to  $40.  Note that
                          903   ;		the lower 3 bits of the 8563 status register will return  the
                          904   ;		revision level of the 8563 part (0=R7, 1=R8, etc.)
                          905   ;
                          906   ;
                          907   ; The following changes have been made to the CHARACTER ROM:
                          908   ;
                          909   ;	1/	The hardware now supports an 8K byte character ROM. The lower
                          910   ;		4K contains the C/64 character set  (P/N 901225-01),  and the
                          911   ;		upper 4K contains the  C/128  character set  (P/N 315010-03).
                          912   ;		In domestic systems the switching mechanism  is  the  /64-128
                          913   ;		MMU signal and is therefore transparent to the user.  It  has
                          914   ;		been proposed that international units replace one of the  4K
                          915   ;		character sets with their particular national  character  set
                          916   ;		and utilize the CAPS_LOCK key to manually switch sets.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 17
RELEASE NOTES:   BETA-8   04/15/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                          918   	.subttl  RELEASE NOTES:   BETA-8   04/15/85
                          919   
                          920   ; THE FOLLOWING MODIFICATIONS HAVE BEEN MADE TO THE BETA-7 CODE TO CREATE THE
                          921   ; BETA-8 VERSION RELEASED ON 04/15/85. THE BETA-8 RELEASE IS A PRE-PRODUCTION
                          922   ; VERSION INTENDED FOR SYSTEM TEST AND EVALUATION AND PRELIMINARY APPLICATION
                          923   ; SOFTWARE DEVELOPMENT ONLY.
                          924   ;
                          925   ;	**************************************************************
                          926   ;	* PENDING SYSTEM TEST, THIS SHALL BE THE FINAL BETA RELEASE. *
                          927   ;	* ANY  PROBLEMS  OR  NEEDS  *MUST*  BE  REPORTED  TO  SYSTEM *
                          928   ;	* ENGINEERING BEFORE  04/19/85  FOR RESOLUTION AND INCLUSION *
                          929   ;	* INTO THE PRODUCTION ROM RELEASE!			     *
                          930   ;	**************************************************************
                          931   ; 
                          932   ;
                          933   ;
                          934   ;
                          935   ; The following changes have been made to the MONITOR:
                          936   ;
                          937   ;	1/	The  Monitor DOS interface  now  uses  the  reserved  logical
                          938   ;		channel number 0, and no longer transmits a 'close' to the
                          939   ;		disk. Previously it used channel 1 (which was often in use by
                          940   ;		the user) and performed a full 'close' (which caused the disk
                          941   ;		to close ALL open files).
                          942   ;
                          943   ;	2/	The  Monitor DOS interface no longer allows  access  to  unit
                          944   ;		numbers 3 and 31. They are illegal serial bus devices.
                          945   ;
                          946   ;	3/	The  Monitor MEMORY DUMP facility correctly displays the full
                          947   ;		CBM ASCII character set.  Previously the  ASCII was masked to
                          948   ;		7 bits.
                          949   ;
                          950   ; The following changes have been made to the KERNAL:
                          951   ;
                          952   ;	1/	The  Kernal BOOT routine no longer transmits a 'close' to the
                          953   ;		disk. The disk status will now reflect the last I/O operation
                          954   ;		status similar to a 'load' operation.  A reduntant attempt to
                          955   ;		transmit the disk warm start (UI) command was removed.
                          956   ;
                          957   ;	2/	The Kernal GO64 routine now insures that the 6510 port /HIRAM
                          958   ;		and /LORAM  lines  are set  HIGH  before entering  C64  mode.
                          959   ;		Previously entering C64 mode  (where /HIRAM and /LORAM select
                          960   ;		RAM and ROM memory configurations)  from a C128 graphics mode
                          961   ;		(where  /HIRAM and /LORAM  select  VIC  and  processor  color
                          962   ;		nybble banks) would crash the C64 system  because its  system
                          963   ;		ROM was not in context and entry was not via hardware reset.
                          964   ;
                          965   ;
                          966   ; The following changes have been made to the EDITOR:
                          967   ;
                          968   ;	1/	The IRQ screen handler has been modified to accommodate 2 MHz
                          969   ;		split screen operation. Previously the split screen operation
                          970   ;		in 2 MHz mode caused the IRQ keyscan to be skipped.
                          971   ;
                          972   ;	2/	A difference between the C64 and C128 screen editors has been

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 17-1
RELEASE NOTES:   BETA-8   04/15/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                          973   ;		noted but will NOT BE CHANGED because the same anomaly occurs
                          974   ;		with the windowing editor on other products.  The  effect  is
                          975   ;		illustrated by the following BASIC operation:
                          976   ;
                          977   ;			10 OPEN 1,0	:REM   OPEN CHANNEL TO KEYBOARD
                          978   ;			20 INPUT#1,A$	:REM   INPUT A LINE
                          979   ;			30 PRINT A$	:REM   DISPLAY LINE INPUT
                          980   ;
                          981   ;		The PRINT A$  will overwrite the last character of the string
                          982   ;		entered in response to the 'INPUT'.  The C/64 editor does not
                          983   ;		overwrite; in fact there are extra spaces found  between  the
                          984   ;		input and output strings.  Any requests to change this should
                          985   ;		be sent as soon as possible!
                          986   ;

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 18
RELEASE NOTES:   BETA-8   04/15/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                          988   	.subttl  RELEASE NOTES:   BETA-8   04/15/85
                          989   
                          990   ; THE FOLLOWING MODIFICATIONS HAVE BEEN MADE TO THE BETA-8 CODE TO CREATE THE
                          991   ; BETA-9 VERSION RELEASED ON 04/19/85. THE BETA-8 RELEASE IS A PRE-PRODUCTION
                          992   ; VERSION INTENDED FOR SYSTEM TEST AND EVALUATION AND PRELIMINARY APPLICATION
                          993   ; SOFTWARE DEVELOPMENT ONLY.
                          994   ;
                          995   ;	**************************************************************
                          996   ;	* PENDING SYSTEM TEST, THIS SHALL BE THE FINAL BETA RELEASE. *
                          997   ;	**************************************************************
                          998   ; 
                          999   ;
                         1000   ; The following changes have been made to the KERNAL:
                         1001   ;
                         1002   ;	1/	The Kernal TAPE handler previously returned the  wrong  error
                         1003   ;		code upon encountering the EOT. This has been fixed to report
                         1004   ;		'file not found'.
                         1005   ;
                         1006   ; The following changes have been made to the EDITOR:
                         1007   ;
                         1008   ;	1/	DOCUMENTATION ONLY:  Please note that  the  Editor  does  not
                         1009   ;		factor in 'VM1' when utilizing 'LDTBL1'.  This means that the
                         1010   ;		IRQ screen handler WILL move the screen per VM1 but that  all
                         1011   ;		printing will continue to update the screen at $400.  Because
                         1012   ;		LDTBL1 is in ROM it cannot be modified as in the  C/64.   Any
                         1013   ;		requests to change this mechanism must be made NOW.
                         1014   ;
                         1015   ;	2/	The Editor now includes the National keyboard  lookup  tables
                         1016   ;		and a National-to-ASCII conversion table.  While there is  no
                         1017   ;		National keyboard driver code in ROM, it is expected that the
                         1018   ;		inclusion of these tables will provide sufficient support for
                         1019   ;		RAM or Function Cartridge based drivers.  AN APPLICATION NOTE
                         1020   ;		WILL BE FORTHCOMING TO DETAIL THE IMPLEMENTATION OF A DRIVER.
                         1021   ;		
                         1022   ; The following changes reference ALL sections of code:
                         1023   ;		
                         1024   ;	1/	The three (3) C/128 ROMs now contain a revision  byte  and  a
                         1025   ;		byte reserved for 'rounding' the checksum. The locations  are
                         1026   ;		given below. Please note that the 'revision'  byte  described
                         1027   ;		here refers to  the  individual  ROM  contents,  NOT  to  the
                         1028   ;		software (e.g.: the KERNAL software revision byte is $FF80).
                         1029   ;
                         1030   ;			LOW (U33):	$7FFE - REVISION BYTE
                         1031   ;					$7FFF - CHECKSUM ADJUST
                         1032   ;
                         1033   ;			MID (U34):	$BFFE - REVISION BYTE
                         1034   ;					$BFFF - CHECKSUM ADJUST
                         1035   ;
                         1036   ;			HIGH (U35):	$CFFE - REVISION BYTE
                         1037   ;					$CFFF - CHECKSUM ADJUST
                         1038   ;
                         1039   ;		The 8-bit checksum is calculated over the ROM's  contents  by
                         1040   ;		adding the sequential bytes for each 16KB ROM, discarding any
                         1041   ;		carry between additions. Thus the sum of each ROM  should  be
                         1042   ;		equal to the MSB of its starting address (e.g.: LO=$40,  MID=

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 18-1
RELEASE NOTES:   BETA-8   04/15/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                         1043   ;		$80, HI=$C0).  Please note the checksum of the HI  (U35)  ROM
                         1044   ;		does NOT include the CP/M portion (address range $D000-$DFFF)
                         1045   ;		as this section of ROM cannot be read by the host processor. 

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 19
RELEASE NOTES:   318020-03   05/08/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                         1047   	.subttl  RELEASE NOTES:   318020-03   05/08/85
                         1048   
                         1049   ; THE FOLLOWING MODIFICATIONS HAVE BEEN MADE TO THE  318020-02 CODE TO CREATE
                         1050   ; THE 318020-03 VERSION RELEASED ON 05/08/85.  THIS RELEASE IS MADE TO CREATE
                         1051   ; MASKED ROMS FOR PRODUCTION.
                         1052   ;
                         1053   ; 
                         1054   ;
                         1055   ; The following changes have been made to the KERNAL:
                         1056   ;
                         1057   ;	1/	Previously the IOINIT routine improperly initialized PAL  and
                         1058   ;		'R8' versions of the 8563 80-column display device. This  has
                         1059   ;		been corrected. Testing of these modes has been very limited.
                         1060   ;
                         1061   ;	2/	Previously the fast SERIAL routine SPINP forced the  50/60 Hz
                         1062   ;		flag on D1CRA low (60Hz). This has been corrected to preserve
                         1063   ;		the status of this line.
                         1064   ;
                         1065   ;	3/	A new jump table entry has been created for the  fast  SERIAL
                         1066   ;		routines SPINP and SPOUT at $FF47.  Users must enter with the
                         1067   ;		carry flag clear to select SPINP and carry flag set for SPOUT
                         1068   ;
                         1069   ;	4/	Previously the SERIAL routine DISK_CLI enabled  IRQ's  before
                         1070   ;		restoring the sprite enable register. This caused  the  BASIC
                         1071   ;		IRQ sprite handler, under stress, to lose sprites.  This  has
                         1072   ;		been corrected. The fix required a change as well to the TAPE
                         1073   ;		routine TNIF which shared portions of the  DISK_CLI  routine.
                         1074   ;		The shared code has been eliminated by copying the  necessary
                         1075   ;		portions to TNIF.
                         1076   ;
                         1077   ;	5/	Previously the Kernal RAM code for  JMPFAR called the  GETCFG
                         1078   ;		ROM code directly.  To preserve code  modularity,  the direct
                         1079   ;		address was replaced by the Kernal jump table address.
                         1080   ;
                         1081   ; The following changes have been made to the EDITOR:
                         1082   ;
                         1083   ;	1/	Due to remaining problems with the 8563 block fill  function,
                         1084   ;		the so-called KLUDGE code has again been added to the  CLRLIN
                         1085   ;		routine.  This patch will clear up the occasional  characters
                         1086   ;		seen on the 80-column text screen after a SCNCLR, and will be
                         1087   ;		valid even after the 8563 bug is fixed.  Two (2) absolute RAM
                         1088   ;		variables were added to DECLARE without disturbing anything.
                         1089   ;
                         1090   ;	2/	Previously it was not possible to move the VIC 40-column text
                         1091   ;		screen and still utilize the screen editor  because  LDTB1 is
                         1092   ;		is ROM based (unlke the C64 which is RAM based).  To  provide
                         1093   ;		this capability a new variable, LDTB1_SA has been created and
                         1094   ;		may be used in conjunction with the variable VM1 to  move the
                         1095   ;		VIC text screen. VM1 should be written instead of VIC reg #24
                         1096   ;		(default value $14) and LDTB1_SA loaded with the high byte of
                         1097   ;		the new screen location (default value $04). Please note that
                         1098   ;		the placement of VIC video matrices is limited by  the  image
                         1099   ;		of the character ROM VIC sees at $1000-$1FFF and the presence
                         1100   ;		of ROM beginning at $4000 in the system's  memory  map.  This
                         1101   ;		change affected Editor routines SCRSET and MOVLIN which  used

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 19-1
RELEASE NOTES:   318020-03   05/08/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                         1102   ;		LDTB1 directly, and CINT which now initializes LDTB1_SA.
                         1103   ;
                         1104   ;	3/	There was a problem with windows one (1) character wide in 80
                         1105   ;		column mode which affected areas outside the  window. It  was
                         1106   ;		been corrected by testing for this special case in CLRL80.
                         1107   ;
                         1108   ;	4/	The NATIONAL keyboard lookup tables and the National-to-ASCII
                         1109   ;		conversion table have been removed.  They were  found  to  be
                         1110   ;		unnecessary for Foreign-language systems and insufficent  for
                         1111   ;		other applications. AN APPLICATION NOTE IS FORTHCOMING.
                         1112   ;
                         1113   ;	5/	The handling of 8563s special attributes (ALT, RVS, UNDERLINE
                         1114   ;		and FLASH) has been  made  more  consistant  throughout.  The
                         1115   ;		BLANK and CLRLN routines now strip all attributes except ALT.
                         1116   ;		(this will affect, for example, INSERT and DELETE).   Various
                         1117   ;		other routines now preserve the RVS bit  (not to be  confused
                         1118   ;		with reverse-field mode; this hardware bit is  unused  by the
                         1119   ;		system but can be set by the user).
                         1120   ;
                         1121   ;	6/	A single <ESCAPE> no longer cancels all  editor  modes  (e.g.
                         1122   ;		quote, insert, underline, flash & reverse). A double <ESCAPE>
                         1123   ;		or <ESCAPE>-O is now required. 
                         1124   ;

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 20
RELEASE NOTES:   318018-03, 318019-03, 318020-04   10/11/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                         1126   	.subttl   RELEASE NOTES:   318018-03, 318019-03, 318020-04   10/11/85
                         1127   
                         1128   ; THE FOLLOWING MODIFICATIONS HAVE BEEN MADE TO THE 318018-02, 318019-02, AND
                         1129   ; 318020-03 CODE TO CREATE A NEW ROM SET RELEASED ON 10/11/85.  THIS  RELEASE
                         1130   ; IS MADE TO CREATE MASKED ROMS FOR PRODUCTION.
                         1131   ;
                         1132   ; 
                         1133   ;        The following information represents a filtered condensation  of
                         1134   ;        all  known problems, complaints, and suggestions that pertain to
                         1135   ;        the C/128 system software to  date  (exclusive  of  CP/M).   The
                         1136   ;        current system software consists of:
                         1137   ;
                         1138   ;        1.  Part No. 318018-02 --> BASIC LOW            ($4000-$7FFF)
                         1139   ;
                         1140   ;        2.  Part No. 318019-02 --> BASIC HIGH, MONITOR  ($8000-$BFFF)
                         1141   ;
                         1142   ;        3.  Part No. 318020-03 --> EDITOR, KERNEL, CP/M ($C000-$FFFF)
                         1143   ;
                         1144   ;        Each 16KB ROM contains  a  small  patch  area  for  changes,  if
                         1145   ;        necessary,   and   all   patches   described   below  have  been
                         1146   ;        accomplished such that any single change will never affect  more
                         1147   ;        that  one  ROM.   Similarly, each ROM contains a revision status
                         1148   ;        byte  (at  $7FFE,   $BFFE,   and   $FF80   respectively)   which
                         1149   ;        applications may test to determine the release level.  Currently
                         1150   ;        they are all zero.  Problems have been found with  the  code  in
                         1151   ;        all   three  ROMs  above.   While  not  all  problems  in-and-of
                         1152   ;        themselves merit changing a particular ROM,  collectively  there
                         1153   ;        is  sufficient  cause  to  make  updates to all three ROMs.  The
                         1154   ;        following summary itemizes the changes by ROM:
                         1155   ;
                         1156   ;
                         1157   ;        Part No.  318018-02 --> BASIC LOW ($4000-$7FFF)
                         1158   ;
                         1159   ;        1.  LIST and DELETE commands.  Previously they did not report as
                         1160   ;            errors  certain  non-numeric characters passed as arguments,
                         1161   ;            such as 'LIST A'.  This has been corrected  totally  in-line
                         1162   ;            by  adjusting  an  erroneous  relative branch in the 'RANGE'
                         1163   ;            subroutine.
                         1164   ;
                         1165   ;        2.  CIRCLE  command.    Previously   an   unspecified   Y-radius
                         1166   ;            defaulted  to  the X-radius (as it should), but the X-radius
                         1167   ;            value had already been scaled for the  X-axis  and  not  the
                         1168   ;            Y-axis.   This has been corrected totally in-line by scaling
                         1169   ;            the radii after the defaults have been established.
                         1170   ;
                         1171   ;        3.  RS-232 STatus.  Previously accessing  ST  after  RS-232  I/O
                         1172   ;            resulted  in  an incorrect status being returned from, and a
                         1173   ;            zero written to, location $10A14,  possibly  corrupting  the
                         1174   ;            BASIC variable area.  This was a result of BASIC calling the
                         1175   ;            Kernel routine 'READSS'  with  the  incorrect  RAM  bank  in
                         1176   ;            context.    This  has  been  corrected  totally  in-line  by
                         1177   ;            substituting the correct BASIC subroutine call.
                         1178   ;
                         1179   ;        4.  CHAR command.  Previously using CHAR with the 80-column text
                         1180   ;            screen  (GRAPHIC  mode  5)  resulted  in  RAM  corruption at

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 20-1
RELEASE NOTES:   318018-03, 318019-03, 318020-04   10/11/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                         1181   ;            locations $D600 and $D601 of RAM  bank  0  (the  BASIC  text
                         1182   ;            bank)  due  to BASIC calling the Editor PLOT routine without
                         1183   ;            the I/O block in context.  This has been corrected utilizing
                         1184   ;            two patch subroutines.
                         1185   ;
                         1186   ;        5.  RENUMBER command.   Previously  the  pass  2  routine, which
                         1187   ;            was to pre-scan BASIC text and report 'out of memory' errors
                         1188   ;            prior  to  actually changing anything, was seriously flawed.
                         1189   ;            This has been corrected utilizing a patch subroutine.
                         1190   ;
                         1191   ;        6.  DELETE command.   Previously did not limit-check itself when
                         1192   ;            moving down BASIC text,  therefore it was possible to  crash
                         1193   ;            when DELETEing lines at or near the top of memory  (near the
                         1194   ;            MMU  configuration  registers).   This  has  been  corrected
                         1195   ;            utilizing a patch subroutine.
                         1196   ;
                         1197   ;
                         1198   ;            Part No.  318019-02 --> BASIC HIGH & MONITOR ($8000-$BFFF)
                         1199   ;
                         1200   ;        7.  RSPRITE and RSPPOS functions.  Previously they  accepted  as
                         1201   ;            parameters  sprite  numbers  in  the  range  1-16,  which is
                         1202   ;            incorrect.  This  has  been  corrected  totally  in-line  by
                         1203   ;            limiting  the  range  check to 1-8, and reporting an illegal
                         1204   ;            quantity error for sprite numbers outside this range.
                         1205   ;
                         1206   ;        8.  PRINT  USING  command.   Previously  there  was  an  anomaly
                         1207   ;            involving  the  use  of  floating  money  symbols  ('$') and
                         1208   ;            commas.  The command  'PRINT USING "#,##$.##"; 123.45',  for
                         1209   ;            example,   resulted  in  the  output  '$,123.45',  which  is
                         1210   ;            incorrect.  This has been fixed utilizing a patch subroutine
                         1211   ;            which  checks  specifically  for  the  '$,'  occurrence  and
                         1212   ;            substitutes a '_$' ('_' = fill character) whenever found.
                         1213   ;
                         1214   ;        9.  Relative  Coordinates  for  all  graphic  commands   (except
                         1215   ;            MOVSPR)   were   incorrectly  processed.   The  problem  was
                         1216   ;            apparent when negative relative coordinates were used, which
                         1217   ;            resulted  in  an  illegal  quantity  error.   This  has been
                         1218   ;            corrected  totally  in-line  by  substituting  a   different
                         1219   ;            subroutine  call  to pre-existing code.  This change affects
                         1220   ;            the BASIC commands LOCATE, DRAW, PAINT, BOX, CIRCLE, GSHAPE,
                         1221   ;            and  SSHAPE.   This  change  also  allows  negative absolute
                         1222   ;            coordinates to be accepted (previously they resulted  in  an
                         1223   ;            illegal  quantity error), although the legal range remains a
                         1224   ;            16-bit  value:   0-65535  (unsigned)  or  -32768  to   32767
                         1225   ;            (signed:  i.e., -1 is equivalent to 65535).
                         1226   ;
                         1227   ;
                         1228   ;            Part No.  318020-03 --> EDITOR & KERNEL ($C000-$FFFF)
                         1229   ;
                         1230   ;       10.  CAPS LOCK Q.  Previously an error in  a  key  matrix  decode
                         1231   ;            table caused a lower-case 'Q' to be passed when the keyboard
                         1232   ;            is in CAPS LOCK mode.   The  table  has  been  corrected  by
                         1233   ;            substituting the correct value for upper-case 'Q'.
                         1234   ;
                         1235   ;       11.  IOINIT  system  initialization.    Previously   the   RS-232

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 20-2
RELEASE NOTES:   318018-03, 318019-03, 318020-04   10/11/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                         1236   ;            pseudo-6551  registers  were  not  initialized because these
                         1237   ;            values are expected to be given by the user whenever  RS-232
                         1238   ;            channels  are  OPENed.  Apparently many C64 users have taken
                         1239   ;            advantage of the fact the  C64  'happened'  to  clear  these
                         1240   ;            locations  and  fail  to specify critical parameters.  These
                         1241   ;            RS-232 registers are now  initialized  to  default  to:   no
                         1242   ;            parity, full duplex, 3-line, 1-stop bit, 8-bit words and 300
                         1243   ;            baud, via a patch subroutine.
                         1244   ;
                         1245   ;       12.  BASIN system  call.   Previously  attempting  input  from  a
                         1246   ;            logical channel to the screen (e.g., via INPUT#) resulted in
                         1247   ;            line too long errors.  This has been corrected  utilizing  a
                         1248   ;            subroutine  patch to preserve bit-7 of CRSW, which serves as
                         1249   ;            a flag to the Editor that a (pseudo)  end-of-line  has  been
                         1250   ;            reached.  Also note: switching between 40 and 80-column text
                         1251   ;            screens will confuse I/O with  logical screen channels.  The
                         1252   ;            Editor variable LINTMP ($A30) is not a local variable. Users
                         1253   ;            can POKE LINTMP with the screen line number  after  changing
                         1254   ;            display screens and before INPUT#'s as a work-around.
                         1255   ;
                         1256   ;       13.  OPEN RS-232 system call.   Previously  it  was  possible  to
                         1257   ;            receive  a  carry-set  status,  normally indicating a error,
                         1258   ;            when no error existed after OPENing an RS-232 channel.  This
                         1259   ;            has  been corrected totally in-line by a modification to the
                         1260   ;            code which checks for the proper X-line hardware states.
                         1261   ;
                         1262   ;       14.  LOAD system call.  Previously the normal (a.k.a.  SLOW) load
                         1263   ;            mechanism  did  not  preserve  the  starting  address of any
                         1264   ;            LOADs, which made  the  BASIC  'BOOT  "file"'  command  form
                         1265   ;            malfunction  unpredictably.  This is apparent when used with
                         1266   ;            1541  drives.   This  has  been  corrected   via   a   patch
                         1267   ;            subroutine,  which  saves the starting address of all LOADed
                         1268   ;            files at SAL and  SAH,  the  same  place  the  fast  (a.k.a.
                         1269   ;            BURST) load mechanism does.
                         1270   ;
                         1271   ;       15.  DMA system call.  Previously the kernel forced the I/O block
                         1272   ;            into  the user's memory configuration at all times, which is
                         1273   ;            no longer necessary  and,  in  fact,  seriously  limits  the
                         1274   ;            functionality  of the (final) RAM expansion cartridge.  This
                         1275   ;            has been corrected totally in-line, and affects  all  Kernel
                         1276   ;            DMA system calls as well as the BASIC FETCH, STASH, and SWAP
                         1277   ;            commands.
                         1278   ;
                         1279   ;
                         1280   ;        There are also quite  a  few  items  that,  for  one  reason  or
                         1281   ;        another,  I have categorized as either un-fixable (the fix would
                         1282   ;        be too radical given the work-around or relative severity of the
                         1283   ;        problem),  or  maybe-fixable  (given more time or the collective
                         1284   ;        approval of others).  They are included here because, one way or
                         1285   ;        the   other,   they   should  be  documented  along  with  their
                         1286   ;        implications, work-arounds, et cetera.
                         1287   ;
                         1288   ;        1.  DMA interface.  It was  recently  discovered  that  the  DMA
                         1289   ;            hardware  necessarily utilized the VIC bank pointer, not the
                         1290   ;            processor bank pointer, for address  generation  during  DMA

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 20-3
RELEASE NOTES:   318018-03, 318019-03, 318020-04   10/11/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                         1291   ;            transfers.   The  VIC  bank is determined by the contents of
                         1292   ;            the MMU RAM configuration register (VA16  (bit-6)  and  VA17
                         1293   ;            (bit-7),  $D506),  which is set at system initialization and
                         1294   ;            never changed by the system.  Consequently the FETCH, STASH,
                         1295   ;            and SWAP functions are bound to RAM-0.  It  should  be noted
                         1296   ;            that the (processor) BANK command  is still required to turn
                         1297   ;            the  I/O  block on or off prior to using those commands.  It
                         1298   ;            should  also  be  noted that  DMA  hardware is unreliable at
                         1299   ;            2MHz  clock  speeds  and  consequently the user insure  1MHz
                         1300   ;            (SLOW) mode is used before any DMA operations are performed.
                         1301   ;
                         1302   ;        2.  IRQ handler.  It is possible for the Kernel IRQ  handler  to
                         1303   ;            perform  a keyscan when the IRQ was not the Kernel's.  While
                         1304   ;            the fix has been coded, I am reluctant to include it because
                         1305   ;            of  its potential to cause problems to existing applications
                         1306   ;            which may be taking advantage of the unintentional keyscan.
                         1307   ;
                         1308   ;        3.  IRQ and NMI handlers.  The Kernel  forces  the  system  bank
                         1309   ;            into  context  before taking the RAM indirect vectors to the
                         1310   ;            actual interrupt handler.  Much flexibility can be added  to
                         1311   ;            the  mechanism if the memory bank to be brought into context
                         1312   ;            at interrupt time could be read from a variable instead of a
                         1313   ;            ROM constant.  I am reluctant to include this change because
                         1314   ;            the RAM variable would have to be located  in  a  previously
                         1315   ;            'free' location, which may be used by existing applications.
                         1316   ;
                         1317   ;        4.  SAVE-to-disk.  It is not possible to SAVE the last  byte  of
                         1318   ;            any  memory  bank  (e.g.,  RAM  at  $FFFF), because the SAVE
                         1319   ;            routine requires you to specify the end of the  area  to  be
                         1320   ;            SAVEd  as  the  ending  address PLUS ONE ($FFFF+1 -> $0000).
                         1321   ;            This is a problem found on all CBM 65xx systems.
                         1322   ;
                         1323   ;        5.  SAVE-to-cassette.  It is not possible to save the last  page
                         1324   ;            of  any memory bank (e.g., RAM at $FF00-$FFFF) to tape.  The
                         1325   ;            tape handler hangs with the motor  running  until  the  user
                         1326   ;            STOPs  it.   This is a problem found on all CBM 65xx systems
                         1327   ;            except the Plus-4.
                         1328   ;
                         1329   ;        6.  SAVE and LOAD.   While  program  SAVEs  correctly  save  the
                         1330   ;            16-bit  starting  address  for  future  LOADs,  the existing
                         1331   ;            formats do  not  save  the  memory  bank.   This  cannot  be
                         1332   ;            accommodated  without  the  creation of special C128 program
                         1333   ;            headers  for  disk  and  tape,  which  is  undesirable   and
                         1334   ;            non-trivial.
                         1335   ;
                         1336   ;        7.  STOP/RESET monitor entry.  It is not possible to  enter  the
                         1337   ;            Monitor  directly via the STOP/RESET sequence from BASIC and
                         1338   ;            then eXit back to BASIC without  incurring  a  'cold'  BASIC
                         1339   ;            initialization.   The  alternative,  taking the BASIC 'warm'
                         1340   ;            start route, would result in a system crash if BASIC had not
                         1341   ;            been properly initialized and is therefore not a recommended
                         1342   ;            fix.  The work-around, assuming  BASIC  was  running  before
                         1343   ;            STOP/RESET,  is  for  the  user  to place the value $C1 into
                         1344   ;            location $A04 (INIT_STATUS) and then eXit.
                         1345   ;

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 20-4
RELEASE NOTES:   318018-03, 318019-03, 318020-04   10/11/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                         1346   ;        8.  Monitor 'H' (hunt) command.   Because  the  editor  performs
                         1347   ;            various translations on data read from the screen, it is not
                         1348   ;            possible to Hunt for certain CBM characters, such as pi  and
                         1349   ;            all reverse-field characters.
                         1350   ;
                         1351   ;        9.  BOX command.   BOX,  because  of  the  particular  algorithm
                         1352   ;            utilized,  has  a  restricted  range  of  -16384  to  +16383
                         1353   ;            (unscaled).  The algorithm uses parameters  that  are  twice
                         1354   ;            those  given  for  calculations  and divides down the result
                         1355   ;            before  plotting.   Thus  it  is  possible  for  very  large
                         1356   ;            (unscaled)  positive coordinates to result in large negative
                         1357   ;            plots.   The  work-around   is   to   use   SCALEing,   user
                         1358   ;            range-checking,  or  avoid BOX and use either DRAW or CIRCLE
                         1359   ;            commands instead.
                         1360   ;
                         1361   ;       10.  RDOT, PEN, and  RSPPOS  functions.   These  BASIC  functions
                         1362   ;            return   the  current  pixel  cursor,  lightpen  and  sprite
                         1363   ;            positions, respectively, but  the  values  they  return  are
                         1364   ;            unSCALEd.   Correcting  this is trivial, but would result in
                         1365   ;            problems  for  existing  applications  as  well   as   being
                         1366   ;            incompatible with C64 VSP and the PLUS-4.
                         1367   ;
                         1368   ;       11.  FNDEF and GRAPHIC modes.  After defining  a  user  function,
                         1369   ;            anything that results in program relocation must be avoided,
                         1370   ;            such as GRAPHIC  'n'  or  GRAPHIC  CLR.   There  is  no  fix
                         1371   ;            planned.  The work-around is a general rule:  define GRAPHIC
                         1372   ;            screens first (then SCALE), then define functions.
                         1373   ;
                         1374   ;       12.  HELP command.  HELP does not completely identify two type of
                         1375   ;            syntax errors:  'RUN n' where 'n' is an undefined statement,
                         1376   ;            and 'XXXX n' where 'XXXX' is any BASIC command which expects
                         1377   ;            no  argument.   In  the  RUN  case,  TXTPTR had already been
                         1378   ;            reset, but not OLDLIN, thus the correct  line  is  displayed
                         1379   ;            but  without  any  highlighting.  In the other case, because
                         1380   ;            XEQCM exits via CHRGET, TXTPTR  is  incremented  before  the
                         1381   ;            error  is  caught,  resulting in part of the error not being
                         1382   ;            highlighted.  The  fix  would  be  too  complex,  especially
                         1383   ;            considering  the  fact that the line containing the error is
                         1384   ;            reported, albeit without highlighting.
                         1385   ;
                         1386   ;       13.  GETKEY  function.   In  the  form  'GETKEY  A',  this  BASIC
                         1387   ;            function  should  wait  until  a numeric key is pressed, but
                         1388   ;            certain non-numeric keys are accepted, such as  'E',  colon,
                         1389   ;            comma,  period,  '+', and '-'.  The same anomaly occurs with
                         1390   ;            'GET A' for the same reason, as is a known CBM 65xx quirk.
                         1391   ;
                         1392   ;       14.  PUDEF and PRINT USING commands.  There is poor documentation
                         1393   ;            of the fact that USING format fields such as "$,###.##", the
                         1394   ;            leading '$' or commas are not interpreted per the PUDEFs  as
                         1395   ;            they  are considered not part of the numeric field.  This is
                         1396   ;            found to occur on all CBM 65xx systems  with  BASIC  3.5  or
                         1397   ;            higher.
                         1398   ;
                         1399   ;       15.  RENUMBER command.  Because of the routine's use of LINNUM to
                         1400   ;            fetch from BASIC text the statement number of an object,  it

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 20-5
RELEASE NOTES:   318018-03, 318019-03, 318020-04   10/11/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                         1401   ;            is possible to get a 'syntax error' when none existed within
                         1402   ;            the RENUMBER command line itself.  LINNUM itself reports any
                         1403   ;            line numbers it reads that are out of range (>63999).  Also,
                         1404   ;            RENUMBER does not renumber line ranges.  Therefore, LIST and
                         1405   ;            DELETE statements within a program are NOT changed.
                         1406   ;
                         1407   ;       16.  OUT of MEMORY ERROR.  It is possible to hang the system with
                         1408   ;            this error from a running program when there is  insuffcient
                         1409   ;            memory to contain the string representation of the  original
                         1410   ;            line number where the error occurred.  One must STOP/RESTORE
                         1411   ;            the system and type CLR to recover.  This problem  is  found
                         1412   ;            on most CBM 65xx systems.
                         1413   ;
                         1414   ;        Finally, there are suggestions, requests, and enhancements  that
                         1415   ;        have  been proposed which deserve consideration even though they
                         1416   ;        pose a degree of risk and therefore are  dubious  inclusions  in
                         1417   ;        any ROM update.
                         1418   ;
                         1419   ;        1.  CHAR command.  Several people have requested  that  CHAR  be
                         1420   ;            able to plot user defined characters.  The fact that you can
                         1421   ;            is one of the many undocumented features of the C128.  In  a
                         1422   ;            graphic  bit  map  mode, CHAR fetches character data per two
                         1423   ;            RAM  pointers,  UPPER_GRAPHIC  ($11EB)   and   LOWER_GRAPHIC
                         1424   ;            ($11EC).   Note  that  the  character  definitions  must  be
                         1425   ;            located in RAM-0 between $0000-$3FFF.
                         1426   ;
                         1427   ;        2.  80-column screen initialization before  entering  C64  mode.
                         1428   ;            This is not possible without modification to C64 ROMs, which
                         1429   ;            is out of the question.  The 80-column screen is set-up when
                         1430   ;            C64 mode is entered from C128 mode, but is not when C64 mode
                         1431   ;            is entered directly from  power-up  (e.g.,  C=/RESET).   The
                         1432   ;            80-column monitor should be turned off in such cases.
                         1433   ;
                         1434   ;        3.  BACKUP command.  This command is  non-functional  without  a
                         1435   ;            dual  disk  drive.   If  there  is  never going to be such a
                         1436   ;            product, now is the time to patch it such that it  functions
                         1437   ;            as  a  unit-to-unit  BACKUP  as well.  The DOS SHELL utility
                         1438   ;            does perform this function, albeit inconveniently.
                         1439   ;
                         1440   ;        4.  New BASIC commands.  Several people have requested something
                         1441   ;            analogous  to FETCH, STASH, and SWAP (DMA BASIC commands) or
                         1442   ;            the  Monitor  'T'  (transfer)  command  to  move  blocks  of
                         1443   ;            internal RAM about.  Other common requests are FIND, CHANGE,
                         1444   ;            MERGE, LLIST and LDIR commands.  While  it  is  clearly  too
                         1445   ;            late  to  incorporate new commands into BASIC, it has always
                         1446   ;            been possible to extend the BASIC command  set  via  wedges.
                         1447   ;
                         1448   ;        5.  New Monitor commands.  There was no room in ROM  to  include
                         1449   ;            ML  tracing,  breakpoints,  code  relocators,  etc.   It  is
                         1450   ;            possible, as with BASIC, to extend the Monitor  command  set
                         1451   ;            via wedges. Also considered were Hunt wildcards, etc.
                         1452   ;
                         1453   ;        6.  ESCAPE-O.  The screen Editor interprets this key sequence as
                         1454   ;            a command to call TOQM, its routine to cancel insert, quote,
                         1455   ;            reverse, underline, and flash  modes.   The  confusion  here

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 20-6
RELEASE NOTES:   318018-03, 318019-03, 318020-04   10/11/85   RELNOTES.SRC

Error Addr  Code          Seq   Source statement

                         1456   ;            involves  insert  mode, and the error is one of terminology.
                         1457   ;            Insert mode refers to the state of the Editor after  one  or
                         1458   ;            more depressions of the INSERT key.  Auto insert mode refers
                         1459   ;            to the state of the Editor after it receives an ESCAPE-A key
                         1460   ;            sequence.   They  are  two  different modes.  Insert mode is
                         1461   ;            canceled by ESCAPE-O.   Auto  insert  mode  is  canceled  by
                         1462   ;            ESCAPE-C.
                         1463   ;
                         1464   ;        7.  CONTROL-O  (flash  mode)  and  CONTROL-B  (underline  mode).
                         1465   ;            Users  complain  that  these  cannot be turned off by typing
                         1466   ;            their complements, CONTROL-SHIFT-O and CONTROL-SHIFT-B.  The
                         1467   ;            Editor  does  not recognize any CONTROL-SHIFT keystrokes (in
                         1468   ;            fact, any 3-key depressions are  invalid  and  may  generate
                         1469   ;            'shadow' (false) keystrokes.  This is common to all CBM 65xx
                         1470   ;            systems,  the  CONTROL-N  (lower-case  mode)  sequence   for
                         1471   ;            example).  In PRINT strings, the corresponding CHR$() string
                         1472   ;            can be used.  From the keyboard, users can use  ESCAPE-O  to
                         1473   ;            cancel  the flash or underline modes (and C=/SHIFT to toggle
                         1474   ;            case modes).
                         1475   ;
                         1476   ;
                         1477   ;        The updated C/128 ROM set will bear the following part numbers:
                         1478   ;
                         1479   ;        1.  # 318018-03 --> BASIC LOW            ($4000-$7FFF, U33) cksum= E540
                         1480   ;
                         1481   ;        2.  # 318019-03 --> BASIC HIGH, MONITOR  ($8000-$BFFF, U34) cksum= 9780
                         1482   ;
                         1483   ;        3.  # 318020-04 --> EDITOR, KERNEL, CP/M ($C000-$FFFF, U35) cksum= 3EC4
                         1484   ;
                         1485   ;
                         1486   ;	 Fred Bowen	09/16/85  10/10/85
                         1487   	.include declare

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 21
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

                         1489   	.subttl DECLARE for Basic
                         1490   
                         1491   
                         1492   ;  assignments
                         1493   
            =0012        1494   lenfor		=18	;length of a 'for' entry in the run-time stack
            =0005        1495   lengos		=5	;length of a 'gosub'....
            =00A1        1496   buflen		=161	;ted input buffer size
            =01FB        1497   stkend		=$1fb
            =000A        1498   column_width	=10	;print window 10 chars
            =00FF        1499   pi		=255
            =0003        1500   strsiz		=3
            =0050        1501   maxchr		=80
            =000D        1502   cr		=$0d  	;carriage return
            =000A        1503   lf		=$0a	;line feed
            =0028        1504   llen		=40
            =0019        1505   nlines		=25
            =0480        1506   beats		=1152
                         1507   
            =0800        1508   stktop		=$0800	;basic's run-time stack
            =09FF        1509   stkbot		=$09ff
                         1510   
            =0E00        1511   sprite_base	=$0e00	;start of 2 page area for sprite defn's
                         1512   
            =1C00        1513   basbgn		=$1c00	;default start of basic
            =FF00        1514   bank_0_top	=$ff00
            =FF00        1515   bank_1_top	=$ff00
            =0400        1516   common_top	=$0400
                         1517   
            =0400        1518   screen_start	=$0400
            =2000        1519   graphic_base	=$2000
                         1520   
            =1C00        1521   color_ram_lo	=$1c00
            =D800        1522   color_ram_hi	=$d800
                         1523   
            =D000        1524   vic		=$d000
            =D020        1525   vic_border	=vic+32
            =D021        1526   vic_background	=vic+33
                         1527   
            =D400        1528   sid		=$d400
                         1529   
            =D500        1530   mmu		=$d500
            =D501        1531   mmu_preconfig_a	=mmu+1
                         1532   
            =D600        1533   _8563_addr	=$d600
            =D601        1534   _8563_data	=$d601
                         1535   
            =DC00        1536   d1_6526		=$dc00
            =DC00        1537   d1pra		=d1_6526
                         1538   
                         1539   
            =DD00        1540   d2_6526		=$dd00
            =DD00        1541   d2pra		=d2_6526
                         1542   
            =DF00        1543   _dma		=$df00

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 21-1
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

                         1544   
            =FF00        1545   mmu_config_reg	=$ff00
            =FF01        1546   sw_ram0		=mmu_config_reg+1
            =FF02        1547   sw_ram1		=mmu_config_reg+2
            =FF03        1548   sw_rom_ram0	=mmu_config_reg+3
            =FF04        1549   sw_rom_ram1	=mmu_config_reg+4
                         1550   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 22
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

                         1552   ;  basic zp storage
                         1553   ;
                         1554   
            =0002        1555   		*=2	;skip over 6510 registers
     0002   =0003        1556   srchtk		*=*+1	;token 'search' looks for (run-time stack) / SYS 'bank#'
            =0009        1557   		*=9	;skip over SYS's address,status, a_reg, x_reg, y_reg
     0009                1558   integr
     0009   =000A        1559   charac		*=*+1
     000A   =000B        1560   endchr		*=*+1
     000B   =000C        1561   trmpos		*=*+1
     000C   =000D        1562   verck		*=*+1
     000D   =000E        1563   count		*=*+1
     000E   =000F        1564   dimflg		*=*+1
     000F   =0010        1565   valtyp		*=*+1
     0010   =0011        1566   intflg		*=*+1
     0011                1567   garbfl
     0011   =0012        1568   dores		*=*+1
     0012   =0013        1569   subflg		*=*+1
     0013   =0014        1570   inpflg		*=*+1
     0014                1571   domask
     0014   =0015        1572   tansgn		*=*+1
     0015   =0016        1573   channl		*=*+1
     0016                1574   poker
     0016   =0018        1575   linnum		*=*+2
     0018   =0019        1576   temppt		*=*+1
     0019   =001B        1577   lastpt		*=*+2
     001B   =0024        1578   tempst		*=*+9
     0024                1579   index
     0024   =0026        1580   index1		*=*+2
     0026   =0028        1581   index2		*=*+2
     0028   =0029        1582   resho		*=*+1
     0029   =002A        1583   resmoh		*=*+1
     002A                1584   addend
     002A   =002B        1585   resmo		*=*+1
     002B   =002C        1586   reslo		*=*+1
            =002D        1587   		*=*+1
     002D   =002F        1588   txttab		*=*+2
     002F   =0031        1589   vartab		*=*+2
     0031   =0033        1590   arytab		*=*+2
     0033   =0035        1591   strend		*=*+2
     0035   =0037        1592   fretop		*=*+2
     0037   =0039        1593   frespc		*=*+2
     0039   =003B        1594   max_mem_1	*=*+2	;top of string/variable bank (bank 1)
     003B   =003D        1595   curlin		*=*+2
     003D   =003F        1596   txtptr		*=*+2	;pointer to basic text used by chrget,etc.
     003F                1597   form			;used by print using
     003F   =0041        1598   fndpnt		*=*+2	;pointer to item found by search
     0041   =0043        1599   datlin		*=*+2
     0043   =0045        1600   datptr		*=*+2
     0045   =0047        1601   inpptr		*=*+2
     0047   =0049        1602   varnam		*=*+2
     0049                1603   fdecpt
     0049   =004B        1604   varpnt		*=*+2
     004B                1605   lstpnt
     004B                1606   andmsk

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 22-1
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

     004B   =004D        1607   forpnt		*=*+2
            =004C        1608   eormsk		=forpnt+1
     004D                1609   vartxt
     004D   =004F        1610   opptr		*=*+2
     004F   =0050        1611   opmask		*=*+1
     0050                1612   grbpnt
     0050                1613   tempf3
     0050   =0052        1614   defpnt		*=*+2
     0052   =0054        1615   dscpnt		*=*+2
            =0055        1616   		*=*+1
     0055   =0056        1617   helper		*=*+1	;flags 'help' or 'list' ?????????????????????????get outta z.p.
     0056   =0057        1618   jmper		*=*+1
            =0058        1619   		*=*+1
     0058   =0059        1620   oldov		*=*+1
                         1621   
                         1622   
     0059   =005A        1623   tempf1		*=*+1
            =0059        1624   ptarg1		=tempf1	;multiply defined for instr
            =005B        1625   ptarg2		=tempf1+2
            =005D        1626   str1		=tempf1+4
            =0060        1627   str2		=tempf1+7
            =0063        1628   positn		=tempf1+10
            =0064        1629   match		=tempf1+11
     005A                1630   arypnt
     005A   =005C        1631   highds		*=*+2
     005C   =005E        1632   hightr		*=*+2
                         1633   
                         1634   
                         1635   
     005E   =005F        1636   tempf2		*=*+1
     005F   =0061        1637   deccnt		*=*+2
     0061                1638   grbtop
     0061                1639   dptflg
     0061   =0062        1640   lowtr		*=*+1
     0062   =0063        1641   expsgn		*=*+1
            =0060        1642   tenexp		=deccnt+1
                         1643   
                         1644   
                         1645   
     0063                1646   fac
     0063                1647   dsctmp
     0063                1648   left_flag		;paint-left flag
     0063   =0064        1649   facexp		*=*+1
     0064                1650   right_flag		;paint-right flag
     0064   =0065        1651   facho		*=*+1
     0065   =0066        1652   facmoh		*=*+1
     0066                1653   indice
     0066   =0067        1654   facmo		*=*+1
     0067   =0068        1655   faclo		*=*+1
     0068   =0069        1656   facsgn		*=*+1
     0069                1657   degree
     0069   =006A        1658   sgnflg		*=*+1
                         1659   
                         1660   
     006A   =006B        1661   argexp		*=*+1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 22-2
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

     006B   =006C        1662   argho		*=*+1
     006C   =006D        1663   argmoh		*=*+1
     006D   =006E        1664   argmo		*=*+1
     006E   =006F        1665   arglo		*=*+1
     006F   =0070        1666   argsgn		*=*+1
     0070                1667   strng1
     0070   =0071        1668   arisgn		*=*+1
                         1669   
                         1670   
                         1671   
     0071   =0072        1672   facov		*=*+1
     0072                1673   strng2
     0072                1674   polypt
     0072                1675   curtol
     0072   =0074        1676   fbufpt		*=*+2
                         1677   
     0074   =0076        1678   autinc		*=*+2	;inc. val for auto (0=off)
     0076   =0077        1679   mvdflg		*=*+1	;flag if 10k hires allocated
                         1680   
     0077   =0078        1681   z_p_temp_1	*=*+1	;using's leading zero counter, 
                         1682   			;movspr & sprite temporary,
                         1683   			;mid$= temporary
                         1684   
     0078                1685   hulp			;counter
     0078   =0079        1686   keysiz		*=*+1
                         1687   
     0079   =007A        1688   syntmp		*=*+1	;used as temp for indirect loads
     007A   =007D        1689   dsdesc		*=*+3	;descriptor for ds$
     007D   =007F        1690   tos		*=*+2	;top of run time stack
     007F   =0080        1691   runmod		*=*+1	;flags run/direct mode
                         1692   
     0080                1693   parsts			;dos parser status word
     0080   =0081        1694   point		*=*+1	;using's pointer to dec.pt
     0081   =0082        1695   parstx		*=*+1
                         1696   
     0082   =0083        1697   oldstk		*=*+1
                         1698   
                         1699   
                         1700   
                         1701   ;  graphic zp storage
                         1702   
     0083   =0084        1703   colsel		*=*+1	;current color selected
     0084   =0085        1704   multicolor_1	*=*+1
     0085   =0086        1705   multicolor_2	*=*+1
     0086   =0087        1706   foreground	*=*+1
     0087   =0089        1707   scale_x		*=*+2	;scale factor in x
     0089   =008B        1708   scale_y		*=*+2	;scale factor in y
     008B   =008C        1709   stopnb		*=*+1	;stop paint if not background/not same color
     008C   =008E        1710   grapnt		*=*+2
     008E   =008F        1711   vtemp1		*=*+1
     008F   =0090        1712   vtemp2		*=*+1
                         1713   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 23
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

            =00FF        1715   		*=$ff
     00FF   =0100        1716   lofbuf		*=*+1
                         1717   
                         1718   ;  basic/dos interface vars
                         1719   ;
     0100   =0110        1720   fbuffr		*=*+16	;area to build filename in
     0110   =0111        1721   xcnt		*=*+1	;dos loop counter
                         1722   
     0111   =0112        1723   dosf1l		*=*+1	;dos filename 1 len
     0112   =0113        1724   dosds1		*=*+1	;dos disk drive 1
                         1725   
     0113   =0114        1726   dosf2l		*=*+1	;dos filename 2 len
     0114   =0115        1727   dosds2		*=*+1	;dos disk drive 2
     0115   =0117        1728   dosf2a		*=*+2	;dos filename 2 addr
                         1729   
     0117   =0119        1730   dosofl		*=*+2	;bload/bsave starting addr
     0119   =011B        1731   dosofh		*=*+2	;..and bsave's ending addr
     011B   =011C        1732   dosla		*=*+1	;dos logical addr
     011C   =011D        1733   dosfa		*=*+1	;dos phys addr
     011D   =011E        1734   dossa		*=*+1	;dos sec. addr
                         1735   
     011E   =011F        1736   dosrcl		*=*+1	;dos record length
     011F   =0120        1737   dosbnk		*=*+1
                         1738   
     0120   =0122        1739   dosdid		*=*+2	;dos dsk identif.
     0122   =0123        1740   didchk		*=*+1	;dos did flg
                         1741   
            =0023        1742   dosspc		=*-fbuffr	;space used by dos rout.
                         1743   
                         1744   ;	Space used by PRINT USING
                         1745   
     0123   =0124        1746   bnr		*=*+1	;pointer to begin. no.
     0124   =0125        1747   enr		*=*+1	;pointer to end no.
     0125   =0126        1748   dolr		*=*+1	;dollar flag
     0126   =0127        1749   flag		*=*+1	;comma flag
     0127   =0128        1750   swe		*=*+1	;counter
     0128   =0129        1751   usgn		*=*+1	;sign exponent
     0129   =012A        1752   uexp		*=*+1	;pointer to exponent
     012A   =012B        1753   vn		*=*+1	;# of digits before decimal point
     012B   =012C        1754   chsn		*=*+1	;justify flag
     012C   =012D        1755   vf		*=*+1	;# of pos before decimal point (field)
     012D   =012E        1756   nf		*=*+1	;# of pos after decimal point (field)
     012E   =012F        1757   posp		*=*+1	;+/- flag (field)
     012F   =0130        1758   fesp		*=*+1	;exponent flag (field)
     0130   =0131        1759   etof		*=*+1	;switch
     0131   =0132        1760   cform		*=*+1	;char counter (field)
     0132   =0133        1761   sno		*=*+1	;sign no
     0133   =0134        1762   blfd		*=*+1	;blank/star flag
     0134   =0135        1763   begfd		*=*+1	;pointer to begin of field
     0135   =0136        1764   lfor		*=*+1	;length of format
     0136   =0137        1765   endfd		*=*+1	;pointer to end of field

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 24
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

                         1767   
     0137   =0200        1768   sysstk		*=$200	;system stack
     0200   =02A1        1769   buf		*=*+buflen	;basic/monitor buffer
                         1770   
                         1771   ; this area reserved for kernal storage
                         1772   
            =02FC        1773   		*=$2fc
     02FC   =02FE        1774   esc_fn_vec	*=*+2	;vector for additional function routines
     02FE   =0300        1775   bnkvec		*=*+2	;vector for function cart. users
     0300   =0302        1776   ierror		*=*+2	;indirect error (output error in .x)
     0302   =0304        1777   imain		*=*+2	;indirect main (system direct loop)
     0304   =0306        1778   icrnch		*=*+2	;indirect crunch (tokenization routine)
     0306   =0308        1779   iqplop		*=*+2	;indirect list (char list)
     0308   =030A        1780   igone		*=*+2	;indirect gone (char dispatch)
     030A   =030C        1781   ieval		*=*+2	;indirect eval (symbol evaluation)
     030C   =030E        1782   iesclk		*=*+2	;escape token crunch,
     030E   =0310        1783   iescpr		*=*+2	;..list,
     0310   =0312        1784   iescex		*=*+2	;..and execute
     0312   =0314        1785   itime		*=*+2	;60 hz interrupt vector (before jiffy)
     0314   =0316        1786   cinv		*=*+2	;irq ram vector
     0316   =0318        1787   cbinv		*=*+2	;brk instr ram vector
                         1788   
                         1789   ; kernal indirects go here
                         1790   
            =0380        1791   		*=$0380
                         1792   
     0380   =0386        1793   chrget		*=*+6
     0386   =0390        1794   chrgot		*=*+10
     0390   =039F        1795   qnum		*=*+15
                         1796   
                         1797   
                         1798   
                         1799   ;  indirect load subroutine area
                         1800   ;
     039F   =03AB        1801   indsub_ram0	*=*+12	;shared rom fetch sub
     03AB   =03B7        1802   indsub_ram1	*=*+12	;shared rom fetch sub
     03B7   =03C0        1803   indin1_ram1	*=*+9	;index1 indirect fetch
     03C0   =03C9        1804   indin2		*=*+9	;index2 indirect fetch
     03C9   =03D2        1805   indtxt		*=*+9	;txtptr
     03D2   =03D5        1806   zero		*=*+3	;numeric constant for basic, downloaded from rom
                         1807   
                         1808   
     03D5   =03D6        1809   current_bank	*=*+1	;context for SYS,POKE,PEEK. Set by BANK command.
     03D6   =03DA        1810   tmpdes		*=*+4	;temp for instr
     03DA   =03DB        1811   fin_bank	*=*+1	;bank pointer for string - number conversion routine (fin)
     03DB   =03DF        1812   savsiz		*=*+4	;temp work locations for sshape
     03DF   =03E0        1813   bits		*=*+1	
     03E0   =03E1        1814   sprtmp_1	*=*+1	;temp for sprsav
     03E1   =03E2        1815   sprtmp_2	*=*+1
     03E2   =03E3        1816   fg_bg		*=*+1	;packed foreground/background color nybbles
     03E3   =03E4        1817   fg_mc1		*=*+1	;packed foreground/multicolor 1 color nybbles
                         1818   
            =03E4        1819   		*=$3e4	;c256 indirects
                         1820   
     03E4   =03E6        1821   plot_point	*=*+2	;plot a point indirect

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 24-1
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

     03E6   =03E8        1822   plot_color	*=*+2	;plot a color indirect
     03E8   =03EA        1823   read_point	*=*+2	;read a point and color indirect
                         1824   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 25
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

            =1100        1826   		*=$1100	;dos/vsp area
     1100   =1101        1827   dosstr		*=*+1	;dos output str. buf
            =1131        1828   		*=*+48	;area to build dos string
                         1829   
                         1830   
     1131                1831   vwork		;graphics vars
     1131                1832   xypos
     1131   =1133        1833   xpos		*=*+2	;current x position
     1133   =1135        1834   ypos		*=*+2	;current y position
     1135   =1137        1835   xdest		*=*+2	;x-coordinate destination
     1137   =1139        1836   ydest		*=*+2	;y-coordinate destination
                         1837   
                         1838   ;  line drawing variables
                         1839   ;
     1139                1840   xyabs
     1139   =113B        1841   xabs		*=*+2
     113B   =113D        1842   yabs		*=*+2
     113D                1843   xysgn
     113D   =113F        1844   xsgn		*=*+2
     113F   =1141        1845   ysgn		*=*+2
     1141   =1145        1846   fct		*=*+4
     1145   =1147        1847   errval		*=*+2
     1147   =1148        1848   lesser		*=*+1
     1148   =1149        1849   greatr		*=*+1
                         1850   
                         1851   ;  angle routine variables
                         1852   ;
     1149   =114A        1853   angsgn		*=*+1	;sign of angle
     114A   =114C        1854   sinval		*=*+2	;sine of value of angle
     114C   =114E        1855   cosval		*=*+2	;cosine of value of angle
     114E   =1150        1856   angcnt		*=*+2	;temps for angle distance routines
                         1857   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 26
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

                         1859   
                         1860   ;  the following 24 bytes are multiply defined, beginning on this
                         1861   ;  page, and continuing for the next 4 pages.
                         1862   
                         1863   ;  circle drawing variables. (multiply defined)
                         1864   
            =1150        1865   params		=*
     1150   =1152        1866   xcircl		*=*+2	;circle center, x coordinate
     1152   =1154        1867   ycircl		*=*+2	;circle center, y coordinate
     1154   =1156        1868   xradus		*=*+2	;x radius
     1156   =1158        1869   yradus		*=*+2	;y radius
     1158   =115C        1870   rotang		*=*+4	;rotation angle
     115C   =115E        1871   angbeg		*=*+2	;arc angle start
     115E   =1160        1872   angend		*=*+2	;arc angle end
     1160   =1162        1873   xrcos		*=*+2	;x radius * cos(rotation angle)
     1162   =1164        1874   yrsin		*=*+2	;y radius * sin(rotation angle)
     1164   =1166        1875   xrsin		*=*+2	;x radius * sin(rotation angle)
     1166   =1168        1876   yrcos		*=*+2	;y radius * cos(rotation angle)
            =1168        1877   parend		=*
                         1878   
                         1879   
                         1880   ;  general use parameters. (multiply defined)
                         1881   
            =1150        1882   		*=params
     1150   =1152        1883   xcentr		*=*+2
     1152   =1154        1884   ycentr		*=*+2
     1154   =1156        1885   xdist1		*=*+2
     1156   =1158        1886   ydist1		*=*+2
     1158   =115A        1887   xdist2		*=*+2
     115A   =115C        1888   ydist2		*=*+2
     115C                1889   disend
            =115E        1890   		*=*+2  	;placeholder
     115E   =115F        1891   colcnt		*=*+1	;char's col. counter
     115F   =1160        1892   rowcnt		*=*+1
     1160   =1161        1893   strcnt		*=*+1
                         1894   
                         1895   
                         1896   ;  box drawing variables. (multiply defined)
                         1897   
            =1150        1898   		*=params
     1150   =1152        1899   xcord1		*=*+2	;point 1 x-coord.
     1152   =1154        1900   ycord1		*=*+2	;point 1 y-coord.
     1154   =1156        1901   boxang		*=*+2	;rotation angle
     1156   =1158        1902   xcount		*=*+2
     1158   =115A        1903   ycount		*=*+2
     115A   =115C        1904   bxleng		*=*+2	;length of a side
     115C   =115E        1905   xcord2		*=*+2
     115E   =1160        1906   ycord2		*=*+2
                         1907   
                         1908   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 27
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

                         1910   ;  shape and move-shape variables (multiply defined)
                         1911   
            =1150        1912   		*=params
            =1151        1913   		*=*+1	;placeholder
     1151   =1152        1914   keylen		*=*+1
     1152   =1153        1915   keynxt		*=*+1
     1153   =1154        1916   strsz		*=*+1	;string len
     1154   =1155        1917   gettyp		*=*+1	;replace shape mode
     1155   =1156        1918   strptr		*=*+1	;string pos'n counter
     1156   =1157        1919   oldbyt		*=*+1	;old bit map byte
     1157   =1158        1920   newbyt		*=*+1	;new string or bit map byte
            =1159        1921   		*=*+1  	;placeholder
     1159   =115B        1922   xsize		*=*+2	;shape column length
     115B   =115D        1923   ysize		*=*+2	;shape row length
     115D   =115F        1924   xsave		*=*+2	;temp for column length
     115F   =1161        1925   stradr		*=*+2	;save shape string descriptor
     1161   =1162        1926   bitidx		*=*+1	;bit index into byte
            =1168        1927   		*=parend

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 28
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

                         1929   
                         1930   ;  graphic variables
                         1931   
     1168   =1169        1932   character_rom	*=*+1	;high byte of address of char rom for 'char' command
     1169   =116A        1933   bitcnt		*=*+1	;temp for gshape
     116A   =116B        1934   scalem		*=*+1	;scale mode flag
     116B   =116C        1935   width		*=*+1	;double width flag
     116C   =116D        1936   filflg		*=*+1	;box fill flag
     116D   =116E        1937   bitmsk		*=*+1	;temp for bit mask
     116E   =116F        1938   numcnt		*=*+1
     116F   =1170        1939   trcflg		*=*+1	;flags trace mode
                         1940   
     1170   =1172        1941   renum_tmp_1	*=*+2	;a temp for renumber
     1172   =1174        1942   renum_tmp_2	*=*+2	;a temp for renumber
                         1943   
     1174   =1175        1944   t3		*=*+1
     1175   =1177        1945   t4		*=*+2
     1177   =1178        1946   vtemp3		*=*+1	;graphic temp storage
     1178   =1179        1947   vtemp4		*=*+1
     1179   =117A        1948   vtemp5		*=*+1
                         1949   
     117A   =117C        1950   adray1		*=*+2	;ptr to routine:  convert float -> integer
     117C   =117E        1951   adray2		*=*+2	;ptr to routine:  convert integer -> float
                         1952   
     117E   =11D6        1953   sprite_data	*=*+88	;speed/direction tables for sprites
     11D6   =11EB        1954   vic_save	*=*+21	;copy of vic reg's, used to update chip during retrace
            =006C        1955   init_as_0	=*-sprite_data-1 ;just a count for init
                         1956   
     11EB   =11EC        1957   upper_lower	*=*+1	;pointer to upper/lower case for char command
     11EC   =11ED        1958   upper_graphic	*=*+1	;  '        upper/graphic
                         1959   
     11ED   =11EE        1960   dossa_temp	*=*+1	;temp sto for file's sa during RECORD command
                         1961   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 29
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

                         1963   
            =1200        1964   		*=$1200 ;general basic non-zp storage
                         1965   
                         1966   
     1200   =1202        1967   oldlin		*=*+2	;basic storage
     1202   =1204        1968   oldtxt		*=*+2	;basic storage
                         1969   
                         1970   
                         1971   ;  declarations for print using
                         1972   ;
     1204                1973   puchrs
     1204   =1205        1974   pufill		*=*+1	;print using fill symbol
     1205   =1206        1975   pucoma		*=*+1	;print using comma symbol
     1206   =1207        1976   pudot		*=*+1	;print using d.p. symbol
     1207   =1208        1977   pumony		*=*+1	;print using monetary symbol
                         1978   
                         1979   
     1208   =1209        1980   errnum		*=*+1	;used by error trapping routine-last error number
     1209   =120B        1981   errlin		*=*+2	;line # of last error - ffff if no error
     120B   =120D        1982   trapno		*=*+2	;line to go to on error.. ffxx if none set
     120D   =120E        1983   tmptrp		*=*+1	;hold trap # tempor.
     120E   =1210        1984   errtxt		*=*+2
                         1985   
     1210   =1212        1986   text_top	*=*+2	;top of text pointer
     1212   =1214        1987   max_mem_0	*=*+2	;highest address available to BASIC in ram 0
                         1988   
     1214   =1216        1989   tmptxt		*=*+2	;used by do-loop. could be mult. assigned
     1216   =1218        1990   tmplin		*=*+2
                         1991   
     1218   =121B        1992   usrpok		*=*+3
     121B   =1220        1993   rndx		*=*+5
                         1994   
     1220   =1221        1995   circle_segment	*=*+1	;degrees per circle segment
                         1996   
     1221   =1222        1997   dejavu		*=*+1	;'cold' or 'warm' reset status (must be in page 5!)
                         1998   
                         1999   
                         2000   ; music stuff
                         2001   
     1222   =1223        2002   tempo_rate	*=*+1
     1223   =1229        2003   voices		*=*+6
     1229   =122B        2004   ntime		*=*+2
     122B   =122C        2005   octave		*=*+1
     122C   =122D        2006   sharp		*=*+1
     122D   =122F        2007   pitch		*=*+2
     122F   =1230        2008   voice		*=*+1
     1230   =1233        2009   wave0		*=*+3
     1233   =1234        2010   dnote		*=*+1
     1234   =1238        2011   fltsav		*=*+4
     1238   =1239        2012   fltflg		*=*+1
     1239   =123A        2013   nibble		*=*+1
     123A   =123B        2014   tonnum		*=*+1
     123B   =123E        2015   tonval		*=*+3
     123E   =123F        2016   parcnt		*=*+1
                         2017   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 29-1
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

     123F   =1249        2018   atktab		*=*+10
     1249   =1253        2019   sustab		*=*+10
     1253   =125D        2020   wavtab		*=*+10
     125D   =1267        2021   pulslw		*=*+10
     1267   =1271        2022   pulshi		*=*+10
     1271   =1276        2023   filters		*=*+5
                         2024   
                         2025   ;  interrupt stuff
                         2026   
     1276   =1279        2027   int_trip_flag	*=*+3
     1279   =127C        2028   int_adr_lo	*=*+3
     127C   =127F        2029   int_adr_hi	*=*+3
                         2030   
     127F   =1280        2031   intval		*=*+1
     1280   =1281        2032   coltyp		*=*+1
                         2033   
                         2034   
                         2035   
                         2036   
                         2037   ; SOUND command stuff
                         2038   
     1281   =1282        2039   sound_voice	*=*+1
                         2040   
     1282   =1285        2041   sound_time_lo	*=*+3
     1285   =1288        2042   sound_time_hi	*=*+3
                         2043   
     1288   =128B        2044   sound_max_lo	*=*+3
     128B   =128E        2045   sound_max_hi	*=*+3
     128E   =1291        2046   sound_min_lo	*=*+3
     1291   =1294        2047   sound_min_hi	*=*+3
     1294   =1297        2048   sound_direction	*=*+3
     1297   =129A        2049   sound_step_lo	*=*+3
     129A   =129D        2050   sound_step_hi	*=*+3
     129D   =12A0        2051   sound_freq_lo	*=*+3
     12A0   =12A3        2052   sound_freq_hi	*=*+3
                         2053   
     12A3   =12A4        2054   temp_time_lo	*=*+1
     12A4   =12A5        2055   temp_time_hi	*=*+1
                         2056   
     12A5   =12A6        2057   temp_max_lo	*=*+1
     12A6   =12A7        2058   temp_max_hi	*=*+1
     12A7   =12A8        2059   temp_min_lo	*=*+1
     12A8   =12A9        2060   temp_min_hi	*=*+1
     12A9   =12AA        2061   temp_direction	*=*+1
     12AA   =12AB        2062   temp_step_lo	*=*+1
     12AB   =12AC        2063   temp_step_hi	*=*+1
     12AC   =12AD        2064   temp_freq_lo	*=*+1
     12AD   =12AE        2065   temp_freq_hi	*=*+1
     12AE   =12AF        2066   temp_pulse_lo	*=*+1
     12AF   =12B0        2067   temp_pulse_hi	*=*+1
     12B0   =12B1        2068   temp_waveform	*=*+1
                         2069   
     12B1   =12B2        2070   pot_temp_1	*=*+1		;temporarys for 'POT' function
     12B2   =12B3        2071   pot_temp_2	*=*+1
                         2072   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 29-2
DECLARE for Basic   DECLARE.SRC

Error Addr  Code          Seq   Source statement

                         2073   
     12B3   =12B7        2074   window_temp	*=*+4
                         2075   
     12B7   =12FA        2076   savram		*=*+67 		;used by SPRDEF,SAVSPR, and DOS parser
     12FA   =12FB        2077   defmod		*=*+1		; "
     12FB   =12FC        2078   lincnt		*=*+1		; "
     12FC   =12FD        2079   sprite_number	*=*+1		; "
                         2080   
                         2081   
                         2082   
     12FD   =12FE        2083   irq_wrap_flag	*=*+1		;used by basic_irq to block all but one irq call
                         2084   
                         2085   
            =FFFE        2086   	.ifge *-$1300		;make sure storagedoesn't overflow
                         2087   	.messg "***** ADDRESS CHECK ***"
                         2088   	.endif
                         2089   
                         2090   ;end
                         2091   	.include entries

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 30
Kernal Entry Points   ENTRIES.SRC

Error Addr  Code          Seq   Source statement

                         2093   	.subttl Kernal Entry Points
                         2094   
            =0001        2095   _6510_data_reg	=$01
            =0002        2096   _bank		=$02		;reg's for kernal jsr far routine (used by sys)
            =0003        2097   _pchi		=$03
            =0004        2098   _pclo		=$04
            =0005        2099   _s_reg		=$05
            =0006        2100   _a_reg		=$06
            =0007        2101   _x_reg		=$07
            =0008        2102   _y_reg		=$08
                         2103   
                         2104   
                         2105   ; these are the addresses of some entries in the standard
                         2106   ; kernal vector table.
                         2107   
            =FF4A        2108   _close_all	=$ff4a	;close all channels on dev. (a)
            =FF4D        2109   _go_64		=$ff4d	;switch to c-64 mode
            =FF50        2110   _do_dma		=$ff50	;call dma processor (tee-hee)
            =FF53        2111   _boot_call	=$ff53	;kernal 'BOOT' routines entry for basic
            =FF59        2112   _lkupla		=$ff59
            =FF5C        2113   _lkupsa		=$ff5c
            =FF5F        2114   _swapper	=$ff5f	;switch 80/40 column
            =FF65        2115   _doakey		=$ff65	;add/remove a definition from the p.f. key table
            =FF68        2116   _set_bank	=$ff68	;set bank for load/save/verify
            =FF6B        2117   _config		=$ff6b	;convert bank 0-15 in .X to config in .A
            =FF6E        2118   _jjsr		=$ff6e	;jsr far routine
            =FF74        2119   _fetch		=$ff74
            =FF77        2120   _stash		=$ff77
            =FF7A        2121   _compare	=$ff7a
                         2122   
            =FF90        2123   _setmsg		=$ff90
            =FFB7        2124   _readst		=$ffb7
            =FFBA        2125   _setlfs		=$ffba
            =FFBD        2126   _setnam		=$ffbd
            =FFC0        2127   _open		=$ffc0
            =FFC3        2128   _close		=$ffc3
            =FFC6        2129   _chkin		=$ffc6
            =FFC9        2130   _chkout		=$ffc9
            =FFCC        2131   _clrch		=$ffcc
            =FFCF        2132   _basin		=$ffcf
            =FFD2        2133   _bsout		=$ffd2
            =FFD5        2134   _loadsp		=$ffd5
            =FFD8        2135   _savesp		=$ffd8
            =FFDB        2136   _settim		=$ffdb
            =FFDE        2137   _rdtim		=$ffde
            =FFE1        2138   _stop		=$ffe1
            =FFE4        2139   _getin		=$ffe4
            =FFE7        2140   _clall		=$ffe7
            =FFED        2141   _screen_org	=$ffed
            =FFF0        2142   _jplot		=$fff0
                         2143   
            =C02D        2144   _set_window	=$c02d
            =C033        2145   _ldtb2		=$c033
            =C04C        2146   _ldtb1		=$c04c
                         2147   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 30-1
Kernal Entry Points   ENTRIES.SRC

Error Addr  Code          Seq   Source statement

            =FF56        2148   _phenix		=$ff56		;jump to 'post-basic initialize' routine.
            =C00C        2149   _print		=$c00c
            =FF7D        2150   _primm		=$ff7d		; print immediate
            =B000        2151   _monitor	=$b000
                         2152   
                         2153   
            =02B9        2154   _stash_vector	=$02b9		;address to set up for _stash routine
            =00F1        2155   _text_color	=$00f1
            =034A        2156   _keyd		=$034a
            =0A04        2157   _init_status	=$0a04		;msb set tells kernal to let basic have irq's
            =0A1D        2158   _sleep_counter	=$0a1d
            =0A34        2159   _split		=$0a34		;line to start split at
                         2160   
                         2161   
                         2162   
                         2163   
            =00AC        2164   _starting_addr	=$ac		;address BLOAD loaded to
            =00B9        2165   _sa		=$b9
            =00BA        2166   _fa		=$ba
            =00D0        2167   _ndx		=$d0
            =00D7        2168   _mode		=$d7		;40/80 mode
            =00D8        2169   _graphm		=$d8		;graphic mode switch (multi/hires/split)
                         2170   
                         2171   
            =00E4        2172   _screen_bottom	=$e4		;these describe the current window
            =00E5        2173   _screen_top	=$e5
            =00E6        2174   _screen_left	=$e6
            =00E7        2175   _screen_right	=$e7
                         2176   
            =00F6        2177   _autoinsert	=$f6		;enable/disable auto insert mode
                         2178   
            =0A00        2179   _restart_vector	=$0a00		;kernal restart vector
                         2180   
            =000A        2181   _pky_max	=10		;max of 10 prog. fn. keys
            =1000        2182   _pky_lengths	=$1000		;table of prog. fn. key sizes
            =100A        2183   _pky_buffer	=_pky_lengths+_pky_max	;actual buffer
                         2184   
                         2185   ;.end
                         2186   	.include header

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 31
'header'   HEADER.SRC

Error Addr  Code          Seq   Source statement

                         2188   	.subttl 'header'
                         2189   
            =4000        2190   	*=$4000
                         2191   
     4000   4C 4026      2192   	jmp hard_reset
     4003   4C 4009      2193   	jmp soft_reset
     4006   4C A85D      2194   	jmp basic_irq
                         2195   
                         2196   ;.end
                         2197   	.include init

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 32
Initialization Code   INIT.SRC

Error Addr  Code          Seq   Source statement

                         2199   	.subttl Initialization Code
                         2200   
     4009                2201   soft_reset
     4009   20 FFCC      2202   	jsr _clrch		;warm start basic...
     400C   20 417D      2203   	jsr init_mmu		;initialize MMU our way
     400F   20 4269      2204   	jsr init_plot_vec	;initialize vectors for c256 graphic80 routines
     4012   20 4190      2205   	jsr stop_sprites	;stop all moving sprites
     4015   20 4115      2206   	jsr init_voices
     4018   20 5255      2207   	jsr stkini		;restore stack 
     401B   A9 00        2208   	lda #0
     401D   85 15        2209   	sta channl		;clear channels
                         2210   
     401F                2211   go_ready
     401F   58           2212   	cli			;enable irq's
     4020   4C 4D54      2213   	jmp ready
                         2214   
     4023   00 FF FF     2215   	.byte $00,$ff,$ff	;BASIC revision number
                         2216   
                         2217   
     4026                2218   hard_reset
     4026   20 417D      2219   	jsr init_mmu		;initialize MMU our way
     4029   20 4254      2220   	jsr init_vectors	;go init vectors
     402C   20 4048      2221   	jsr init_storage	;go init charget & z-page
     402F   20 419E      2222   	jsr signon_message	;go print initilization messages
                         2223   
     4032   AD 0A04      2224   	lda _init_status
     4035   09 01        2225   	ora #1
     4037   8D 0A04      2226   	sta _init_status	;tell kernal to give basic a crack at irq's
                         2227   
     403A   A2 03        2228   	ldx #<$4003		;point restart vector at warm start entry
     403C   8E 0A00      2229   	stx _restart_vector
                         2230   
     403F   A2 FB        2231   	ldx #stkend-256 	;set up end of stack
     4041   9A           2232   	txs
                         2233   
     4042   20 FF56      2234   	jsr _phenix		;let any cartridges out there have a say
     4045   4C 401F      2235   	jmp go_ready		;jmp...ready
                         2236   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 33
Initialization Code   INIT.SRC

Error Addr  Code          Seq   Source statement

     4048                2238   init_storage
     4048   A9 4C        2239   	lda #76			;'jmp' opcode
     404A   85 56        2240   	sta jmper
     404C   8D 1218      2241   	sta usrpok
                         2242   
     404F   A9 C5        2243   	lda #<fcerr     	;init usr vector to 'qty err'
     4051   A0 7D        2244   	ldy #>fcerr
     4053   8D 1219      2245   	sta usrpok+1
     4056   8C 121A      2246   	sty usrpok+2
                         2247   
     4059   A9 9F        2248   	lda #<flpint
     405B   A0 84        2249   	ldy #>flpint
     405D   8D 117A      2250   	sta adray1
     4060   8C 117B      2251   	sty adray1+1
                         2252   
     4063   A9 D9        2253   	lda #<givayf
     4065   A0 79        2254   	ldy #>givayf
     4067   8D 117C      2255   	sta adray2
     406A   8C 117D      2256   	sty adray2+1
                         2257   
                         2258   ;
                         2259   ; download CHRGET and INDSUB code into ram.
                         2260   ;
     406D   A2 55        2261   	ldx #endmov-chrget_pattern
     406F   BD 4295      2262   1$	lda chrget_pattern-1,x	
     4072   9D 037F      2263   	sta chrget-1,x			;move to ram.
     4075   CA           2264   	dex
     4076   D0 F7        2265   	bne 1$
                         2266   
     4078   8E 03DF      2267   	stx bits		;.x=0
     407B   86 15        2268   	stx channl
     407D   86 1A        2269   	stx lastpt+1
     407F   8E 116F      2270   	stx trcflg		;start trace mode off
     4082   8E 1C00      2271   	stx basbgn
     4085   86 76        2272   	stx mvdflg		;flag '8k graphics screen not allocated'
     4087   86 74        2273    	stx autinc		;turn off auto increment
     4089   86 75        2274    	stx autinc+1
     408B   8E 116B      2275   	stx width		;init to single-width lines
     408E   8E 116A      2276    	stx scalem		;turn off scaleing
     4091   8E 116C      2277    	stx filflg
     4094   8E 121B      2278   	stx rndx		;zero-ing msb will guarantee a legal value
     4097   8E 011C      2279   	stx dosfa		;zero device number
                         2280   
     409A   8E 1276      2281   	stx int_trip_flag
     409D   8E 1277      2282   	stx int_trip_flag+1
     40A0   8E 1278      2283   	stx int_trip_flag+2
     40A3   8E 127F      2284   	stx intval
                         2285   
     40A6   A0 58        2286   	ldy #88			;zero out sprite information area
     40A8   99 117E      2287   2$	sta sprite_data,y
     40AB   88           2288   	dey
     40AC   10 FA        2289   	bpl 2$
                         2290   
     40AE   E8           2291   	inx			;.x=1
     40AF   8E 01FD      2292   	stx buf-3

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 33-1
Initialization Code   INIT.SRC

Error Addr  Code          Seq   Source statement

     40B2   8E 01FC      2293   	stx buf-4
                         2294   
     40B5   A2 0F        2295   	ldx #15
     40B7   8E 03D5      2296   	stx current_bank	 ;set default bank for POKE,PEEK,SYS
                         2297   
     40BA   A2 0D        2298   	ldx #13
     40BC   86 86        2299   	stx foreground		;init bit map's fg color to light green
     40BE   A2 01        2300   	ldx #1
     40C0   86 84        2301   	stx multicolor_1	;init mc1 to white
     40C2   A2 02        2302   	ldx #2
     40C4   86 85        2303   	stx multicolor_2	;init mc2 to red
     40C6   20 6A79      2304   	jsr set_packed_color	;set up packed fg/bg and fg/mc1 bytes
     40C9   A2 1B        2305   	ldx #tempst
     40CB   86 18        2306   	stx temppt
                         2307   
            =1C01        2308   	baswrk=basbgn+1
     40CD   A2 01        2309   	ldx #<baswrk    	;set up bottom of bank 0 (text area)
     40CF   A0 1C        2310   	ldy #>baswrk
     40D1   86 2D        2311   	stx txttab
     40D3   84 2E        2312   	sty txttab+1
                         2313   
     40D5   A9 00        2314   	lda #<common_top	;set up bottom of bank 1 (storage area)
     40D7   A0 04        2315   	ldy #>common_top
     40D9   85 2F        2316   	sta vartab
     40DB   84 30        2317   	sty vartab+1
                         2318   
     40DD   A9 00        2319   	lda #<bank_0_top	;set up top of bank 0
     40DF   A0 FF        2320   	ldy #>bank_0_top
     40E1   8D 1212      2321   	sta max_mem_0
     40E4   8C 1213      2322   	sty max_mem_0+1
                         2323   
     40E7   A9 00        2324   	lda #<bank_1_top	;set up  top of bank 1
     40E9   A0 FF        2325   	ldy #>bank_1_top
     40EB   85 39        2326   	sta max_mem_1
     40ED   84 3A        2327   	sty max_mem_1+1
                         2328   
                         2329   ;
                         2330   ; set up sprite pointers
                         2331   ;
                         2332   
     40EF   A2 3F        2333   	ldx #sprite_base/64+7
     40F1   A0 07        2334   	ldy #7
     40F3   8A           2335   10$	txa
     40F4   99 07F8      2336   	sta screen_start+$3f8,y
     40F7   CA           2337   	dex
     40F8   88           2338   	dey
     40F9   10 F8        2339   	bpl 10$
                         2340   ;
                         2341   ; zero out sprite movement stuff and some vic stuff too
                         2342   ;
     40FB   A9 00        2343   	lda #0
     40FD   A2 6C        2344   	ldx #init_as_0
     40FF   9D 117E      2345   15$	sta sprite_data,x
     4102   CA           2346   	dex
     4103   10 FA        2347   	bpl 15$

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 33-2
Initialization Code   INIT.SRC

Error Addr  Code          Seq   Source statement

                         2348   
     4105   20 4115      2349   	jsr init_voices
                         2350   
     4108   A9 D0        2351   	lda #$d0		;initialize pointers to character rom
     410A   8D 11EC      2352   	sta upper_graphic
     410D   A9 D8        2353   	lda #$d8
     410F   8D 11EB      2354   	sta upper_lower
                         2355   
     4112   4C 51F6      2356   	jmp scrtch		;go to 'new', rts
                         2357   
                         2358   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 34
Initialization Code   INIT.SRC

Error Addr  Code          Seq   Source statement

     4115                2360   init_voices
                         2361   ;
                         2362   ; initialize music stuff
                         2363   ;
                         2364   
     4115   A9 20        2365   	lda #<beats/4		;set beat to quarter note
     4117   A0 01        2366   	ldy #>beats/4
     4119   8D 1229      2367   	sta ntime
     411C   8C 122A      2368   	sty ntime+1
                         2369   
     411F   A9 04        2370   	lda #4			;set default octave
     4121   8D 122B      2371   	sta octave
                         2372   
     4124   A9 10        2373   	lda #16			;set default tempo
     4126   8D 1222      2374   	sta tempo_rate
                         2375   
     4129   A9 00        2376   	lda #0			;make sure all gates are off
     412B   8D D404      2377   	sta sid+4
     412E   8D D40B      2378   	sta sid+11
     4131   8D D412      2379   	sta sid+18
     4134   8D 12FD      2380   	sta irq_wrap_flag	;enable basic irq handler
                         2381   
     4137   A9 0F        2382   	lda #$0f		;set volume to max
     4139   8D 1274      2383   	sta filters+3
     413C   8D 1275      2384   	sta filters+4
     413F   8D D418      2385   	sta sid+24
                         2386   
     4142   A0 1D        2387   	ldy #29			;initialize music tables
     4144   B9 70AE      2388   20$	lda atkmus,y
     4147   99 123F      2389   	sta atktab,y
     414A   88           2390   	dey
     414B   10 F7        2391   	bpl 20$
                         2392   
     414D   A2 09        2393   	ldx #9			;initialize pulse widths
     414F   BD 70CC      2394   30$	lda pwhmus,x
     4152   9D 1267      2395   	sta pulshi,x
     4155   CA           2396   	dex
     4156   10 F7        2397   	bpl 30$
                         2398   
     4158   8E 1285      2399   	stx sound_time_hi	;turn all SOUND counters off (.X = $ff)
     415B   8E 1286      2400   	stx sound_time_hi+1
     415E   8E 1287      2401   	stx sound_time_hi+2
     4161   8E 1224      2402   	stx voices+1		;turn all PLAY counters off
     4164   8E 1226      2403   	stx voices+3
     4167   8E 1228      2404   	stx voices+5
                         2405   
     416A   A0 02        2406   	ldy #2			;set default envelope (piano) for all voices
     416C   8C 122F      2407   	sty voice
     416F   A2 00        2408   10$	ldx #0
     4171   20 6F4F      2409   	jsr set_envelope_1
     4174   CE 122F      2410   	dec voice
     4177   10 F6        2411   	bpl 10$
     4179   EE 122F      2412   	inc voice		;set default voice (0)
     417C   60           2413   	rts
                         2414   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 35
Initialization Code   INIT.SRC

Error Addr  Code          Seq   Source statement

                         2416   
     417D                2417   init_mmu			;initialize mmu pre-configs for our purposes
     417D   20 A855      2418   	jsr put_io_in_map
     4180   A2 03        2419   	ldx #3			;now do 4 pre-configs
     4182   BD 418C      2420   1$	lda 2$,x
     4185   9D D501      2421   	sta mmu_preconfig_a,x
     4188   CA           2422   	dex
     4189   10 F7        2423   	bpl 1$
     418B   60           2424   	rts
                         2425   
     418C   3F           2426   2$	.byte %00111111		;sw_ram0 (ram 0, no rom, no i/o)
     418D   7F           2427   	.byte %01111111		;sw_ram1 (ram 1, no rom, no i/o)
     418E   01           2428   	.byte %00000001		;sw_rom_ram0 (ram 0, system rom, no i/o)
     418F   41           2429   	.byte %01000001		;sw_rom_ram1 (ram 1, system rom, no i/o)
                         2430   
                         2431   
                         2432   
                         2433   
     4190                2434   stop_sprites				;stop all moving sprites
     4190   A9 00        2435   	lda #0
     4192   A0 07        2436   	ldy #7
     4194   BE 6E76      2437   1$	ldx sproff,y
     4197   9D 117E      2438   	sta sprite_data,x
     419A   88           2439   	dey
     419B   10 F7        2440   	bpl 1$
     419D   60           2441   	rts
                         2442   
                         2443   
                         2444   
                         2445   
     419E                2446   signon_message
     419E   A0 00        2447   	ldy #0
     41A0   B9 41BE      2448   10$	lda signon_msg,y
     41A3   C9 40        2449   	cmp #'@'
     41A5   D0 0E        2450   	bne 30$
                         2451   
     41A7   24 D7        2452   	bit _mode		;80 or 40 column?
     41A9   10 0D        2453   	bpl 35$			;40, don't expand
                         2454   
     41AB   A2 13        2455   	ldx #19
     41AD   A9 20        2456   20$	lda #' '
     41AF   20 9269      2457   	jsr k_bsout
     41B2   CA           2458   	dex
     41B3   D0 F8        2459   	bne 20$
                         2460   
     41B5   20 9269      2461   30$	jsr k_bsout
     41B8   C8           2462   35$	iny
     41B9   C0 96        2463   	cpy #signon_end-signon_msg
     41BB   D0 E3        2464   	bne 10$
     41BD   60           2465   	rts
                         2466   
                         2467   
     41BE                2468   signon_msg
     41BE   93 0D 40     2469   	.byte 147,cr,'@ COMMODORE BASIC V7.0 122365 BYTES FREE',cr
     41C1   20 43 4F            

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 35-1
Initialization Code   INIT.SRC

Error Addr  Code          Seq   Source statement

     41C4   4D 4D 4F            
     41C7   44 4F 52            
     41CA   45 20 42            
     41CD   41 53 49            
     41D0   43 20 56            
     41D3   37 2E 30            
     41D6   20 31 32            
     41D9   32 33 36            
     41DC   35 20 42            
     41DF   59 54 45            
     41E2   53 20 46            
     41E5   52 45 45            
     41E8   0D                  
     41E9   40 20 20     2470   	.byte        '@   (C)1985 COMMODORE ELECTRONICS, LTD.',cr
     41EC   20 28 43            
     41EF   29 31 39            
     41F2   38 35 20            
     41F5   43 4F 4D            
     41F8   4D 4F 44            
     41FB   4F 52 45            
     41FE   20 45 4C            
     4201   45 43 54            
     4204   52 4F 4E            
     4207   49 43 53            
     420A   2C 20 4C            
     420D   54 44 2E            
     4210   0D                  
     4211   40 20 20     2471   	.byte	     '@         (C)1977 MICROSOFT CORP.',cr
     4214   20 20 20            
     4217   20 20 20            
     421A   20 28 43            
     421D   29 31 39            
     4220   37 37 20            
     4223   4D 49 43            
     4226   52 4F 53            
     4229   4F 46 54            
     422C   20 43 4F            
     422F   52 50 2E            
     4232   0D                  
     4233   40 20 20     2472   	.byte	     '@           ALL RIGHTS RESERVED',cr
     4236   20 20 20            
     4239   20 20 20            
     423C   20 20 20            
     423F   41 4C 4C            
     4242   20 52 49            
     4245   47 48 54            
     4248   53 20 52            
     424B   45 53 45            
     424E   52 56 45            
     4251   44 0D               
     4253   00           2473   	.byte 0
     4254                2474   signon_end

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 36
Initialization Code   INIT.SRC

Error Addr  Code          Seq   Source statement

                         2476   
     4254                2477   init_vectors
     4254   A2 11        2478   	ldx #iv20-iv10-1
     4256   BD 427E      2479   1$	lda iv10,x
     4259   9D 0300      2480   	sta ierror,x
     425C   CA           2481   	dex
     425D   10 F7        2482   	bpl 1$
                         2483   
     425F   A9 95        2484   	lda #<n_esc_fn_vec
     4261   8D 02FC      2485   	sta esc_fn_vec
     4264   A9 4C        2486   	lda #>n_esc_fn_vec
     4266   8D 02FD      2487   	sta esc_fn_vec+1
                         2488   
     4269                2489   init_plot_vec
     4269   A2 05        2490   	ldx #iv30-iv20-1
     426B   BD 4290      2491   2$	lda iv20,x
     426E   9D 03E4      2492   	sta plot_point,x
     4271   CA           2493   	dex
     4272   10 F7        2494   	bpl 2$
                         2495   
     4274   A2 1C        2496   	ldx #28			;patch 8563 initialization for 64k display ram
     4276   A9 30        2497   	lda #$30
     4278   20 CDCC      2498   	jsr vdcout
     427B   4C FF62      2499   	jmp $ff62		;download character set again & rts
                         2500   
                         2501   
     427E   4D5C 4DE3    2502   iv10	.wor nerror,nmain,ncrnch,nqplop,ngone,neval
     4282   432A 516E           
     4286   4ABF 7977           
     428A   433E 51EA    2503   	.wor nesclk,nescpr,nescex 	;escape vectors
     428E   4BC6                
     4290                2504   iv20
     4290   9C1C 9C79    2505   	.wor plot_vic,color_vic,read_vic
     4294   9C4F                
     4296                2506   iv30
                         2507   
                         2508   
                         2509   
                         2510   ; this is the chrget/chrgot code. it is moved to ram
                         2511   ;
     4296                2512   chrget_pattern
     4296   E6 3D        2513   	inc txtptr
     4298   D0 02        2514   	bne 1$
     429A   E6 3E        2515   	inc txtptr+1
     429C   8D FF01      2516   1$	sta sw_ram0
     429F   A0 00        2517   	ldy #0
     42A1   B1 3D        2518   	lda (txtptr),y
     42A3   8D FF03      2519   	sta sw_rom_ram0
     42A6   C9 3A        2520   	cmp #':'
     42A8   B0 0A        2521   	bcs 2$
     42AA   C9 20        2522   	cmp #' '
     42AC   F0 E8        2523   	beq chrget_pattern
     42AE   38           2524   	sec
     42AF   E9 30        2525   	sbc #'0'
     42B1   38           2526   	sec

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 36-1
Initialization Code   INIT.SRC

Error Addr  Code          Seq   Source statement

     42B2   E9 D0        2527   	sbc #$d0
     42B4   60           2528   2$	rts
                         2529   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 37
Initialization Code   INIT.SRC

Error Addr  Code          Seq   Source statement

                         2531   
                         2532   ;indsub_ram0
     42B5   8D 03A6      2533   	sta indsub_ram0+3$-*+1	;set up for self-modifying (mea culpa) code.
     42B8   8D FF01      2534   	sta sw_ram0
     42BB   B1 00        2535   3$	lda ($00),y
     42BD   8D FF03      2536   	sta sw_rom_ram0
     42C0   60           2537   	rts
                         2538   
                         2539   ;indsub_ram1
     42C1   8D 03B2      2540   	sta indsub_ram1+4$-*+1
     42C4   8D FF02      2541   	sta sw_ram1
     42C7   B1 00        2542   4$	lda ($00),y
     42C9   8D FF04      2543   	sta sw_rom_ram1
     42CC   60           2544   	rts
                         2545   
                         2546   ;indin1_ram1
     42CD   8D FF02      2547   	sta sw_ram1
     42D0   B1 24        2548   	lda (index1),y
     42D2   8D FF04      2549   	sta sw_rom_ram1
     42D5   60           2550   	rts
                         2551   
                         2552   ;indin2
     42D6   8D FF01      2553   	sta sw_ram0
     42D9   B1 26        2554   	lda (index2),y
     42DB   8D FF03      2555   	sta sw_rom_ram0
     42DE   60           2556   	rts
                         2557   
                         2558   ;indtxt
     42DF   8D FF01      2559   	sta sw_ram0
     42E2   B1 3D        2560   	lda (txtptr),y
     42E4   8D FF03      2561   	sta sw_rom_ram0
     42E7   60           2562   	rts
                         2563   
                         2564   
                         2565   ;
                         2566   ; constants which must be moved to ram
                         2567   ;
     42E8   00 00 00     2568   	.byte   0,0,0	;zero, of course!
     42EB                2569   endmov
                         2570   
                         2571   ;end
                         2572   	.include indjumps

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 38
Indirect Load Subroutines   INDJUMPS.SRC

Error Addr  Code          Seq   Source statement

                         2574   	.subttl Indirect Load Subroutines
                         2575   
     42EB   A9 50        2576   inddef	lda #defpnt
     42ED   4C 03AB      2577   	jmp indsub_ram1
                         2578   
     42F0   A9 3F        2579   indfrm	lda #form
     42F2   4C 03AB      2580   	jmp indsub_ram1
                         2581   
     42F5   A9 52        2582   inddpt	lda #dscpnt
     42F7   4C 03AB      2583   	jmp indsub_ram1
                         2584   
     42FA   A9 5C        2585   indhtr	lda #hightr
     42FC   4C 039F      2586   	jmp indsub_ram0
                         2587   
     42FF                2588   indhtr_ram1
     42FF   A9 5C        2589   	lda #hightr
     4301   4C 03AB      2590   	jmp indsub_ram1
                         2591   
     4304   A9 66        2592   indfmo	lda #facmo
     4306   4C 03AB      2593   	jmp indsub_ram1
                         2594   
     4309   A9 61        2595   indlow	lda #lowtr
     430B   4C 039F      2596   	jmp indsub_ram0
                         2597   
     430E   A9 70        2598   indst1	lda #strng1
     4310   4C 039F      2599   	jmp indsub_ram0
                         2600   
     4313                2601   indst1_ram1
     4313   A9 70        2602   	lda #strng1
     4315   4C 03AB      2603   	jmp indsub_ram1
                         2604   
     4318   A9 50        2605   indgrb	lda #grbpnt
     431A   4C 03AB      2606   	jmp indsub_ram1
                         2607   
     431D                2608   indlow_ram1
     431D   A9 61        2609   	lda #lowtr
     431F   4C 03AB      2610   	jmp indsub_ram1
                         2611   
     4322   A9 24        2612   indin1	lda #index1
     4324   4C 039F      2613   	jmp indsub_ram0
                         2614   
                         2615   ;end
                         2616   	.include crunch

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 39
Crunch - Tokenization Routine   CRUNCH.SRC

Error Addr  Code          Seq   Source statement

                         2618   	.subttl Crunch - Tokenization Routine
                         2619   ;        crunch
                         2620   ;
                         2621   ;  entry:  txtptr points to start of text to crunch
                         2622   ;  exit:   txtptr points to start of crunched text
                         2623   ;  calls:  chrget
                         2624   ;          chrgot
                         2625   ;          reser
                         2626   ;          kloop
                         2627   ;          rem
                         2628   ;          data
                         2629   ;  collapses all reserved words to tokens.  does
                         2630   ;  not alter data or rem.  removes all graphic
                         2631   ;  characters not in quoted strings
                         2632   ;
                         2633   ;
                         2634   ;  an escape token is implemented as follows:
                         2635   ;
                         2636   ;     as each character on a line of text to be crunched is scanned, an
                         2637   ;     indirect jump is performed. anyone wishing to scan for their own
                         2638   ;     commands should grab off this vector, saving the return vector.
                         2639   ;     on entry, if the carry flag is set, it is still up for grabs.
                         2640   ;     the current text pointer is at txtptr. if the escape
                         2641   ;     routine recognizes the command, it should:
                         2642   ;
                         2643   ;            ) put the length of the reserved word in y
                         2644   ;            ) put the desired 'second' token in a
                         2645   ;            ) clear the carry flag
                         2646   ;	     ) put type of token in x: 0==>command, ff==>function
                         2647   ;
                         2648   ;     if it is not your command, leave the acc. and the carry
                         2649   ;     flag intact. note: the reserved word *must* be >= 2 charcters
                         2650   ;     long. exit through the old vector (for daisy chaining). if
                         2651   ;     the carry flag is clear on entry, it means someone else
                         2652   ;     before you recognizes this command. in this case, just pass
                         2653   ;     control through the old vector
                         2654   
     4327                2655   crunch
     4327   6C 0304      2656   	jmp (icrnch)
     432A                2657   ncrnch
     432A   A5 3D        2658   	lda txtptr	;save old text loc
     432C   48           2659   	pha
     432D   A5 3E        2660   	lda txtptr+1
     432F   48           2661   	pha
     4330                2662   crun05
     4330   20 0386      2663   	jsr chrgot
     4333   4C 4339      2664   	jmp crun20
                         2665   
     4336                2666   crun10
     4336   20 0380      2667   	jsr chrget
     4339                2668   crun20
     4339   90 FB        2669   	bcc crun10	;don't crunch numbers
     433B   6C 030C      2670   	jmp (iesclk)    ;give others a chance at this. carry is set.
     433E   B0 03        2671   nesclk	bcs 1$
     4340   4C 43CF      2672   	jmp crun95	;carry clear if someone wanted it

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 39-1
Crunch - Tokenization Routine   CRUNCH.SRC

Error Addr  Code          Seq   Source statement

                         2673   
     4343   C9 00        2674   1$	cmp #0		;end of line?
     4345   F0 77        2675   	beq crun90	;yes...
     4347   C9 3A        2676   	cmp #':'	;multi-stmt char?
     4349   F0 EB        2677   	beq crun10
     434B   C9 3F        2678   	cmp #'?'	;print abreviation?
     434D   D0 04        2679   	bne crun30	;no...
     434F   A9 99        2680   	lda #printk     ;substitute print token
     4351   D0 50        2681   	bne crun75	;branch always
     4353                2682   crun30
     4353   C9 80        2683   	cmp #$80	;graphics?
     4355   90 0B        2684   	bcc crun40	;no...
     4357   C9 FF        2685   	cmp #pi		;yes...pi?
     4359   F0 DB        2686   	beq crun10	;o.k....leave alone
     435B   A0 01        2687   	ldy #1
     435D   20 43E9      2688   	jsr kloop	;crunch out graphics
     4360   F0 CE        2689   	beq crun05	;branch always
     4362                2690   crun40
     4362   C9 22        2691   	cmp #'"'	;quote string?
     4364   D0 0D        2692   	bne crun_esc	;no...
     4366                2693   crun50
     4366   20 0380      2694   	jsr chrget
     4369   C9 00        2695   	cmp #0		;end of line?
     436B   F0 51        2696   	beq crun90	;yes...
     436D   C9 22        2697   	cmp #'"'	;close quote?
     436F   F0 C5        2698   	beq crun10	;yes...
     4371   D0 F3        2699   	bne crun50	;no...
                         2700   
                         2701   
     4373                2702   crun_esc
     4373   A9 46        2703   	lda #>esc_cmd_lst	;set up to look for token in escape-command list
     4375   A0 26        2704   	ldy #<esc_cmd_lst
     4377   20 43FF      2705   	jsr reser
     437A   90 06        2706   	bcc 10$			;not found.
     437C   A9 81        2707   	lda #lowest_esc_cmd_tk+$80-1 ;set up for common escape routine
     437E   A2 00        2708   	ldx #0			;..flag 'cmd' type escape
     4380   F0 4B        2709   	beq crun94		;..and go to it.
                         2710   
     4382   A9 46        2711   10$	lda #>esc_fn_lst	;set up to look for token in escape-function list
     4384   A0 E6        2712   	ldy #<esc_fn_lst
     4386   20 43FF      2713   	jsr reser
     4389   90 06        2714   	bcc 20$			;not found.
     438B   A9 81        2715   	lda #lowest_esc_fn_tk+$80-1 ;set up for common escape routine
     438D   A2 FF        2716   	ldx #$ff		;..flag 'function' type escape
     438F   D0 3C        2717   	bne crun94		;..always
                         2718   
     4391   A9 44        2719   20$	lda #>reslst	;set up to look for token in normal list
     4393   A0 34        2720   	ldy #<reslst
     4395   20 43FF      2721   	jsr reser	;..and go look.
     4398   90 9C        2722   	bcc crun10	;not found
     439A   C0 00        2723   	cpy #0	   	;anything to move?
     439C   F0 03        2724   	beq 30$		;no...
     439E   20 43E9      2725   	jsr kloop	;crunch it out
     43A1   A5 0D        2726   30$	lda count	;put token...
                         2727   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 39-2
Crunch - Tokenization Routine   CRUNCH.SRC

Error Addr  Code          Seq   Source statement

     43A3   A0 00        2728   crun75	ldy #0
     43A5   91 3D        2729   	sta (txtptr),y	;in text
     43A7   C9 8F        2730   	cmp #remtk
     43A9   F0 0D        2731   	beq crun80
     43AB   C9 83        2732   	cmp #datatk
     43AD   D0 87        2733   	bne crun10
     43AF   20 0380      2734   	jsr chrget
     43B2   20 52AC      2735   	jsr data
     43B5   4C 4330      2736   	jmp crun05
                         2737   
     43B8   20 0380      2738   crun80	jsr chrget
     43BB   20 52BA      2739   	jsr rem
                         2740   ;
                         2741   ;  no other statements can follow a rem
                         2742   ;
                         2743   
     43BE   A6 3D        2744   crun90	ldx txtptr
     43C0   68           2745   	pla
     43C1   85 3E        2746   	sta txtptr+1
     43C3   68           2747   	pla
     43C4   85 3D        2748   	sta txtptr
     43C6   38           2749   	sec		;compute length of line
     43C7   8A           2750   	txa
     43C8   E5 3D        2751   	sbc txtptr
     43CA   A8           2752   	tay
     43CB   C8           2753   	iny
     43CC   60           2754   	rts
                         2755   
                         2756   
                         2757   
                         2758   
                         2759   ;crunch out old text, install an escape token
                         2760   
     43CD   65 0D        2761   crun94	adc count	;make pointer into a token
     43CF   48           2762   crun95	pha		;save second token
     43D0   88           2763   	dey		;waste (# of chars) - 1
     43D1   20 43E9      2764   	jsr kloop
                         2765   
                         2766   ; see if this is function (x=ff) or command (x=0)
                         2767   
     43D4   A9 FE        2768   	lda #esc_cmd_tk	;assume command
     43D6   E8           2769   	inx
     43D7   D0 02        2770   	bne 1$		;branch if command
     43D9   A9 CE        2771   	lda #esc_fn_tk	;..else get correct token
                         2772   
     43DB   A0 00        2773   1$	ldy #0
     43DD   91 3D        2774   	sta (txtptr),y	;install escape token...
     43DF   C8           2775   	iny
     43E0   68           2776   	pla
     43E1   91 3D        2777   	sta (txtptr),y  ;..and second token
     43E3   20 0380      2778   	jsr chrget	;skip over token,
     43E6   4C 4336      2779   	jmp crun10	;..and continue with line.
                         2780   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 40
Crunch - Tokenization Routine   CRUNCH.SRC

Error Addr  Code          Seq   Source statement

                         2782   ;      kloop
                         2783   ;
                         2784   ;  crunch loop.  moves offset .y characters
                         2785   ;  from txtptr to end of line. .x is preserved
                         2786   
     43E9   18           2787   kloop	clc		;compute source address
     43EA   98           2788   	tya
     43EB   65 3D        2789   	adc txtptr
     43ED   85 24        2790   	sta index1
     43EF   A5 3E        2791   	lda txtptr+1
     43F1   69 00        2792   	adc #0
     43F3   85 25        2793   	sta index1+1
     43F5   A0 FF        2794   	ldy #$ff
                         2795   
     43F7   C8           2796   1$	iny
     43F8   B1 24        2797   	lda (index1),y	;move source..
     43FA   91 3D        2798   	sta (txtptr),y	;to destination offset
     43FC   D0 F9        2799   	bne 1$		;not end of line
     43FE   60           2800   	rts

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 41
Crunch - Tokenization Routine   CRUNCH.SRC

Error Addr  Code          Seq   Source statement

                         2802   ;      reser
                         2803   ;
                         2804   ;  search reserved word list for a match
                         2805   ;  entry:  (txtptr) is first char of word to match
                         2806   ;	   (y,a) is start of table to check
                         2807   ;
                         2808   ;  exit:   .y=length of word matched
                         2809   ;	   .c=success/fail (set/clear) flag
                         2810   ;	   count=token value
                         2811   
     43FF   85 25        2812   reser	sta index1+1
     4401   84 24        2813   	sty index1
     4403   A0 00        2814   	ldy #0
     4405   84 0D        2815   	sty count
     4407   88           2816   	dey
     4408   C8           2817   rese10	iny
     4409   B1 3D        2818   rese20	lda (txtptr),y
     440B   38           2819   	sec
     440C   F1 24        2820   	sbc (index1),y	;does letter match? (ind.ok)
     440E   F0 F8        2821   	beq rese10	;yes...continue
     4410   C9 80        2822   	cmp #$80	;no....end of word?
     4412   F0 1B        2823   	beq rese60	;yes...c set...done
                         2824   ;
                         2825   ;  find next word
                         2826   ;
     4414   B1 24        2827   rese30	lda (index1),y	;ind.ok
     4416   30 03        2828   	bmi rese40	;found end of current
     4418   C8           2829   	iny
     4419   D0 F9        2830   	bne rese30
     441B   C8           2831   rese40	iny		;start of next
     441C   E6 0D        2832   	inc count	;value of token
     441E   18           2833   	clc
     441F   98           2834   	tya
     4420   65 24        2835   	adc index1
     4422   85 24        2836   	sta index1
     4424   90 02        2837   	bcc rese50
     4426   E6 25        2838   	inc index1+1
     4428   18           2839   rese50	clc
     4429   A0 00        2840   	ldy #0
     442B   B1 24        2841   	lda (index1),y	; end of list? ind.ok
     442D   D0 DA        2842   	bne rese20	;no...
                         2843   ;
                         2844   ;  yes...carry clear...fail
                         2845   ;
     442F   05 0D        2846   rese60	ora count	;.a=$80 if match
     4431   85 0D        2847   	sta count	;token is formed
     4433   60           2848   	rts
                         2849   
                         2850   ;.end
                         2851   	.include tokens1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 42
Non-Escape Keyword List   TOKENS1.SRC

Error Addr  Code          Seq   Source statement

                         2853   	.subttl Non-Escape Keyword List
     4434                2854   reslst
     4434   45 4E C4     2855          .byte 'EN','D'+$80
            =0080        2856   endtk  =$80
     4437   46 4F D2     2857          .byte 'FO','R'+$80
            =0081        2858   fortk  =endtk+1
     443A   4E 45 58     2859          .byte 'NEX','T'+$80
     443D   D4                  
            =0082        2860   nexttk =fortk+1
     443E   44 41 54     2861          .byte 'DAT','A'+$80
     4441   C1                  
            =0083        2862   datatk =nexttk+1
     4442   49 4E 50     2863          .byte 'INPUT','#'+$80
     4445   55 54 A3            
     4448   49 4E 50     2864          .byte 'INPU','T'+$80
     444B   55 D4               
     444D   44 49 CD     2865          .byte 'DI',$CD
     4450   52 45 41     2866          .byte 'REA',$C4
     4453   C4                  
     4454   4C 45 D4     2867          .byte 'LE','T'+$80
     4457   47 4F 54     2868          .byte 'GOT',$CF
     445A   CF                  
            =0089        2869   gototk =datatk+6
     445B   52 55 CE     2870          .byte 'RU',$CE
            =008A        2871   runtk  =gototk+1
     445E   49 C6        2872          .byte 'I','F'+$80
     4460   52 45 53     2873          .byte 'RESTOR','E'+$80
     4463   54 4F 52            
     4466   C5                  
            =008C        2874   resttk =runtk+2
     4467   47 4F 53     2875          .byte 'GOSU',$C2
     446A   55 C2               
            =008D        2876   gosutk =resttk+1
     446C   52 45 54     2877          .byte 'RETUR',$CE
     446F   55 52 CE            
     4472   52 45 CD     2878          .byte 'RE',$CD
            =008F        2879   remtk  =gosutk+2
     4475   53 54 4F     2880          .byte 'STO',$D0
     4478   D0                  
     4479   4F CE        2881          .byte 'O',$CE
            =0091        2882   ontk   =remtk+2
     447B   57 41 49     2883          .byte 'WAI','T'+$80
     447E   D4                  
     447F   4C 4F 41     2884          .byte 'LOA',$C4
     4482   C4                  
     4483   53 41 56     2885          .byte 'SAV','E'+$80
     4486   C5                  
     4487   56 45 52     2886          .byte 'VERIF',$D9
     448A   49 46 D9            
     448D   44 45 C6     2887          .byte 'DE','F'+$80
     4490   50 4F 4B     2888          .byte 'POK','E'+$80
     4493   C5                  
     4494   50 52 49     2889          .byte 'PRINT',$A3
     4497   4E 54 A3            
     449A   50 52 49     2890          .byte 'PRIN','T'+$80

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 42-1
Non-Escape Keyword List   TOKENS1.SRC

Error Addr  Code          Seq   Source statement

     449D   4E D4               
            =0099        2891   printk =ontk+8
     449F   43 4F 4E     2892          .byte 'CON','T'+$80
     44A2   D4                  
     44A3   4C 49 53     2893          .byte 'LIS','T'+$80
     44A6   D4                  
     44A7   43 4C D2     2894          .byte 'CL','R'+$80
            =009C        2895   clrtk  =printk+3
     44AA   43 4D C4     2896          .byte 'CM',$C4
     44AD   53 59 D3     2897          .byte 'SY',$D3
     44B0   4F 50 45     2898          .byte 'OPE',$CE
     44B3   CE                  
     44B4   43 4C 4F     2899          .byte 'CLOS','E'+$80
     44B7   53 C5               
     44B9   47 45 D4     2900          .byte 'GE','T'+$80
     44BC   4E 45 D7     2901          .byte 'NE',$D7
            =00A2        2902   scratk =clrtk+6
     44BF   54 41 42     2903          .byte 'TAB',$A8
     44C2   A8                  
            =00A3        2904   tabtk  =scratk+1
     44C3   54 CF        2905          .byte 'T',$CF
            =00A4        2906   totk   =tabtk+1
     44C5   46 CE        2907          .byte 'F',$CE
            =00A5        2908   fntk   =totk+1
     44C7   53 50 43     2909          .byte 'SPC',$A8
     44CA   A8                  
            =00A6        2910   spctk  =fntk+1
     44CB   54 48 45     2911          .byte 'THE',$CE
     44CE   CE                  
            =00A7        2912   thentk =spctk+1
     44CF   4E 4F D4     2913          .byte 'NO','T'+$80
            =00A8        2914   nottk  =thentk+1
     44D2   53 54 45     2915          .byte 'STE',$D0
     44D5   D0                  
            =00A9        2916   steptk =nottk+1
     44D6   AB           2917          .byte $ab        	;+
            =00AA        2918   PLUSTK =STEPTK+1
     44D7   AD           2919          .byte $ad        	;-
            =00AB        2920   MINUTK =PLUSTK+1
     44D8   AA           2921          .byte $aa        	;*
     44D9   AF           2922          .byte $af        	;/
     44DA   DE           2923          .byte $de        	;~
     44DB   41 4E C4     2924          .byte 'AN',$C4
     44DE   4F D2        2925          .byte 'O','R'+$80
     44E0   BE           2926          .byte 190        	;>
            =00B1        2927   greatk =minutk+6
     44E1   BD           2928          .byte $bd        	;=
            =00B2        2929   equltk =greatk+1
     44E2   BC           2930          .byte 188        	;<
            =00B3        2931   lesstk =equltk+1
     44E3   53 47 CE     2932          .byte 'SG',$ce
            =00B4        2933   onefun =lesstk+1
     44E6   49 4E D4     2934          .byte 'IN','T'+$80
     44E9   41 42 D3     2935          .byte 'AB',$D3
     44EC   55 53 D2     2936          .byte 'US','R'+$80

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 42-2
Non-Escape Keyword List   TOKENS1.SRC

Error Addr  Code          Seq   Source statement

     44EF   46 52 C5     2937          .byte 'FR','E'+$80
     44F2   50 4F D3     2938          .byte 'PO',$D3
     44F5   53 51 D2     2939          .byte 'SQ','R'+$80
     44F8   52 4E C4     2940          .byte 'RN',$C4
     44FB   4C 4F C7     2941          .byte 'LO',$C7
     44FE   45 58 D0     2942          .byte 'EX',$D0
     4501   43 4F D3     2943          .byte 'CO',$D3
     4504   53 49 CE     2944          .byte 'SI',$CE
     4507   54 41 CE     2945          .byte 'TA',$CE
     450A   41 54 CE     2946          .byte 'AT',$CE
     450D   50 45 45     2947          .byte 'PEE',$CB
     4510   CB                  
     4511   4C 45 CE     2948          .byte 'LE',$CE
     4514   53 54 52     2949          .byte 'STR','$'+$80
     4517   A4                  
     4518   56 41 CC     2950          .byte 'VA',$CC
     451B   41 53 C3     2951          .byte 'AS',$C3
     451E   43 48 52     2952          .byte 'CHR','$'+$80
     4521   A4                  
            =00C7        2953   lasnum =onefun+19
     4522   4C 45 46     2954          .byte 'LEFT','$'+$80
     4525   54 A4               
            =00C8        2955   lefttk =lasnum+1
     4527   52 49 47     2956          .byte 'RIGHT','$'+$80
     452A   48 54 A4            
     452D   4D 49 44     2957          .byte 'MID','$'+$80
     4530   A4                  
            =00CA        2958   middtk=lefttk+2
     4531   47 CF        2959          .byte 'G',$CF
            =00CB        2960   gotk   =middtk+1
                         2961   
                         2962   
     4533   52 47 D2     2963          .byte 'RG','R'+$80
            =00CC        2964   rgrtk  =gotk+1
     4536   52 43 4C     2965          .byte 'RCL','R'+$80
     4539   D2                  
     453A   80           2966          .byte $80		;a null for the escape function token
            =00CE        2967   esc_fn_tk =rgrtk+2
     453B   4A 4F D9     2968          .byte 'JO',$D9
     453E   52 44 4F     2969          .byte 'RDO','T'+$80
     4541   D4                  
     4542   44 45 C3     2970          .byte 'DE',$C3
     4545   48 45 58     2971          .byte 'HEX','$'+$80
     4548   A4                  
     4549   45 52 52     2972          .byte 'ERR','$'+$80
     454C   A4                  
     454D   49 4E 53     2973          .byte 'INST','R'+$80
     4550   54 D2               
            =00D4        2974   insttk =esc_fn_tk+6
            =00D4        2975   highest_old_fn_tk=insttk
     4552   45 4C 53     2976          .byte 'ELS','E'+$80
     4555   C5                  
            =00D5        2977   elsetk =insttk+1
     4556   52 45 53     2978          .byte 'RESUM','E'+$80
     4559   55 4D C5            

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 42-3
Non-Escape Keyword List   TOKENS1.SRC

Error Addr  Code          Seq   Source statement

            =00D6        2979   resutk=elsetk+1
     455C   54 52 41     2980          .byte 'TRA',$D0
     455F   D0                  
            =00D7        2981   traptk=resutk+1
     4560   54 52 4F     2982          .byte 'TRO',$CE
     4563   CE                  
     4564   54 52 4F     2983          .byte 'TROF','F'+$80
     4567   46 C6               
     4569   53 4F 55     2984          .byte 'SOUN','D'+$80
     456C   4E C4               
     456E   56 4F CC     2985          .byte 'VO','L'+$80
     4571   41 55 54     2986          .byte 'AUT',$CF
     4574   CF                  
     4575   50 55 44     2987          .byte 'PUDE','F'+$80
     4578   45 C6               
     457A   47 52 41     2988          .byte 'GRAPHI',$C3
     457D   50 48 49            
     4580   C3                  
     4581   50 41 49     2989          .byte 'PAIN','T'+$80
     4584   4E D4               
     4586   43 48 41     2990          .byte 'CHA','R'+$80
     4589   D2                  
     458A   42 4F D8     2991          .byte 'BO',$D8
     458D   43 49 52     2992          .byte 'CIRCL','E'+$80
     4590   43 4C C5            
     4593   47 53 48     2993          .byte 'GSHAP','E'+$80
     4596   41 50 C5            
     4599   53 53 48     2994          .byte 'SSHAP','E'+$80
     459C   41 50 C5            
     459F   44 52 41     2995          .byte 'DRA',$D7
     45A2   D7                  
     45A3   4C 4F 43     2996          .byte 'LOCAT','E'+$80
     45A6   41 54 C5            
     45A9   43 4F 4C     2997          .byte 'COLO','R'+$80
     45AC   4F D2               
     45AE   53 43 4E     2998          .byte 'SCNCL','R'+$80
     45B1   43 4C D2            
     45B4   53 43 41     2999          .byte 'SCAL','E'+$80
     45B7   4C C5               
     45B9   48 45 4C     3000          .byte 'HEL',$D0
     45BC   D0                  
     45BD   44 CF        3001          .byte 'D',$CF
            =00EB        3002   dotk=traptk+20
     45BF   4C 4F 4F     3003          .byte 'LOO',$D0
     45C2   D0                  
            =00EC        3004   looptk=dotk+1
     45C3   45 58 49     3005          .byte 'EXI','T'+$80
     45C6   D4                  
     45C7   44 49 52     3006          .byte 'DIRECTOR',$D9
     45CA   45 43 54            
     45CD   4F 52 D9            
     45D0   44 53 41     3007          .byte 'DSAV','E'+$80
     45D3   56 C5               
     45D5   44 4C 4F     3008          .byte 'DLOA',$C4
     45D8   41 C4               

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 42-4
Non-Escape Keyword List   TOKENS1.SRC

Error Addr  Code          Seq   Source statement

     45DA   48 45 41     3009          .byte 'HEADE','R'+$80
     45DD   44 45 D2            
     45E0   53 43 52     3010          .byte 'SCRATC',$C8
     45E3   41 54 43            
     45E6   C8                  
     45E7   43 4F 4C     3011          .byte 'COLLEC','T'+$80
     45EA   4C 45 43            
     45ED   D4                  
     45EE   43 4F 50     3012          .byte 'COP',$D9
     45F1   D9                  
     45F2   52 45 4E     3013          .byte 'RENAM','E'+$80
     45F5   41 4D C5            
     45F8   42 41 43     3014          .byte 'BACKU',$D0
     45FB   4B 55 D0            
     45FE   44 45 4C     3015          .byte 'DELET','E'+$80
     4601   45 54 C5            
     4604   52 45 4E     3016          .byte 'RENUMBE','R'+$80
     4607   55 4D 42            
     460A   45 D2               
     460C   4B 45 D9     3017          .byte 'KE',$D9
            =00F9        3018   keytk  =looptk+13
     460F   4D 4F 4E     3019          .byte 'MONITO','R'+$80
     4612   49 54 4F            
     4615   D2                  
            =00FA        3020   montk  =keytk+1
     4616   55 53 49     3021          .byte 'USIN',$C7
     4619   4E C7               
            =00FB        3022   usetk  =montk+1
     461B   55 4E 54     3023          .byte 'UNTI',$CC
     461E   49 CC               
            =00FC        3024   untltk =usetk+1
     4620   57 48 49     3025          .byte 'WHIL','E'+$80
     4623   4C C5               
            =00FD        3026   whiltk =untltk+1
            =00FE        3027   esc_cmd_tk  = $fe
     4625   00           3028          .byte 0
                         3029   
                         3030   ;END
                         3031   
                         3032   	.include tokens2

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 43
Escape Tokens and Keywords   TOKENS2.SRC

Error Addr  Code          Seq   Source statement

                         3034   	.subttl Escape Tokens and Keywords
                         3035   
                         3036   ; Escape Command Tokens
                         3037   
     4626                3038   esc_cmd_lst
                         3039   
            =0002        3040   lowest_esc_cmd_tk=2
     4626   42 41 4E     3041   	.byte 'BAN','K'+$80		; 2: set bank number
     4629   CB                  
     462A   46 49 4C     3042   	.byte 'FILTE','R'+$80		; 3: set up filter
     462D   54 45 D2            
     4630   50 4C 41     3043   	.byte 'PLA','Y'+$80		; 4: play a tune
     4633   D9                  
     4634   54 45 4D     3044   	.byte 'TEMP','O'+$80		; 5: set rate for playing
     4637   50 CF               
     4639   4D 4F 56     3045   	.byte 'MOVSP','R'+$80		; 6: sprite position/movement
     463C   53 50 D2            
     463F   53 50 52     3046   	.byte 'SPRIT','E'+$80		; 7: turn on/set up sprite
     4642   49 54 C5            
     4645   53 50 52     3047   	.byte 'SPRCOLO','R'+$80		; 8: set sprite multicolor registers
     4648   43 4F 4C            
     464B   4F D2               
     464D   52 52 45     3048   	.byte 'RRE','G'+$80		; 9: retreive register values after 'SYS'
     4650   C7                  
     4651   45 4E 56     3049   	.byte 'ENVELOP','E'+$80		;10: set up SID envelopes
     4654   45 4C 4F            
     4657   50 C5               
     4659   53 4C 45     3050   	.byte 'SLEE','P'+$80		;11: delay
     465C   45 D0               
     465E   43 41 54     3051   	.byte 'CATALO','G'+$80		;12: disk directory
     4661   41 4C 4F            
     4664   C7                  
     4665   44 4F 50     3052   	.byte 'DOPE','N'+$80		;13: open a disk file
     4668   45 CE               
     466A   41 50 50     3053   	.byte 'APPEN','D'+$80		;14: open a disk file for appending
     466D   45 4E C4            
     4670   44 43 4C     3054   	.byte 'DCLOS','E'+$80		;15: close a file opened w/ DOPEN
     4673   4F 53 C5            
     4676   42 53 41     3055   	.byte 'BSAV','E'+$80		;16: binary (non-program) save
     4679   56 C5               
     467B   42 4C 4F     3056   	.byte 'BLOA','D'+$80		;17: binary load
     467E   41 C4               
     4680   52 45 43     3057   	.byte 'RECOR','D'+$80		;18: 
     4683   4F 52 C4            
     4686   43 4F 4E     3058   	.byte 'CONCA','T'+$80		;19: concatenate 2 files
     4689   43 41 D4            
     468C   44 56 45     3059   	.byte 'DVERIF','Y'+$80		;20: verify a saved program
     468F   52 49 46            
     4692   D9                  
     4693   44 43 4C     3060   	.byte 'DCLEA','R'+$80		;21: re-initialize a drive
     4696   45 41 D2            
     4699   53 50 52     3061   	.byte 'SPRSA','V'+$80		;22: sprite/string to sprite/string
     469C   53 41 D6            
     469F   43 4F 4C     3062   	.byte 'COLLISIO','N'+$80	;23: set traps for sprite & light pen collisions
     46A2   4C 49 53            

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 43-1
Escape Tokens and Keywords   TOKENS2.SRC

Error Addr  Code          Seq   Source statement

     46A5   49 4F CE            
            =0017        3063   collision_tk=23
     46A8   42 45 47     3064   	.byte 'BEGI','N'+$80		;24: mark start of a b-block
     46AB   49 CE               
            =0018        3065   begintk=24
     46AD   42 45 4E     3066   	.byte 'BEN','D'+$80		;25: ..and it's end, too!
     46B0   C4                  
            =0019        3067   bendtk=25
     46B1   57 49 4E     3068   	.byte 'WINDO','W'+$80		;26: set screen window
     46B4   44 4F D7            
     46B7   42 4F 4F     3069   	.byte 'BOO','T'+$80		;27: boot CP/M (etc.) off disk
     46BA   D4                  
     46BB   57 49 44     3070   	.byte 'WIDT','H'+$80		;28: single/double width drawing
     46BE   54 C8               
     46C0   53 50 52     3071   	.byte 'SPRDE','F'+$80		;29: define a sprite
     46C3   44 45 C6            
     46C6   51 55 49     3072   	.byte 'QUI','T'+$80		;30: (UNIMPLEMENTED)
     46C9   D4                  
     46CA   53 54 41     3073   	.byte 'STAS','H'+$80		;31: access external memory
     46CD   53 C8               
     46CF   A0           3074   	.byte ' '+$80			;32: POISON - space character
     46D0   46 45 54     3075   	.byte 'FETC','H'+$80		;33: access external memory
     46D3   43 C8               
     46D5   A0           3076   	.byte ' '+$80			;34: POISON - quote character
     46D6   53 57 41     3077   	.byte 'SWA','P'+$80		;35: access external memory
     46D9   D0                  
     46DA   4F 46 C6     3078   	.byte 'OF','F'+$80		;36: (UNIMPLEMENTED)
            =0024        3079   off_tk=36
     46DD   46 41 53     3080   	.byte 'FAS','T'+$80		;37: go to 2 MHz. mode
     46E0   D4                  
     46E1   53 4C 4F     3081   	.byte 'SLO','W'+$80		;38: go to 1 MHz. mode
     46E4   D7                  
     46E5   00           3082   	.byte 0				;  end marker
            =0026        3083   highest_esc_cmd_tk=38
                         3084   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 44
Escape Tokens and Keywords   TOKENS2.SRC

Error Addr  Code          Seq   Source statement

                         3086   ; Escape Function Tokens
                         3087   
     46E6                3088   esc_fn_lst
                         3089   
            =0002        3090   lowest_esc_fn_tk=2
     46E6   50 4F D4     3091   	.byte 'PO','T'+$80		; 2: return paddle value
     46E9   42 55 4D     3092   	.byte 'BUM','P'+$80		; 3: read sprite collision
     46EC   D0                  
     46ED   50 45 CE     3093   	.byte 'PE','N'+$80		; 4: read light pen value
     46F0   52 53 50     3094   	.byte 'RSPPO','S'+$80		; 5: read sprite position
     46F3   50 4F D3            
     46F6   52 53 50     3095   	.byte 'RSPRIT','E'+$80		; 6: read sprite value
     46F9   52 49 54            
     46FC   C5                  
     46FD   52 53 50     3096   	.byte 'RSPCOLO','R'+$80		; 7: read sprite multicolor value
     4700   43 4F 4C            
     4703   4F D2               
     4705   58 4F D2     3097   	.byte 'XO','R'+$80		; 8: exclusive or
     4708   52 57 49     3098   	.byte 'RWINDO','W'+$80		; 9: read window size
     470B   4E 44 4F            
     470E   D7                  
     470F   50 4F 49     3099   	.byte 'POINTE','R'+$80		;10: return address of descriptor
     4712   4E 54 45            
     4715   D2                  
            =000A        3100   pointer_tk=10
            =000A        3101   highest_esc_fn_tk=pointer_tk
     4716   00           3102   	.byte 0
     4717   00 00        3103   	.byte 0,0			;fill to compensate for 7APR85 change
                         3104   					;from 'SYSTEM' to 'QUIT'
                         3105   
                         3106   ;end
                         3107   	.include disptable

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 45
Jump Table For Dispatch Routine   DISPTABLE.SRC

Error Addr  Code          Seq   Source statement

                         3109   	.subttl Jump Table For Dispatch Routine
     4719                3110   stmdsp
     4719   4BE9         3111   	.word  end-1
     471B   5E15         3112   	.word  for-1
     471D   5810         3113   	.word  next-1
     471F   52AB         3114   	.word  data-1
     4721   5664         3115   	.word  inputn-1
     4723   567E         3116   	.word  input-1
     4725   5897         3117   	.word  dim-1
     4727   56C5         3118   	.word  read-1
     4729   53E2         3119   	.word  let-1
     472B   59F7         3120   	.word  goto-1
     472D   5AB7         3121   	.word  run-1
     472F   52E1         3122   	.word  if-1
     4731   5AE6         3123   	.word  restor-1
     4733   59EB         3124   	.word  gosub-1
     4735   527E         3125   	.word  return-1
     4737   52B9         3126   	.word  rem-1
     4739   4BE7         3127   	.word  stop-1
     473B   53BF         3128   	.word  ongoto-1
     473D   6CC9         3129   	.word  wait-1
     473F   912B         3130   	.word  load-1
     4741   9111         3131   	.word  save-1
     4743   9128         3132   	.word  verify-1
     4745   84F9         3133   	.word  def-1
     4747   80E4         3134   	.word  poke-1
     4749   5556         3135   	.word  printn-1
     474B   5576         3136   	.word  print-1
     474D   5A7C         3137   	.word  cont-1
     474F   50FE         3138   	.word  list-1
     4751   5214         3139   	.word  clear-1
     4753   555C         3140   	.word  cmd-1
     4755   58A1         3141   	.word  sys-1 
     4757   918C         3142   	.word  open-1
     4759   9199         3143   	.word  close-1
     475B   562E         3144   	.word  get-1
     475D   51F2         3145   	.word  new-1
     475F   53AD         3146   	.word  else-1
     4761   5F7E         3147   	.word  resume-1
     4763   5F69         3148   	.word  trap-1
     4765   58D0         3149   	.word  tron-1
     4767   58D3         3150   	.word  troff-1
     4769   7288         3151   	.word  sound-1
     476B   7261         3152   	.word  volume-1
     476D   5991         3153   	.word  auto-1
     476F   5F50         3154   	.word  puctrl-1
     4771   6B80         3155   	.word  graphic-1       	;'graphic'
     4773   61C4         3156   	.word  paint-1
     4775   67F3         3157   	.word  char-1
     4777   62D3         3158   	.word  box-1
     4779   66AA         3159   	.word  circle-1
     477B   65A9         3160   	.word  gshape-1
     477D   6447         3161   	.word  sshape-1
     477F   67B3         3162   	.word  draw-1
     4781   6971         3163   	.word  locate-1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 45-1
Jump Table For Dispatch Routine   DISPTABLE.SRC

Error Addr  Code          Seq   Source statement

     4783   69FE         3164   	.word  color-1
     4785   6A95         3165   	.word  scnclr-1
     4787   697C         3166   	.word  scale-1
     4789   59A2         3167   	.word  help-1
     478B   5FFC         3168   	.word  do-1
     478D   60A6         3169   	.word  loop-1
     478F   6055         3170   	.word  exit-1
     4791   A08D         3171   	.word  catalog-1
     4793   A19B         3172   	.word  dsave-1
     4795   A1B6         3173   	.word  dload-1
     4797   A276         3174   	.word  header-1
     4799   A2B0         3175   	.word  scratc-1
     479B   A33E         3176   	.word  collect-1
     479D   A355         3177   	.word  dcopy-1
     479F   A37D         3178   	.word  rename-1
     47A1   A38B         3179   	.word  backup-1
     47A3   5EA3         3180   	.word  delete-1
     47A5   5B14         3181   	.word  renum-1
     47A7   6126         3182   	.word  key-1
     47A9   AFFF         3183   	.word  _monitor-1
     47AB   6C65         3184   	.word  bank-1		;escape
     47AD   70E2         3185   	.word  filter-1		;escape
     47AF   6E7D         3186   	.word  play-1		;escape
     47B1   7073         3187   	.word  tempo-1		;escape
     47B3   6D62         3188   	.word  movspr-1		;escape
     47B5   6CEB         3189   	.word  sprite-1		;escape
     47B7   722C         3190   	.word  sprcolor-1	;escape
     47B9   58D9         3191   	.word  rreg-1		;escape
     47BB   715D         3192   	.word  envelope-1	;escape
     47BD   6C73         3193   	.word  sleep-1		;escape
     47BF   A08D         3194   	.word  catalog-1	;escape
     47C1   A12C         3195   	.word  dopen-1		;escape
     47C3   A143         3196   	.word  append-1		;escape
     47C5   A17E         3197   	.word  dclose-1		;escape
     47C7   A1D7         3198   	.word  bsave-1		;escape
     47C9   A227         3199   	.word  bload-1		;escape
     47CB   A2E6         3200   	.word  record-1		;escape
     47CD   A371         3201   	.word  concat-1		;escape
     47CF   A1B3         3202   	.word  dverify-1	;escape
     47D1   A331         3203   	.word  dclear-1		;escape
     47D3   7788         3204   	.word  sprsav-1		;escape
     47D5   7200         3205   	.word  collision-1	;escape
     47D7   7A08         3206   	.word  snerr-1		;escape - BEGIN
     47D9   52AB         3207   	.word  data-1		;escape - BEND
     47DB   7368         3208   	.word  window-1		;escape
     47DD   73D1         3209   	.word  boot-1		;escape
     47DF   7252         3210   	.word  set_width-1	;escape - WIDTH
     47E1   740E         3211   	.word  sprdef-1		;escape
     47E3   4862         3212   	.word  bad_command-1	;escape - SYSTEM - unimplemented command
     47E5   AA2E         3213   	.word  stash-1		;escape
     47E7   0000         3214   	.word  0		; placeholder to skip over the space character
     47E9   AA33         3215   	.word  fetch-1		;escape
     47EB   0000         3216   	.word  0		; placeholder to skip over the quote character
     47ED   AA38         3217   	.word  swap-1		;escape
     47EF   4862         3218   	.word  bad_command-1	;escape - OFF - unimplemented command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 45-2
Jump Table For Dispatch Routine   DISPTABLE.SRC

Error Addr  Code          Seq   Source statement

     47F1   784F         3219   	.word  fast-1		;escape
     47F3   7860         3220   	.word  slow-1
                         3221   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 46
Jump Table For Dispatch Routine   DISPTABLE.SRC

Error Addr  Code          Seq   Source statement

     47F5                3223   fundsp
     47F5   8C65         3224   	.word  sgn
     47F7   8CFB         3225   	.word  int
     47F9   8C84         3226   	.word  abs
     47FB   1218         3227   	.word  usrpok
     47FD   8000         3228   	.word  fre
     47FF   84D0         3229   	.word  pos
     4801   8FB7         3230   	.word  sqr
     4803   8434         3231   	.word  rnd
     4805   89CA         3232   	.word  log
     4807   9033         3233   	.word  exp
     4809   9409         3234   	.word  cos
     480B   9410         3235   	.word  sin
     480D   9459         3236   	.word  tan
     480F   94B3         3237   	.word  atn
     4811   80C5         3238   	.word  peek
     4813   8668         3239   	.word  len
     4815   85AE         3240   	.word  strd
     4817   804A         3241   	.word  val
     4819   8677         3242   	.word  asc
     481B   85BF         3243   	.word  chrd
     481D   85D6         3244   	.word  leftd
     481F   860A         3245   	.word  rightd
     4821   861C         3246   	.word  midd
     4823   8182         3247   	.word  rgr
     4825   819B         3248   	.word  rclr
     4827   0000         3249   	.word  0		;placeholder for escape function token
     4829   8203         3250   	.word  joy
     482B   9B0C         3251   	.word  rdot
     482D   8076         3252   	.word  dcml            	;dec
     482F   8142         3253   	.word  hexd
     4831   80F6         3254   	.word  errd
     4833   824D         3255   	.word  pot		;escape
     4835   837C         3256   	.word  bump		;escape
     4837   82AE         3257   	.word  pen		;escape
     4839   8397         3258   	.word  rsppos		;escape
     483B   831E         3259   	.word  rsprite		;escape
     483D   8361         3260   	.word  rspcolor		;escape
     483F   83E1         3261   	.word  xor		;escape
     4841   8407         3262   	.word  rwindow		;escape
     4843   82FA         3263   	.word  pointer		;escape
                         3264   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 47
Jump Table For Dispatch Routine   DISPTABLE.SRC

Error Addr  Code          Seq   Source statement

                         3266   
     4845   79           3267   optab	.byte   121
     4846   8847         3268   	.word  faddt-1
     4848   79           3269   	.byte   121
     4849   8830         3270   	.word  fsubt-1
     484B   7B           3271   	.byte   123
     484C   8A26         3272   	.word  fmultt-1
     484E   7B           3273   	.byte   123
     484F   8B4B         3274   	.word  fdivt-1
     4851   7F           3275   	.byte   127
     4852   8FC0         3276   	.word  fpwrt-1
     4854   50           3277   	.byte   80
     4855   4CA5         3278   	.word  andop-1
     4857   46           3279   	.byte   70
     4858   4CA2         3280   	.word  orop-1
     485A   7D           3281   negtab	.byte 125
     485B   8FF9         3282   	.word  negop-1 
     485D   5A           3283   	.byte   90
     485E   79CC         3284   	.word  notop-1
     4860   64           3285   ptdorl	.byte 100
     4861   4CD2         3286   	.word  dorel-1
                         3287   
     4863                3288   bad_command
     4863   A2 28        3289   	ldx #err_bad_command		;unimplemented command
     4865   4C 4D59      3290   	jmp error
                         3291   ;.end
                         3292   	.include errmsgs

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 48
Error Messages   ERRMSGS.SRC

Error Addr  Code          Seq   Source statement

                         3294   	.subttl Error Messages
     4868                3295   ERR01
     4868   54 4F 4F     3296   	.byte 'TOO MANY FILE','S'+$80
     486B   20 4D 41            
     486E   4E 59 20            
     4871   46 49 4C            
     4874   45 D3               
            =0001        3297   errtmf	=1
     4876   46 49 4C     3298   	.byte 'FILE OPE','N'+$80
     4879   45 20 4F            
     487C   50 45 CE            
     487F   46 49 4C     3299   	.byte 'FILE NOT OPE','N'+$80
     4882   45 20 4E            
     4885   4F 54 20            
     4888   4F 50 45            
     488B   CE                  
     488C   46 49 4C     3300   	.byte 'FILE NOT FOUN','D'+$80
     488F   45 20 4E            
     4892   4F 54 20            
     4895   46 4F 55            
     4898   4E C4               
            =0004        3301   errfnf	=4
     489A   44 45 56     3302   	.byte 'DEVICE NOT PRESEN','T'+$80
     489D   49 43 45            
     48A0   20 4E 4F            
     48A3   54 20 50            
     48A6   52 45 53            
     48A9   45 4E D4            
     48AC   4E 4F 54     3303   	.byte 'NOT INPUT FIL','E'+$80
     48AF   20 49 4E            
     48B2   50 55 54            
     48B5   20 46 49            
     48B8   4C C5               
     48BA   4E 4F 54     3304   	.byte 'NOT OUTPUT FIL','E'+$80
     48BD   20 4F 55            
     48C0   54 50 55            
     48C3   54 20 46            
     48C6   49 4C C5            
     48C9   4D 49 53     3305   	.byte 'MISSING FILE NAM','E'+$80
     48CC   53 49 4E            
     48CF   47 20 46            
     48D2   49 4C 45            
     48D5   20 4E 41            
     48D8   4D C5               
            =0008        3306   err_missing_fname=8
     48DA   49 4C 4C     3307   	.byte 'ILLEGAL DEVICE NUMBE','R'+$80
     48DD   45 47 41            
     48E0   4C 20 44            
     48E3   45 56 49            
     48E6   43 45 20            
     48E9   4E 55 4D            
     48EC   42 45 D2            
            =0009        3308   err_illegal_device=9
     48EF   4E 45 58     3309   	.byte 'NEXT WITHOUT FO','R'+$80
     48F2   54 20 57            

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 48-1
Error Messages   ERRMSGS.SRC

Error Addr  Code          Seq   Source statement

     48F5   49 54 48            
     48F8   4F 55 54            
     48FB   20 46 4F            
     48FE   D2                  
            =000A        3310   ERRNF  =10
     48FF   53 59 4E     3311   	.byte 'SYNTA','X'+$80
     4902   54 41 D8            
            =000B        3312   ERRSN  =11
     4905   52 45 54     3313   	.byte 'RETURN WITHOUT GOSU','B'+$80
     4908   55 52 4E            
     490B   20 57 49            
     490E   54 48 4F            
     4911   55 54 20            
     4914   47 4F 53            
     4917   55 C2               
            =000C        3314   ERRRG  =12
     4919   4F 55 54     3315   	.byte 'OUT OF DAT','A'+$80
     491C   20 4F 46            
     491F   20 44 41            
     4922   54 C1               
            =000D        3316   ERROD  =13
     4924   49 4C 4C     3317   	.byte 'ILLEGAL QUANTIT','Y'+$80
     4927   45 47 41            
     492A   4C 20 51            
     492D   55 41 4E            
     4930   54 49 54            
     4933   D9                  
            =000E        3318   ERRFC  =14
     4934   4F 56 45     3319   	.byte 'OVERFLO','W'+$80
     4937   52 46 4C            
     493A   4F D7               
            =000F        3320   ERROV  =15
     493C   4F 55 54     3321   	.byte 'OUT OF MEMOR','Y'+$80
     493F   20 4F 46            
     4942   20 4D 45            
     4945   4D 4F 52            
     4948   D9                  
            =0010        3322   ERROM  =16
     4949   55 4E 44     3323   	.byte 'UNDEF',$27,'D STATEMEN','T'+$80
     494C   45 46 27            
     494F   44 20 53            
     4952   54 41 54            
     4955   45 4D 45            
     4958   4E D4               
            =0011        3324   ERRUS  =17
     495A   42 41 44     3325   	.byte 'BAD SUBSCRIP','T'+$80
     495D   20 53 55            
     4960   42 53 43            
     4963   52 49 50            
     4966   D4                  
            =0012        3326   ERRBS  =18
     4967   52 45 44     3327   	.byte 'REDIM',$27,'D ARRA','Y'+$80
     496A   49 4D 27            
     496D   44 20 41            
     4970   52 52 41            

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 48-2
Error Messages   ERRMSGS.SRC

Error Addr  Code          Seq   Source statement

     4973   D9                  
            =0013        3328   ERRDD  =19
     4974   44 49 56     3329   	.byte 'DIVISION BY ZER','O'+$80
     4977   49 53 49            
     497A   4F 4E 20            
     497D   42 59 20            
     4980   5A 45 52            
     4983   CF                  
            =0014        3330   ERRDVO =20
     4984   49 4C 4C     3331   	.byte 'ILLEGAL DIREC','T'+$80
     4987   45 47 41            
     498A   4C 20 44            
     498D   49 52 45            
     4990   43 D4               
            =0015        3332   ERRID  =21
     4992   54 59 50     3333   	.byte 'TYPE MISMATC','H'+$80
     4995   45 20 4D            
     4998   49 53 4D            
     499B   41 54 43            
     499E   C8                  
            =0016        3334   ERRTM  =22
     499F   53 54 52     3335   	.byte 'STRING TOO LON','G'+$80
     49A2   49 4E 47            
     49A5   20 54 4F            
     49A8   4F 20 4C            
     49AB   4F 4E C7            
            =0017        3336   ERRLS  =23
     49AE   46 49 4C     3337   	.byte 'FILE DAT','A'+$80
     49B1   45 20 44            
     49B4   41 54 C1            
            =0018        3338   ERRBD  =24
     49B7   46 4F 52     3339   	.byte 'FORMULA TOO COMPLE','X'+$80
     49BA   4D 55 4C            
     49BD   41 20 54            
     49C0   4F 4F 20            
     49C3   43 4F 4D            
     49C6   50 4C 45            
     49C9   D8                  
            =0019        3340   ERRST  =25
     49CA   43 41 4E     3341   	.byte 'CAN',$27,'T CONTINU','E'+$80
     49CD   27 54 20            
     49D0   43 4F 4E            
     49D3   54 49 4E            
     49D6   55 C5               
            =001A        3342   ERRCN  =26
     49D8   55 4E 44     3343   	.byte 'UNDEF''D FUNCTIO','N'+$80
     49DB   45 46 27            
     49DE   44 20 46            
     49E1   55 4E 43            
     49E4   54 49 4F            
     49E7   CE                  
            =001B        3344   ERRUF  =27
     49E8   56 45 52     3345   	.byte 'VERIF','Y'+$80
     49EB   49 46 D9            
            =001C        3346   ERVFY  =28

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 48-3
Error Messages   ERRMSGS.SRC

Error Addr  Code          Seq   Source statement

     49EE   4C 4F 41     3347   	.byte 'LOA','D'+$80
     49F1   C4                  
            =001D        3348   ERLOAD =29
     49F2   42 52 45     3349   	.byte 'BREAK',0,' '+$80
     49F5   41 4B 00            
     49F8   A0                  
            =001E        3350   ERBRK  =30
     49F9   43 41 4E     3351   	.byte 'CAN''T RESUM','E'+$80
     49FC   27 54 20            
     49FF   52 45 53            
     4A02   55 4D C5            
            =001F        3352   ERRCR  =31
     4A05   4C 4F 4F     3353   	.byte 'LOOP NOT FOUN','D'+$80
     4A08   50 20 4E            
     4A0B   4F 54 20            
     4A0E   46 4F 55            
     4A11   4E C4               
            =0020        3354   ERRLNF =32
     4A13   4C 4F 4F     3355   	.byte 'LOOP WITHOUT D','O'+$80
     4A16   50 20 57            
     4A19   49 54 48            
     4A1C   4F 55 54            
     4A1F   20 44 CF            
            =0021        3356   ERRLWD =33
     4A22   44 49 52     3357   	.byte 'DIRECT MODE ONL','Y'+$80
     4A25   45 43 54            
     4A28   20 4D 4F            
     4A2B   44 45 20            
     4A2E   4F 4E 4C            
     4A31   D9                  
            =0022        3358   ERROID =34
     4A32   4E 4F 20     3359   	.byte 'NO GRAPHICS ARE','A'+$80
     4A35   47 52 41            
     4A38   50 48 49            
     4A3B   43 53 20            
     4A3E   41 52 45            
     4A41   C1                  
            =0023        3360   ERRNG  =35
     4A42   42 41 44     3361   	.byte 'BAD DIS','K'+$80
     4A45   20 44 49            
     4A48   53 CB               
            =0024        3362   errbdk =36
     4A4A   42 45 4E     3363   	.byte 'BEND NOT FOUN','D'+$80
     4A4D   44 20 4E            
     4A50   4F 54 20            
     4A53   46 4F 55            
     4A56   4E C4               
            =0025        3364   err_no_bend =37
     4A58   4C 49 4E     3365   	.byte 'LINE NUMBER TOO LARG','E'+$80
     4A5B   45 20 4E            
     4A5E   55 4D 42            
     4A61   45 52 20            
     4A64   54 4F 4F            
     4A67   20 4C 41            
     4A6A   52 47 C5            

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 48-4
Error Messages   ERRMSGS.SRC

Error Addr  Code          Seq   Source statement

            =0026        3366   err_too_large =38
     4A6D   55 4E 52     3367   	.byte 'UNRESOLVED REFERENC','E'+$80
     4A70   45 53 4F            
     4A73   4C 56 45            
     4A76   44 20 52            
     4A79   45 46 45            
     4A7C   52 45 4E            
     4A7F   43 C5               
            =0027        3368   err_ref =39
     4A81   55 4E 49     3369   	.byte 'UNIMPLEMENTED COMMAN','D'+$80
     4A84   4D 50 4C            
     4A87   45 4D 45            
     4A8A   4E 54 45            
     4A8D   44 20 43            
     4A90   4F 4D 4D            
     4A93   41 4E C4            
            =0028        3370   err_bad_command =40
     4A96   46 49 4C     3371   	.byte 'FILE REA','D'+$80
     4A99   45 20 52            
     4A9C   45 41 C4            
            =0029        3372   errlst = err_bad_command+1		;keep track of # of last error msg
                         3373   
                         3374   ;.end
                         3375   	.include errprint

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 49
print correct error message   ERRPRINT.SRC

Error Addr  Code          Seq   Source statement

                         3377   	.subttl print correct error message
                         3378   
                         3379   ; routine to translate error message # in .a
                         3380   ; to address of string containing message in index2
                         3381   ;
     4A9F   AA           3382   erstup	tax			;error set up
     4AA0   A0 00        3383   	ldy #0
     4AA2   A9 68        3384   	lda #<err01     	;start with address of first error message
     4AA4   85 26        3385   	sta index2
     4AA6   A9 48        3386   	lda #>err01
     4AA8   85 27        3387   	sta index2+1
                         3388   
     4AAA   CA           3389   1$	dex
     4AAB   30 0E        3390   	bmi 4$			;finished when .x decrements out
                         3391   
     4AAD   B1 26        3392   2$	lda (index2),y		;look at msg, and find end (msb set) (ind.ok)
     4AAF   48           3393   	pha
     4AB0   E6 26        3394   	inc index2
     4AB2   D0 02        3395   	bne 3$
     4AB4   E6 27        3396   	inc index2+1
     4AB6   68           3397   3$	pla			;was msb set?
     4AB7   10 F4        3398   	bpl 2$			;no, not end of message
     4AB9   30 EF        3399   	bmi 1$			;yes, tick off another msg
                         3400   
     4ABB   60           3401   4$	rts
                         3402   
                         3403   ;end
                         3404   	.include execute

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 50
execute dispatcher   EXECUTE.SRC

Error Addr  Code          Seq   Source statement

                         3406   	.subttl execute dispatcher
                         3407   
                         3408   ; here for new statement. character -> by txtptr is ':' or eol. the adr of
                         3409   ; this loc is left on the stack when a statement is executed so that it can
                         3410   ; merely do a rts when it is done.
                         3411   ; get char, exit via xeqcm3, and return to newstt.
                         3412   
     4ABC   6C 0308      3413   xeqcm	jmp (igone)
                         3414   
                         3415   ; check if there is an interrupt from  the VIC that needs to be serviced
                         3416   
     4ABF   24 7F        3417   ngone	bit runmod		;are we in direct mode?
     4AC1   10 4A        3418   	bpl 30$			;yes, get off here
                         3419   
     4AC3   AD 127F      3420   	lda intval		;check if there is an interrupt already in progress
     4AC6   30 45        3421   	bmi 30$			;yes, don't go any further
                         3422   
     4AC8   A2 02        3423   	ldx #2			;check for 3 types of interrupts: s/s, s/b, & lp
     4ACA   BD 1276      3424   10$	lda int_trip_flag,x
     4ACD   F0 3B        3425   	beq 20$			;this wasn't set, go check next
                         3426   
     4ACF   A9 00        3427   	lda #0
     4AD1   9D 1276      3428   	sta int_trip_flag,x	;reset this flag to show 'serviced'
     4AD4   BD 1279      3429   	lda int_adr_lo,x	;install the trap address as linnum
     4AD7   85 16        3430   	sta linnum
     4AD9   BD 127C      3431   	lda int_adr_hi,x
     4ADC   85 17        3432   	sta linnum+1
     4ADE   8A           3433   	txa
     4ADF   48           3434   	pha			;save counter & text pointer
     4AE0   A5 3D        3435   	lda txtptr
     4AE2   48           3436   	pha
     4AE3   A5 3E        3437   	lda txtptr+1
     4AE5   48           3438   	pha
                         3439   
     4AE6   AD 127F      3440   	lda intval
     4AE9   09 80        3441   	ora #$80		;flag 'no other interrupt traps, please'
     4AEB   8D 127F      3442   	sta intval
                         3443   
     4AEE   20 0380      3444   	jsr chrget		;skip over 2nd byte of line number
     4AF1   20 5A3A      3445   	jsr gosub_sub		;fake a 'gosub' from here, so trap rx can do a RETURN
     4AF4   20 59FF      3446   	jsr goto_1
     4AF7   20 4B13      3447   	jsr newstt
                         3448   
     4AFA   AD 127F      3449   	lda intval
     4AFD   29 7F        3450   	and #$7f
     4AFF   8D 127F      3451   	sta intval
                         3452   
     4B02   68           3453   	pla
     4B03   85 3E        3454   	sta txtptr+1
     4B05   68           3455   	pla
     4B06   85 3D        3456   	sta txtptr
     4B08   68           3457   	pla
     4B09   AA           3458   	tax
                         3459   
     4B0A   CA           3460   20$	dex

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 50-1
execute dispatcher   EXECUTE.SRC

Error Addr  Code          Seq   Source statement

     4B0B   10 BD        3461   	bpl 10$
                         3462   
                         3463   
     4B0D   20 0380      3464   30$	jsr chrget	;get statement type
     4B10   20 4B5C      3465   xeqdir	jsr xeqcm3
                         3466   
     4B13   20 4BD2      3467   newstt	jsr is_stop_key_down
     4B16   24 7F        3468   	bit runmod	;direct mode?
     4B18   10 06        3469   	bpl 10$		;yes...
                         3470   
                         3471   ; in run mode...save txtptr for cont command
                         3472   
     4B1A   20 4B51      3473   	jsr tto	  	;transfer txtptr to oldtxt
     4B1D   BA           3474   	tsx
     4B1E   86 82        3475   	stx oldstk
                         3476   
     4B20   A0 00        3477   10$	ldy #0
     4B22   20 03C9      3478   	jsr indtxt	;end of the line?
     4B25   F0 03        3479   	beq 20$		;yes
     4B27   4C 4BCB      3480   	jmp morsts	;no...out of statement
                         3481   
     4B2A   24 7F        3482   20$	bit runmod	;in direct mode?
     4B2C   10 20        3483   	bpl nstt5	;yes, go to ready
     4B2E   A0 02        3484   	ldy #2
     4B30   20 03C9      3485   	jsr indtxt	;end of text?
     4B33   F0 19        3486   	beq nstt5	;yes...finished
     4B35   C8           3487   	iny		;y=3
     4B36   20 03C9      3488   	jsr indtxt	;extract line# lo byte
     4B39   85 3B        3489   	sta curlin
     4B3B   C8           3490   	iny
     4B3C   20 03C9      3491   	jsr indtxt	;extract line # hi byte
     4B3F   85 3C        3492   	sta curlin+1
     4B41   98           3493   	tya		;y=4
     4B42   18           3494   	clc
     4B43   65 3D        3495   	adc txtptr	;point @ character before line start
     4B45   85 3D        3496   	sta txtptr
     4B47   90 02        3497   	bcc 30$
     4B49   E6 3E        3498   	inc txtptr+1
     4B4B   4C 4ABC      3499   30$	jmp xeqcm	;execute new line
                         3500   
     4B4E   4C 4D54      3501   nstt5	jmp ready
                         3502   
                         3503   
                         3504   
     4B51   A5 3D        3505   tto	lda txtptr
     4B53   A4 3E        3506   	ldy txtptr+1
     4B55   8D 1202      3507   	sta oldtxt
     4B58   8C 1203      3508   	sty oldtxt+1
     4B5B   60           3509   xeqrts	rts
                         3510   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 51
execute dispatcher   EXECUTE.SRC

Error Addr  Code          Seq   Source statement

                         3512   ; set up for command processing and set processor address on stack,
                         3513   ; exit via jmp to chrget
                         3514   
     4B5C   F0 FD        3515   xeqcm3	beq xeqrts	;nothing here...null statement
                         3516   
     4B5E   2C 116F      3517   	bit trcflg	;in trace mode?
     4B61   10 13        3518   	bpl xeqcm2	;branch if not.
                         3519   
     4B63   24 7F        3520   	bit runmod	;in direct mode?
     4B65   10 0F        3521   	bpl xeqcm2	;branch if yes. can't trace in direct mode
                         3522   
     4B67   48           3523   	pha		;save token
     4B68   A9 5B        3524   	lda #'['	;print '{ line-number }'
     4B6A   20 5629      3525   	jsr outdo
     4B6D   20 8E2E      3526   	jsr curprt	;print curlin
     4B70   A9 5D        3527   	lda #']'
     4B72   20 5629      3528   	jsr outdo
     4B75   68           3529   	pla		;restore token
                         3530   
                         3531   
     4B76   C9 FE        3532   xeqcm2	cmp #esc_cmd_tk	;special case: escape token
     4B78   F0 37        3533   	beq xeqesc
                         3534   
     4B7A   C9 CB        3535   	cmp #gotk	;special case: go to
     4B7C   D0 03        3536   	bne 1$
     4B7E   4C 5A5A      3537   	jmp go_without_to
                         3538   
     4B81   C9 CA        3539   1$	cmp #middtk	;special case: mid$()=
     4B83   F0 23        3540   	beq xeqmid
                         3541   
                         3542   ; command can be in the range end..new (old basic) & else..monitor
                         3543   ; (new extensions). although there is a gap between these two blocks,
                         3544   ; it will be quickest & easiest to collapse them into one
                         3545   ; continuous block.
                         3546   
     4B85   C9 FB        3547   	cmp #montk+1
     4B87   B0 3F        3548   	bcs snerr1
     4B89   C9 A3        3549   	cmp #scratk+1
     4B8B   90 06        3550   	bcc xeqcm4	;no need to collapse
     4B8D   C9 D5        3551   	cmp #elsetk
     4B8F   90 37        3552   	bcc snerr1
     4B91   E9 32        3553   	sbc #elsetk-scratk-1
                         3554   
     4B93   38           3555   xeqcm4	sec		;convert adjusted token into an index into a jump table.
     4B94   E9 80        3556   	sbc #endtk
     4B96   B0 03        3557   	bcs xeqcm5
     4B98   4C 53E3      3558   	jmp let		;it wasn't a token after all! assume an assignment
                         3559   
     4B9B   0A           3560   xeqcm5	asl a
     4B9C   A8           3561   	tay
     4B9D   B9 471A      3562   	lda stmdsp+1,y
     4BA0   48           3563   	pha
     4BA1   B9 4719      3564   	lda stmdsp,y
     4BA4   48           3565   	pha
     4BA5   4C 0380      3566   	jmp chrget	;execution will commence after chrget's rts.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 51-1
execute dispatcher   EXECUTE.SRC

Error Addr  Code          Seq   Source statement

                         3567   
                         3568   
                         3569   
     4BA8                3570   xeqmid 			;handle special case of mid$= (what we call a kludge).
     4BA8   A9 59        3571   	lda #>midwrk	;midd2-1
     4BAA   48           3572   	pha
     4BAB   A9 1D        3573   	lda #<midwrk
     4BAD   48           3574   	pha
     4BAE                3575   xeqchr
     4BAE   4C 0380      3576   	jmp chrget
                         3577   
                         3578   
                         3579   
                         3580   
     4BB1                3581   xeqesc 				;execute escape token
     4BB1   20 0380      3582   	jsr chrget		;lets have us a look at the second char
     4BB4   F0 12        3583   	beq snerr1		;oops, there wasn't any!
     4BB6   C9 02        3584   	cmp #lowest_esc_cmd_tk	;is it one of our esc tokens?
     4BB8   90 08        3585   	bcc 1$			;no, foreign.
     4BBA   C9 27        3586   	cmp #highest_esc_cmd_tk+1
     4BBC   B0 04        3587   	bcs 1$			;foreign
                         3588   
                         3589   ;it's one of our own. convert to index into command dispatch table
                         3590   
     4BBE   69 47        3591   	adc #montk-elsetk+scratk-endtk-lowest_esc_cmd_tk+2 ;+eye of newt-toe of frog...
     4BC0   D0 D9        3592   	bne xeqcm5		;always
                         3593   
     4BC2   38           3594   1$	sec			;set up flag for a trip into the users code
     4BC3   6C 0310      3595   	jmp (iescex)
     4BC6   90 E6        3596   nescex	bcc xeqchr		;jmp chrget
                         3597   
     4BC8   4C 7A09      3598   snerr1	jmp snerr
                         3599   
     4BCB   C9 3A        3600   morsts	cmp #':'
     4BCD   D0 F9        3601   	bne snerr1
     4BCF   4C 4ABC      3602   	jmp xeqcm		;if ':', continue statement
                         3603   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 52
execute dispatcher   EXECUTE.SRC

Error Addr  Code          Seq   Source statement

                         3605   
     4BD2                3606   is_stop_key_down
     4BD2   20 9293      3607   	jsr k_stop	;test stop key
     4BD5   F0 01        3608   	beq 10$
     4BD7   60           3609   	rts		;not down, exit
                         3610   
     4BD8   AC 120C      3611   10$	ldy trapno+1	;test if trap on
     4BDB   C8           3612   	iny
     4BDC   F0 0F        3613   	beq stop_1	;no, do a normal stop
                         3614   
     4BDE   20 9293      3615   20$	jsr k_stop	;wait for the user to release the key
     4BE1   F0 FB        3616   	beq 20$
     4BE3   A2 1E        3617   	ldx #erbrk
     4BE5   4C 4D59      3618   	jmp error
                         3619   
                         3620   
                         3621   
     4BE8   B0 01        3622   stop	bcs stopc	;make (c) nonzero as a flag
                         3623   
     4BEA   18           3624   end	clc
     4BEB   D0 26        3625   stopc	bne do_rts
     4BED   24 7F        3626   stop_1	bit runmod	;in direct mode?
     4BEF   10 0D        3627   	bpl diris	;yes
     4BF1   20 4B51      3628   	jsr tto	  	;transfer txtptr to oldtxt
     4BF4   A5 3B        3629   	lda curlin
     4BF6   A4 3C        3630   	ldy curlin+1
     4BF8   8D 1200      3631   	sta oldlin
     4BFB   8C 1201      3632   	sty oldlin+1
     4BFE                3633   diris
     4BFE   68           3634   	pla
     4BFF   68           3635   	pla
     4C00   90 0E        3636   	bcc 1$
     4C02   20 9281      3637   	jsr k_primm
     4C05   0D 0A 42     3638   	.byte cr, $a, 'BREAK', 0
     4C08   52 45 41            
     4C0B   4B 00               
     4C0D   4C 4DCC      3639   	jmp errfin
     4C10   4C 4D54      3640   1$	jmp ready	;type "ready".
                         3641   
     4C13   60           3642   do_rts	rts
                         3643   
                         3644   ;end
                         3645   	.include functions

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 53
Function Handler   FUNCTIONS.SRC

Error Addr  Code          Seq   Source statement

                         3647   	.subttl Function Handler
                         3648   
                         3649   ; at this point, eval has determined that the token in a has to be a
                         3650   ; function. it must therefor be in the range sgn..mid$ (old basic),
                         3651   ; or rgr..instr (new extensions). we will collapse these two
                         3652   ; disjoint blocks into one continuous range.
                         3653   ;
                         3654   ; on entry, we can assume the token is >= 'sgn'
                         3655   
     4C14   C9 CE        3656   isfun	cmp #esc_fn_tk	;is this an escape function?
     4C16   F0 59        3657   	beq do_esc_fn	;branch if so
     4C18   C9 D5        3658   	cmp #insttk+1	;instring token is last function
     4C1A   B0 AC        3659   	bcs snerr1
     4C1C   C9 CB        3660   	cmp #middtk+1
     4C1E   90 02        3661   	bcc 1$		;no need to adjust
     4C20   E9 01        3662   	sbc #rgrtk-middtk-1
                         3663   
     4C22   48           3664   1$	pha		;save token
     4C23   AA           3665   	tax
     4C24   20 0380      3666   	jsr chrget	;set up for synchk.
     4C27   E0 D3        3667   	cpx #insttk-1	;look for (adjusted) instr token
     4C29   F0 08        3668   	beq 2$
     4C2B   E0 CB        3669   	cpx #middtk+1
     4C2D   B0 29        3670   	bcs oknorm
     4C2F   E0 C8        3671   	cpx #lefttk	;is it past "lastnum"?
     4C31   90 25        3672   	bcc oknorm	;no, must be normal function.
                         3673   
                         3674   
                         3675   ; Most functions take a single argument. the return address of these functions
                         3676   ; is "chknum", which ascertains that (valtyp)=0 (numeric). Normal functions
                         3677   ; that return string results (eg.,chr$) must pop off that return addr and 
                         3678   ; return directly to "frmevl".
                         3679   ;
                         3680   ; The so called "funny" functions can take more than one argument, the first
                         3681   ;  of which must be string and the second of which must be a number between 0
                         3682   ; and 255. The closed parenthesis must be checked and return is directly to
                         3683   ; "frmevl" with the text pointer pointing beyond the ")". the pointer to the
                         3684   ; description of the string argument  is stored on the stack underneath the
                         3685   ;  value of the integer argument.
                         3686   
     4C33   20 79F6      3687   2$	jsr chkopn	;check for an open parenthesis.
     4C36   20 788C      3688   	jsr frmevl	;eat open paren and first argument.
     4C39   20 79F9      3689   	jsr chkcom	;two args so comma must delimit.
     4C3C   20 787A      3690   	jsr chkstr	;make sur efirst was string.
                         3691   
     4C3F   68           3692   	pla		;move token to x
     4C40   C9 D3        3693   	cmp #insttk-1   ;yet another special case: instr bails out here.
     4C42   F0 59        3694   	beq instgo
     4C44   AA           3695   	tax
     4C45   A5 67        3696   	lda facmo+1
     4C47   48           3697   	pha
     4C48   A5 66        3698   	lda facmo
     4C4A   48           3699   	pha
     4C4B   8A           3700   	txa		;push token on stack
     4C4C   48           3701   	pha

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 53-1
Function Handler   FUNCTIONS.SRC

Error Addr  Code          Seq   Source statement

     4C4D   20 87F4      3702   	jsr getbyt
     4C50   68           3703   	pla		;put token in y
     4C51   A8           3704   	tay
     4C52   8A           3705   	txa
     4C53   48           3706   	pha
     4C54   98           3707   	tya		;put token in a
     4C55   4C 4C5C      3708   	jmp fingo	;go set up to evaluate fn
                         3709   
                         3710   
                         3711   
     4C58                3712   oknorm
     4C58   20 79ED      3713   	jsr parchk	;check for open parens, evaluate argument
     4C5B   68           3714   	pla		;restore token
                         3715   
     4C5C                3716   fingo
     4C5C   38           3717   	sec		;convert token to index into jump table
     4C5D   E9 B4        3718   	sbc #onefun
     4C5F   0A           3719   	asl a
     4C60   A8           3720   	tay
     4C61   B9 47F6      3721   	lda fundsp+1,y
     4C64   85 58        3722   	sta jmper+2
     4C66   B9 47F5      3723   	lda fundsp,y
     4C69   85 57        3724   	sta jmper+1
     4C6B   20 0056      3725   	jsr jmper	;dispatch.
                         3726   			;string functions remove this ret addr.
     4C6E   4C 7877      3727   	jmp chknum	;check for numericness and return.
                         3728   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 54
Function Handler   FUNCTIONS.SRC

Error Addr  Code          Seq   Source statement

                         3730   ; escape function handler
                         3731   
     4C71                3732   do_esc_fn
     4C71   20 0380      3733   	jsr chrget		get second token
     4C74   F0 2A        3734   	beq snerr6		;error if no second token
     4C76   C9 0A        3735   	cmp #pointer_tk
     4C78   F0 0B        3736   	beq 10$			;skip pre-parse if 'POINTER()'
     4C7A   48           3737   	pha
     4C7B   20 0380      3738   	jsr chrget		;should be '('
     4C7E   20 79F6      3739   	jsr chkopn
     4C81   20 788C      3740   	jsr frmevl		;evaluate first argument
     4C84   68           3741   	pla
     4C85   C9 02        3742   10$	cmp #lowest_esc_fn_tk	;see if this esc fn is one of ours
     4C87   90 08        3743   	bcc foreign_esc_fn	;nope.
     4C89   C9 0B        3744   	cmp #highest_esc_fn_tk+1
     4C8B   B0 04        3745   	bcs foreign_esc_fn	;nope
                         3746   ; convert to index into the function dispatch table
     4C8D   69 D1        3747   	adc #highest_old_fn_tk-lowest_esc_fn_tk-1
     4C8F   D0 CB        3748   	bne fingo		;always
                         3749   
                         3750   
     4C91                3751   foreign_esc_fn
     4C91   38           3752   	sec			;flag 'up for grabs'
     4C92   20 4C9A      3753   	jsr go_foreign_esc_fn
     4C95                3754   n_esc_fn_vec
     4C95   B0 09        3755   	bcs snerr6		;it's unwanted. off to the refuse pile
     4C97   4C 7877      3756   	jmp chknum
                         3757   
     4C9A                3758   go_foreign_esc_fn
     4C9A   6C 02FC      3759   	jmp (esc_fn_vec)
                         3760   
     4C9D   4C 99C1      3761   instgo	jmp instr
                         3762   
     4CA0   4C 7A09      3763   snerr6	jmp snerr

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 55
Function Handler   FUNCTIONS.SRC

Error Addr  Code          Seq   Source statement

                         3765   
     4CA3   A0 FF        3766   orop	ldy #255	;must always complement.
     4CA5   2C           3767   	.byte $2c	;skip two instructions.
     4CA6   A0 00        3768   andop	ldy #0
     4CA8   84 0D        3769   	sty count	;operator.
     4CAA   20 84B4      3770   	jsr ayint	;(facmo&lo)=int value and check size.
     4CAD   A5 66        3771   	lda facmo	;use demorgan's law on high.
     4CAF   45 0D        3772   	eor count
     4CB1   85 09        3773   	sta integr
     4CB3   A5 67        3774   	lda faclo	;and low.
     4CB5   45 0D        3775   	eor count
     4CB7   85 0A        3776   	sta integr+1
     4CB9   20 8C28      3777   	jsr movfa
     4CBC   20 84B4      3778   	jsr ayint	;(facmo&lo)=int of arg.
     4CBF   A5 67        3779   	lda faclo
     4CC1   45 0D        3780   	eor count
     4CC3   25 0A        3781   	and integr+1
     4CC5   45 0D        3782   	eor count	;finish out demorgan.
     4CC7   A8           3783   	tay		;save high.
     4CC8   A5 66        3784   	lda facmo
     4CCA   45 0D        3785   	eor count
     4CCC   25 09        3786   	and integr
     4CCE   45 0D        3787   	eor count
     4CD0   4C 79D9      3788   	jmp givayf	;float 9a,y) and ret to user.
                         3789   			;
                         3790   			;time to perform a relational operator.
                         3791   			;(domask) contains the bits as to which relational
                         3792   			;operator it was. carry bit on=string compare.
                         3793   			;
                         3794   
                         3795   
     4CD3                3796   dorel
     4CD3   20 787B      3797   	jsr chkval	;check for match.
     4CD6   B0 13        3798   	bcs strcmp	;is it a string?
     4CD8   A5 6F        3799   	lda argsgn	;pack argument for fcomp.
     4CDA   09 7F        3800   	ora #$7f
     4CDC   25 6B        3801   	and argho
     4CDE   85 6B        3802   	sta argho
     4CE0   A9 6A        3803   	lda #<argexp
     4CE2   A0 00        3804   	ldy #>argexp
     4CE4   20 8C87      3805   	jsr fcomp
     4CE7   AA           3806   	tax
     4CE8   4C 4D1E      3807   	jmp qcomp
                         3808   
                         3809   
                         3810   
     4CEB                3811   strcmp
     4CEB   A9 00        3812   	lda #0
     4CED   85 0F        3813   	sta valtyp
     4CEF   C6 4F        3814   	dec opmask
     4CF1   20 8781      3815   	jsr frefac	;free the faclo string.
     4CF4   85 63        3816   	sta dsctmp	;save it for later.
     4CF6   86 64        3817   	stx dsctmp+1
     4CF8   84 65        3818   	sty dsctmp+2
     4CFA   A5 6D        3819   	lda argmo	;get pointer to other string.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 55-1
Function Handler   FUNCTIONS.SRC

Error Addr  Code          Seq   Source statement

     4CFC   A4 6E        3820   	ldy argmo+1
     4CFE   20 8785      3821   	jsr fretmp	;frees first desc pointer.
     4D01   86 6D        3822   	stx argmo
     4D03   84 6E        3823   	sty argmo+1
     4D05   AA           3824   	tax		;copy count into x.
     4D06   38           3825   	sec
     4D07   E5 63        3826   	sbc dsctmp	;which is greater. if 0, all set up.
     4D09   F0 08        3827   	beq stasgn	;just put sign of difference away.
     4D0B   A9 01        3828   	lda #1
     4D0D   90 04        3829   	bcc stasgn	;sign is positive.
     4D0F   A6 63        3830   	ldx dsctmp	;length of fac is shorter.
     4D11   A9 FF        3831   	lda #$ff	;get a minus one for negatives.
     4D13   85 68        3832   stasgn	sta facsgn	;keep for later.
     4D15   A0 FF        3833   	ldy #255	;set pointer to first string. (arg).
     4D17   E8           3834   	inx		;to loop properly.
     4D18   C8           3835   nxtcmp	iny
     4D19   CA           3836   	dex		;any characters left to compare?
     4D1A   D0 07        3837   	bne getcmp	;not done yet.
     4D1C   A6 68        3838   	ldx facsgn	;use sign of length difference.
                         3839   			;since all characters are the same.
     4D1E   30 1B        3840   qcomp	bmi docmp	;c is always set then.
     4D20   18           3841   	clc
     4D21   90 18        3842   	bcc docmp	;always branch.
                         3843   
                         3844   
     4D23   A9 6D        3845   getcmp	lda #argmo
     4D25   20 03AB      3846   	jsr indsub_ram1	;(argmo),y
     4D28   48           3847   	pha
     4D29   A9 64        3848   	lda #dsctmp+1
     4D2B   20 03AB      3849   	jsr indsub_ram1	;(dsctmp+1),y
     4D2E   85 79        3850   	sta syntmp
     4D30   68           3851   	pla
     4D31   C5 79        3852   	cmp syntmp
     4D33   F0 E3        3853   	beq nxtcmp
     4D35   A2 FF        3854   	ldx #$ff
     4D37   B0 02        3855   	bcs docmp
     4D39   A2 01        3856   	ldx #1
                         3857   
                         3858   
                         3859   
     4D3B                3860   docmp
     4D3B   E8           3861   	inx		;-1 to 1, 0 to 2, 1 to 4.
     4D3C   8A           3862   	txa
     4D3D   2A           3863   	rol a
     4D3E   25 14        3864   	and domask
     4D40   F0 02        3865   	beq goflot
     4D42   A9 FF        3866   	lda #$ff	;map 0 to 0. all others to -1.
     4D44                3867   goflot
     4D44   4C 8C68      3868   	jmp float	;float the one-byte result into fac.
                         3869   ;.end
                         3870   	.include code0

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 56
'code0'   CODE0.SRC

Error Addr  Code          Seq   Source statement

                         3872   	.subttl  'code0'
                         3873   
     4D47   20 9281      3874   reddy	jsr k_primm		;print immediate
     4D4A   0D 52 45     3875   	.byte cr,'READY.',cr,0
     4D4D   41 44 59            
     4D50   2E 0D 00            
     4D53   60           3876   	rts
                         3877   
     4D54   A2 80        3878   ready	ldx #$80
     4D56   2C           3879   	.byte $2c
                         3880   
     4D57   A2 10        3881   omerr	ldx #errom
                         3882   
     4D59   6C 0300      3883   error	jmp (ierror)
     4D5C   8D FF03      3884   nerror	sta sw_rom_ram0		;bank ram 0 in (just in case)
     4D5F   8A           3885   	txa
     4D60   30 72        3886   	bmi readyx
     4D62   8E 1208      3887   	stx errnum		;save error # for 'er'
     4D65   24 7F        3888   	bit runmod		;direct mode?
     4D67   10 30        3889   	bpl errisd		;yes...always display error text
                         3890   
     4D69   A0 01        3891   	ldy #1			;copy curlin to errlin, oldtxt to errtxt
     4D6B   B9 003B      3892   1$	lda curlin,y
     4D6E   99 1209      3893   	sta errlin,y
     4D71   B9 1202      3894   	lda oldtxt,y
     4D74   99 120E      3895   	sta errtxt,y
     4D77   88           3896   	dey
     4D78   10 F1        3897   	bpl 1$
                         3898   
     4D7A   AC 120C      3899   	ldy trapno+1    	;is trap set?
     4D7D   C8           3900   	iny
     4D7E   F0 19        3901   	beq errisd		;no.
     4D80   88           3902   	dey			;restore msb of line #
     4D81   84 17        3903   	sty linnum+1
     4D83   8C 120D      3904   	sty tmptrp		;save until a resume is executed
     4D86   AC 120B      3905   	ldy trapno
     4D89   84 16        3906   	sty linnum
                         3907   
     4D8B   A2 FF        3908   	ldx #$ff
     4D8D   8E 120C      3909   	stx trapno+1    	;flag no more traps
     4D90   A6 82        3910   	ldx oldstk
     4D92   9A           3911   	txs
     4D93   20 5A18      3912   	jsr luk4it
     4D96   4C 4B13      3913   	jmp newstt
     4D99                3914   errisd
     4D99   CA           3915   	dex
     4D9A   8A           3916   	txa
     4D9B   20 4A9F      3917   	jsr erstup		;set up address of error msg in .a in index2
     4D9E   20 926F      3918   	jsr k_clrch
     4DA1   A9 00        3919   	lda #0
     4DA3   85 15        3920   	sta channl
     4DA5   24 D7        3921   	bit _mode		;are we in 80 col?
     4DA7   30 02        3922   	bmi 10$			;yes, don't reset graphics mode
     4DA9   85 D8        3923   	sta _graphm		;make sure we're in text mode
                         3924   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 56-1
'code0'   CODE0.SRC

Error Addr  Code          Seq   Source statement

     4DAB   20 55B5      3925   10$	jsr crdo
     4DAE   20 5627      3926   	jsr outqst
     4DB1   A0 00        3927   	ldy #0
                         3928   
     4DB3   B1 26        3929   geterr	lda (index2),y  	;ind.ok
     4DB5   48           3930   	pha
     4DB6   29 7F        3931   	and #127
     4DB8   20 5629      3932   	jsr outdo
     4DBB   C8           3933   	iny
     4DBC   68           3934   	pla
     4DBD   10 F4        3935   	bpl geterr
                         3936   
     4DBF   20 5255      3937   	jsr stkini
     4DC2   20 9281      3938   	jsr k_primm
     4DC5   20 45 52     3939   	.byte   ' ERROR',0
     4DC8   52 4F 52            
     4DCB   00                  
                         3940   
     4DCC   A4 3C        3941   errfin	ldy curlin+1		;direct mode?
     4DCE   C8           3942   	iny
     4DCF   F0 03        3943   	beq readyx		;yes...no line #
     4DD1   20 8E26      3944   	jsr inprt
                         3945   
                         3946   
                         3947   
                         3948   
     4DD4   20 4D47      3949   readyx	jsr reddy		;print 'ready'
     4DD7   A9 80        3950   	lda #$80
     4DD9   20 FF90      3951   	jsr _setmsg		;turn kernal messages on
     4DDC   A9 00        3952   	lda #0
     4DDE   85 7F        3953   	sta runmod		;turn run mode off
                         3954   
                         3955   
                         3956   
     4DE0   6C 0302      3957   main	jmp (imain)
     4DE3   A2 FF        3958   nmain	ldx #$ff
     4DE5   86 3C        3959   	stx curlin+1
     4DE7   20 4FB0      3960   	jsr inlin		;get a line from terminal
     4DEA                3961   execute_a_line
     4DEA   86 3D        3962   	stx txtptr		;txtptr is ptr to index buffer
     4DEC   84 3E        3963   	sty txtptr+1
     4DEE   20 0380      3964   	jsr chrget
     4DF1   AA           3965   	tax
                         3966   
     4DF2   F0 EC        3967   main00	beq main		;if end of line
     4DF4   90 09        3968   	bcc main1		;if line number
     4DF6   20 4327      3969   	jsr crunch
     4DF9   20 0386      3970   	jsr chrgot		;get command
     4DFC   4C 4B10      3971   	jmp xeqdir		;execute command
                         3972   
                         3973   
                         3974   
     4DFF                3975   main1
     4DFF   20 50BD      3976   	jsr linget		;read line # into linnum
     4E02   20 4327      3977   	jsr crunch

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 56-2
'code0'   CODE0.SRC

Error Addr  Code          Seq   Source statement

     4E05   84 0D        3978   	sty count		;retain char count
     4E07   20 5081      3979   	jsr fndlin
     4E0A   90 7B        3980   	bcc nodel		;no match, so don't delete
                         3981   
                         3982   ; test : if new line is longer than the line it replaces,
                         3983   ;	 then if there isn't enough room in memory to add this new line,
                         3984   ;		then out-of-memory error
                         3985   ;
                         3986   ; before this fix, the old line was deleted BEFORE testing if the new line fit
                         3987   ;
                         3988   ;N.B.: I am assuming that lines cannot be greater than 255 chars, as is the
                         3989   ; case where the line was entered 'normally', that is, using LINGET, The only
                         3990   ; consequence of this assumption is that lines > 255 will fall prey to the
                         3991   ; pre-fix problem mentioned above.
                         3992   
     4E0C   A0 00        3993   	ldy #0
     4E0E   20 4309      3994   	jsr indlow		;get lsb of the next lines starting address
     4E11   38           3995   	sec
     4E12   E5 61        3996   	sbc lowtr		;subtract lsb of this lines starting address
     4E14   38           3997   	sec			;ignore borrow (gives abs. value)
     4E15   E9 04        3998   	sbc #4			;allow for link & line number
     4E17   E5 0D        3999   	sbc count		;compare with new length
     4E19   B0 1C        4000   	bcs 3$			;new line is shorter, no problem.
     4E1B   49 FF        4001   	eor #$ff
     4E1D   69 01        4002   	adc #1			;convert to positive delta (.c=0)
                         4003   
     4E1F   AC 1211      4004   	ldy text_top+1		;get msb of end of text
     4E22   6D 1210      4005   	adc text_top		;add our calculated delta to end of text
     4E25   90 01        4006   	bcc 1$
     4E27   C8           4007   	iny
     4E28   CC 1213      4008   1$	cpy max_mem_0+1
     4E2B   90 0A        4009   	bcc 3$			;result is less than top-of-memory : ok
     4E2D   D0 05        4010   	bne 2$			;oops, overflow. too bad.
     4E2F   CD 1212      4011   	cmp max_mem_0		;msb's the same, test lsb's
     4E32   90 03        4012   	bcc 3$			;ok if lsb is less than top,
     4E34   4C 4D57      4013   2$	jmp omerr		;..else an error
                         4014   
                         4015   
     4E37   A0 01        4016   3$	ldy #1
     4E39   20 4309      4017   	jsr indlow
     4E3C   85 25        4018   	sta index1+1
     4E3E   AD 1210      4019   	lda text_top		;text end
     4E41   85 24        4020   	sta index1
     4E43   A5 62        4021   	lda lowtr+1     	;set xfer to
     4E45   85 27        4022   	sta index2+1
     4E47   88           4023   	dey
     4E48   20 4309      4024   	jsr indlow		;compute length
     4E4B   18           4025   	clc
     4E4C   E5 61        4026   	sbc lowtr
     4E4E   49 FF        4027   	eor #$ff		;make it negative
     4E50   18           4028   	clc
     4E51   6D 1210      4029   	adc text_top		;compute new text end
     4E54   8D 1210      4030   	sta text_top
     4E57   85 26        4031   	sta index2		;set low of xfer to
     4E59   AD 1211      4032   	lda text_top+1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 56-3
'code0'   CODE0.SRC

Error Addr  Code          Seq   Source statement

     4E5C   69 FF        4033   	adc #255
     4E5E   8D 1211      4034   	sta text_top+1		;compute high of text end
     4E61   E5 62        4035   	sbc lowtr+1     	;compute # of blocks to move
     4E63   AA           4036   	tax
     4E64   38           4037   	sec
     4E65   A5 61        4038   	lda lowtr
     4E67   ED 1210      4039   	sbc text_top		;compute offset
     4E6A   A8           4040   	tay
     4E6B   B0 03        4041   	bcs qdect1		;if text_top <= lowtr
     4E6D   E8           4042   	inx			;dec due to carry and
     4E6E   C6 27        4043   	dec index2+1    	;dec store so carry works
     4E70                4044   qdect1
     4E70   18           4045   	clc
     4E71   65 24        4046   	adc index1
     4E73   90 03        4047   	bcc 10$
     4E75   C6 25        4048   	dec index1+1
     4E77   18           4049   	clc
                         4050   
     4E78   20 4322      4051   10$	jsr indin1
     4E7B   91 26        4052   	sta (index2),y
     4E7D   C8           4053   	iny
     4E7E   D0 F8        4054   	bne 10$
     4E80   E6 25        4055   	inc index1+1
     4E82   E6 27        4056   	inc index2+1
     4E84   CA           4057   	dex
     4E85   D0 F1        4058   	bne 10$
                         4059   
     4E87   20 5255      4060   nodel	jsr stkini		;jsr clearc removed since changes to text no longer
     4E8A   20 4F6C      4061   	jsr lnkprg
     4E8D   A0 00        4062   	ldy #0			;..require trashing variables
     4E8F   B1 3D        4063   	lda (txtptr),y		;delete line?
     4E91   D0 03        4064   	bne 5$
     4E93   4C 4DF2      4065   	jmp main00
                         4066   
     4E96   18           4067   5$	clc			;no...something to insert
     4E97   AD 1210      4068   	lda text_top
     4E9A   AC 1211      4069   	ldy text_top+1
     4E9D   85 5C        4070   	sta hightr
     4E9F   84 5D        4071   	sty hightr+1    	;top of block to move
                         4072   
     4EA1   65 0D        4073   	adc count		;length of characters in line
     4EA3   90 01        4074   	bcc 1$
     4EA5   C8           4075   	iny
     4EA6   18           4076   1$	clc
     4EA7   69 04        4077   	adc #4			;plus link and line #
     4EA9   90 01        4078   	bcc 2$
     4EAB   C8           4079   	iny
     4EAC   85 5A        4080   2$	sta highds		;destination of top
     4EAE   84 5B        4081   	sty highds+1
                         4082   
                         4083   ; low block address is lowtr
                         4084   ; where it was left in the call to fndlin
                         4085   ;
     4EB0   CC 1213      4086   	cpy max_mem_0+1		;make sure new top doesn't crash into top of available ram
     4EB3   90 0A        4087   	bcc 4$			;ok

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 56-4
'code0'   CODE0.SRC

Error Addr  Code          Seq   Source statement

     4EB5   D0 05        4088   	bne 3$			;out of memory
     4EB7   CD 1212      4089   	cmp max_mem_0
     4EBA   90 03        4090   	bcc 4$			;ok
     4EBC   4C 4D57      4091   3$	jmp omerr		;out of memory
                         4092   
     4EBF   8D 1210      4093   4$	sta text_top		;new top of text
     4EC2   8C 1211      4094   	sty text_top+1
                         4095   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 57
'code0'   CODE0.SRC

Error Addr  Code          Seq   Source statement

                         4097   ; Move text up to make room for an insertion.
                         4098   ;
                         4099   ; our story so far...
                         4100   ;
                         4101   ; (highds)= destination of (high address).
                         4102   ; (lowtr)= lowest addr to be transferred.
                         4103   ; (hightr)= highest addr to be transferred.
                         4104   ;
     4EC5   38           4105   	sec			;prepare to subtract.
     4EC6   A5 5C        4106   	lda hightr
     4EC8   E5 61        4107   	sbc lowtr		;compute number of things to move.
     4ECA   85 24        4108   	sta index		;save it for later.	
     4ECC   A8           4109   	tay
     4ECD   A5 5D        4110   	lda hightr+1
     4ECF   E5 62        4111   	sbc lowtr+1
     4ED1   AA           4112   	tax			;put it in a counter register.
     4ED2   E8           4113   	inx 			;so that counter algorithm works.
     4ED3   98           4114   	tya			;see if low part of count is zero.
     4ED4   F0 25        4115   	beq 60$			;yes, go start moving blocks.
     4ED6   A5 5C        4116   	lda hightr		;no, must modify base address.
     4ED8   38           4117   	sec
     4ED9   E5 24        4118   	sbc index		;borrow if off since (hightr) > (lowtr).
     4EDB   85 5C        4119   	sta hightr		;save modified abse address.
     4EDD   B0 03        4120   	bcs 30$			;if no borrow, go shove it.
     4EDF   C6 5D        4121   	dec hightr+1		;borrow implies sub 1 from high order.
     4EE1   38           4122   	sec
                         4123   
     4EE2   A5 5A        4124   30$	lda highds		;mod base of dest addr.
     4EE4   E5 24        4125   	sbc index
     4EE6   85 5A        4126   	sta highds
     4EE8   B0 09        4127   	bcs 50$			;no borrow.
     4EEA   C6 5B        4128   	dec highds+1		;decrement high order byte
     4EEC   90 05        4129   	bcc 50$			;always skip
                         4130   
     4EEE   20 42FA      4131   40$	jsr indhtr		;lda (hightr),y
     4EF1   91 5A        4132   	sta (highds),y
                         4133   
     4EF3   88           4134   50$	dey
     4EF4   D0 F8        4135   	bne 40$
     4EF6   20 42FA      4136   	jsr indhtr		;lda (hightr),y
     4EF9   91 5A        4137   	sta (highds),y
                         4138   
     4EFB   C6 5D        4139   60$	dec hightr+1
     4EFD   C6 5B        4140   	dec highds+1		;start on new blocks.
     4EFF   CA           4141   	dex
     4F00   D0 F1        4142   	bne 50$
                         4143   
                         4144   ;
                         4145   ; make links non-null to fool chead
                         4146   ;
     4F02   A0 00        4147   	ldy #0
     4F04   A9 01        4148   	lda #1
     4F06   91 61        4149   	sta (lowtr),y
     4F08   C8           4150   	iny			;y=1
     4F09   91 61        4151   	sta (lowtr),y

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 57-1
'code0'   CODE0.SRC

Error Addr  Code          Seq   Source statement

                         4152   ;
                         4153   ; put line number in text
                         4154   ;
     4F0B   C8           4155   	iny			;y=2
     4F0C   A5 16        4156   	lda linnum
     4F0E   91 61        4157   	sta (lowtr),y
     4F10   A5 17        4158   	lda linnum+1
     4F12   C8           4159   	iny			;y=3
     4F13   91 61        4160   	sta (lowtr),y
                         4161   ;
                         4162   ; advance lowtr to start of line
                         4163   ;
     4F15   18           4164   	clc
     4F16   A5 61        4165   	lda lowtr
     4F18   69 04        4166   	adc #4
     4F1A   85 61        4167   	sta lowtr
     4F1C   90 02        4168   	bcc 80$
     4F1E   E6 62        4169   	inc lowtr+1
                         4170   
                         4171   ;
                         4172   ; block move line to text
                         4173   ;
     4F20   A4 0D        4174   80$	ldy count
     4F22   88           4175   	dey
                         4176   
     4F23   B1 3D        4177   90$	lda (txtptr),y
     4F25   91 61        4178   	sta (lowtr),y
     4F27   88           4179   	dey
     4F28   C0 FF        4180   	cpy #$ff
     4F2A   D0 F7        4181   	bne 90$
     4F2C   20 4F6C      4182   	jsr lnkprg
     4F2F   20 5271      4183   	jsr stxtpt		;set up txtptr (was jsr runc)
                         4184   
                         4185   ; test if auto in effect
                         4186   
     4F32   A5 74        4187   	lda autinc		;if in auto mode, increment val <> 0
     4F34   05 75        4188   	ora autinc+1
     4F36   F0 31        4189   	beq gomain		;not in
                         4190   	
     4F38   A5 16        4191   	lda linnum		;yes, construct new line number
     4F3A   18           4192   	clc
     4F3B   65 74        4193   	adc autinc
     4F3D   85 65        4194   	sta facho+1
     4F3F   A5 17        4195   	lda linnum+1
     4F41   65 75        4196   	adc autinc+1
     4F43   B0 24        4197   	bcs gomain		;no auto if wrapped
     4F45   C9 FA        4198   	cmp #$fa		;test if # >= 64000
     4F47   B0 20        4199   	bcs gomain		;no auto if so.
     4F49   85 64        4200   	sta facho
     4F4B   A2 90        4201   	ldx #$90
     4F4D   38           4202   	sec
     4F4E   20 8C75      4203   	jsr floatc		;float it
     4F51   20 8E42      4204   	jsr fout		;make it into a string
                         4205   	
     4F54   A2 00        4206   	ldx #0			;move string into kbd buffer

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 57-2
'code0'   CODE0.SRC

Error Addr  Code          Seq   Source statement

     4F56                4207   aline1
     4F56   BD 0101      4208   	lda $101,x		;copy number formed into buffer, ignoring leading space
     4F59   F0 06        4209   	beq aline2		;a null marks end
     4F5B   9D 034A      4210   	sta _keyd,x
     4F5E   E8           4211   	inx
     4F5F   D0 F5        4212   	bne aline1		;always
                         4213   	
                         4214   
     4F61                4215   aline2
     4F61   A9 1D        4216   	lda #29			;cursor right
     4F63   9D 034A      4217   	sta _keyd,x
     4F66   E8           4218   	inx
     4F67   86 D0        4219   	stx _ndx
     4F69                4220   gomain
     4F69   4C 4DE0      4221   	jmp main
                         4222   	
                         4223   
                         4224   
     4F6C                4225   lnkprg
     4F6C   A5 2D        4226   	lda txttab
     4F6E   A4 2E        4227   	ldy txttab+1
     4F70   85 24        4228   	sta index
     4F72   84 25        4229   	sty index+1
     4F74   18           4230   	clc 
     4F75                4231   chead
     4F75   A0 00        4232   	ldy #0
     4F77   20 4322      4233   	jsr indin1		;lda (index),y .. check for null link
     4F7A   D0 06        4234   	bne 1$
     4F7C   C8           4235   	iny
     4F7D   20 4322      4236   	jsr indin1		;lda (index),y
     4F80   F0 2D        4237   	beq lnkrts
                         4238   
     4F82   A0 04        4239   1$	ldy #4
     4F84   C8           4240   2$	iny
     4F85   20 4322      4241   	jsr indin1		;lda (index),y
     4F88   D0 FA        4242   	bne 2$
     4F8A   C8           4243   	iny
     4F8B   98           4244   	tya
     4F8C   65 24        4245   	adc index
     4F8E   AA           4246   	tax
     4F8F   A0 00        4247   	ldy #0
     4F91   91 24        4248   	sta (index),y
     4F93   98           4249   	tya
     4F94   65 25        4250   	adc index+1
     4F96   C8           4251   	iny
     4F97   91 24        4252   	sta (index),y
     4F99   86 24        4253   	stx index
     4F9B   85 25        4254   	sta index+1
     4F9D   90 D6        4255   	bcc chead		;always
                         4256   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 58
'code0'   CODE0.SRC

Error Addr  Code          Seq   Source statement

                         4258   
     4F9F   18           4259   fixlnk	clc
     4FA0   A5 24        4260   	lda index		;set pointer to end of text
     4FA2   A4 25        4261   	ldy index+1     	;(called only when allocating or deallocating bit maps)
     4FA4   69 02        4262   	adc #2
     4FA6   90 01        4263   	bcc *+3
     4FA8   C8           4264   	iny
     4FA9   8D 1210      4265   	sta text_top
     4FAC   8C 1211      4266   	sty text_top+1
     4FAF                4267   lnkrts
     4FAF   60           4268   	rts
                         4269   
                         4270   
                         4271   ;
                         4272   ; function to get a line one character at a time from the input
                         4273   ; channel and build it in the input buffer.
                         4274   ;
                         4275   
     4FB0   A2 00        4276   inlin	ldx #0
     4FB2   20 90E5      4277   1$	jsr inchr
     4FB5   C9 0D        4278   	cmp #cr			;a carriage return?
     4FB7   D0 03        4279   	bne 2$
     4FB9   4C 55A8      4280   	jmp fininl		;yes...done build
     4FBC   9D 0200      4281   2$	sta buf,x		;put it away
     4FBF   E8           4282   	inx
     4FC0   E0 A1        4283   	cpx #buflen     	;max character line?
     4FC2   90 EE        4284   	bcc 1$			;no...o.k.
     4FC4   4C A5FD      4285   	jmp errlen		;'too long' error
                         4286   
                         4287   ;.end
                         4288   	.include rtstack

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 59
Run-Time Stack Routines   RTSTACK.SRC

Error Addr  Code          Seq   Source statement

                         4290   	.subttl Run-Time Stack Routines
                         4291   
                         4292   ; find a specific token in the run-time stack. token to be found is
                         4293   ; in srchtk.
                         4294   ;
                         4295   ; if called by 'for' or 'next', scan entries in stack, looking for
                         4296   ; a specific 'for-variable' (in (forpnt)). if found, (fndpnt) will
                         4297   ; point to it, and z is set. otherwise, (fndpnt) will point to
                         4298   ; either :
                         4299   ;           1) the non-for token
                         4300   ;           2) bottom-of-stack
                         4301   ;
                         4302   ; special case : 'next' with no argument will match first 'for'
                         4303   ; entry on stack found, if any. this case is signaled by a (forpnt)
                         4304   ; with a msb of $ff (an impossible value).
                         4305   ;
                         4306   ; all other calls to search will result in either
                         4307   ;           1) (success) z = 1, (fndpnt) = address
                         4308   ;           2) (failure) z = 0
                         4309   
                         4310   
                         4311   
                         4312   ;
                         4313   ; set up temporary pointer with current top of stack
                         4314   ;
     4FC7   85 02        4315   search	sta srchtk	;save token to search for
     4FC9   20 5064      4316   	jsr movtos	;tos => fndpnt
                         4317   ;
                         4318   ; test if pointer at bottom of stack. if so, item not found.
                         4319   ;
     4FCC   A5 3F        4320   srch05	lda fndpnt
     4FCE   C9 FF        4321   	cmp #<stkbot
     4FD0   D0 06        4322   	bne srch10	;(fndpnt) <> bottom, ok
     4FD2   A5 40        4323   	lda fndpnt+1    ;lsb's the same, test msb's
     4FD4   C9 09        4324   	cmp #>stkbot
     4FD6   F0 40        4325   	beq srch98	;stack empty, rts
                         4326   
     4FD8   8D FF03      4327   srch10	sta sw_rom_ram0	;make sure we're not talking apples & oranges
     4FDB   A0 00        4328   	ldy #0
     4FDD   A5 02        4329   	lda srchtk	;what are we looking for?
     4FDF   C9 81        4330   	cmp #fortk	;'for' tokens are special cases
     4FE1   D0 1B        4331   	bne srch20
                         4332   
                         4333   ; looking for a 'for' token. if next token examined is not a 'for' token,
                         4334   ; return with z = 0. otherwise, check the pointer to it's 'for' variable.
                         4335   ; If the variable pointer = (forpnt), or if (forpnt) = ffxx, return with z = 1. 
                         4336   ; Otherwise, set up x with length of a 'for' entry, and use the usual
                         4337   ; mechanisim for examining the next entry.
                         4338   
     4FE3   D1 3F        4339   	cmp (fndpnt),y
     4FE5   D0 33        4340   	bne srch99	;not 'for', do rts with z = 0
     4FE7   A0 02        4341   	ldy #2		;point to msb of 'for' variable
     4FE9   A5 4C        4342   	lda forpnt+1
     4FEB   C9 FF        4343   	cmp #$ff
     4FED   F0 2B        4344   	beq srch99	;do rts with z = 1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 59-1
Run-Time Stack Routines   RTSTACK.SRC

Error Addr  Code          Seq   Source statement

     4FEF   D1 3F        4345   	cmp (fndpnt),y
     4FF1   D0 07        4346   	bne srch15	;not right variable, keep looking.
     4FF3   88           4347   	dey
     4FF4   A5 4B        4348   	lda forpnt	;test lsb
     4FF6   D1 3F        4349   	cmp (fndpnt),y
     4FF8   F0 20        4350   	beq srch99	;a hit! rts with z = 1
                         4351   
     4FFA   A2 12        4352   srch15	ldx #lenfor
     4FFC   D0 0E        4353   	bne srch30	;keep looking.
                         4354   
     4FFE   B1 3F        4355   srch20	lda (fndpnt),y
     5000   C5 02        4356   	cmp srchtk	;is this the correct type of entry?
     5002   F0 16        4357   	beq srch99	;rts with z = 1
                         4358   
                         4359   ; the entry on top of the run-time stack is not the entry we are looking for.
                         4360   ; Find out what is there, and advance temp. pointer past it.
                         4361   
     5004   A2 12        4362   	ldx #lenfor     ;is it a 'for' entry?
     5006   C9 81        4363   	cmp #fortk
     5008   F0 02        4364   	beq srch30
     500A   A2 05        4365   	ldx #5		;must be gosub or do by default
                         4366   
     500C   8A           4367   srch30	txa
     500D   18           4368   	clc
     500E   65 3F        4369   	adc fndpnt
     5010   85 3F        4370   	sta fndpnt
     5012   90 B8        4371   	bcc srch05
     5014   E6 40        4372   	inc fndpnt+1
     5016   D0 B4        4373   	bne srch05	;always
                         4374   
     5018   A0 01        4375   srch98	ldy #1		;clear z flag
     501A   60           4376   srch99	rts
                         4377   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 60
Run-Time Stack Routines   RTSTACK.SRC

Error Addr  Code          Seq   Source statement

                         4379   ;
                         4380   ; getstk routine
                         4381   ;
                         4382   ; add (.A) elements to top of run-time stack. error if result exceeds tos.
                         4383   
     501B   49 FF        4384   getstk	eor #$ff	;make value 2's comp.
     501D   38           4385   	sec
     501E   65 7D        4386   	adc tos
     5020   85 7D        4387   	sta tos
     5022   A4 7E        4388   	ldy tos+1
     5024   B0 01        4389   	bcs 10$
     5026   88           4390   	dey
     5027   84 7E        4391   10$	sty tos+1
     5029   C0 08        4392   	cpy #>stktop
     502B   90 34        4393   	bcc gomerr
     502D   D0 04        4394   	bne 20$
     502F   C5 7D        4395   	cmp tos
     5031   90 2E        4396   	bcc gomerr
     5033   60           4397   20$	rts

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 61
Run-Time Stack Routines   RTSTACK.SRC

Error Addr  Code          Seq   Source statement

                         4399   ;
                         4400   ;(a,y) is a certain address. "reason" makes sure it is less than (fretop).
                         4401   ;
     5034   C4 36        4402   reason	cpy fretop+1
     5036   90 28        4403   	bcc 4$
     5038   D0 04        4404   	bne 1$		;go garbage collect.
     503A   C5 35        4405   	cmp fretop
     503C   90 22        4406   	bcc 4$
                         4407   
     503E   48           4408   1$	pha
     503F   A2 09        4409   	ldx #9		;if tempf2 has zero in between.
     5041   98           4410   	tya
                         4411   
     5042   48           4412   2$	pha
     5043   B5 59        4413   	lda highds-1,x	;save highds on stack.
     5045   CA           4414   	dex
     5046   10 FA        4415   	bpl 2$		;put 8 of them on stack.
     5048   20 92EA      4416   	jsr garba2	;go garbage collect.
     504B   A2 F7        4417   	ldx #$f7
                         4418   
     504D   68           4419   3$	pla
     504E   95 63        4420   	sta highds+9,x	;restore after garbage collect.
     5050   E8           4421   	inx
     5051   30 FA        4422   	bmi 3$
     5053   68           4423   	pla
     5054   A8           4424   	tay
     5055   68           4425   	pla		;restore a and y.
     5056   C4 36        4426   	cpy fretop+1	;compare highs.
     5058   90 06        4427   	bcc 4$
     505A   D0 05        4428   	bne gomerr	;higher is bad.
     505C   C5 35        4429   	cmp fretop	;compare the lows.
     505E   B0 01        4430   	bcs gomerr
     5060   60           4431   4$	rts
                         4432   
     5061   4C 4D57      4433   gomerr	jmp omerr
                         4434   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 62
Run-Time Stack Routines   RTSTACK.SRC

Error Addr  Code          Seq   Source statement

                         4436   
                         4437   ;  utilities involved in the run-time stack.
                         4438   
                         4439   
                         4440   ; move top-of-stack pointer to (fndpnt)
                         4441   
     5064   A5 7D        4442   movtos	lda tos
     5066   85 3F        4443   	sta fndpnt
     5068   A5 7E        4444   	lda tos+1
     506A   85 40        4445   	sta fndpnt+1
     506C   60           4446   	rts
                         4447   
                         4448   
                         4449   
                         4450   ; move (fndpnt) to (tos)
                         4451   
     506D   A5 3F        4452   movfnd	lda fndpnt
     506F   85 7D        4453   	sta tos
     5071   A5 40        4454   	lda fndpnt+1
     5073   85 7E        4455   	sta tos+1
     5075   60           4456   	rts
                         4457   
                         4458   ; reduce size of run-time stack by (y). no error checking performed!
                         4459   
     5076   98           4460   rlsstk	tya
     5077   18           4461   	clc
     5078   65 7D        4462   	adc tos
     507A   85 7D        4463   	sta tos
     507C   90 02        4464   	bcc 10$
     507E   E6 7E        4465   	inc tos+1
     5080   60           4466   10$	rts
                         4467   
                         4468   ;.end
                         4469   	.include findline

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 63
Find Line Routine   FINDLINE.SRC

Error Addr  Code          Seq   Source statement

                         4471   	.subttl Find Line Routine
                         4472   
                         4473   ;fndlin routine
                         4474   ;
                         4475   ;fndlin searches the program text for the line whose number is passed in "linnum".
                         4476   ;there are two possible returns
                         4477   ;   1) carry set.
                         4478   ; 	lowtr points to the link field in the line 
                         4479   ;	which is the one searched for.
                         4480   ;
                         4481   ;   2) carry clear.
                         4482   ;	line not found. (lowtr) points to the line in 
                         4483   ;       the program greater than the one sought after.
                         4484   ; 
     5081   A5 2D        4485   fndlin	lda txttab
     5083   A6 2E        4486   	ldx txttab+1	;load up (a,x) with (txttab).
                         4487   
     5085   A0 01        4488   fndlnc	ldy #1
     5087   85 61        4489   	sta lowtr
     5089   86 62        4490   	stx lowtr+1
     508B   20 4309      4491   	jsr indlow	;see if link is zero.
     508E   F0 2B        4492   	beq flinrt
     5090   C8           4493   	iny
     5091   C8           4494   	iny
     5092   20 4309      4495   	jsr indlow
     5095   85 79        4496   	sta syntmp
     5097   A5 17        4497   	lda linnum+1	;compare high orders of line numbers.
     5099   C5 79        4498   	cmp syntmp
     509B   90 1F        4499   	bcc flnrts	;no such line number.
     509D   F0 03        4500   	beq 1$
     509F   88           4501   	dey
     50A0   D0 0E        4502   	bne affrts	;always branch
                         4503   
     50A2   88           4504   1$	dey
     50A3   20 4309      4505   	jsr indlow
     50A6   85 79        4506   	sta syntmp	
     50A8   A5 16        4507   	lda linnum
     50AA   C5 79        4508   	cmp syntmp	;compare low orders.
     50AC   90 0E        4509   	bcc flnrts	;no such number.
     50AE   F0 0C        4510   	beq flnrts	;got it.
                         4511   
     50B0   88           4512   affrts	dey
     50B1   20 4309      4513   	jsr indlow	;fetch link.
     50B4   AA           4514   	tax
     50B5   88           4515   	dey
     50B6   20 4309      4516   	jsr indlow
     50B9   B0 CA        4517   	bcs fndlnc	;always branches
                         4518   
     50BB   18           4519   flinrt	clc		;c may be high
     50BC   60           4520   flnrts	rts		;return to caller
                         4521   
                         4522   ;end
                         4523   	.include lineget

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 64
'lineget subroutine   LINEGET.SRC

Error Addr  Code          Seq   Source statement

                         4525   	.subttl 'lineget subroutine
                         4526   
                         4527   ; linget  reads a line # from the current txtptr position
                         4528   ;	  and stores it in linnum  (valid range is 0-63999).
                         4529   ;
                         4530   ;	  on exit txtptr is pointing to the terminating char
                         4531   ;	  which is in .a with condition codes set.
                         4532   ;	  endchr will be =0 if no digit input, else >0. use it
                         4533   ;	  to distinguish between line # 0 & null input.
                         4534   
     50BD   A2 00        4535   linget	ldx #0
     50BF   86 0A        4536   	stx endchr	;flags line # input
     50C1   86 16        4537   	stx linnum	;init line # to 0
     50C3   86 17        4538   	stx linnum+1
                         4539   
     50C5   B0 37        4540   1$	bcs 4$		;it's not a digit, do rts
     50C7   E6 0A        4541   	inc endchr	;indicate line # input
     50C9   E9 2F        4542   	sbc #$2f	;'0'-1 since c=0
     50CB   85 09        4543   	sta charac	;save for later
     50CD   A5 17        4544   	lda linnum+1
     50CF   85 24        4545   	sta index
     50D1   C9 19        4546   	cmp #25		;line number will be .lt. 64000?
     50D3   90 03        4547   	bcc 2$
     50D5   4C 7A09      4548   	jmp snerr	;..no, syntax error.
     50D8   A5 16        4549   2$	lda linnum
     50DA   0A           4550   	asl a	    	;multiply by 10
     50DB   26 24        4551   	rol index
     50DD   0A           4552   	asl a
     50DE   26 24        4553   	rol index
     50E0   65 16        4554   	adc linnum
     50E2   85 16        4555   	sta linnum
     50E4   A5 24        4556   	lda index
     50E6   65 17        4557   	adc linnum+1
     50E8   85 17        4558   	sta linnum+1
     50EA   06 16        4559   	asl linnum
     50EC   26 17        4560   	rol linnum+1
     50EE   A5 16        4561   	lda linnum
     50F0   65 09        4562   	adc charac	;add in digit
     50F2   85 16        4563   	sta linnum
     50F4   90 02        4564   	bcc 3$
     50F6   E6 17        4565   	inc linnum+1
     50F8   20 0380      4566   3$	jsr chrget
     50FB   4C 50C5      4567   	jmp 1$
                         4568   
     50FE   60           4569   4$	rts
                         4570   ;end
                         4571   	.include list		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 65
LIST Command   LIST.SRC

Error Addr  Code          Seq   Source statement

                         4573   	.subttl LIST Command
                         4574   
     50FF   20 5F18      4575   list	jsr range	;set up line range
                         4576   
     5102   A0 01        4577   1$	ldy #1
     5104   20 4309      4578   	jsr indlow	;get ms byte of line to lists pointer
     5107   D0 06        4579   	bne 2$		;ok if not zero, but..
     5109   88           4580   	dey
     510A   20 4309      4581   	jsr indlow
     510D   F0 2E        4582   	beq gordy2	;..if ls byte is also zero, we're done.
                         4583   
     510F   20 4BD2      4584   2$	jsr is_stop_key_down
     5112   20 55B5      4585   	jsr crdo	;new line
     5115   A0 02        4586   	ldy #2
     5117   20 4309      4587   	jsr indlow	;get ms byte of line number
     511A   AA           4588   	tax
     511B   C8           4589   	iny
     511C   20 4309      4590   	jsr indlow	;get ls byte.
                         4591   
     511F   C5 17        4592   	cmp linnum+1	;test if we are past the last line requested.
     5121   D0 04        4593   	bne 3$
     5123   E4 16        4594   	cpx linnum
     5125   F0 02        4595   	beq 4$
     5127   B0 14        4596   3$	bcs gordy2	;next line is > last line requested, exit.
     5129   20 5140      4597   4$	jsr p1line	;print line #, space, and the line of code.
     512C   A0 00        4598   	ldy #0	   	;move 'pointer to next line' into (lowtr)
     512E   20 4309      4599   	jsr indlow
     5131   AA           4600   	tax
     5132   C8           4601   	iny
     5133   20 4309      4602   	jsr indlow
     5136   86 61        4603   	stx lowtr
     5138   85 62        4604   	sta lowtr+1
     513A   4C 5102      4605   	jmp 1$
                         4606   
     513D   4C 55B5      4607   gordy2	jmp crdo	;jmp ready
                         4608   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 66
LIST Command   LIST.SRC

Error Addr  Code          Seq   Source statement

                         4610   ;******************************************************
                         4611   ; print 1 line of basic.
                         4612   ; entry:
                         4613   ;	x,a contains line number low,high
                         4614   ;	(lowtr) points to begining of line in text
                         4615   ;
                         4616   ;	next-line   line-num  basic.......text  null
                         4617   ;	lo    hi    lo    hi  byte byte...byte   00
                         4618   ;	/|
                         4619   ;    (lowtr)	 acc   x
                         4620   ;
                         4621   ;******************************************************
                         4622   
     5140   A0 03        4623   p1line	ldy #3
     5142   84 4B        4624   	sty lstpnt
     5144   84 11        4625   	sty dores	;reset quote-switch
     5146   20 8E32      4626   	jsr linprt	;print line number
     5149   A9 20        4627   	lda #' '	;print a space
                         4628   
     514B   A4 4B        4629   p1l010	ldy lstpnt
     514D   29 7F        4630   	and #$7f
                         4631   
     514F   20 5629      4632   p1l015	jsr outdo
     5152   C9 22        4633   	cmp #'"'	;if quote character, toggle quote-switch
     5154   D0 06        4634   	bne p1l019
     5156   A5 11        4635   	lda dores
     5158   49 FF        4636   	eor #$ff
     515A   85 11        4637   	sta dores
                         4638   
     515C   C8           4639   p1l019	iny		;point to next character
     515D   F0 DE        4640   	beq gordy2	;failsafe mechanism...basic text was mangled, crash.
     515F   24 55        4641   	bit helper	;called by 'help' or 'list' cmd?
     5161   10 03        4642   	bpl p1l020	;list!
     5163   20 59C9      4643   	jsr helpsb	;help!
                         4644   
     5166   20 4309      4645   p1l020	jsr indlow
     5169   F0 3D        4646   	beq p1lrts	;finished when trailing null is found
     516B   6C 0306      4647   	jmp (iqplop)	;usually points to nqplop
                         4648   
                         4649   
                         4650   
                         4651   
     516E   10 DF        4652   nqplop	bpl p1l015	;not a token, just print character
     5170   C9 FF        4653   	cmp #pi
     5172   F0 DB        4654   	beq p1l015	;pi is >$80, but should be printed 'as is' anyway.
     5174   24 11        4655   	bit dores	;is quote switch on?
     5176   30 D7        4656   	bmi p1l015	;yes, print char 'as is'

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 67
LIST Command   LIST.SRC

Error Addr  Code          Seq   Source statement

                         4658   
                         4659   ;  at this point, we know we're talking token. scan the token text
                         4660   ;  list until the correct text is found, and print that text.
                         4661   
     5178   C9 FE        4662   	cmp #esc_cmd_tk	;is this an escape token?
     517A   F0 2D        4663   	beq print_esc_cmd
     517C   C9 CE        4664   	cmp #esc_fn_tk
     517E   F0 43        4665   	beq print_esc_fn
                         4666   
     5180   AA           4667   	tax		;use the token as index
     5181   84 4B        4668   	sty lstpnt
     5183   A9 44        4669   	lda #>reslst
     5185   A0 34        4670   	ldy #<reslst
                         4671   
     5187   85 25        4672   p1l026	sta index1+1	;set index1 pointing to token text list
     5189   84 24        4673   	sty index1
                         4674   
     518B   A0 00        4675   	ldy #0
     518D                4676   p1l030
     518D   CA           4677   	dex		;is this the correct text?
     518E   10 0F        4678   	bpl p1l070	;yes
     5190                4679   p1l040
     5190   B1 24        4680   	lda (index1),y	;ind.ok
     5192   48           4681   	pha
     5193   E6 24        4682   	inc index1	;else scan till next command text
     5195   D0 02        4683   	bne p1l050
     5197   E6 25        4684   	inc index1+1
     5199                4685   p1l050
     5199   68           4686   	pla
     519A   10 F4        4687   	bpl p1l040	;look for char with msb set (end terminator)
     519C   30 EF        4688   	bmi p1l030	;check next command
                         4689   
     519E                4690   p1l060
     519E   C8           4691   	iny
     519F                4692   p1l070
     519F   B1 24        4693   	lda (index1),y  ;indirect ok.
     51A1   30 A8        4694   	bmi p1l010	;print last chr after masking msb, continue on line.
     51A3   20 5629      4695   	jsr outdo	;print non-terminator character
     51A6   D0 F6        4696   	bne p1l060	;always
                         4697   
     51A8                4698   p1lrts
     51A8   60           4699   	rts
                         4700   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 68
LIST Command   LIST.SRC

Error Addr  Code          Seq   Source statement

                         4702   
                         4703   ; print escape command
                         4704   
     51A9                4705   print_esc_cmd
     51A9   AA           4706   	tax			;save type (cmd) in case it is a foreign esc token
     51AA   C8           4707   	iny
     51AB   20 4309      4708   	jsr indlow		;look at second token
     51AE   F0 9F        4709   	beq p1l015		;..oops, none. print funny character.
     51B0   84 4B        4710   	sty lstpnt
     51B2   C9 02        4711   	cmp #lowest_esc_cmd_tk	;is this one of ours?
     51B4   90 27        4712   	bcc print_foreign_esc	;nope.
     51B6   C9 27        4713   	cmp #highest_esc_cmd_tk+1
     51B8   B0 23        4714   	bcs print_foreign_esc	;nope.
     51BA   69 7E        4715   	adc #$80-lowest_esc_cmd_tk ;make this a pointer p1l will be proud of.
     51BC   AA           4716   	tax
     51BD   A0 26        4717   	ldy #<esc_cmd_lst
     51BF   A9 46        4718   	lda #>esc_cmd_lst
     51C1   D0 C4        4719   	bne p1l026		;always
                         4720   
                         4721   
                         4722   ; print escape function
                         4723   
     51C3                4724   print_esc_fn
     51C3   AA           4725   	tax			;save type (function) in case it is a foreign esc token
     51C4   C8           4726   	iny
     51C5   20 4309      4727   	jsr indlow		;look at second token
     51C8   F0 85        4728   	beq p1l015		;..oops, none. print funny character.
     51CA   84 4B        4729   	sty lstpnt
     51CC   C9 02        4730   	cmp #lowest_esc_fn_tk	;is this one of ours?
     51CE   90 0D        4731   	bcc print_foreign_esc	;nope.
     51D0   C9 0B        4732   	cmp #highest_esc_fn_tk+1
     51D2   B0 09        4733   	bcs print_foreign_esc	;nope.
     51D4   69 7E        4734   	adc #$80-lowest_esc_fn_tk ;make this a pointer p1l will be proud of.
     51D6   AA           4735   	tax
     51D7   A0 E6        4736   	ldy #<esc_fn_lst
     51D9   A9 46        4737   	lda #>esc_fn_lst
     51DB   D0 AA        4738   	bne p1l026		;always

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 69
LIST Command   LIST.SRC

Error Addr  Code          Seq   Source statement

                         4740   ;
                         4741   ; The token to be printed is an escape token which is NOT recognized by BASIC.
                         4742   ; We will jump through the indirect chain and see if anyone claims this token.
                         4743   ;
                         4744   ; At this point:
                         4745   ;	.C = 1 to signal 'unclaimed'
                         4746   ;	.X = type (0==>command, ff==>function)
                         4747   ;	.A = second token character
                         4748   ;
                         4749   ; If anyone claims this token, they should:
                         4750   ;
                         4751   ;	> Clear .C to flag 'taken'
                         4752   ;	> Point (INDEX1) at the string to be printed (with msb of last char set)
                         4753   ;	> Note: string to print MUST be in RAM-0!
                         4754   
     51DD                4755   print_foreign_esc
     51DD   E0 FE        4756   	cpx #esc_cmd_tk
     51DF   D0 03        4757   	bne 1$
     51E1   A2 00        4758   	ldx #0
     51E3   2C           4759   	.byte $2c	;mea culpa
     51E4   A2 FF        4760   1$	ldx #$ff
     51E6   38           4761   	sec
     51E7   6C 030E      4762   	jmp (iescpr)
                         4763   
     51EA   B0 04        4764   nescpr	bcs 10$		;no takers, print a funny graphics character.
     51EC   A0 00        4765   	ldy #0
     51EE   F0 AF        4766   	beq p1l070
                         4767   
                         4768   
     51F0   4C 514F      4769   10$	jmp p1l015
                         4770   
                         4771   ;.end
                         4772   	.include newclr		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 70
NEW / CLEAR Commands   NEWCLR.SRC

Error Addr  Code          Seq   Source statement

                         4774   	.subttl NEW / CLEAR Commands
                         4775   ;
                         4776   ; The "new" command clears the program text as well as variable space.
                         4777   ;
                         4778   
     51F3   F0 01        4779   new	beq scrtch	;make sure there is a terminator.
     51F5   60           4780   	rts		;return in shame.
                         4781   
     51F6   A9 00        4782   scrtch	lda #0		;get a clearer.
     51F8   A8           4783   	tay		;set up index.
     51F9   91 2D        4784   	sta (txttab),y	;clear first link.
     51FB   C8           4785   	iny
     51FC   91 2D        4786   	sta (txttab),y
     51FE   8D 116F      4787   	sta trcflg	;reset trace flag.
     5201   A5 2D        4788   	lda txttab
     5203   18           4789   	clc
     5204   69 02        4790   	adc #2
     5206   8D 1210      4791   	sta text_top	;set up (text_top), the end of text
     5209   A5 2E        4792   	lda txttab+1
     520B   69 00        4793   	adc #0
     520D   8D 1211      4794   	sta text_top+1
                         4795   
     5210   20 5271      4796   runc	jsr stxtpt	;load (txtptr) with (txttab)-1
     5213   A9 00        4797   	lda #0		;fall thru to "CLR"
                         4798   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 71
NEW / CLEAR Commands   NEWCLR.SRC

Error Addr  Code          Seq   Source statement

                         4800   
                         4801   ;clearc routine
                         4802   ;
                         4803   ; Clearc is a subroutine which initializes the variable and array space by
                         4804   ; resetting strend (the end of array storage).It falls into "stkini"
                         4805   ; which resets the stack.
                         4806   
     5215   D0 55        4807   clear	bne stkrts
     5217   20 927B      4808   clearc	jsr k_clall	;close all files
     521A   A0 00        4809   	ldy #0
     521C   84 7A        4810   	sty dsdesc	;flag 'no ds string'
     521E   88           4811   	dey		;y=$ff
     521F   8C 120C      4812   	sty trapno+1    ;flag no current trap line
     5222   8C 1209      4813   	sty errlin	;reset last error pointers
     5225   8C 120A      4814   	sty errlin+1
     5228   8C 1208      4815   	sty errnum
                         4816   
     522B   A5 39        4817   	lda max_mem_1	;clear string space
     522D   A4 3A        4818   	ldy max_mem_1+1
     522F   85 35        4819   	sta fretop
     5231   84 36        4820   	sty fretop+1
                         4821   
     5233   A9 FF        4822   	lda #<stkbot	;empty run-time stack
     5235   A0 09        4823   	ldy #>stkbot
     5237   85 7D        4824   	sta tos
     5239   84 7E        4825   	sty tos+1
                         4826   
     523B   A5 2F        4827   	lda vartab
     523D   A4 30        4828   	ldy vartab+1
     523F   85 31        4829   	sta arytab		;this will delete all variavbles,
     5241   84 32        4830   	sty arytab+1
     5243   85 33        4831   	sta strend		;..and arrays
     5245   84 34        4832   	sty strend+1
                         4833   
     5247   A2 03        4834   	ldx #pumony-puchrs 	;reset print using chars
     5249   BD 526D      4835   1$	lda pudefs,x
     524C   9D 1204      4836   	sta puchrs,x
     524F   CA           4837   	dex
     5250   10 F7        4838   	bpl 1$
                         4839   
     5252   20 5AFE      4840   fload	jsr restore$1		;reset pointer for data statements
                         4841   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 72
NEW / CLEAR Commands   NEWCLR.SRC

Error Addr  Code          Seq   Source statement

                         4843   
                         4844   
                         4845   ; stkini routine
                         4846   
                         4847   ;   stkini resets the stack pointer. string temporaries are freed up,
                         4848   ;   subflg is reset, continuing is prohibited.
                         4849   
     5255   A2 1B        4850   stkini	ldx #tempst	;initialize string temporaries
     5257   86 18        4851   	stx temppt
     5259   68           4852   	pla		;set up return address
     525A   A8           4853   	tay
     525B   68           4854   	pla
     525C   A2 FA        4855   	ldx #stkend-257
     525E   9A           4856   	txs
     525F   48           4857   	pha
     5260   98           4858   	tya
     5261   48           4859   	pha
     5262   A9 00        4860   	lda #0
     5264   8D 1203      4861   	sta oldtxt+1
     5267   85 12        4862   	sta subflg	;allow subscripts
     5269   8D 03DF      4863   	sta bits
     526C   60           4864   stkrts	rts
                         4865   
                         4866   
     526D   20 2C 2E     4867   pudefs .byte ' ,.$'	;default:  fill, comma, dec pnt, money symbol
     5270   24                  
                         4868   
     5271   18           4869   stxtpt	clc
     5272   A5 2D        4870   	lda txttab
     5274   69 FF        4871   	adc #$ff
     5276   85 3D        4872   	sta txtptr
     5278   A5 2E        4873   	lda txttab+1
     527A   69 FF        4874   	adc #$ff
     527C   85 3E        4875   	sta txtptr+1	;set up text pointers
     527E   60           4876   	rts
                         4877   
                         4878   ;.end
                         4879   
                         4880   	.include return		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 73
RETURN command   RETURN.SRC

Error Addr  Code          Seq   Source statement

                         4882   	.subttl RETURN command
                         4883   ;*********************************************************************
                         4884   ; return routine
                         4885   ;
                         4886   ; "return" restores the line number and text pointer from the stack,
                         4887   ; and eliminates all the "for" entries in front of the "gosub" entry.
                         4888   ;
                         4889   ;*********************************************************************
                         4890   
     527F                4891   return
                         4892   
                         4893   ;ok, pay attention: we got here by a pseudo-jsr which left a return to 'newstt'
                         4894   ; on the stack for us to return to. There is also a return to 'newstt' left
                         4895   ; on the stack from the 'gosub' we are returning from. This is true UNLESS we
                         4896   ; got here on a sprite collision, in which case we still have the 'newsub'
                         4897   ; return recently left by our current call, but the second return goes back to
                         4898   ; the trapping mechanism. The bottom line is: we have an extra return address
                         4899   ; on the stack, which we have to get rid of before leaving.
                         4900   
     527F   68           4901   	pla		;mea culpa, mea culpa, mea culpa
     5280   68           4902   	pla
     5281   A9 8D        4903   	lda #gosutk
     5283   20 4FC7      4904   	jsr search	;look for 'gosub' on runtime stack
     5286   F0 05        4905   	beq ret010	;branch if 'gosub' found on stack
     5288   A2 0C        4906   	ldx #errrg	;else error
     528A   4C 4D59      4907   	jmp error
                         4908   
     528D   20 506D      4909   ret010	jsr movfnd	;(fndpnt) => (tos)
     5290   A0 05        4910   	ldy #lengos
     5292   20 5076      4911   	jsr rlsstk	;effectivly pop gosub off run-time stack
                         4912   
     5295   88           4913   	dey
     5296   B1 3F        4914   	lda (fndpnt),y
     5298   85 3E        4915   	sta txtptr+1
     529A   88           4916   	dey
     529B   B1 3F        4917   	lda (fndpnt),y
     529D   85 3D        4918   	sta txtptr
     529F   88           4919   	dey
     52A0   B1 3F        4920   	lda (fndpnt),y
     52A2   20 A84B      4921   	jsr retpat	;01/18/84 patch: correct 'return' to 'gosub' from direct mode
     52A5   B1 3F        4922   	lda (fndpnt),y
     52A7   85 3B        4923   	sta curlin	;jump to 'data' to waste rest of stmt (in case of on..gosub)
     52A9   4C 52AC      4924   	jmp data
                         4925   
                         4926   ;end
                         4927   	.include remdata	;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 74
data statment   REMDATA.SRC

Error Addr  Code          Seq   Source statement

                         4929   	.subttl data statment
                         4930   ;
     52AC                4931   data
     52AC   20 52BF      4932   	jsr datan	;skip to end of statement.
     52AF   98           4933   addon	tya
     52B0   18           4934   	clc
     52B1   65 3D        4935   	adc txtptr
     52B3   85 3D        4936   	sta txtptr
     52B5   90 02        4937   	bcc remrts
     52B7   E6 3E        4938   	inc txtptr+1
     52B9   60           4939   remrts	rts		;"newstt" rts addr is still there.
                         4940   
                         4941   
                         4942   
     52BA   20 52C2      4943   rem	jsr remn	;skip rest of statement.
     52BD   F0 F0        4944   	beq addon	;will always branch.
                         4945   
                         4946   
     52BF   A2 3A        4947   datan	ldx #':'	;"data" teminates on ":" and null
     52C1   2C           4948   	.byte $2c	;skip the next 2 instructions
                         4949   
     52C2   A2 00        4950   remn	ldx #0		;the only terminator is null.
     52C4   86 09        4951   	stx charac	;preserve it.
     52C6   A0 00        4952   	ldy #0		;this makes charar=0 after swap.
     52C8   84 0A        4953   	sty endchr
                         4954   
     52CA   A5 0A        4955   exchqt	lda endchr
     52CC   A6 09        4956   	ldx charac
     52CE   85 09        4957   	sta charac
     52D0   86 0A        4958   	stx endchr
     52D2   20 03C9      4959   remer	jsr indtxt
     52D5   F0 E2        4960   	beq remrts	;null always termiantes.
     52D7   C5 0A        4961   	cmp endchr	;is it another terminator?
     52D9   F0 DE        4962   	beq remrts	;yes, it's finished.
     52DB   C8           4963   	iny		;progress to next character.
     52DC   C9 22        4964   	cmp #'"'	;is it a quote?
     52DE   D0 F2        4965   	bne remer	;no, just continue.
     52E0   F0 E8        4966   	beq exchqt	;yes, time to change.
                         4967   
                         4968   ;end
                         4969   	.include if		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 75
IF statement   IF.SRC

Error Addr  Code          Seq   Source statement

                         4971   	.subttl IF statement
                         4972   
                         4973   ;****************************************************************
                         4974   ;*
                         4975   ;* if statment
                         4976   ;*
                         4977   ;*	IF exp {GOTO line#  | THEN {line# | statements | b-block} }
                         4978   ;*		[:ELSE {line# | statements | b-block} ]
                         4979   ;*	
                         4980   ;* b-block
                         4981   ;*
                         4982   ;*	BEGIN : [statement(s) on one or more lines] : BEND
                         4983   ;*
                         4984   ;****************************************************************
                         4985   
     52E2   20 788C      4986   if	jsr frmevl	;evaluate the conditional expression
     52E5   20 0386      4987   	jsr chrgot	;get current character.
     52E8   C9 89        4988   	cmp #gototk	;is terminating character a gototk?
     52EA   F0 05        4989   	beq 10$		;yes.
     52EC   A9 A7        4990   	lda #thentk	;no, it must be "then".
     52EE   20 79FB      4991   	jsr synchr
                         4992   
     52F1   A5 63        4993   10$	lda facexp	;test truth value of argument
     52F3   D0 26        4994   	bne if_true	;branch if true
                         4995   
     52F5                4996   if_false
     52F5   20 0386      4997   	jsr chrgot	;is there a b-block?
     52F8   C9 FE        4998   	cmp #esc_cmd_tk
     52FA   D0 0B        4999   	bne 20$		;no, must be an escape command
     52FC   C8           5000   	iny		;might be, look at escape token
     52FD   20 03C9      5001   	jsr indtxt
     5300   C9 18        5002   	cmp #begintk
     5302   D0 03        5003   	bne 20$		;branch if not
     5304   20 533D      5004   	jsr find_bend	;skip to end of b-block
                         5005   
     5307   20 52AC      5006   20$	jsr data	;may be 'else' clause. first skip over 'then' clause..
     530A   A0 00        5007   	ldy #0
     530C   20 03C9      5008   	jsr indtxt	;..and see if end of stmt or end of line.
     530F   F0 A9        5009   	beq rem	  	;end of line, no 'else'. go to next line.
     5311   20 0380      5010   	jsr chrget	;another statement on this line.. is it 'else'?
     5314   C9 D5        5011   	cmp #elsetk
     5316   D0 EF        5012   	bne 20$		;no, keep looking on this line.
     5318   20 0380      5013   	jsr chrget	;yes! skip over token ,and execute clause (below).
                         5014   
     531B   20 0386      5015   if_true	jsr chrgot
     531E   F0 17        5016   	beq 20$		;branch if end of statement
     5320   B0 03        5017   	bcs 10$		;branch if not a number
     5322   4C 59F8      5018   	jmp goto	;here if of the form 'THEN line#'
                         5019   
     5325   C9 FE        5020   10$	cmp #esc_cmd_tk	;is this the beginning of a b-block?
     5327   D0 0E        5021   	bne 20$		;no, must be an escape command
     5329   C8           5022   	iny		;might be, look at escape token
     532A   20 03C9      5023   	jsr indtxt
     532D   C9 18        5024   	cmp #begintk
     532F   D0 06        5025   	bne 20$

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 75-1
IF statement   IF.SRC

Error Addr  Code          Seq   Source statement

     5331   20 0380      5026   	jsr chrget	;skip over 'BEGIN' if so...
     5334   20 0380      5027   	jsr chrget	;..and the second token, as well.
                         5028   
     5337   20 0386      5029   20$	jsr chrgot	;get back original character, & set up flags
     533A   4C 4B5C      5030   	jmp xeqcm3	;..and go execute whatever it is
                         5031   	

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 76
IF statement   IF.SRC

Error Addr  Code          Seq   Source statement

                         5033   
     533D                5034   find_bend ;... subroutine to find end of current b-block
                         5035   
     533D   20 0380      5036   	jsr chrget
     5340   D0 27        5037   	bne 20$
                         5038   
                         5039   ; end of statement.. set up next
                         5040   
     5342   C9 3A        5041   10$	cmp #':'	;is this eol?
     5344   F0 F7        5042   	beq find_bend	;no, keep looking
                         5043   
     5346   24 7F        5044   15$	bit runmod	;end of line. are we in direct mode?
     5348   10 4A        5045   	bpl 99$		;yes,'block terminator not found' error
                         5046   
     534A   A0 02        5047   	ldy #2
     534C   20 03C9      5048   	jsr indtxt	;end of text?
     534F   F0 43        5049   	beq 99$		;yes, msb of next stmt pointer = 0. error.
                         5050   
     5351   C8           5051   	iny
     5352   20 03C9      5052   	jsr indtxt
     5355   85 3B        5053   	sta curlin	;set up next line of text
     5357   C8           5054   	iny
     5358   20 03C9      5055   	jsr indtxt
     535B   85 3C        5056   	sta curlin+1
     535D   98           5057   	tya
     535E   18           5058   	clc
     535F   65 3D        5059   	adc txtptr
     5361   85 3D        5060   	sta txtptr
     5363   90 D8        5061   	bcc find_bend
     5365   E6 3E        5062   	inc txtptr+1
     5367   D0 D4        5063   	bne find_bend	;always
                         5064   
     5369   C9 22        5065   20$	cmp #'"'
     536B   D0 07        5066   	bne 30$
     536D   20 5399      5067   	jsr un_quote	;look for terminating quote, or e-o-l
     5370   F0 D0        5068   	beq 10$		;e-o-l, or ':' after closing quote
     5372   D0 C9        5069   	bne find_bend	;..else normal char, keep looking
                         5070   
     5374   C9 8F        5071   30$	cmp #remtk	;is this a 'rem'?
     5376   D0 06        5072   	bne 35$		;if not, go on
     5378   20 52BA      5073   	jsr rem		;yes, trash this line
     537B   4C 5346      5074   	jmp 15$		;..and go test for end of text
                         5075   
     537E   C9 FE        5076   35$	cmp #esc_cmd_tk	;is this a BEND?
     5380   D0 BB        5077   	bne find_bend	;can't be, has to be an escape
                         5078   
     5382   20 0380      5079   	jsr chrget	;skip over esc token
     5385   C9 19        5080   	cmp #bendtk
     5387   F0 0A        5081   	beq 40$		;this is what we came for. bye!
                         5082   
     5389   C9 18        5083   	cmp #begintk	;not a BEND. is it a BEGIN?
     538B   D0 B0        5084   	bne find_bend	;it's just a normal, stick-in-the-mud char. keep looking.
                         5085   
     538D   20 533D      5086   	jsr find_bend	;oh-oh, recursion. Dr. Ja-Ja warned me about this.
     5390   4C 533D      5087   	jmp find_bend

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 76-1
IF statement   IF.SRC

Error Addr  Code          Seq   Source statement

                         5088   
     5393   60           5089   40$	rts
                         5090   
     5394   A2 25        5091   99$	ldx #err_no_bend
     5396   4C 4D59      5092   	jmp error
                         5093   
     5399                5094   un_quote		;txtptr points to a '"'. look for closing '"', or e-o-l
     5399   A0 00        5095   	ldy #0
     539B   E6 3D        5096   10$	inc txtptr
     539D   D0 02        5097   	bne 20$
     539F   E6 3E        5098   	inc txtptr+1
     53A1   20 03C9      5099   20$	jsr indtxt
     53A4   F0 07        5100   	beq 30$		;e-o-l, get out here with .z set and a '00' in .a
     53A6   C9 22        5101   	cmp #'"'
     53A8   D0 F1        5102   	bne 10$		;keep looking until quote
     53AA   4C 0380      5103   	jmp chrget	;got closing quote, get byte after quote, set flags
     53AD   60           5104   30$	rts
                         5105   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 77
IF statement   IF.SRC

Error Addr  Code          Seq   Source statement

                         5107   
     53AE   C9 FE        5108   else	cmp #esc_cmd_tk	;is this of the form "ELSE b-block"?
     53B0   D0 0B        5109   	bne 10$		;no, must be an escape command
     53B2   C8           5110   	iny		;might be, look at escape token
     53B3   20 03C9      5111   	jsr indtxt
     53B6   C9 18        5112   	cmp #begintk
     53B8   D0 03        5113   	bne 10$		;no, justa plain-old "ELSE statement"
     53BA   20 533D      5114   	jsr find_bend	;yes, it is a b-block. skip over the b-block.
     53BD   4C 52BA      5115   10$	jmp rem
                         5116   
                         5117   
                         5118   ;end
                         5119   	.include ongoto		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 78
on...goto/gosub   ONGOTO.SRC

Error Addr  Code          Seq   Source statement

                         5121   	.subttl on...goto/gosub
                         5122   
                         5123   ;**********************************************************
                         5124   ;*
                         5125   ;*	ON expression {GOTO | GOSUB} line_number
                         5126   ;*
                         5127   ;*********************************************************
     53C0                5128   ongoto
     53C0   20 87F4      5129   	jsr getbyt
     53C3   48           5130   	pha
     53C4   C9 8D        5131   	cmp #gosutk
     53C6   F0 07        5132   	beq 1$
     53C8   C9 89        5133   	cmp #gototk	;must be "gototk".
     53CA   F0 03        5134   	beq 1$
     53CC   4C 7A09      5135   	jmp snerr	;neither, must be syntax error
                         5136   
     53CF   C6 67        5137   1$	dec faclo
     53D1   D0 04        5138   	bne 2$		;skip another line number.
     53D3   68           5139   	pla		;get dispatch character.
     53D4   4C 4B76      5140   	jmp xeqcm2
                         5141   
     53D7   20 0380      5142   2$	jsr chrget	;advance and set codes
     53DA   20 50BD      5143   	jsr linget	;read next line
     53DD   C9 2C        5144   	cmp #','	;is it a "comma"?
     53DF   F0 EE        5145   	beq 1$
     53E1   68           5146   	pla		;remove stack entry (token).
     53E2   60           5147   	rts		;either end of line or syntax error.
                         5148   
                         5149   ;end
                         5150   	.include let		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 79
LET command   LET.SRC

Error Addr  Code          Seq   Source statement

                         5152   	.subttl LET command
                         5153   
                         5154   ;****************************************************************
                         5155   ;*
                         5156   ;*  [LET] variable = expression
                         5157   ;*
                         5158   ;****************************************************************
                         5159   
     53E3   20 7B4C      5160   let	jsr ptrget	;get pntr to variable into "varpnt".
     53E6   85 4B        5161   	sta forpnt	;preserve pointer.
     53E8   84 4C        5162   	sty forpnt+1
     53EA   A9 B2        5163   	lda #equltk
     53EC   20 79FB      5164   	jsr synchr	;"=" is necessary.
     53EF   A5 10        5165   	lda intflg	;save for later.
     53F1   48           5166   	pha
     53F2   A5 0F        5167   	lda valtyp	;retain the variable's value type
     53F4   48           5168   	pha
     53F5   20 788C      5169   	jsr frmevl	;get value of formula into "fac".
     53F8   68           5170   	pla
     53F9   2A           5171   	rol a		;carry set for string , off for numeric.
     53FA   20 787B      5172   	jsr chkval	;make sure "valtyp" matches carry.
                         5173   			;and set zero flag for numeric.
     53FD   D0 22        5174   	bne copstr	;if numeric, copy it.
     53FF   68           5175   	pla		;get number type.
                         5176   
     5400   10 15        5177   qintgr	bpl copflt	;store a flting number.
     5402   20 8C47      5178   	jsr round	;round integer.
     5405   20 84B4      5179   	jsr ayint	;make two-byte number.
     5408   A0 00        5180   	ldy #0
     540A   A5 66        5181   	lda facmo	;get high 
     540C   8D FF04      5182   	sta sw_rom_ram1
     540F   91 4B        5183   	sta (forpnt),y	;store it.
     5411   C8           5184   	iny
     5412   A5 67        5185   	lda faclo	;get low.
     5414   91 4B        5186   	sta (forpnt),y
     5416   60           5187   	rts
                         5188   
                         5189   
     5417   A6 4B        5190   copflt	ldx forpnt
     5419   A4 4C        5191   	ldy forpnt+1
     541B   8D FF04      5192   	sta sw_rom_ram1
     541E   4C 8C00      5193   	jmp movmf	;put number @fdrpnt.
                         5194   
                         5195   
     5421   68           5196   copstr	pla		;if string, no intflg.
                         5197   
     5422   A4 4C        5198   inpcom	ldy forpnt+1	;ti$?
     5424   C0 03        5199   	cpy #>zero	;only ti$ can be this on assign.
     5426   D0 72        5200   	bne getspt	;was not ti$.
     5428   20 8781      5201   	jsr frefac	;we won't need it.
     542B   C9 06        5202   	cmp #6		;length correct?
     542D   D0 3E        5203   	bne fcerr2
     542F   A0 00        5204   	ldy #0		;yes, do setup.
     5431   84 63        5205   	sty facexp	;zero to start with.
     5433   84 68        5206   	sty facsgn

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 79-1
LET command   LET.SRC

Error Addr  Code          Seq   Source statement

     5435                5207   timelp
     5435   84 72        5208   	sty fbufpt	;save position.
     5437   20 5465      5209   	jsr timnum	;get a digit.
     543A   20 8B17      5210   	jsr mul10	;whole quantity by 10.
     543D   E6 72        5211   	inc fbufpt
     543F   A4 72        5212   	ldy fbufpt
     5441   20 5465      5213   	jsr timnum
     5444   20 8C38      5214   	jsr movaf
     5447   AA           5215   	tax		;if num=0 then no mult.
     5448   F0 05        5216   	beq noml6	;if =0, go tit.
     544A   E8           5217   	inx		;mult by two.
     544B   8A           5218   	txa
     544C   20 8B22      5219   	jsr finml6	;add in and mult by 2 gives *6.
     544F   A4 72        5220   noml6	ldy fbufpt
     5451   C8           5221   	iny
     5452   C0 06        5222   	cpy #6		;done all six?
     5454   D0 DF        5223   	bne timelp
     5456   20 8B17      5224   	jsr mul10	;one last time.
     5459   20 8CC7      5225   	jsr qint	;shift it over to the right.
     545C   A6 66        5226   	ldx facmo	
     545E   A4 65        5227   	ldy facmoh
     5460   A5 67        5228   	lda faclo
     5462   4C FFDB      5229   	jmp _settim
     5465                5230   timnum
     5465   20 03B7      5231   	jsr indin1_ram1	;lda (index),y
     5468   20 0390      5232   	jsr qnum
     546B   90 03        5233   	bcc gotnum
     546D                5234   fcerr2
     546D   4C 7DC5      5235   	jmp fcerr	;must be numeric string.
     5470                5236   gotnum
     5470   E9 2F        5237   	sbc #$2f	;c is off.
     5472   4C 8DB0      5238   	jmp finlog	;add in digit to fac.
                         5239   
                         5240   
                         5241   
     5475                5242   dskx1
     5475   68           5243   	pla
     5476   C8           5244   	iny
     5477                5245   dskx2
     5477   C5 36        5246   	cmp fretop+1
     5479   90 18        5247   	bcc dntcpy
     547B   D0 08        5248   	bne qvaria
     547D   88           5249   	dey
     547E   20 4304      5250   	jsr indfmo
     5481   C5 35        5251   	cmp fretop
     5483   90 0E        5252   	bcc dntcpy
     5485                5253   qvaria
     5485   A4 67        5254   	ldy faclo
     5487   C4 30        5255   	cpy vartab+1	;if (vartab).gt.(facmo), don't copy.
     5489   90 08        5256   	bcc dntcpy
     548B   D0 24        5257   	bne copy	;it is less.
     548D   A5 66        5258   	lda facmo
     548F   C5 2F        5259   	cmp vartab	;compare low orders.
     5491   B0 1E        5260   	bcs copy
     5493                5261   dntcpy

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 79-2
LET command   LET.SRC

Error Addr  Code          Seq   Source statement

     5493   A5 66        5262   	lda facmo
     5495   A4 67        5263   	ldy facmo+1
     5497   4C 54CF      5264   	jmp copyc
                         5265   
                         5266   
                         5267   
     549A                5268   getspt
     549A   A0 02        5269   	ldy #2		;get pntr to descriptor.
     549C   20 4304      5270   	jsr indfmo
     549F   C5 7C        5271   	cmp dsdesc+2	;check for ds$ hi
     54A1   D0 D4        5272   	bne dskx2	;nope
     54A3   48           5273   	pha
     54A4   88           5274   	dey
                         5275   
     54A5   20 4304      5276   	jsr indfmo
     54A8   C5 7B        5277   	cmp dsdesc+1	;check for ds$ lo
     54AA   D0 C9        5278   	bne dskx1	;nope
     54AC   A5 7A        5279   	lda dsdesc	;check if len=0
     54AE   F0 C5        5280   	beq dskx1	;yup
     54B0   68           5281   	pla		;fall through to copy
                         5282   
     54B1                5283   copy
     54B1   A0 00        5284   	ldy #0
     54B3   20 4304      5285   	jsr indfmo
     54B6   20 8688      5286   	jsr strini	;get room to copy string into.
     54B9   A5 52        5287   	lda dscpnt	;get pointer to old descriptor, so
     54BB   A4 53        5288   	ldy dscpnt+1	
     54BD   85 70        5289   	sta strng1	;movins can find string.
     54BF   84 71        5290   	sty strng1+1
     54C1   20 874E      5291   	jsr movins	;copy it.
                         5292   
     54C4   A5 70        5293   	lda strng1	;fix to free get strings
     54C6   A4 71        5294   	ldy strng1+1
     54C8   20 87E0      5295   	jsr fretms	;free the string, if it is a temp
                         5296   
     54CB   A9 63        5297   	lda #<dsctmp
     54CD   A0 00        5298   	ldy #>dsctmp
     54CF                5299   copyc
     54CF   85 52        5300   	sta dscpnt
     54D1   84 53        5301   	sty dscpnt+1
     54D3   85 24        5302   	sta index	;index points to new descriptor
     54D5   84 25        5303   	sty index+1
     54D7   20 87E0      5304   	jsr fretms
                         5305   
                         5306   ;   fix the strings by flagging the old string as
                         5307   ;   garbage and the new string by pointing it to
                         5308   ;   its new descriptor.
                         5309   
     54DA   20 5513      5310   	jsr stradj	;set up new string
     54DD   90 0E        5311   	bcc 10$		;leave it alone
     54DF   A0 00        5312   	ldy #0
     54E1   A5 4B        5313   	lda forpnt	;put in backwards link
     54E3   8D FF04      5314   	sta sw_rom_ram1	;set up string bank
     54E6   91 24        5315   	sta (index),y
     54E8   C8           5316   	iny

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 79-3
LET command   LET.SRC

Error Addr  Code          Seq   Source statement

     54E9   A5 4C        5317   	lda forpnt+1
     54EB   91 24        5318   	sta (index),y
                         5319   
     54ED   A5 4B        5320   10$	lda forpnt	;fix old string
     54EF   85 24        5321   	sta index
     54F1   A5 4C        5322   	lda forpnt+1
     54F3   85 25        5323   	sta index+1
     54F5   20 5513      5324   	jsr stradj	;point to old string
     54F8   90 0C        5325   	bcc 20$		;in text do not fix
     54FA   88           5326   	dey		;restore y
     54FB   A9 FF        5327   	lda #$ff	;garbage flag
     54FD   8D FF04      5328   	sta sw_rom_ram1	;set up string bank
     5500   91 24        5329   	sta (index),y
     5502   88           5330   	dey
     5503   8A           5331   	txa
     5504   91 24        5332   	sta (index),y	;store length
                         5333   
     5506   A0 02        5334   20$	ldy #2
                         5335   
     5508   A9 52        5336   30$	lda #dscpnt
     550A   20 03AB      5337   	jsr indsub_ram1	;lda (dscpnt),y
     550D   91 4B        5338   	sta (forpnt),y	;set the descriptor
     550F   88           5339   	dey
     5510   10 F6        5340   	bpl 30$
     5512   60           5341   	rts
                         5342   
                         5343   
                         5344   
                         5345   ;   takes the pointer index which points to a descriptor
                         5346   ;   and indexes to the desciptors string data.
                         5347   ;   if the string is not in string space (no action to take)
                         5348   ;   we return with carry clear, else we return with
                         5349   ;   the pointer set to the link bytes in the string
                         5350   ;   the length in .a and the carry set.
                         5351   
     5513   A0 00        5352   stradj	ldy #0
     5515   20 03B7      5353   	jsr indin1_ram1	;push length on stack
     5518   48           5354   	pha
     5519   F0 39        5355   	beq sadj8	;length 0 do nothing
     551B   C8           5356   	iny
     551C   20 03B7      5357   	jsr indin1_ram1	;lo byte to x
     551F   AA           5358   	tax
     5520   C8           5359   	iny
     5521   20 03B7      5360   	jsr indin1_ram1
     5524   C5 3A        5361   	cmp max_mem_1+1
     5526   90 06        5362   	bcc sadj2	;ok
     5528   D0 2A        5363   	bne sadj8	;if above top of memory
     552A   E4 39        5364   	cpx max_mem_1	;msb the same, test lsb
     552C   B0 26        5365   	bcs sadj8	;if above top of memory
     552E                5366   sadj2
     552E   20 03B7      5367   	jsr indin1_ram1
     5531   C5 36        5368   	cmp fretop+1
     5533   90 1F        5369   	bcc sadj8	;if below fretop
     5535   D0 04        5370   	bne sadj3
     5537   E4 35        5371   	cpx fretop

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 79-4
LET command   LET.SRC

Error Addr  Code          Seq   Source statement

     5539   90 19        5372   	bcc sadj8	;if below fretop
     553B                5373   sadj3
     553B   C5 7C        5374   	cmp dsdesc+2
     553D   D0 04        5375   	bne sadj4	;fix
     553F   E4 7B        5376   	cpx dsdesc+1
     5541   F0 11        5377   	beq sadj8
     5543                5378   sadj4
     5543   86 24        5379   	stx index	;ok set pointer
     5545   85 25        5380   	sta index+1
     5547   68           5381   	pla		;get back length
     5548   AA           5382   	tax		;into x also
     5549   18           5383   	clc
     554A   65 24        5384   	adc index
     554C   85 24        5385   	sta index
     554E   90 02        5386   	bcc sadj6
     5550   E6 25        5387   	inc index+1
     5552                5388   sadj6
     5552   38           5389   	sec		;carry set
     5553   60           5390   	rts
                         5391   
     5554                5392   sadj8
     5554   68           5393   	pla		;clean up stack
     5555   18           5394   	clc
     5556   60           5395   	rts
                         5396   
                         5397   ;end
                         5398   	.include print		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 80
PRINT / PRINT# / CMD   PRINT.SRC

Error Addr  Code          Seq   Source statement

                         5400   	.subttl PRINT / PRINT# / CMD
                         5401   
                         5402   ;***********************************************************
                         5403   ;*
                         5404   ;*	PRINT / PRINT# /CMD
                         5405   ;*
                         5406   ;**********************************************************
                         5407   
     5557   20 555D      5408   printn	jsr cmd		;docmd.
     555A   4C 5675      5409   	jmp iodone	;release channel.
                         5410   
     555D   20 87F4      5411   cmd	jsr getbyt
     5560   F0 05        5412   	beq saveit
     5562   A9 2C        5413   	lda #','	;comma?
     5564   20 79FB      5414   	jsr synchr
     5567                5415   saveit
     5567   08           5416   	php
     5568   86 15        5417   	stx channl	;channel to output on.
     556A   20 90EB      5418   	jsr coout
     556D   28           5419   	plp		;get status back.
     556E   4C 5577      5420   	jmp print
                         5421   
     5571                5422   strdon
     5571   20 5602      5423   	jsr strprt
     5574                5424   newchr
     5574   20 0386      5425   	jsr chrgot	;reget last character.
     5577                5426   print
     5577   F0 3C        5427   	beq crdo	;terminate so type crlf
     5579   C9 FB        5428   	cmp #usetk
     557B   D0 03        5429   	bne printc
     557D   4C 9520      5430   	jmp using
                         5431   
                         5432   
                         5433   
     5580                5434   printc
     5580   F0 43        5435   	beq prtrts	;here after seeing tab(x) or , or.
                         5436   			;in which case a terminator does not mean a crlf
                         5437   			;but just rts.
     5582   C9 A3        5438   	cmp #tabtk	;tab function?
     5584   F0 50        5439   	beq taber	;yes.
     5586   C9 A6        5440   	cmp #spctk	;space function?
     5588   18           5441   	clc		;clear carry.
     5589   F0 4B        5442   	beq taber	;yes.
     558B   C9 2C        5443   	cmp #','	;comma?
     558D   F0 37        5444   	beq comprt	;yes.
     558F   C9 3B        5445   	cmp #';'	;a semicolon?
     5591   F0 5E        5446   	beq notabr	;yes.
     5593   20 788C      5447   	jsr frmevl	;evaluate the formula
     5596   24 0F        5448   	bit valtyp	;a string?
     5598   30 D7        5449   	bmi strdon	;yes.
     559A   20 8E42      5450   	jsr fout
     559D   20 869A      5451   	jsr strlit	;build descriptor.
     55A0   20 5602      5452   	jsr strprt	;print the number.
     55A3   20 561D      5453   	jsr outspc	;print a space.
     55A6   D0 CC        5454   	bne newchr	;always goes.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 80-1
PRINT / PRINT# / CMD   PRINT.SRC

Error Addr  Code          Seq   Source statement

                         5455   
     55A8                5456   fininl
     55A8   A9 00        5457   	lda #0		;put a zero at end of buf.
     55AA   9D 0200      5458   	sta buf,x
                         5459   
            =01FF        5460   zz5	=buf-1		;set up pointer.
                         5461   
     55AD   A2 FF        5462   	ldx #<zz5
     55AF   A0 01        5463   	ldy #>zz5
     55B1   A5 15        5464   	lda channl	;no crdo if not termianl. 
     55B3   D0 10        5465   	bne prtrts
                         5466   
     55B5                5467   crdo
     55B5   A9 0D        5468   	lda #cr
     55B7   20 5629      5469   	jsr outdo
     55BA   24 15        5470   	bit channl
     55BC   10 05        5471   	bpl crfin
     55BE   A9 0A        5472   	lda #lf
     55C0   20 5629      5473   	jsr outdo
     55C3                5474   crfin
     55C3   49 FF        5475   	eor #$ff
     55C5                5476   prtrts
     55C5   60           5477   	rts
                         5478   
                         5479   
                         5480   
     55C6   38           5481   comprt	sec
     55C7   20 928D      5482   	jsr k_jplot	;get tab position in x
     55CA   98           5483   	tya
     55CB   38           5484   	sec
     55CC   E9 0A        5485   morco1	sbc #column_width
     55CE   B0 FC        5486   	bcs morco1
     55D0   49 FF        5487   	eor #$ff
     55D2   69 01        5488   	adc #1
     55D4   D0 16        5489   	bne aspac
                         5490   
     55D6   08           5491   taber	php		;remember if spc or tab function.
     55D7   38           5492   	sec
     55D8   20 928D      5493   	jsr k_jplot	;read tab position
     55DB   84 0B        5494   	sty trmpos
     55DD   20 87F1      5495   	jsr gtbytc	;get value into accx.
     55E0   C9 29        5496   	cmp #')'
     55E2   D0 13        5497   	bne snerr4
     55E4   28           5498   	plp
     55E5   90 06        5499   	bcc xspac
     55E7   8A           5500   	txa
     55E8   E5 0B        5501   	sbc trmpos
     55EA   90 05        5502   	bcc notabr	;negative, don't print any.
     55EC   AA           5503   aspac	tax
     55ED   E8           5504   xspac	inx
     55EE   CA           5505   xspac2	dex
     55EF   D0 09        5506   	bne xspac1
                         5507   
     55F1                5508   notabr
     55F1   20 0380      5509   	jsr chrget	;reget last character.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 80-2
PRINT / PRINT# / CMD   PRINT.SRC

Error Addr  Code          Seq   Source statement

     55F4   4C 5580      5510   	jmp printc	;don't call crdo.
                         5511   
     55F7                5512   snerr4
     55F7   4C 7A09      5513   	jmp snerr
                         5514   
     55FA                5515   xspac1
     55FA   20 561D      5516   	jsr outspc
     55FD   D0 EF        5517   	bne xspac2

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 81
PRINT / PRINT# / CMD   PRINT.SRC

Error Addr  Code          Seq   Source statement

                         5519   ;
                         5520   ; strout routine
                         5521   ;
                         5522   ; Print the string pointed to by (xreg) which ends with a zero.
                         5523   
     55FF   20 869A      5524   strout	jsr strlit	;get a string literal.
                         5525   
     5602   20 8781      5526   strprt	jsr frefac	;return temp pointer.
     5605   AA           5527   	tax		;put count into counter.
     5606   A0 00        5528   	ldy #0
     5608   E8           5529   	inx		;move one ahead.
     5609   CA           5530   strpr2	dex
     560A   F0 B9        5531   	beq prtrts	;all done.
     560C   20 03B7      5532   	jsr indin1_ram1	;lda (index),y
     560F   20 5629      5533   	jsr outdo
     5612   C8           5534   	iny
     5613   C9 0D        5535   	cmp #cr
     5615   D0 F2        5536   	bne strpr2
     5617   20 55C3      5537   	jsr crfin	;type rest of carriage return.
     561A   4C 5609      5538   	jmp strpr2	;and on and on.
                         5539   
     561D   A5 15        5540   outspc	lda channl
     561F   F0 03        5541   	beq crtskp
                         5542   
     5621   A9 20        5543   realsp	lda #' '	;space
     5623   2C           5544   	.byte $2c
     5624   A9 1D        5545   crtskp	lda #29	  	;cbm cursor right (non-destructive skip char)
     5626   2C           5546   	.byte $2c
     5627   A9 3F        5547   outqst	lda #'?'
                         5548   
     5629   20 90DF      5549   outdo	jsr outch	;output char in .a
     562C   29 FF        5550   	and #$ff
     562E   60           5551   	rts
                         5552   
                         5553   ;.end
                         5554   	.include input		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 82
INPUT / GET / READ  commands   INPUT.SRC

Error Addr  Code          Seq   Source statement

                         5556   	.subttl INPUT / GET / READ  commands
                         5557   
     562F   20 84D9      5558   get	jsr errdir
     5632   85 77        5559   	sta z_p_temp_1	;use as a flag to distinguish between 'get' and 'get key'
     5634   C9 23        5560   	cmp #'#'	;is it 'get#'?
     5636   F0 0A        5561   	beq getn	;branch if yes
     5638   C9 F9        5562   	cmp #keytk	;is it 'get key'?
     563A   D0 16        5563   	bne gettty	;branch if not
     563C   20 0380      5564   	jsr chrget	;skip over 'key' token
     563F   4C 5652      5565   	jmp gettty
                         5566   
     5642   20 0380      5567   getn	jsr chrget	;move up to next byte
     5645   20 87F4      5568   	jsr getbyt	;get channel into x
     5648   A9 2C        5569   	lda #','	;comma?
     564A   20 79FB      5570   	jsr synchr	
     564D   86 15        5571   	stx channl
     564F   20 90FD      5572   	jsr coin	;chkin
                         5573   
            =0201        5574   zz2	=buf+1
            =0202        5575   zz3	=buf+2
                         5576   
     5652   A2 01        5577   gettty	ldx #<zz2	;point to 0.
     5654   A0 02        5578   	ldy #>zz3
     5656   A9 00        5579   	lda #0		;to stuff and to point
     5658   8D 0201      5580   	sta buf+1	;zero it
     565B   A9 40        5581   	lda #64		;turn on v-bit.
     565D   20 56CF      5582   	jsr inpco1	;do the get.
     5660   A6 15        5583   	ldx channl
     5662   D0 13        5584   	bne iorele	;release.
     5664   60           5585   	rts
                         5586   
     5665   20 87F4      5587   inputn	jsr getbyt	;get channel number.
     5668   A9 2C        5588   	lda #','	;a comma?
     566A   20 79FB      5589   	jsr synchr
     566D   86 15        5590   	stx channl
     566F   20 90FD      5591   	jsr coin	;chkin
     5672   20 568E      5592   	jsr notqti	;do input to variables.
     5675   A5 15        5593   iodone	lda channl	;release channel.
     5677   20 926F      5594   iorele	jsr k_clrch
     567A   A2 00        5595   	ldx #0		;reset channel to terminal.
     567C   86 15        5596   	stx channl
     567E   60           5597   	rts
                         5598   
                         5599   
                         5600   
     567F   C9 22        5601   input	cmp #'"'	;a quote?
     5681   D0 0B        5602   	bne notqti	;no message.
     5683   20 79B0      5603   	jsr strtxt	;literalize the string in text.
     5686   A9 3B        5604   	lda #';'	;must end in semicolon.
     5688   20 79FB      5605   	jsr synchr
     568B   20 5602      5606   	jsr strprt	;print it out.
     568E                5607   notqti
     568E   20 84D9      5608   	jsr errdir	;use common routine since def direct.
     5691   A9 2C        5609   	lda #','	;get comma.
     5693   8D 01FF      5610   	sta buf-1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 82-1
INPUT / GET / READ  commands   INPUT.SRC

Error Addr  Code          Seq   Source statement

                         5611   			;is also illegal.
     5696                5612   getagn
     5696   20 56B9      5613   	jsr qinlin	;type "?" and input a line of text.
     5699   A5 15        5614   	lda channl
     569B   F0 0D        5615   	beq bufful
     569D   20 9251      5616   	jsr k_readst	;get status byte
     56A0   29 02        5617   	and #2
     56A2   F0 06        5618   	beq bufful	;a-ok.
     56A4   20 5675      5619   	jsr iodone	;bad, close channel.
     56A7   4C 52AC      5620   	jmp data	;skip rest of input.
                         5621   
     56AA                5622   bufful
     56AA   AD 0200      5623   	lda buf	  	;get anything?
     56AD   D0 1E        5624   	bne inpcon	;yes
     56AF   A5 15        5625   	lda channl	;no, is this keyboard
     56B1   D0 E3        5626   	bne getagn	;no
     56B3   20 52BF      5627   	jsr datan
     56B6   4C 52AF      5628   	jmp addon
     56B9                5629   qinlin
     56B9   A5 15        5630   	lda channl
     56BB   D0 06        5631   	bne ginlin
     56BD   20 5627      5632   	jsr outqst	;print '?'...
     56C0   20 5621      5633   	jsr realsp	;...and a space
     56C3                5634   ginlin
     56C3   4C 4FB0      5635   	jmp inlin

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 83
INPUT / GET / READ  commands   INPUT.SRC

Error Addr  Code          Seq   Source statement

     56C6   A6 43        5637   read	ldx datptr	;get last data location.
     56C8   A4 44        5638   	ldy datptr+1
     56CA   A9 98        5639   	lda #$98
     56CC   2C           5640   	.byte $2c
                         5641   
     56CD   A9 00        5642   inpcon	lda #0
                         5643   
     56CF   85 13        5644   inpco1	sta inpflg	;store the flag.
                         5645   
                         5646   ; In the processing of data and read statements:
                         5647   ; One pointer points to the data (i.e., the numbers being fetched) and another
                         5648   ; points to the list of variables.
                         5649   ;
                         5650   ; The pointer into the data always starts pointing to a terminator -- a , : or
                         5651   ; end-of-line.
                         5652   ;
                         5653   ; At this point txtptr points to list of variables and xreg points to data
                         5654   ; or input line.
                         5655   
     56D1   86 45        5656   	stx inpptr
     56D3   84 46        5657   	sty inpptr+1
                         5658   
     56D5   20 7B4C      5659   inloop	jsr ptrget	;get a pointer to the variable
     56D8   85 4B        5660   	sta forpnt	;store it's address
     56DA   84 4C        5661   	sty forpnt+1
     56DC   A2 01        5662   	ldx #1
                         5663   
     56DE   B5 3D        5664   1$	lda txtptr,x
     56E0   95 4D        5665   	sta vartxt,x
     56E2   B5 45        5666   	lda inpptr,x
     56E4   95 3D        5667   	sta txtptr,x
     56E6   CA           5668   	dex
     56E7   10 F5        5669   	bpl 1$
                         5670   
     56E9   20 0386      5671   	jsr chrgot
     56EC   D0 31        5672   	bne datbk1
     56EE   24 13        5673   	bit inpflg	;read($98),get($40),or input($00)?
     56F0   50 1A        5674   	bvc qdata	;branch if read or input
                         5675   
     56F2   A5 77        5676   	lda z_p_temp_1	;is this a 'get' or a 'get key'?
     56F4   C9 F9        5677   	cmp #keytk
     56F6   D0 08        5678   	bne inlop1	;branch if 'get'
                         5679   
     56F8   20 9109      5680   2$	jsr cgetl	;get a key
     56FB   AA           5681   	tax		;test if zero
     56FC   F0 FA        5682   	beq 2$		;it is zero, keep scanning
     56FE   D0 03        5683   	bne inlop2	;got a key, go put it in var.
                         5684   
     5700   20 9109      5685   inlop1	jsr cgetl	;get a key if pressed, otherwise gets a zero
     5703   8D 0200      5686   inlop2	sta buf
                         5687   
            =01FF        5688   zz4	=buf-1
                         5689   
     5706   A2 FF        5690   	ldx #<zz4
     5708   A0 01        5691   	ldy #>zz4

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 83-1
INPUT / GET / READ  commands   INPUT.SRC

Error Addr  Code          Seq   Source statement

     570A   D0 0F        5692   	bne datbk
     570C                5693   qdata
     570C   10 03        5694   	bpl qdata1
     570E   4C 57E7      5695   	jmp datlop	;branch if 'read'
     5711                5696   qdata1
     5711   A5 15        5697   	lda channl
     5713   D0 03        5698   	bne getnth
     5715   20 5627      5699   	jsr outqst
     5718                5700   getnth
     5718   20 56B9      5701   	jsr qinlin	;get another line.
     571B                5702   datbk
     571B   86 3D        5703   	stx txtptr	;set for "chrget".
     571D   84 3E        5704   	sty txtptr+1
     571F                5705   datbk1
     571F   20 0380      5706   	jsr chrget
     5722   24 0F        5707   	bit valtyp	;get value type.
     5724   10 31        5708   	bpl numins	;input a number if numeric.
     5726   24 13        5709   	bit inpflg	;get?
     5728   50 09        5710   	bvc setqut	;no, set quote.
     572A   E8           5711   	inx
     572B   86 3D        5712   	stx txtptr
     572D   A9 00        5713   	lda #0
     572F   85 09        5714   	sta charac
     5731   F0 0C        5715   	beq resetc
     5733   85 09        5716   setqut	sta charac	;assume quoted string.
     5735   C9 22        5717   	cmp #'"'	;terminators ok?
     5737   F0 07        5718   	beq nowget  	;yes.
     5739   A9 3A        5719   	lda #':'	;set terminators to ":" and
     573B   85 09        5720   	sta charac
     573D   A9 2C        5721   	lda #','	;comma.
     573F   18           5722   resetc	clc
     5740   85 0A        5723   nowget	sta endchr
     5742   A5 3D        5724   	lda txtptr
     5744   A4 3E        5725   	ldy txtptr+1
     5746   69 00        5726   	adc #0		;c is set properly above.
     5748   90 01        5727   	bcc nowge1
     574A   C8           5728   	iny
     574B   20 86A0      5729   nowge1	jsr strlt2	;make a string descriptor for the value.
                         5730   			;and copy if necessary.
     574E   20 79BC      5731   	jsr st2txt	;copy strng2 to txtptr (st-2-txt... get it?)
                         5732   
     5751   20 5422      5733   	jsr inpcom	;do assignment.
     5754   4C 5761      5734   	jmp strdn2
                         5735   
     5757   A2 00        5736   numins	ldx #0		;flag 'text bank' (0)
     5759   20 8D22      5737   	jsr fin
                         5738   
     575C   A5 10        5739   	lda intflg	;set codes on flags.
     575E   20 5400      5740   	jsr qintgr	;go decide on float.
     5761   20 0386      5741   strdn2	jsr chrgot	;read last character.
     5764   F0 3B        5742   	beq trmok	;":" or eol is ok
     5766   C9 2C        5743   	cmp #','	;a comma?
     5768   F0 37        5744   	beq trmok
                         5745   
     576A   A5 13        5746   	lda inpflg	;is this get, read, or input?

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 83-2
INPUT / GET / READ  commands   INPUT.SRC

Error Addr  Code          Seq   Source statement

     576C   F0 0A        5747   	beq trmn01	;input
     576E   30 04        5748   	bmi tmerr	;read
     5770   A6 15        5749   	ldx channl	;get. if not kbd, go use 'bad file data error'
     5772   D0 08        5750   	bne trmn02
                         5751   
     5774   A2 16        5752   tmerr	ldx #errtm	;'get from kbd' or 'read' saw a bad type
     5776   D0 06        5753   	bne trmn03	;always
                         5754   
     5778   A5 15        5755   trmn01	lda channl
     577A   F0 05        5756   	beq doagin	;do again if keybd input
     577C   A2 18        5757   trmn02	ldx #errbd	;input saw bad file data
     577E   4C 4D59      5758   trmn03	jmp error
                         5759   
     5781   20 9281      5760   doagin	jsr k_primm
     5784   3F 52 45     5761   	.byte '?REDO FROM START', cr, 0
     5787   44 4F 20            
     578A   46 52 4F            
     578D   4D 20 53            
     5790   54 41 52            
     5793   54 0D 00            
                         5762   
     5796   AD 1202      5763   	lda oldtxt
     5799   AC 1203      5764   	ldy oldtxt+1
     579C   85 3D        5765   	sta txtptr	;put user back to beginning of input
     579E   84 3E        5766   	sty txtptr+1
     57A0   60           5767   	rts
                         5768   
                         5769   
                         5770   
     57A1   A2 01        5771   trmok	ldx #1
     57A3   B5 3D        5772   1$	lda txtptr,x
     57A5   95 45        5773   	sta inpptr,x	;save for more reads.
     57A7   B5 4D        5774   	lda vartxt,x
     57A9   95 3D        5775   	sta txtptr,x	;point to variable list.
     57AB   CA           5776   	dex
     57AC   10 F5        5777   	bpl 1$
                         5778   
     57AE   20 0386      5779   	jsr chrgot	;look at last vartab character.
     57B1   F0 06        5780   	beq 2$		;that's the end of the list.
     57B3   20 79F9      5781   	jsr chkcom	;not end. check for comma.
     57B6   4C 56D5      5782   	jmp inloop
                         5783   
     57B9   A5 45        5784   2$	lda inpptr	;put away a new data pntr name.
     57BB   A4 46        5785   	ldy inpptr+1
     57BD   A6 13        5786   	ldx inpflg
     57BF   10 05        5787   	bpl 3$
     57C1   85 43        5788   	sta datptr
     57C3   84 44        5789   	sty datptr+1
     57C5   60           5790   	rts
                         5791   
     57C6   A0 00        5792   3$	ldy #0	    ;last data chr could have been ',' or ':'but should be null
     57C8   A9 45        5793   	lda #inpptr
     57CA   20 039F      5794   	jsr indsub_ram0
     57CD   F0 17        5795   	beq inprts	;it is null
     57CF   A5 15        5796   	lda channl	;if not terminal, no type.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 83-3
INPUT / GET / READ  commands   INPUT.SRC

Error Addr  Code          Seq   Source statement

     57D1   D0 13        5797   	bne inprts
     57D3   20 9281      5798   	jsr k_primm
     57D6   3F 45 58     5799   	.byte '?EXTRA IGNORED', cr, 0
     57D9   54 52 41            
     57DC   20 49 47            
     57DF   4E 4F 52            
     57E2   45 44 0D            
     57E5   00                  
     57E6   60           5800   inprts	rts		;do next statement

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 84
INPUT / GET / READ  commands   INPUT.SRC

Error Addr  Code          Seq   Source statement

                         5802   
                         5803   ;
                         5804   ; Datlop routine
                         5805   ;
                         5806   ; Subroutine to find data.
                         5807   ;
                         5808   ; The search is made by using the execution code for data to skip over
                         5809   ; statements, the start word of each statement is compared with "datatk".
                         5810   ; Each new line number is stored in "datlin" so that if any error occurs while
                         5811   ; reading data the error message can give the line number of the 
                         5812   ; ill-formatted data.
                         5813   
     57E7   20 52BF      5814   datlop	jsr datan	;skip some text.
     57EA   C8           5815   	iny
     57EB   AA           5816   	tax		;end of line?
     57EC   D0 15        5817   	bne nowlin	;no.
     57EE   A2 0D        5818   	ldx #errod	;yes, "no data" error.
     57F0   C8           5819   	iny
     57F1   20 03C9      5820   	jsr indtxt
     57F4   F0 40        5821   	beq next25
     57F6   C8           5822   	iny
     57F7   20 03C9      5823   	jsr indtxt	;get high byte of line number.
     57FA   85 41        5824   	sta datlin
     57FC   C8           5825   	iny
     57FD   20 03C9      5826   	jsr indtxt	;get low byte.
     5800   C8           5827   	iny
     5801   85 42        5828   	sta datlin+1
                         5829   
     5803   20 52AF      5830   nowlin	jsr addon	;txtptr+.y
     5806   20 0386      5831   	jsr chrgot	;span blanks
     5809   AA           5832   	tax	      	;used later
     580A   E0 83        5833   	cpx #datatk	;is it a "data" statement?
     580C   D0 D9        5834   	bne datlop	;not quite right, keep looking.
     580E   4C 571F      5835   	jmp datbk1	;this is the one.
                         5836   
                         5837   
                         5838   ;end
                         5839   	.include next		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 85
NEXT Command   NEXT.SRC

Error Addr  Code          Seq   Source statement

                         5841   	.subttl NEXT Command
                         5842   
                         5843   ; Next routine
                         5844   ;
                         5845   ; A "for" entry on the stack has the following format:
                         5846   ;
                         5847   ; Low address
                         5848   ;    token (fortk) 1 byte
                         5849   ;    a pointer to the loop variable 2 bytes
                         5850   ;    the step 5 bytes
                         5851   ;    a byte reflecting the sign of the incr. 2 bytes
                         5852   ;    the upper value (packed) 5 bytes
                         5853   ;    the line number of the "for" statement 2 bytes
                         5854   ;    a text pointer into the "for" statement 2 bytes
                         5855   ; High address
                         5856   ;
                         5857   ;(total 16 bytes)
                         5858   
     5811   D0 13        5859   next	bne next10	;hop if 'next' variable given
     5813   A0 FF        5860   	ldy #$ff	;flag no specific 'for' variable
     5815   D0 14        5861   	bne next20	;always
                         5862   
     5817   A0 12        5863   next50 	ldy #lenfor	;done, clean up stack
     5819   20 5076      5864   	jsr rlsstk	;release (y) items from stack
     581C   20 0386      5865   	jsr chrgot
     581F   C9 2C        5866   	cmp #','	;ie., next j,k
     5821   D0 71        5867   	bne next45
     5823   20 0380      5868   	jsr chrget
                         5869   
     5826   20 7B4C      5870   next10	jsr ptrget     	;get pointer to variable in (a,y)
     5829   85 4B        5871   	sta forpnt
                         5872   
     582B   84 4C        5873   next20	sty forpnt+1
     582D   A9 81        5874   	lda #fortk
     582F   20 4FC7      5875   	jsr search	;look for 'for' entry in run-time stack
     5832   F0 05        5876   	beq next30	;branch if found
     5834   A2 0A        5877   	ldx #errnf	;otherwise 'error, not found'
     5836                5878   next25
     5836   4C 4D59      5879   	jmp error
     5839                5880   next30
     5839   20 506D      5881   	jsr movfnd	;(fndpnt) => (tos)
                         5882   ;
                         5883   ; set up to move 'step' value to fac
                         5884   ;
     583C   A5 3F        5885   	lda fndpnt
     583E   18           5886   	clc
     583F   69 03        5887   	adc #3	   	;offset to step value
     5841   A4 40        5888   	ldy fndpnt+1
     5843   90 01        5889   	bcc next35
     5845   C8           5890   	iny
     5846                5891   next35
     5846   20 8BD4      5892   	jsr movfm	;actually "move from rom",but sys stack is in comm. ram
                         5893   ;
                         5894   ; movfm doesn't move sign. get it.
                         5895   ;

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 85-1
NEXT Command   NEXT.SRC

Error Addr  Code          Seq   Source statement

     5849   A0 08        5896   	ldy #8
     584B   B1 3F        5897   	lda (fndpnt),y
     584D   85 68        5898   	sta facsgn
                         5899   ;
                         5900   ; get pointer to 'for' variable
                         5901   ;
     584F   A0 01        5902   	ldy #1
     5851   B1 3F        5903   	lda (fndpnt),y	;get lsb
     5853   48           5904   	pha
     5854   AA           5905   	tax
     5855   C8           5906   	iny
     5856   B1 3F        5907   	lda (fndpnt),y	;get msb
     5858   48           5908   	pha
     5859   A8           5909   	tay	      	;msb in y,
     585A   8A           5910   	txa	      	;lsb in a
                         5911   
     585B   20 8845      5912   	jsr fadd	;add 'step' value to 'for' varible (fadd gets from bank 1)
     585E   68           5913   	pla	      	;re-get msb
     585F   A8           5914   	tay	      	;msb in y,
     5860   68           5915   	pla
     5861   AA           5916   	tax	      	;lsb in x
     5862   8D FF04      5917   	sta sw_rom_ram1	;variables are in bank 1
     5865   20 8C00      5918   	jsr movmf	;put result back into 'for' variable.
                         5919   ;
                         5920   ; make (a,y) point to 'to' value in stack
                         5921   ;
     5868   A5 3F        5922   	lda fndpnt
     586A   18           5923   	clc
     586B   69 09        5924   	adc #9
     586D   A4 40        5925   	ldy fndpnt+1
     586F   90 01        5926   	bcc next40
     5871   C8           5927   	iny
                         5928   ;
                         5929   ; test if loop done
                         5930   ;
     5872   8D FF03      5931   next40	sta sw_rom_ram0
     5875   20 8C87      5932   	jsr fcomp	;compare fac to value pointed to by (a,y)
     5878   A0 08        5933   	ldy #8
     587A   38           5934   	sec
     587B   F1 3F        5935   	sbc (fndpnt),y
     587D   F0 98        5936   	beq next50	;branch taken if done
                         5937   ;
                         5938   ; not done, set pointers to re-execute loop
                         5939   ;
     587F   A0 11        5940   	ldy #17
     5881   B1 3F        5941   	lda (fndpnt),y
     5883   85 3D        5942   	sta txtptr
     5885   88           5943   	dey
     5886   B1 3F        5944   	lda (fndpnt),y
     5888   85 3E        5945   	sta txtptr+1
     588A   88           5946   	dey
     588B   B1 3F        5947   	lda (fndpnt),y
     588D   85 3C        5948   	sta curlin+1
     588F   88           5949   	dey
     5890   B1 3F        5950   	lda (fndpnt),y

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 85-2
NEXT Command   NEXT.SRC

Error Addr  Code          Seq   Source statement

     5892   85 3B        5951   	sta curlin
     5894                5952   next45
     5894   60           5953   	rts
                         5954   
                         5955   ;end
                         5956   	.include dim		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 86
DIM Statement   DIM.SRC

Error Addr  Code          Seq   Source statement

                         5958   	.subttl DIM Statement
                         5959   
                         5960   ;	The 'dim' code sets [dimflg] and then falls into the variable search
                         5961   ;	routine, which looks at dimflg at 3 different points:
                         5962   ;
                         5963   ;		1) if an entry is found, 'dimflg' being on indicates
                         5964   ;		   a doublly-defined variable.
                         5965   ;		2) when a new entry is being built, 'dimflg' being on indicates
                         5966   ;		   the indices should be used for the size of each index.
                         5967   ;		   Otherwise the default of ten is used.
                         5968   ;		3) When the build entry code finishes, indexing will be done
                         5969   ;		   only if 'dimflg' is off.
                         5970   
                         5971   
     5895   20 79F9      5972   dim3	jsr chkcom	;must be a comma.
     5898   AA           5973   dim	tax		;make .x non-zero (.a must be non zero to work correctly)
     5899   20 7B51      5974   	jsr ptrgt1
     589C   20 0386      5975   	jsr chrgot	;get last character.
     589F   D0 F4        5976   	bne dim3
     58A1   60           5977   	rts
                         5978   
                         5979   ;end
                         5980   	.include sys		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 87
SYS Command   SYS.SRC

Error Addr  Code          Seq   Source statement

                         5982   	.subttl SYS Command
                         5983   
                         5984   
     58A2   20 8812      5985   sys	jsr getwrd	;convert arg. to integer value
                         5986   
     58A5   A5 16        5987   	lda linnum	;set up arg's for call to 'long jsr'
     58A7   85 04        5988   	sta _pclo
     58A9   A5 17        5989   	lda linnum+1
     58AB   85 03        5990   	sta _pchi
     58AD   AD 03D5      5991   	lda current_bank
     58B0   85 02        5992   	sta _bank
                         5993   
     58B2   20 9E27      5994   	jsr optbyt	;(optional) .A reg arg
     58B5   90 02        5995   	bcc 10$
     58B7   86 06        5996   	stx _a_reg
                         5997   
     58B9   20 9E27      5998   10$	jsr optbyt	;(optional) .X reg arg
     58BC   90 02        5999   	bcc 20$
     58BE   86 07        6000   	stx _x_reg
                         6001   
     58C0   20 9E27      6002   20$	jsr optbyt	;(optional) .Y reg arg
     58C3   90 02        6003   	bcc 30$
     58C5   86 08        6004   	stx _y_reg
                         6005   
     58C7   20 9E27      6006   30$	jsr optbyt	;(optional) .S reg arg
     58CA   90 02        6007   	bcc 40$
     58CC   86 05        6008   	stx _s_reg
                         6009   
     58CE   4C FF6E      6010   40$	jmp _jjsr	;far, far away
                         6011   
                         6012   ;end
                         6013   	.include trontroff	;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 88
TRON / TROFF Commands   TRONTROFF.SRC

Error Addr  Code          Seq   Source statement

                         6015   	.subttl TRON / TROFF Commands
                         6016   
     58D1                6017   tron			;trace mode on
     58D1   A9 FF        6018   	lda #$ff
     58D3   2C           6019   	.byte $2c
                         6020   
     58D4                6021   troff			;trace mode off
     58D4   A9 00        6022   	lda #0
     58D6   8D 116F      6023   	sta trcflg
     58D9   60           6024   	rts
                         6025   
                         6026   ;end
                         6027   	.include rreg		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 89
RREG Command   RREG.SRC

Error Addr  Code          Seq   Source statement

                         6029   	.subttl	RREG Command
                         6030   
                         6031   ;
                         6032   ; RREG - return values of 6502 registers following a SYS call.
                         6033   ;
                         6034   ; Syntax : RREG [.A variable [,[.X variable] [,[.Y variable] [,[.S variable] ]]]
                         6035   
     58DA   A9 00        6036   rreg	lda #0
     58DC   85 0D        6037   	sta count
                         6038   
     58DE   20 0386      6039   10$	jsr chrgot
     58E1   F0 37        6040   	beq 50$			;reached end of statement - quit
     58E3   C9 2C        6041   	cmp #','		;skip this arg?
     58E5   F0 21        6042   	beq 30$			;branch if so
     58E7   20 7B4C      6043   	jsr ptrget		;get pointer to target variable
     58EA   85 4B        6044   	sta forpnt		;a little bit of set up so we can share LET code
     58EC   84 4C        6045   	sty forpnt+1
     58EE   A5 0F        6046   	lda valtyp		;what kind of variable name did ptrget find?
     58F0   D0 29        6047   	bne 99$			;error if non-zero (string)
                         6048   
     58F2   A4 0D        6049   	ldy count		;which register's value are we looking for?
     58F4   B9 0006      6050   	lda _a_reg,y		;.A, .X, & .Y are contiguious
     58F7   C0 03        6051   	cpy #3
     58F9   D0 02        6052   	bne 20$
     58FB   A5 05        6053   	lda _s_reg		;... .S isn't.
                         6054   
     58FD   A8           6055   20$	tay			;low byte in .Y,
     58FE   A9 00        6056   	lda #0			;high byte of zero,
     5900   20 79D9      6057   	jsr givayf		;..and go float it.
     5903   A5 10        6058   	lda intflg		;set conditions for type of var (int/float)
     5905   20 5400      6059   	jsr qintgr		;..and use part of 'LET' to do the work
                         6060   
     5908   E6 0D        6061   30$	inc count		;only 4 registers to do
     590A   A5 0D        6062   	lda count
     590C   C9 04        6063   	cmp #4
     590E   B0 0A        6064   	bcs 50$
     5910   20 0386      6065   	jsr chrgot		;was this e-o-statement?
     5913   F0 05        6066   	beq 50$
     5915   20 0380      6067   	jsr chrget		;not e-o-s, skip over comma,
     5918   D0 C4        6068   	bne 10$			;..and go do next
                         6069   
     591A   60           6070   50$	rts
                         6071   
     591B   4C 7884      6072   99$	jmp chkerr		;type mismatch error (gotta rename that someday)
                         6073   
                         6074   
                         6075   ;end
                         6076   	.include midequal	;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 90
MID$ Pseudo-variable   MIDEQUAL.SRC

Error Addr  Code          Seq   Source statement

                         6078   	.subttl MID$ Pseudo-variable
                         6079   
                         6080   ; alternate use of the mid$ fn., as the target of an assignment stmt.
                         6081   ;
                         6082   ; mid$(string_var,starting_position [,length]) = string_expression
                         6083   
     591E                6084   midd2
                         6085   
            =591D        6086   midwrk	=midd2-1
                         6087   
     591E   20 79F6      6088   	jsr chkopn		;check for '('
     5921   20 7B4C      6089   	jsr ptrget		;get pointer to descriptor of string-var
     5924   85 4B        6090   	sta forpnt		;store for later use
     5926   84 4C        6091   	sty forpnt+1
     5928   20 787A      6092   	jsr chkstr		;check if string
                         6093   
     592B   20 8809      6094   	jsr combyt		;look for comma, followed by 1 byte starting address
     592E   CA           6095   	dex			;adjust starting addr.
     592F   86 78        6096   	stx hulp		;store    "	"
                         6097   
     5931   C9 29        6098   	cmp #')'		;finished?
     5933   F0 04        6099   	beq 10$			;branch if so (use default length)
     5935   20 8809      6100   	jsr combyt		;..else get length
     5938   2C           6101   	.byte $2c
                         6102   
     5939   A2 FF        6103   10$	ldx #$ff		;default length
     593B   86 77        6104   	stx z_p_temp_1
     593D   20 79F3      6105   	jsr chkcls		;look for ')'
     5940   A9 B2        6106   	lda #equltk		;look for '='
     5942   20 79FB      6107   	jsr synchr
                         6108   
     5945   20 788C      6109   	jsr frmevl		;bring on the source!
     5948   20 787A      6110   	jsr chkstr		;nothing funny.
                         6111   
     594B   A0 02        6112   	ldy #2	   		;get string descriptors
     594D   A9 4B        6113   20$	lda #forpnt		;target
     594F   20 03AB      6114   	jsr indsub_ram1		;lda (forpnt),y
     5952   99 005D      6115   	sta str1,y
     5955   20 4304      6116   	jsr indfmo		;source
     5958   99 0060      6117   	sta str2,y
     595B   88           6118   	dey
     595C   10 EF        6119   	bpl 20$
                         6120   
                         6121   ; test for target string in text was removed-  all strings in ted are
                         6122   ; copied to string ram when they are created.
     595E   38           6123   	sec			;adjust pointer to source string so that the same
     595F   A5 61        6124   	lda str2+1		;..index can load & save
     5961   E5 78        6125   	sbc hulp
     5963   85 61        6126   	sta str2+1
     5965   B0 02        6127   	bcs *+4
     5967   C6 62        6128   	dec str2+2
                         6129   
     5969   A5 77        6130   	lda z_p_temp_1		;get specified length (or default)
     596B   C5 60        6131   	cmp str2		;compare with length of source
     596D   90 02        6132   	bcc *+4	  		;ok if less,

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 90-1
MID$ Pseudo-variable   MIDEQUAL.SRC

Error Addr  Code          Seq   Source statement

     596F   A5 60        6133   	lda str2		;..else use length of source
     5971   AA           6134   	tax
     5972   F0 18        6135   	beq 80$			;done if length=0
     5974   18           6136   	clc
     5975   65 78        6137   	adc hulp		;add length to starting posn.
     5977   B0 16        6138   	bcs 98$			;error if > 256,
     5979   C5 5D        6139   	cmp str1
     597B   90 02        6140   	bcc *+4
     597D   D0 10        6141   	bne 98$			;...or if > target length.
                         6142   
     597F   A4 78        6143   	ldy hulp		;get adjusted starting address
     5981   A9 61        6144   70$	lda #str2+1
     5983   20 03AB      6145   	jsr indsub_ram1		;fetch from string bank
     5986   91 5E        6146   	sta (str1+1),y		;this is what it's all about
     5988   C8           6147   	iny
     5989   CA           6148   	dex
     598A   D0 F5        6149   	bne 70$			;keep going for specified length
                         6150   
     598C   4C 8781      6151   80$	jmp frefac		;free up temp. string, rts
                         6152   
     598F   4C 7DC5      6153   98$	jmp fcerr		;illegal quantity error
                         6154   
                         6155   ;end
                         6156   	.include auto		;command
                         6157   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 91
AUTO Command   AUTO.SRC

Error Addr  Code          Seq   Source statement

                         6159   	.subttl AUTO Command
                         6160   
                         6161   ; auto increment
                         6162   ;	  syntax :    auto {line-number}
                         6163   ;      line-number = 0 means turn off
                         6164   
     5992                6165   auto
     5992   20 84F0      6166   	jsr errind
     5995   20 50BD      6167   	jsr linget
     5998   A5 16        6168   	lda linnum
     599A   85 74        6169   	sta autinc
     599C   A5 17        6170   	lda linnum+1
     599E   85 75        6171   	sta autinc+1
     59A0   4C 4D54      6172   	jmp ready
                         6173   
                         6174   ;end
                         6175   	.include help		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 92
HELP Command   HELP.SRC

Error Addr  Code          Seq   Source statement

                         6177   	.subttl HELP Command
                         6178   
     59A3   AE 1208      6179   help	ldx errnum	;anything to do?
     59A6   E8           6180   	inx
     59A7   F0 1D        6181   	beq 1$		;no errors
     59A9   AD 1209      6182   	lda errlin
     59AC   AC 120A      6183   	ldy errlin+1
     59AF   85 16        6184   	sta linnum
     59B1   84 17        6185   	sty linnum+1
     59B3   20 5081      6186   	jsr fndlin	;find the beginning of line with error
     59B6   90 0E        6187   	bcc 1$		;we've been deceived!
     59B8   66 55        6188   	ror helper	;ok, set help flag
     59BA   20 55B5      6189   	jsr crdo	;new line
     59BD   A6 16        6190   	ldx linnum
     59BF   A5 17        6191   	lda linnum+1
     59C1   20 5140      6192   	jsr p1line	;show him where error was
     59C4   46 55        6193   	lsr helper	;clear help flag just in case 'p1line' had problems
     59C6   4C 55B5      6194   1$	jmp crdo	;and return to caller
                         6195   
                         6196   
     59C9   A6 62        6197   helpsb	ldx lowtr+1	;has 'list' reached code in error?
     59CB   98           6198   	tya
     59CC   18           6199   	clc
     59CD   65 61        6200   	adc lowtr	;add .y index to line pointer...
     59CF   90 01        6201   	bcc 1$
     59D1   E8           6202   	inx
     59D2   EC 120F      6203   1$	cpx errtxt+1	;and compare to error pointer
     59D5   D0 14        6204   	bne 3$		;no
     59D7   CD 120E      6205   	cmp errtxt
     59DA   90 0F        6206   	bcc 3$
     59DC   F0 0D        6207   	beq 3$
     59DE   46 55        6208   	lsr helper	;yes: remove list wedge...
     59E0   A9 12        6209   	lda #$12	;assume 40 col : reverse
     59E2   24 D7        6210   	bit _mode	; 80 col?
     59E4   10 02        6211   	bpl 2$		; it was 40!
     59E6   A9 02        6212   	lda #$02	;80 uses underline
     59E8   4C 5629      6213   2$	jmp outdo
                         6214   
     59EB   60           6215   3$	rts
                         6216   
                         6217   ;end
                         6218   	.include gosubgoto	;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 93
gosub / goto routines   GOSUBGOTO.SRC

Error Addr  Code          Seq   Source statement

                         6220   	.subttl gosub / goto routines
                         6221   
                         6222   ; gosub. push text pointer, line #, & gosub token on stack:
                         6223   ;
                         6224   ;		(bottom) highest memory
                         6225   ;===========================================================
                         6226   ;		txtptr+1 address of next statement
                         6227   ;		txtptr
                         6228   ;		========
                         6229   ;		curlin+1 current line number
                         6230   ;		curlin
                         6231   ;		========
                         6232   ;		'gosub' token <== (tos) top of stack pointer
                         6233   ;===========================================================
                         6234   ;		(top of stack) lowest memory
                         6235   
     59EC   20 5A3A      6236   gosub	jsr gosub_sub
     59EF   20 0386      6237   	jsr chrgot	;get character and set carry for linget.
     59F2   20 59F8      6238   	jsr goto
     59F5   4C 4B13      6239   	jmp newstt
                         6240   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 94
gosub / goto routines   GOSUBGOTO.SRC

Error Addr  Code          Seq   Source statement

                         6242   
     59F8   20 50BD      6243   goto	jsr linget	;pick up the line number in "linnum".
     59FB   A5 0A        6244   	lda endchr	;test if linget found any number
     59FD   F0 38        6245   	beq no_number_error
                         6246   
     59FF   20 52C2      6247   goto_1	jsr remn	;jump to end of line. (entry for interrupt code)
     5A02   38           6248   	sec
     5A03   A5 3B        6249   	lda curlin
     5A05   E5 16        6250   	sbc linnum
     5A07   A5 3C        6251   	lda curlin+1
     5A09   E5 17        6252   	sbc linnum+1
     5A0B   B0 0B        6253   	bcs luk4it
     5A0D   98           6254   	tya
     5A0E   38           6255   	sec
     5A0F   65 3D        6256   	adc txtptr
     5A11   A6 3E        6257   	ldx txtptr+1
     5A13   90 07        6258   	bcc lukall
     5A15   E8           6259   	inx
     5A16   B0 04        6260   	bcs lukall	;always goes.
                         6261   
     5A18   A5 2D        6262   luk4it	lda txttab
     5A1A   A6 2E        6263   	ldx txttab+1
                         6264   
     5A1C   20 5085      6265   lukall	jsr fndlnc	;(a,x) are all set up.
     5A1F   90 11        6266   	bcc userr	;undefined statement error
     5A21   A5 61        6267   	lda lowtr
     5A23   E9 01        6268   	sbc #1
     5A25   85 3D        6269   	sta txtptr
     5A27   A5 62        6270   	lda lowtr+1
     5A29   E9 00        6271   	sbc #0
     5A2B   85 3E        6272   	sta txtptr+1
     5A2D   24 7F        6273   	bit runmod	;in direct mode?
     5A2F   10 6D        6274   	bpl setexc	;yes
     5A31   60           6275   	rts
                         6276   
     5A32   A2 11        6277   userr	ldx #errus
     5A34   4C 4D59      6278   	jmp error
                         6279   
     5A37                6280   no_number_error
     5A37   4C 7A09      6281   	jmp snerr
                         6282   
                         6283   
                         6284   
     5A3A                6285   gosub_sub
     5A3A   A9 05        6286   	lda #lengos	;free up necessary space on stack
     5A3C   20 501B      6287   	jsr getstk	;make sure there is room.
     5A3F   A0 04        6288   	ldy #lengos-1
     5A41   A5 3E        6289   	lda txtptr+1	;push on the text pointer.
     5A43   91 7D        6290   	sta (tos),y
     5A45   88           6291   	dey
     5A46   A5 3D        6292   	lda txtptr
     5A48   91 7D        6293   	sta (tos),y
     5A4A   88           6294   	dey
     5A4B   A5 3C        6295   	lda curlin+1	;push on the curent line number.
     5A4D   91 7D        6296   	sta (tos),y

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 94-1
gosub / goto routines   GOSUBGOTO.SRC

Error Addr  Code          Seq   Source statement

     5A4F   88           6297   	dey
     5A50   A5 3B        6298   	lda curlin
     5A52   91 7D        6299   	sta (tos),y
     5A54   88           6300   	dey
     5A55   A9 8D        6301   	lda #gosutk	(acca) were smashed by getstk.
     5A57   91 7D        6302   	sta (tos),y
     5A59   60           6303   	rts
                         6304   
                         6305   ;.end
                         6306   	.include go		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 95
GO   GO.SRC

Error Addr  Code          Seq   Source statement

                         6308   	.subttl GO 
                         6309   
     5A5A                6310   go_without_to
     5A5A   20 0380      6311   	jsr chrget		;what is next character?
     5A5D   C9 A4        6312   	cmp #totk		;..is it GO TO?
     5A5F   D0 06        6313   	bne 1$
     5A61   20 0380      6314   	jsr chrget		;..yes, set up for goto
     5A64   4C 59F8      6315   	jmp goto		;..bye!
                         6316   
     5A67   20 87F4      6317   1$	jsr getbyt		;is it GO 64?
     5A6A   E0 40        6318   	cpx #64
     5A6C   F0 03        6319   	beq 2$			;..it's twooo! it's twooo!
     5A6E   4C 7A09      6320   	jmp snerr
                         6321   
                         6322   ; The user wants to go to C64 mode.
                         6323   
     5A71   20 A7F1      6324   2$	jsr are_you_sure
     5A74   D0 06        6325   	bne 5$			;must have had second thoughts. never mind.
     5A76   20 A855      6326   	jsr put_io_in_map
     5A79   4C FF4D      6327   	jmp _go_64
                         6328   
     5A7C   60           6329   5$	rts
                         6330   
                         6331   ;end
                         6332   	.include continue	;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 96
CONTINUE Command   CONTINUE.SRC

Error Addr  Code          Seq   Source statement

                         6334   	.subttl CONTINUE Command
                         6335   ;**********************************************************
                         6336   ;*
                         6337   ;*	continue execution after stop/end
                         6338   ;*
                         6339   ;*
                         6340   ;**********************************************************
     5A7D   D0 38        6341   cont	bne cont_rts		;make sure there is a terminator.
                         6342   
     5A7F   24 7F        6343   	bit runmod		;if in run-mode, just rts
     5A81   30 34        6344   	bmi cont_rts
                         6345   
     5A83   A2 1A        6346   	ldx #errcn		;continue error.
     5A85   AC 1203      6347   	ldy oldtxt+1		;a stored txtptr of zero is set up
     5A88   D0 03        6348   	bne 1$			;by stkini and indicates there is nothing to continue.
     5A8A   4C 4D59      6349   	jmp error		;"stop", "end", typing crlf to
                         6350   
     5A8D   AD 1202      6351   1$	lda oldtxt		;"input" and ^c setup oldtxt
     5A90   85 3D        6352   	sta txtptr
     5A92   84 3E        6353   	sty txtptr+1
     5A94   AD 1200      6354   	lda oldlin
     5A97   AC 1201      6355   	ldy oldlin+1
     5A9A   85 3B        6356   	sta curlin
     5A9C   84 3C        6357   	sty curlin+1
                         6358   
     5A9E   A9 80        6359   setexc	lda #$80
     5AA0   85 7F        6360   	sta runmod		;set up run mode
     5AA2   0A           6361   	asl a	    		;.a=0
     5AA3   85 74        6362   	sta autinc		;turn auto increment off
     5AA5   85 75        6363   	sta autinc+1
     5AA7   8D 127F      6364   	sta intval		;enable & reset collision-trapping mechanism
     5AAA   85 F6        6365   	sta _autoinsert		;disable auto-insert mode
                         6366   
     5AAC   A2 02        6367   	ldx #2			;turn off all interrupt trip flags
     5AAE   9D 1276      6368   10$	sta int_trip_flag,x
     5AB1   CA           6369   	dex
     5AB2   10 FA        6370   	bpl 10$
                         6371   
     5AB4   4C FF90      6372   	jmp _setmsg		;turn kernal messages off & rts
                         6373   
     5AB7                6374   cont_rts
     5AB7   60           6375   	rts
                         6376   
                         6377   ;end
                         6378   	.include run		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 97
'run command'   RUN.SRC

Error Addr  Code          Seq   Source statement

                         6380   	.subttl 'run command'
                         6381   ;************************************************************
                         6382   ;*
                         6383   ;*	run command
                         6384   ;*
                         6385   ;*	run [line_number]
                         6386   ;*	   | filename [[ON] Ddrive_number[,Uunit_number]]
                         6387   ;*
                         6388   ;*
                         6389   ;*	ENTRY run_a_program sets up, links, and executes
                         6390   ;*		a program previously loaded into ram.
                         6391   ;*
                         6392   ;***********************************************************
                         6393   
     5AB8   F0 18        6394   run	beq run$10		;branch if no arguments
     5ABA   90 1C        6395   	bcc run$20		;branch if number (i.e., RUN line_number)
                         6396   
                         6397   ; here if of the form "RUN file_name"
                         6398   
     5ABC   A9 40        6399   	lda #$40
     5ABE   85 7F        6400   	sta runmod		;signal to load not to go to ready
     5AC0   20 A1B7      6401   	jsr dload		;use DLOAD's parser, and load the program.
                         6402   
     5AC3                6403   run_a_program
                         6404   
     5AC3   20 5A9E      6405   	jsr setexc		;set various run modes
     5AC6   20 5210      6406   	jsr runc
     5AC9   20 4F6C      6407   	jsr lnkprg		;link the program,
     5ACC   20 55B5      6408   	jsr crdo
     5ACF   4C 4B13      6409   	jmp newstt		;...start executing.
                         6410   
                         6411   ; here if of the form "RUN"
                         6412   
     5AD2   20 5A9E      6413   run$10	jsr setexc		;set various run codes
     5AD5   4C 5210      6414   	jmp runc		;..and start executing
                         6415   
                         6416   ; here if of the form "RUN line_number"
                         6417   
     5AD8   20 5217      6418   run$20	jsr clearc		;first trash all variables (???????)
     5ADB   20 0386      6419   	jsr chrgot
     5ADE   20 59F8      6420   	jsr goto		;set up to execute from new line number
     5AE1   20 5A9E      6421   	jsr setexc		;..and do a little housekeeping,
     5AE4   4C 4B13      6422   	jmp newstt		;..otherwise it's business as usual.
                         6423   
                         6424   ;end
                         6425   	.include restore	;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 98
restore command   RESTORE.SRC

Error Addr  Code          Seq   Source statement

                         6427   	.subttl restore command
                         6428   ;*********************************************************************
                         6429   ;*
                         6430   ;* restore command
                         6431   ;*
                         6432   ;* reset pointers to next data statement. allows optional argument
                         6433   ;* specifying a specific line number, otherwise default is
                         6434   ;* beginning of text area.
                         6435   ;*
                         6436   ;*********************************************************************
     5AE7                6437   restor
     5AE7   F0 15        6438   	beq restore$1	;branch if no argument...use default
     5AE9   20 8812      6439   	jsr getwrd	;get 2 byte argument
     5AEC   84 16        6440   	sty linnum
     5AEE   85 17        6441   	sta linnum+1
     5AF0   20 5081      6442   	jsr fndlin	;get pointer to specified line
     5AF3   B0 03        6443   	bcs 1$		;branch if found...
     5AF5   4C 5A32      6444   	jmp userr	;else flag an error
     5AF8   A5 61        6445   1$	lda lowtr	;decrement 2 byte pointer, and save it
     5AFA   A4 62        6446   	ldy lowtr+1
     5AFC   B0 05        6447   	bcs restore$2		;always
                         6448   
     5AFE                6449   restore$1
     5AFE   38           6450   	sec
     5AFF   A5 2D        6451   	lda txttab
     5B01   A4 2E        6452   	ldy txttab+1
     5B03                6453   restore$2
     5B03   E9 01        6454   	sbc #1
     5B05   B0 01        6455   	bcs 1$
     5B07   88           6456   	dey
     5B08   85 43        6457   1$	sta datptr
     5B0A   84 44        6458   	sty datptr+1
     5B0C   60           6459   	rts
                         6460   
                         6461   ;end
                         6462   	.include renumber	;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 99
renumber   RENUMBER.SRC

Error Addr  Code          Seq   Source statement

                         6464   	.subttl renumber
                         6465   
                         6466   ;***********************************************************************
                         6467   ;
                         6468   ; renumber                                 
                         6469   ;                                          
                         6470   ; 	syntax:                                  
                         6471   ;   	  renumber [n1 [,[n2] ,n3]]              
                         6472   ;           n1 =new start line number, default 10 
                         6473   ;           n2 =line increment, default 10        
                         6474   ;           n3 =start line, default first         
                         6475   ;                                          
                         6476   ; 	syntax error may occur for missing commas or bad line numbers
                         6477   ;   	illegal quantity error for line inc. of 0 & for bad ren. range
                         6478   ; 	overflow error if increment wraps line number during renumber
                         6479   ;	line number too large error if renumbering would force line
                         6480   ;       	numbers greater than 63999
                         6481   ;	out of memory error if the renumbered program would be too large
                         6482   ;	unresolved reference error if an imbedded line number references
                         6483   ;	       a line which does not exit
                         6484   ;                                             
                         6485   ; 	returns to ready mode on completion of renumber
                         6486   ;                                          				
                         6487   ;***********************************************************************
                         6488   
                         6489   
                         6490   ; before actually renumbering the program, two preliminary passes are
                         6491   ; made to insure no errors would occur during the actual renumbering
                         6492   ; process (as detailed below)
                         6493   ;
                         6494   ; pass1 makes sure that the renumbered program would have no line
                         6495   ; numbers greater than 63999 (nothing is actually renumbered; the 
                         6496   ; statement table is not modified)
                         6497   ;
                         6498   ; pass 2 checks if the renumbered program would be too long and also
                         6499   ; checks for non-existant line number destinations
                         6500   ;
                         6501   ; pass 3 examines the entire statement table first for imbedded line
                         6502   ; numbers (branches) to fix. this is done by looking for keywords (goto,
                         6503   ; gosub, then, run) which are usually followed by line numbers. the old
                         6504   ; line number is mapped to a new value and the string representing the 
                         6505   ; new branch label replaces the original text. 
                         6506   ;
                         6507   ; pass 4 then replaces the statement number bytes by their final values. 
                         6508   ; lastly, the table is relinked.
                         6509   
                         6510   
     5B0D                6511   testwd
     5B0D   89 8A 8D     6512           .byte gototk,runtk,gosutk,thentk,resttk,resutk,traptk,elsetk
     5B10   A7 8C D6            
     5B13   D7 D5               
                         6513   
     5B15                6514   renum
     5B15   20 84F0      6515   	jsr errind		;allowed only in direct mode
                         6516   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 99-1
renumber   RENUMBER.SRC

Error Addr  Code          Seq   Source statement

                         6517   ; set up default values for n1, n2, and n3
                         6518   
     5B18   A9 00        6519   	lda #0	   		;line #10...
     5B1A   A2 0A        6520   	ldx #10
     5B1C   8E 1170      6521   	stx renum_tmp_1		;default renum origin (n1)
     5B1F   8D 1171      6522   	sta renum_tmp_1+1
     5B22   8E 1172      6523   	stx renum_tmp_2		;default increment (n2)
     5B25   8D 1173      6524   	sta renum_tmp_2+1
     5B28   85 5C        6525   	sta hightr		;default start line # (n3)
     5B2A   85 5D        6526   	sta hightr+1
                         6527   
     5B2C   20 0386      6528   	jsr chrgot		;any parameters?
     5B2F   F0 54        6529   	beq ren_pass_1		;no...
                         6530   
                         6531   
                         6532   ; check for new starting line number (n1)
                         6533   
     5B31   20 50BD      6534   	jsr linget		;check for a number
     5B34   A5 0A        6535   	lda endchr		;was there one?
     5B36   F0 0A        6536   	beq renum_10		;no...use default
     5B38   A5 16        6537   	lda linnum
     5B3A   A6 17        6538   	ldx linnum+1
     5B3C   8D 1170      6539   	sta renum_tmp_1
     5B3F   8E 1171      6540   	stx renum_tmp_1+1
                         6541   
                         6542   ; check for new increment
                         6543   
     5B42                6544   renum_10
     5B42   20 9E0F      6545   	jsr optwrd		;an increment given?
     5B45   90 0E        6546    	bcc renum_30		;no...use default
                         6547   
     5B47   8C 1172      6548   	sty renum_tmp_2
     5B4A   8D 1173      6549   	sta renum_tmp_2+1
     5B4D   0D 1172      6550   	ora renum_tmp_2		;increment must be >0
     5B50   D0 03        6551   	bne renum_30		;ok
                         6552   
     5B52                6553   renum_20
     5B52   4C 7DC5      6554   	jmp fcerr		;illegal quantity error
                         6555   
                         6556   
                         6557   ; check for starting line number
                         6558   
     5B55                6559   renum_30
     5B55   20 9E0F      6560   	jsr optwrd		;starting line number given?
     5B58   90 2B        6561   	bcc ren_pass_1		;no...
                         6562   
     5B5A   84 5C        6563   	sty hightr
     5B5C   84 16        6564   	sty linnum		
     5B5E   85 5D        6565   	sta hightr+1
     5B60   85 17        6566   	sta linnum+1
     5B62   20 5081      6567   	jsr fndlin		;test for illegal renumber range
     5B65   A5 61        6568   	lda lowtr		;(n1 must be >= n3)
     5B67   A6 62        6569   	ldx lowtr+1
     5B69   85 5A        6570   	sta highds		;pointer to first statement to renumber
     5B6B   86 5B        6571   	stx highds+1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 99-2
renumber   RENUMBER.SRC

Error Addr  Code          Seq   Source statement

     5B6D   AD 1170      6572   	lda renum_tmp_1
     5B70   AE 1171      6573   	ldx renum_tmp_1+1
     5B73   85 16        6574   	sta linnum
     5B75   86 17        6575   	stx linnum+1
     5B77   20 5081      6576   	jsr fndlin		;lowtr = ptr to 1st stmt to be overlapped
     5B7A   38           6577   	sec
     5B7B   A5 61        6578   	lda lowtr		;can't be smaller
     5B7D   E5 5A        6579   	sbc highds
     5B7F   A5 62        6580   	lda lowtr+1
     5B81   E5 5B        6581   	sbc highds+1
     5B83   90 CD        6582   	bcc renum_20		;bad...
                         6583   
                         6584   
                         6585   ;***********************************************************************
                         6586   ;*************************  p a s s    o n e  **************************
                         6587   ;***********************************************************************
                         6588   
                         6589   ; pass1 makes sure that the renumbered program will not have any line numbers
                         6590   ; greater than 63999 (however, nothing is actually renumbered in this pass)
                         6591   
     5B85                6592   ren_pass_1
     5B85   20 5D85      6593   	jsr n1_reset		;put n1 in fac, reset txtptr
                         6594   
     5B88   20 5DB9      6595   	jsr chargt		;skip low link
     5B8B   C8           6596   	iny			;(.y=1)
     5B8C   20 03C9      6597   	jsr indtxt		;skip high link
     5B8F   F0 3A        6598   	beq ren_pass_2		;end of program => exit
                         6599   
     5B91                6600   r_pass1_10
     5B91   C8           6601   	iny			;(.y=2)
     5B92   20 03C9      6602   	jsr indtxt		;line number low
     5B95   38           6603   	sec
     5B96   E5 5C        6604   	sbc hightr		;in line range which is to be renumbered?
     5B98   C8           6605   	iny			;(.y=3)
     5B99   20 03C9      6606   	jsr indtxt		;line number high
     5B9C   E5 5D        6607   	sbc hightr+1
     5B9E   B0 07        6608   	bcs r_pass1_20		;yes => fake renumbering
     5BA0   20 5BBA      6609   	jsr set_next		;goto next line
     5BA3   D0 EC        6610   	bne r_pass1_10		;if z=0 then not end-of-text => keep going
     5BA5   F0 24        6611   	beq ren_pass_2		;	else end
                         6612   
     5BA7                6613   r_pass1_20
     5BA7   20 5BBA      6614   	jsr set_next		;goto next line
     5BAA   F0 1F        6615   	beq ren_pass_2		;if z=1 then end-of-text => exit
     5BAC   20 5DA6      6616   	jsr new_num		;create next line number
     5BAF   B0 04        6617   	bcs r_pass1_30		;if c=1 then it wrapped => error
     5BB1   C9 F9        6618   	cmp #>63999		;can't have lines > 63999
     5BB3   90 F2        6619   	bcc r_pass1_20		;if c=0 then ok
                         6620   
     5BB5                6621   r_pass1_30			;renumbering will generate an illegal line #
     5BB5   A2 26        6622   	ldx #err_too_large	;'line number too large' error
     5BB7   4C 4D59      6623   	jmp error
                         6624   
     5BBA                6625   set_next
     5BBA   A0 00        6626   	ldy #$00		;set for next basic line

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 99-3
renumber   RENUMBER.SRC

Error Addr  Code          Seq   Source statement

     5BBC   20 03C9      6627   	jsr indtxt		;low link
     5BBF   AA           6628   	tax
     5BC0   C8           6629   	iny			;(.y=1)
     5BC1   20 03C9      6630   	jsr indtxt		;high link
     5BC4   F0 04        6631   	beq set_end		;if z=1 then end of program => exit
     5BC6   86 3D        6632   	stx txtptr
     5BC8   85 3E        6633   	sta txtptr+1
     5BCA   60           6634   set_end	rts
                         6635   
                         6636   
                         6637   ;***********************************************************************
                         6638   ;*************************  p a s s    t w o  **************************
                         6639   ;***********************************************************************
                         6640   
                         6641   ; pass 2 checks if the renumbered program will be too long and also
                         6642   ; checks for non-existant line number destinations
                         6643   
     5BCB                6644   ren_pass_2
     5BCB   A9 01        6645   	lda #$01		;set flag for 'pass 2'
     5BCD   85 77        6646   	sta z_p_temp_1
     5BCF   AD 1210      6647   	lda text_top		;copy top-of-text pointer for later use
     5BD2   AE 1211      6648   	ldx text_top+1		;(we don't want to change original here)
     5BD5   85 3F        6649   	sta fndpnt
     5BD7   86 40        6650   	stx fndpnt+1
     5BD9   20 5C18      6651   	jsr imbed_lines		;search for imbedded lines (but don't change)
                         6652   
                         6653   
                         6654   ;***********************************************************************
                         6655   ;***********************  p a s s    t h r e e  ************************
                         6656   ;***********************************************************************
                         6657   
                         6658   ; pass 3 actually renumbers the imbedded destination line numbers
                         6659   ; which follow goto, gosub, trap, etc.
                         6660   
     5BDC                6661   ren_pass_3
     5BDC   C6 77        6662   	dec z_p_temp_1		;z_p_temp_1 = 0 (for pass 3)
     5BDE   20 5C18      6663   	jsr imbed_lines		;search for and update imbedded line #'s
                         6664   
                         6665   
                         6666   ;***********************************************************************
                         6667   ;************************  p a s s    f o u r  *************************
                         6668   ;***********************************************************************
                         6669   
                         6670   ; pass 4 actually renumbers the program line numbers
                         6671   
     5BE1                6672   ren_pass_4
     5BE1   20 5DB6      6673   	jsr chargt_x2		;skip link
     5BE4   F0 2F        6674   	beq ren_exit		;null => end-of-text, exit
     5BE6   20 5DB9      6675   	jsr chargt		;not null...
     5BE9   85 16        6676   	sta linnum		;if line# >= start#, replace with facho
     5BEB   C8           6677   	iny
     5BEC   20 03C9      6678   	jsr indtxt
     5BEF   38           6679   	sec
     5BF0   E5 5D        6680   	sbc hightr+1
     5BF2   90 19        6681   	bcc r_pass4_20		;no, let alone

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 99-4
renumber   RENUMBER.SRC

Error Addr  Code          Seq   Source statement

     5BF4   D0 06        6682   	bne r_pass4_10		;yes, replace
     5BF6   A5 16        6683   	lda linnum
     5BF8   E5 5C        6684   	sbc hightr
     5BFA   90 11        6685   	bcc r_pass4_20		;no, let alone
     5BFC                6686   r_pass4_10
     5BFC   A5 64        6687   	lda facho
     5BFE   91 3D        6688   	sta (txtptr),y		;hi
     5C00   88           6689   	dey
     5C01   A5 65        6690   	lda facho+1
     5C03   91 3D        6691   	sta (txtptr),y		;lo
     5C05   20 5DB9      6692   	jsr chargt		;skip past 2nd byte of line#
     5C08   20 5D9D      6693   	jsr line_inc		;incr line# and scan to eol
     5C0B   F0 D4        6694   	beq ren_pass_4		;always...
     5C0D                6695   r_pass4_20
     5C0D   20 5DB9      6696   	jsr chargt		;skip past line#
     5C10   20 5DA0      6697   	jsr scan_thru		;scan to eol
     5C13   F0 CC        6698   	beq ren_pass_4		;always...
                         6699   
                         6700   									
                         6701   ;*************************** ren_exit **********************************
                         6702   									
                         6703   ;exit: jsr lnkprg, fix text_top, jsr runc, jmp ready
                         6704   
     5C15                6705   ren_exit
     5C15   4C 5F02      6706   	jmp notdel	
                         6707   
                         6708   									
                         6709   ;************************** imbed_lines ********************************
                         6710   
                         6711   ; look for imbedded line #'s (after goto, gosub, etc.)
                         6712   ; but only change them in pass 3 (ie. z_p_temp_1 = 0)
                         6713   
     5C18                6714   imbed_lines
     5C18   20 5271      6715   	jsr stxtpt		;start at first line	
     5C1B                6716   next_line
     5C1B   20 5DB6      6717   	jsr chargt_x2		;skip link
     5C1E   D0 03        6718   	bne 10$			;not last (null) link
     5C20   4C 5D85      6719   	jmp n1_reset		;put current line # in fac, reset txtptr, exit
     5C23                6720   10$
     5C23   20 5DB9      6721   	jsr chargt		;line number
     5C26   85 4B        6722   	sta forpnt		;save in case there is an error
     5C28   20 5DB9      6723   	jsr chargt
     5C2B   85 4C        6724   	sta forpnt+1
     5C2D                6725   next_char
     5C2D   20 5DB9      6726   	jsr chargt		;first character in the line
     5C30                6727   chk_quote
     5C30   C9 22        6728   	cmp #'"'		;opening double quote?
     5C32   D0 0B        6729   	bne not_quote		;no...
     5C34   20 5DB9      6730   20$	jsr chargt		;scan line
     5C37   F0 E2        6731   	beq next_line		;end...
     5C39   C9 22        6732   	cmp #'"'		;close double quote
     5C3B   D0 F7        6733   	bne 20$ 		;no... continue
     5C3D   F0 EE        6734   	beq next_char		;yes... resume renumber
     5C3F                6735   not_quote
     5C3F   AA           6736   	tax			;end of line?

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 99-5
renumber   RENUMBER.SRC

Error Addr  Code          Seq   Source statement

     5C40   F0 D9        6737   	beq next_line		;yes...
     5C42   10 E9        6738   	bpl next_char		;not a token...
                         6739   
     5C44   A2 08        6740   	ldx #8	   		;check special token list
     5C46   DD 5B0C      6741   30$	cmp testwd-1,x
     5C49   F0 28        6742   	beq iline_10		;a match...
     5C4B   CA           6743   	dex
     5C4C   D0 F8        6744   	bne 30$  		;continue until zero
                         6745   
     5C4E   C9 CB        6746   	cmp #gotk		;wasn't in the token list. check for 'go to'
     5C50   D0 0B        6747   	bne chk_escape		;not 'go', go check for 'collision' *c128 fix*
     5C52   20 0380      6748   hop_1	jsr chrget		;got a 'go', look for 'to'
     5C55   F0 C4        6749   	beq next_line		;end of line, abort
     5C57   C9 A4        6750   	cmp #totk
     5C59   F0 18        6751   	beq iline_10		;got it! go to fix number routine
     5C5B   D0 D0        6752   	bne next_char		;no 'to', keep looking
                         6753   
                         6754   ; look for 'COLLISION'. This is an escape command. *c128 fix*
                         6755   
     5C5D                6756   chk_escape		
     5C5D   C9 FE        6757   	cmp #esc_cmd_tk	
     5C5F   D0 CC        6758   	bne next_char	
     5C61   20 0380      6759   	jsr chrget	
     5C64   F0 EC        6760   	beq hop_1     		;end of line ,abort
     5C66   C9 17        6761   	cmp #collision_tk	
     5C68   D0 C3        6762    	bne next_char	
     5C6A   20 0380      6763   40$	jsr chrget		;got it! skip over first argument
     5C6D   F0 E3        6764   	beq hop_1 		;end of line, abort
     5C6F   C9 2C        6765   	cmp #','
     5C71   D0 F7        6766   	bne 40$			;not there yet.	
                         6767   
                         6768   
     5C73                6769   iline_10
     5C73   A5 3D        6770   	lda txtptr		;save current txtptr
     5C75   8D 1200      6771   	sta oldlin
     5C78   A5 3E        6772   	lda txtptr+1
     5C7A   8D 1201      6773   	sta oldlin+1
     5C7D   20 0380      6774   	jsr chrget
     5C80   B0 AE        6775   	bcs chk_quote		;not a #...
     5C82   20 50BD      6776   	jsr linget		;get line # from text
     5C85   20 5D36      6777   	jsr form_line		;replace if this line # > n3 
     5C88   AD 1200      6778   	lda oldlin		;restore old txtptr
     5C8B   85 3D        6779   	sta txtptr
     5C8D   AD 1201      6780   	lda oldlin+1
     5C90   85 3E        6781   	sta txtptr+1
                         6782   
     5C92   20 0380      6783   	jsr chrget		;skip over leading spaces
     5C95   A5 3D        6784   	lda txtptr		;then backup (txtptr) by 1
     5C97   D0 02        6785   	bne iline_15
     5C99   C6 3E        6786   	dec txtptr+1
     5C9B                6787   iline_15
     5C9B   C6 3D        6788   	dec txtptr
                         6789   
     5C9D   A2 FF        6790   	ldx #$ff
     5C9F   A5 77        6791   	lda z_p_temp_1		;if this is pass2 then don't actually change

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 99-6
renumber   RENUMBER.SRC

Error Addr  Code          Seq   Source statement

     5CA1   F0 41        6792   	beq p3code		;if z=1 then pass3 => ok to change
     5CA3   20 7F2B      6793   	jsr p2code_patch	;	else pass2 => don't change
                         6794   				; (318018_03 mod: FAB; fix 'memory error' check)
     5CA6                6795   iline_20
     5CA6   C9 2C        6796   	cmp #','		;comma from 'on'?
     5CA8   F0 C9        6797   	beq iline_10		;it is...
     5CAA   D0 84        6798   	bne chk_quote		;no...
                         6799   
                         6800   
                         6801   ;*********** this part of imbed_lines executed in pass 2 only **********
                         6802   
     5CAC                6803   p2code				;updates text_top without actually changing lines
     5CAC   E8           6804   	inx
     5CAD   BD 0101      6805   	lda fbuffr+1,x		;get character from number
     5CB0   F0 1F        6806   	beq p2cd30		;end of number
     5CB2   20 0380      6807   	jsr chrget		;get digit from old number
     5CB5   90 F5        6808   	bcc p2code		;digit...move on
                         6809   
     5CB7   E6 3F        6810   p2cd10	inc fndpnt
     5CB9   D0 02        6811   	bne p2cd20
     5CBB   E6 40        6812   	inc fndpnt+1
     5CBD   38           6813   p2cd20	sec			;have we run out of memory (theoretically)?
     5CBE   A5 3F        6814   	lda fndpnt		;(compare with limit-of-memory pointer)
     5CC0   ED 1212      6815   	sbc max_mem_0
     5CC3   A5 40        6816   	lda fndpnt+1
     5CC5   ED 1213      6817   	sbc max_mem_0+1
     5CC8   B0 17        6818   	bcs p2cd60		;yes - error
     5CCA   E8           6819   	inx			;no - next...
     5CCB   BD 0101      6820   	lda fbuffr+1,x
     5CCE   D0 E7        6821   	bne p2cd10
     5CD0   60           6822   	rts			;no more
                         6823   
     5CD1                6824   p2cd30
     5CD1   20 0380      6825   	jsr chrget
     5CD4   B0 0A        6826   	bcs p2cd50		;old stuff after # is other char
     5CD6   A5 3F        6827   	lda fndpnt		;digit...move down
     5CD8   D0 02        6828   	bne p2cd40
     5CDA   C6 40        6829   	dec fndpnt+1
     5CDC   C6 3F        6830   p2cd40	dec fndpnt
     5CDE   90 F1        6831   	bcc p2cd30		;still digits...
     5CE0   60           6832   p2cd50	rts	
                         6833   
     5CE1   4C 4D57      6834   p2cd60	jmp omerr		;'out of memory' error
                         6835   
                         6836   
                         6837   ;*********** this part of imbed_lines executed in pass 3 only **********
                         6838   
     5CE4                6839   p3code
     5CE4   E8           6840   	inx
     5CE5   BD 0101      6841   p3cd10	lda fbuffr+1,x		;get character from number
     5CE8   F0 2C        6842   	beq p3cd30		;end of number
     5CEA   48           6843   	pha			;save digit from new number
                         6844   
     5CEB   20 5DB9      6845   	jsr chargt		;get digit from old number
     5CEE   C9 3A        6846   	cmp #':'		;command terminator or letter?

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 99-7
renumber   RENUMBER.SRC

Error Addr  Code          Seq   Source statement

     5CF0   B0 0C        6847   	bcs p3cd15
     5CF2   C9 20        6848   	cmp #' '		;space? (fix for goto10 :rem)
     5CF4   F0 08        6849   	beq p3cd15
     5CF6   38           6850   	sec
     5CF7   E9 30        6851   	sbc #'0'		;number?
     5CF9   38           6852   	sec
     5CFA   E9 D0        6853   	sbc #$d0
     5CFC   90 10        6854   	bcc p3cd20		;digit...move on
                         6855   
     5CFE   20 5DC4      6856   p3cd15	jsr move_init		;other char...move up  
     5D01   E6 6D        6857   	inc argmo
     5D03   20 5DFC      6858   	jsr moveup_20
     5D06   EE 1210      6859   	inc text_top
     5D09   D0 03        6860   	bne p3cd20
     5D0B   EE 1211      6861   	inc text_top+1
                         6862   
     5D0E                6863   p3cd20
     5D0E   68           6864   	pla
     5D0F   A0 00        6865   	ldy #0
     5D11   91 3D        6866   	sta (txtptr),y		;put new digit in new number
     5D13   E8           6867   	inx
     5D14   D0 CF        6868   	bne p3cd10		;branch always
                         6869   
     5D16                6870   p3cd30
     5D16   20 0380      6871   	jsr chrget
     5D19   B0 8B        6872   	bcs iline_20		;old stuff after # is other char
     5D1B                6873   p3cd40				;digit...move down
     5D1B   20 5DC4      6874   	jsr move_init
     5D1E   C6 6D        6875   	dec argmo
     5D20   20 5DE3      6876   	jsr movedown_10
     5D23   AD 1210      6877   	lda text_top
     5D26   D0 03        6878   	bne 50$
     5D28   CE 1211      6879   	dec text_top+1
     5D2B   CE 1210      6880   50$	dec text_top
     5D2E   20 0386      6881   	jsr chrgot
     5D31   90 E8        6882   	bcc p3cd40		;still digits...
     5D33   4C 5CA6      6883   	jmp iline_20		;branch always
                         6884   
                         6885   
                         6886   ;*************************** form_line *********************************
                         6887   
                         6888   ;remaps the destination line if it is greater than n3
                         6889   
     5D36                6890   form_line
     5D36   20 5D85      6891   	jsr n1_reset
     5D39                6892   find_it
     5D39   20 5DB6      6893   	jsr chargt_x2		;new line, skip over link
     5D3C   D0 0D        6894   	bne 70$			;if we get to end-of-text without finding the
     5D3E   A2 27        6895   	ldx #err_ref		;line # then 'unresolved reference' error
     5D40   A5 4B        6896   	lda forpnt
     5D42   85 3B        6897   	sta curlin		;fake error routine into saying 'in line xxxxx'
     5D44   A5 4C        6898   	lda forpnt+1
     5D46   85 3C        6899   	sta curlin+1
     5D48   4C 4D59      6900   	jmp error
                         6901   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 99-8
renumber   RENUMBER.SRC

Error Addr  Code          Seq   Source statement

     5D4B   20 5DB9      6902   70$	jsr chargt		;get line number low
     5D4E   85 5A        6903   	sta highds		;highds = current line# in loop
     5D50   C5 16        6904   	cmp linnum
     5D52   D0 27        6905   	bne 100$
     5D54   20 5DB9      6906   	jsr chargt		;get line number high
     5D57   85 5B        6907   	sta highds+1
     5D59   C5 17        6908   	cmp linnum+1
     5D5B   D0 23        6909   	bne 110$
     5D5D   38           6910   	sec			;if linnum < start#, no remapping
     5D5E   E5 5D        6911   	sbc hightr+1
     5D60   90 08        6912   	bcc 80$
     5D62   D0 0E        6913   	bne 90$
     5D64   A5 16        6914   	lda linnum
     5D66   E5 5C        6915   	sbc hightr
     5D68   B0 08        6916   	bcs 90$
     5D6A                6917   80$
     5D6A   A5 16        6918   	lda linnum		;use same line#
     5D6C   85 65        6919   	sta facho+1
     5D6E   A5 17        6920   	lda linnum+1
     5D70   85 64        6921   	sta facho
     5D72                6922   90$
     5D72   A2 90        6923   	ldx #$90		;make replacement string
     5D74   38           6924   	sec
     5D75   20 8C75      6925   	jsr floatc
     5D78   4C 8E42      6926   	jmp fout
                         6927   
     5D7B                6928   100$
     5D7B   20 5DB9      6929   	jsr chargt
     5D7E   85 5B        6930   	sta highds+1		;(** 01/27/84 fix)
     5D80                6931   110$
     5D80   20 5D92      6932   	jsr line_add		;scan to end of line
     5D83   F0 B4        6933   	beq find_it		;always
                         6934   
                         6935   
                         6936   
                         6937   
                         6938   ;*************************** n1_reset **********************************
                         6939   
                         6940   ;copies n1 (new renumber origin) into facho & sets (txtptr) = (txttab)-1
                         6941   
     5D85                6942   n1_reset
     5D85   AD 1170      6943   	lda renum_tmp_1
     5D88   85 65        6944   	sta facho+1
     5D8A   AD 1171      6945   	lda renum_tmp_1+1
     5D8D   85 64        6946   	sta facho
     5D8F   4C 5271      6947   	jmp stxtpt
                         6948   
                         6949   
                         6950   ;*************************** line_add **********************************
                         6951   
                         6952   ;adds n2 (new line increment) to line number stored in facho if the 
                         6953   ;current line number (highds) >= n3 (line to start renumbering with).
                         6954   ;the line is then scanned through
                         6955   
     5D92                6956   line_add

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 99-9
renumber   RENUMBER.SRC

Error Addr  Code          Seq   Source statement

     5D92   A5 5A        6957   	lda highds		;if line# >= start# then incr new#
     5D94   38           6958   	sec
     5D95   E5 5C        6959   	sbc hightr
     5D97   A5 5B        6960   	lda highds+1
     5D99   E5 5D        6961   	sbc hightr+1
     5D9B   90 03        6962   	bcc scan_thru
     5D9D                6963   line_inc
     5D9D   20 5DA6      6964   	jsr new_num
                         6965   
     5DA0                6966   scan_thru
     5DA0   20 5DB9      6967   	jsr chargt		;scan to end of line
     5DA3   D0 FB        6968   	bne scan_thru
     5DA5   60           6969   	rts
                         6970   
                         6971   
                         6972   ;**************************** new_num **********************************
                         6973   
                         6974   ;adds n2 (the new line increment) to the line number stored in facho
                         6975   
     5DA6                6976   new_num
     5DA6   A5 65        6977   	lda facho+1		;increment new line#
     5DA8   18           6978   	clc
     5DA9   6D 1172      6979   	adc renum_tmp_2
     5DAC   85 65        6980   	sta facho+1
     5DAE   A5 64        6981   	lda facho
     5DB0   6D 1173      6982   	adc renum_tmp_2+1
     5DB3   85 64        6983   	sta facho
     5DB5   60           6984   	rts
                         6985   
                         6986   
                         6987   ;********************** chargt & chargt_x2 *****************************
                         6988   
                         6989   ;chargt simulates chrget but doesn't ignore spaces & carry has no
                         6990   ;significance.  chargt_x2 executes chargt twice.
                         6991   
     5DB6                6992   chargt_x2								
     5DB6   20 5DB9      6993   	jsr chargt
     5DB9                6994   chargt
     5DB9   A0 00        6995   	ldy #0	   		;increment txtptr
     5DBB   E6 3D        6996   	inc txtptr
     5DBD   D0 02        6997   	bne 1$
     5DBF   E6 3E        6998   	inc txtptr+1
     5DC1                6999   1$
     5DC1   4C 03C9      7000   	jmp indtxt
                         7001   
                         7002   
                         7003   ;***********************************************************************
                         7004   ;********************** memory move routines ***************************
                         7005   ;***********************************************************************
                         7006   
                         7007   
                         7008   ;*************************** move_init *********************************
                         7009   
                         7010   ;intitialize variables for memory move routines
                         7011   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 99-10
renumber   RENUMBER.SRC

Error Addr  Code          Seq   Source statement

     5DC4                7012   move_init
     5DC4   A5 3D        7013   	lda txtptr
     5DC6   85 24        7014   	sta index1
     5DC8   A5 3E        7015   	lda txtptr+1
     5DCA   85 25        7016   	sta index1+1
     5DCC   AD 1210      7017   	lda text_top
     5DCF   85 26        7018   	sta index2
     5DD1   AD 1211      7019   	lda text_top+1
     5DD4   85 27        7020   	sta index2+1
     5DD6   A0 00        7021   	ldy #0
     5DD8   84 0D        7022   	sty count
     5DDA   84 6D        7023   	sty argmo
     5DDC   60           7024   	rts
                         7025   
                         7026   
                         7027   ;*************************** movedown **********************************
                         7028   
                         7029   ;move basic text area from (index1) to (index2) down one byte
                         7030   ;(call movedown_10)
                         7031   
     5DDD                7032   movedown
     5DDD   E6 24        7033   	inc index1
     5DDF   D0 02        7034   	bne movedown_10
     5DE1   E6 25        7035   	inc index1+1
     5DE3                7036   movedown_10
     5DE3   A4 0D        7037   	ldy count
     5DE5   C8           7038   	iny
     5DE6   20 4322      7039   	jsr indin1
     5DE9   A4 6D        7040   	ldy argmo
     5DEB   C8           7041   	iny
     5DEC   91 24        7042   	sta (index1),y
     5DEE   20 5E0B      7043   	jsr compare
     5DF1   D0 EA        7044   	bne movedown
     5DF3   60           7045   	rts
                         7046   
                         7047   
                         7048   ;**************************** moveup ***********************************
                         7049   
                         7050   ;move basic text area from (index1) to (index2) up one byte
                         7051   ;(call moveup_20)
                         7052   
     5DF4                7053   moveup
     5DF4   A5 26        7054   	lda index2
     5DF6   D0 02        7055   	bne moveup_10
     5DF8   C6 27        7056   	dec index2+1
     5DFA                7057   moveup_10
     5DFA   C6 26        7058   	dec index2
     5DFC                7059   moveup_20
     5DFC   A4 0D        7060   	ldy count
     5DFE   20 03C0      7061   	jsr indin2
     5E01   A4 6D        7062   	ldy argmo
     5E03   91 26        7063   	sta (index2),y
     5E05   20 5E0B      7064   	jsr compare
     5E08   D0 EA        7065   	bne moveup
     5E0A   60           7066   	rts

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 99-11
renumber   RENUMBER.SRC

Error Addr  Code          Seq   Source statement

                         7067   
                         7068   
                         7069   ;**************************** compare ***********************************
                         7070   
                         7071   ;compares index1 with index2, sets c and z flags accordingly
                         7072   
     5E0B                7073   compare
     5E0B   A5 24        7074   	lda index1
     5E0D   C5 26        7075   	cmp index2
     5E0F   D0 04        7076   	bne 1$
     5E11   A5 25        7077   	lda index1+1
     5E13   C5 27        7078   	cmp index2+1
     5E15   60           7079   1$	rts
                         7080   
                         7081   ;.end
                         7082   	.include for		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 100
'for'   FOR.SRC

Error Addr  Code          Seq   Source statement

                         7084   	.subttl 'for'
                         7085   ;       for
                         7086   ;
                         7087   ;    push the following information on the run-time stack
                         7088   ;            (bottom)   highest memory
                         7089   ;    =========================
                         7090   ;             txtptr    address of next statement
                         7091   ;             txtptr+1
                         7092   ;             ========
                         7093   ;             curlin+1  current line number
                         7094   ;             curlin
                         7095   ;             ========
                         7096   ;             to lo
                         7097   ;             to mo
                         7098   ;             to moh    'to' value
                         7099   ;             to ho
                         7100   ;             to exp
                         7101   ;             ========
                         7102   ;             step sign
                         7103   ;             step lo
                         7104   ;             step mo
                         7105   ;             step moh  'step' value
                         7106   ;             step ho
                         7107   ;             step exp
                         7108   ;             ========
                         7109   ;             forpnt+1  'for' variable pointer
                         7110   ;             forpnt
                         7111   ;             ========
                         7112   ;             'for' token       <== (tos) top of stack pointer
                         7113   ;   ============================
                         7114   ;        (top of stack)  lowest memory
                         7115   
     5E16                7116   for
     5E16   A9 80        7117   	lda #$80	;no arrays, please.
     5E18   85 12        7118   	sta subflg
     5E1A   20 53E3      7119   	jsr let	    	;get & set 'for' variables
     5E1D   A9 81        7120   	lda #fortk	;set up for call to see if
     5E1F   20 4FC7      7121   	jsr search	;..this 'for' variable is unique
     5E22   F0 08        7122   	beq for010	;branch if not
                         7123   
                         7124   ; if variable is not unique, (fndpnt) will point to last
                         7125   ; occurance in stack, and we will reset the stack to that point.
                         7126   ; otherwise we will adjust the pointer by 'lenfor',
                         7127   ; and start from that point.
                         7128   
     5E24   A9 12        7129   	lda #lenfor
     5E26   20 501B      7130   	jsr getstk	;updates stack pointer, error if overflow
     5E29   20 5064      7131   	jsr movtos	;(tos) => (fndpnt)
                         7132   
     5E2C   20 506D      7133   for010	jsr movfnd	;(fndpnt) => (tos)   (redundant for new entries)
     5E2F   20 52BF      7134   	jsr datan	;find address of next statement
     5E32   98           7135   	tya		;offset from (txtptr) in y
     5E33   A0 11        7136   	ldy #lenfor-1
                         7137   ;
                         7138   ; push address of next statement on stack

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 100-1
'for'   FOR.SRC

Error Addr  Code          Seq   Source statement

                         7139   ;
     5E35   18           7140   	clc
     5E36   65 3D        7141   	adc txtptr
     5E38   91 7D        7142   	sta (tos),y
     5E3A   A5 3E        7143   	lda txtptr+1
     5E3C   69 00        7144   	adc #0
     5E3E   88           7145   	dey
     5E3F   91 7D        7146   	sta (tos),y
                         7147   ;
                         7148   ; push current line number on stack
                         7149   ;
     5E41   A5 3C        7150   	lda curlin+1
     5E43   88           7151   	dey
     5E44   91 7D        7152   	sta (tos),y
     5E46   A5 3B        7153   	lda curlin
     5E48   88           7154   	dey
     5E49   91 7D        7155   	sta (tos),y
                         7156   ;
                         7157   ; look for 'to'... must appear
                         7158   ;
     5E4B   A9 A4        7159   	lda #totk
     5E4D   20 79FB      7160   	jsr synchr
                         7161   ;
                         7162   ; get 'to' value
                         7163   ;
     5E50   20 7877      7164   	jsr chknum
     5E53   20 7874      7165   	jsr frmnum
     5E56   A5 68        7166   	lda facsgn
     5E58   09 7F        7167   	ora #$7f
     5E5A   25 64        7168   	and facho
     5E5C   85 64        7169   	sta facho
     5E5E   A2 04        7170   	ldx #4
     5E60   A0 0D        7171   	ldy #lenfor-5
                         7172   
     5E62   B5 63        7173   for020	lda facexp,x	;push faclo,mo,moh,ho,exp
     5E64   91 7D        7174   	sta (tos),y
     5E66   CA           7175   	dex
     5E67   88           7176   	dey
     5E68   10 F8        7177   	bpl for020
                         7178   ;
                         7179   ; push 'step' value
                         7180   ;
     5E6A   A9 9C        7181   	lda #<fone	;point to default 'one' in rom
     5E6C   A0 89        7182   	ldy #>fone
     5E6E   20 8BD4      7183   	jsr movfm
     5E71   20 0386      7184   	jsr chrgot
     5E74   C9 A9        7185   	cmp #steptk
     5E76   D0 06        7186   	bne for030	;branch if no step given
     5E78   20 0380      7187   	jsr chrget
     5E7B   20 7874      7188   	jsr frmnum
                         7189   
     5E7E   20 8C57      7190   for030	jsr sign
     5E81   48           7191   	pha		;save sign for a moment
     5E82   20 8C47      7192   	jsr round
     5E85   68           7193   	pla

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 100-2
'for'   FOR.SRC

Error Addr  Code          Seq   Source statement

     5E86   A0 08        7194   	ldy #lenfor-10
     5E88   A2 05        7195   	ldx #5
                         7196   
     5E8A   91 7D        7197   for040	sta (tos),y
     5E8C   B5 62        7198   	lda facexp-1,x
     5E8E   88           7199   	dey
     5E8F   CA           7200   	dex
     5E90   10 F8        7201   	bpl for040
                         7202   ;
                         7203   ; finally push pointer to 'for' variable, & 'for' token
                         7204   ;
     5E92   A5 4C        7205   	lda forpnt+1
     5E94   91 7D        7206   	sta (tos),y
     5E96   A5 4B        7207   	lda forpnt
     5E98   88           7208   	dey
     5E99   91 7D        7209   	sta (tos),y
     5E9B   A9 81        7210   	lda #fortk
     5E9D   88           7211   	dey
     5E9E   91 7D        7212   	sta (tos),y
     5EA0   60           7213   	rts
                         7214   
                         7215   ;.end
                         7216   	.include delete		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 101
DELETE Command   DELETE.SRC

Error Addr  Code          Seq   Source statement

                         7218   	.subttl DELETE Command
                         7219   
                         7220   ; delete a range of source
                         7221   ;
                         7222   ; syntax:   delete from# - to#
                         7223   
     5EA1   4C 7A09      7224   nrange	jmp snerr
                         7225   
     5EA4   20 84F0      7226   delete	jsr errind		;allowed only in direct mode
     5EA7   20 0386      7227   	jsr chrgot
     5EAA   F0 F5        7228   	beq nrange		;bad..no range parms.
     5EAC   20 5F18      7229   	jsr range		;get line # range
     5EAF   A5 61        7230   	lda lowtr		;save it
     5EB1   A6 62        7231   	ldx lowtr+1
     5EB3   85 26        7232   	sta index2
     5EB5   86 27        7233   	stx index2+1
     5EB7   20 5081      7234   	jsr fndlin		;find it
     5EBA   90 15        7235   	bcc del300		;skip if not found
     5EBC   A0 01        7236   	ldy #1
     5EBE   20 4309      7237   	jsr indlow		;at end of source ?
     5EC1   88           7238   	dey
     5EC2   AA           7239   	tax			;save it in case of swap
     5EC3   D0 05        7240   	bne noteos
     5EC5   20 4309      7241   	jsr indlow
     5EC8   F0 07        7242   	beq del300		;both zero means end-of-source
     5ECA                7243   noteos
     5ECA   20 4309      7244   	jsr indlow
     5ECD   85 61        7245   	sta lowtr		;include to line #
     5ECF   86 62        7246   	stx lowtr+1
     5ED1                7247   del300
     5ED1   A5 26        7248   	lda index2		;check from#<to#
     5ED3   38           7249   	sec
     5ED4   E5 61        7250   	sbc lowtr		;gen neg delta
     5ED6   AA           7251   	tax
     5ED7   A5 27        7252   	lda index2+1
     5ED9   E5 62        7253   	sbc lowtr+1
     5EDB   A8           7254   	tay
     5EDC   B0 24        7255   	bcs notdel		;no good
     5EDE   8A           7256   	txa
     5EDF   18           7257   	clc
     5EE0   6D 1210      7258   	adc text_top		;gen new end of source
     5EE3   8D 1210      7259   	sta text_top
     5EE6   98           7260   	tya
     5EE7   6D 1211      7261   	adc text_top+1
     5EEA   8D 1211      7262   	sta text_top+1
     5EED   A0 00        7263   	ldy #0
                         7264   
     5EEF   20 4309      7265   del500	jsr indlow		;move source down
     5EF2   91 26        7266   	sta (index2),y
     5EF4   E6 61        7267   	inc lowtr		;increment source (318018-03 fix; FAB)
     5EF6   D0 02        7268   	bne 10$
     5EF8   E6 62        7269   	inc lowtr+1
     5EFA   20 7F31      7270   10$	jsr delete_patch	;increment destination & compare with text_top
     5EFD   90 F0        7271   	bcc del500		;loop until done
     5EFF   EA           7272   	nop

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 101-1
DELETE Command   DELETE.SRC

Error Addr  Code          Seq   Source statement

     5F00   EA           7273   	nop			;(318018-03 placeholders)
     5F01   EA           7274   	nop
                         7275   
     5F02                7276   notdel 				;entry for renumber also!
     5F02   20 4F6C      7277   	jsr lnkprg		;fix links
     5F05   A5 24        7278   	lda index1		;calc new end
     5F07   A6 25        7279   	ldx index1+1
     5F09   18           7280   	clc
     5F0A   69 02        7281   	adc #2
     5F0C   8D 1210      7282   	sta text_top
     5F0F   90 01        7283   	bcc not500
     5F11   E8           7284   	inx
     5F12                7285   not500
     5F12   8E 1211      7286   	stx text_top+1
     5F15   4C 4D54      7287   	jmp ready			;say ready
                         7288   
                         7289   ;********************************
                         7290   ;*
                         7291   ;* input range parameters
                         7292   ;*
                         7293   ;********************************
                         7294   
     5F18   F0 12        7295   range	beq 10$			;a terminator from chrgot
     5F1A   90 10        7296   	bcc 10$			;a number
     5F1C   C9 AB        7297   	cmp #minutk		;a dash
     5F1E   D0 2E        7298   	bne rngerr		;if it's not a dash, error (318018-03 fix; FAB)
     5F20   A0 01        7299   	ldy #1
     5F22   20 03C9      7300   	jsr indtxt		;let's peek, and see what follows the dash!
     5F25   F0 27        7301   	beq rngerr		;uh-oh! it's of the form 'delete -' - error
     5F27   C9 3A        7302   	cmp #':'		;the other terminator
     5F29   F0 23        7303   	beq rngerr		;..still bad
     5F2B   38           7304   	sec			;set up for linget
                         7305   
     5F2C   20 50BD      7306   10$	jsr linget		;get first #
     5F2F   20 5081      7307   	jsr fndlin		;find it & set ptrs
     5F32   20 0386      7308   	jsr chrgot		;get last char
     5F35   F0 0C        7309   	beq 20$			;skip done
     5F37   C9 AB        7310   	cmp #minutk		;a dash
     5F39   D0 13        7311   	bne rngerr		;syntax error
     5F3B   20 0380      7312   	jsr chrget		;yes - skip dash
     5F3E   20 50BD      7313   	jsr linget		;get second #
     5F41   D0 0B        7314   	bne rngerr		;wasn't a number
                         7315   
     5F43   A5 0A        7316   20$	lda endchr		;was a # input?
     5F45   D0 06        7317   	bne rngrts		;yes
     5F47   A9 FF        7318   	lda #$ff		;no - make max
     5F49   85 16        7319   	sta linnum
     5F4B   85 17        7320   	sta linnum+1
     5F4D   60           7321   rngrts	rts
                         7322   
     5F4E   4C 7A09      7323   rngerr	jmp snerr		;syntax error
                         7324   
                         7325   ;.end
                         7326   	.include pudef		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 102
PUDEF Command   PUDEF.SRC

Error Addr  Code          Seq   Source statement

                         7328   	.subttl PUDEF Command
                         7329   
                         7330   
     5F51   20 877B      7331   puctrl	jsr frmstr		;do frmevl,frestr. return with a=len, index=~string
     5F54   A8           7332   	tay
     5F55   88           7333   	dey
     5F56   C0 04        7334   	cpy #4
     5F58   90 03        7335   	bcc 1$
     5F5A   4C 7DC5      7336   	jmp fcerr		;len > 4 is illegal value error.
     5F5D   20 03B7      7337   1$	jsr indin1_ram1		;lda (index),y
     5F60   8D FF03      7338   	sta sw_rom_ram0
     5F63   99 1204      7339   	sta puchrs,y
     5F66   88           7340   	dey
     5F67   10 F4        7341   	bpl 1$
     5F69   60           7342   	rts
                         7343   
                         7344   ;.end
                         7345   	.include trap		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 103
TRAP Instruction   TRAP.SRC

Error Addr  Code          Seq   Source statement

                         7347   	.subttl	TRAP Instruction
                         7348   
     5F6A   20 84D9      7349   trap	jsr errdir
     5F6D   20 0386      7350   	jsr chrgot	;if no #, means 'turn off trap'
     5F70   F0 07        7351   	beq 1$
     5F72   20 8812      7352   	jsr getwrd
     5F75   8C 120B      7353   	sty trapno
     5F78   2C           7354   	.byte $2c
     5F79   A9 FF        7355   1$	lda #$ff	;flag no trap
     5F7B   8D 120C      7356   	sta trapno+1
     5F7E   60           7357   	rts
                         7358   
                         7359   ;end
                         7360   	.include resume		;command
                         7361   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 104
RESUME command   RESUME.SRC

Error Addr  Code          Seq   Source statement

                         7363   	.subttl RESUME command
                         7364   
                         7365   ; RESUME command
                         7366   ;
                         7367   ; Used to resume execution following a TRAPped error.
                         7368   ;
                         7369   ; Syntax:
                         7370   ;	RESUME [line_number | NEXT]
                         7371   ;
                         7372   ; Can take the following forms:
                         7373   ;
                         7374   ;	RESUME			:resume executing at the statement which caused 
                         7375   ;				 the error.
                         7376   ;	RESUME NEXT		:resume execution at the statement FOLLOWING
                         7377   ;				 the statement which caused the error.
                         7378   ;	RESUME line_number	:resume at the specified line number.
                         7379   
                         7380   
     5F7F   20 84D9      7381   resume	jsr errdir	;no direct mode
     5F82   AE 120A      7382   	ldx errlin+1	;is there an error to resume from?
     5F85   E8           7383   	inx
     5F86   F0 70        7384   	beq rescnt	;can't resume!
     5F88   20 0386      7385   	jsr chrgot	;look for arguments
     5F8B   F0 47        7386   	beq resswp	;no arg's...restart err'd line
     5F8D   90 3A        7387   	bcc resnum	;numeric argument
     5F8F   C9 82        7388   	cmp #nexttk	;only other choice is 'next'
     5F91   D0 62        7389   	bne ressnr	;if not, syntax error
                         7390   
     5F93   20 5FD4      7391   	jsr resswp	;resume execution with next stm't
     5F96   A0 00        7392   	ldy #0
     5F98   20 03C9      7393   	jsr indtxt
     5F9B   D0 26        7394   	bne 2$		;must be a ':'
     5F9D   C8           7395   	iny		;must be a null,get next line
     5F9E   20 03C9      7396   	jsr indtxt	;make sure its not end-of-text
     5FA1   D0 09        7397   	bne 1$
     5FA3   C8           7398   	iny
     5FA4   20 03C9      7399   	jsr indtxt
     5FA7   D0 03        7400   	bne 1$
     5FA9   4C 4D54      7401   	jmp ready	;2 nulls, eot. bye!
                         7402   
     5FAC   A0 03        7403   1$	ldy #3	   	;new line, update pointers
     5FAE   20 03C9      7404   	jsr indtxt
     5FB1   85 3B        7405   	sta curlin
     5FB3   C8           7406   	iny
     5FB4   20 03C9      7407   	jsr indtxt
     5FB7   85 3C        7408   	sta curlin+1
     5FB9   98           7409   	tya
     5FBA   18           7410   	clc
     5FBB   65 3D        7411   	adc txtptr
     5FBD   85 3D        7412   	sta txtptr
     5FBF   90 02        7413   	bcc 2$
     5FC1   E6 3E        7414   	inc txtptr+1
     5FC3   20 0380      7415   2$	jsr chrget	;skip over this character, into body of statement
     5FC6   4C 52AC      7416   	jmp data	;advance until null or ':', then rts
                         7417   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 104-1
RESUME command   RESUME.SRC

Error Addr  Code          Seq   Source statement

     5FC9   20 8812      7418   resnum	jsr getwrd
     5FCC   85 17        7419   	sta linnum+1
     5FCE   20 5FE3      7420   	jsr resend
     5FD1   4C 5A18      7421   	jmp luk4it
                         7422   
     5FD4   A2 01        7423   resswp	ldx #1
     5FD6   BD 1209      7424   1$	lda errlin,x
     5FD9   95 3B        7425   	sta curlin,x
     5FDB   BD 120E      7426   	lda errtxt,x
     5FDE   95 3D        7427   	sta txtptr,x
     5FE0   CA           7428   	dex
     5FE1   10 F3        7429   	bpl 1$
                         7430   
     5FE3   A2 FF        7431   resend	ldx #$ff
     5FE5   8E 1208      7432   	stx errnum	;reset error status- he's saying he's fixed it
     5FE8   8E 1209      7433   	stx errlin
     5FEB   8E 120A      7434   	stx errlin+1	;flag 'no further resumes until next error'
     5FEE   AE 120D      7435   	ldx tmptrp	;restore trap line to allow traps again
     5FF1   8E 120C      7436   	stx trapno+1
     5FF4   60           7437   	rts
                         7438   
     5FF5   4C 7A09      7439   ressnr	jmp snerr
                         7440   
                         7441   
     5FF8   A2 1F        7442   rescnt	ldx #errcr
     5FFA   4C 4D59      7443   	jmp error
                         7444   
                         7445   ;end
                         7446   	.include doloop		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 105
DO / LOOP Commands   DOLOOP.SRC

Error Addr  Code          Seq   Source statement

                         7448   	.subttl DO / LOOP Commands
                         7449   
     5FFD   A0 01        7450   do	ldy #1
                         7451   
     5FFF   B9 003D      7452   1$	lda txtptr,y	;save current pointers for stack entry
     6002   99 1214      7453   	sta tmptxt,y
     6005   B9 003B      7454   	lda curlin,y
     6008   99 1216      7455   	sta tmplin,y
     600B   88           7456   	dey
     600C   10 F1        7457   	bpl 1$
                         7458   
     600E   20 0386      7459   	jsr chrgot	;look for 'while' or 'until'
     6011   F0 1C        7460   	beq doyes	;unconditional
     6013   C9 FC        7461   	cmp #untltk
     6015   F0 11        7462   	beq do10
     6017   C9 FD        7463   	cmp #whiltk
     6019   D0 43        7464   	bne snrjmp
                         7465   ;
                         7466   ;  here for 'while'
                         7467   ;
     601B   20 60F8      7468   	jsr frmjmp
     601E   A5 63        7469   	lda facexp
     6020   D0 0D        7470   	bne doyes	;conditional evaluated true
                         7471   
     6022   20 0386      7472   dono	jsr chrgot
     6025   4C 6064      7473   	jmp fnd010	;advance to end of block, do rts
                         7474   ;
                         7475   ;  here for 'until'
                         7476   ;
     6028   20 60F8      7477   do10	jsr frmjmp
     602B   A5 63        7478   	lda facexp
     602D   D0 F3        7479   	bne dono
                         7480   
     602F   A9 05        7481   doyes	lda #5		;'do' needs 5 bytes on the run-time stack
     6031   20 501B      7482   	jsr getstk
     6034   8D FF03      7483   	sta sw_rom_ram0
     6037   A0 04        7484   	ldy #4		;..now stuff those 5 bytes!
     6039   AD 1215      7485   	lda tmptxt+1
     603C   91 7D        7486   	sta (tos),y
     603E   88           7487   	dey
     603F   AD 1214      7488   	lda tmptxt
     6042   91 7D        7489   	sta (tos),y
     6044   88           7490   	dey
     6045   AD 1217      7491   	lda tmplin+1
     6048   91 7D        7492   	sta (tos),y
     604A   88           7493   	dey
     604B   AD 1216      7494   	lda tmplin
     604E   91 7D        7495   	sta (tos),y
     6050   88           7496   	dey
     6051   A9 EB        7497   	lda #dotk
     6053   91 7D        7498   	sta (tos),y
     6055   60           7499   	rts
                         7500   
                         7501   
                         7502   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 105-1
DO / LOOP Commands   DOLOOP.SRC

Error Addr  Code          Seq   Source statement

     6056   20 60B8      7503   exit	jsr popdgo	;pop do entry off stack
     6059   20 0386      7504   	jsr chrgot
     605C   F0 06        7505   	beq fnd010
     605E   4C 7A09      7506   snrjmp	jmp snerr
                         7507   
                         7508   
                         7509   ;  find end of current block
                         7510   ;
     6061                7511   fndend
     6061   20 0380      7512   	jsr chrget
     6064                7513   fnd010
     6064   F0 17        7514   	beq fnd50	;end of statement
     6066   C9 EC        7515   	cmp #looptk
     6068   F0 3A        7516   	beq fnd60	;a hit!
     606A   C9 22        7517   	cmp #'"'	;quote
     606C   F0 0A        7518   	beq fnd40
     606E   C9 EB        7519   	cmp #dotk
     6070   D0 EF        7520   	bne fndend	;keep looking
     6072   20 6061      7521   	jsr fndend	;recursivly
     6075   4C 6022      7522   	jmp dono	;do a chrgot,go to fnd010
                         7523   
                         7524   
     6078   20 5399      7525   fnd40	jsr un_quote	;look for terminating quote, or end of statement
     607B   D0 E4        7526   	bne fndend	;character after quote wasn't terminator, keep going
                         7527   
     607D   C9 3A        7528   fnd50	cmp #':'	;end of line or end of stmt?
     607F   F0 E0        7529   	beq fndend	;just stmt, keep going
     6081   24 7F        7530   	bit runmod	;direct mode?
     6083   10 42        7531   	bpl fnderr	;yes, so not found
     6085   A0 02        7532   	ldy #2
     6087   20 03C9      7533   	jsr indtxt	;end of text?
     608A   F0 3B        7534   	beq fnderr	;'fraid so
     608C   C8           7535   	iny		;y=3
     608D   20 03C9      7536   	jsr indtxt	;update pointers
     6090   85 3B        7537   	sta curlin
     6092   C8           7538   	iny
     6093   20 03C9      7539   	jsr indtxt
     6096   85 3C        7540   	sta curlin+1
     6098   98           7541   	tya
     6099   18           7542   	clc
     609A   65 3D        7543   	adc txtptr
     609C   85 3D        7544   	sta txtptr
     609E   90 C1        7545   	bcc fndend
     60A0   E6 3E        7546   	inc txtptr+1
     60A2   D0 BD        7547   	bne fndend
                         7548   
     60A4   4C 52AC      7549   fnd60	jmp data	;read to end of statement,rts
                         7550   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 106
DO / LOOP Commands   DOLOOP.SRC

Error Addr  Code          Seq   Source statement

                         7552   
     60A7   F0 35        7553   loop	beq popngo	;no conditionals, just do it
     60A9   C9 FD        7554   	cmp #whiltk
     60AB   F0 2C        7555   	beq loop10
     60AD   C9 FC        7556   	cmp #untltk
     60AF   D0 AD        7557   	bne snrjmp
                         7558   ;
                         7559   ;  here for 'until'
                         7560   ;
     60B1   20 60F8      7561   	jsr frmjmp
     60B4   A5 63        7562   	lda facexp
     60B6   F0 26        7563   	beq popngo	;false, do it again!
                         7564   
     60B8   A9 EB        7565   popdgo	lda #dotk	;pop, but don't go
     60BA   20 4FC7      7566   	jsr search
     60BD   D0 15        7567   	bne poperr	;branch if not found
     60BF   20 506D      7568   	jsr movfnd
     60C2   A0 05        7569   	ldy #5
     60C4   4C 5076      7570   	jmp rlsstk
                         7571   
                         7572   
     60C7                7573   fnderr
     60C7   AD 1216      7574   	lda tmplin	;loop not found error: must make curlin match oldtxt
     60CA   AE 1217      7575   	ldx tmplin+1
     60CD   85 3B        7576   	sta curlin
     60CF   86 3C        7577   	stx curlin+1
     60D1   A2 20        7578   	ldx #errlnf
     60D3   2C           7579   	.byte $2c
     60D4                7580   poperr
     60D4   A2 21        7581   	ldx #errlwd    	;loop without do
     60D6   4C 4D59      7582   	jmp error
                         7583   
                         7584   
                         7585   ;
                         7586   ;  here for 'while'
                         7587   ;
     60D9                7588   loop10
     60D9   20 60F8      7589   	jsr frmjmp
     60DC   F0 DA        7590   	beq popdgo	;false, exit
     60DE                7591   popngo
     60DE   20 60B8      7592   	jsr popdgo
     60E1   88           7593   	dey
     60E2   B1 3F        7594   	lda (fndpnt),y	;restore pointers
     60E4   85 3E        7595   	sta txtptr+1
     60E6   88           7596   	dey
     60E7   B1 3F        7597   	lda (fndpnt),y
     60E9   85 3D        7598   	sta txtptr
     60EB   88           7599   	dey
     60EC   B1 3F        7600   	lda (fndpnt),y
     60EE   20 A84B      7601   	jsr retpat	;(** 01/18/84 fixes 'loop' to a direct mode 'do')
     60F1   B1 3F        7602   	lda (fndpnt),y
     60F3   85 3B        7603   	sta curlin
     60F5   4C 5FFD      7604   	jmp do
                         7605   
     60F8                7606   frmjmp

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 106-1
DO / LOOP Commands   DOLOOP.SRC

Error Addr  Code          Seq   Source statement

     60F8   20 0380      7607   	jsr chrget
     60FB   4C 788C      7608   	jmp frmevl
                         7609   
                         7610   
                         7611   ;.end
                         7612   	.include key		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 107
KEY Command   KEY.SRC

Error Addr  Code          Seq   Source statement

                         7614   	.subttl KEY Command
                         7615   
                         7616   ;**************************************************************
                         7617   ;
                         7618   ;   chgkey  --  add, delete or change function key definition
                         7619   ;
                         7620   ;**************************************************************
                         7621   
     60FE   20 87F4      7622   chgkey	jsr getbyt	;get key number
     6101   CA           7623   	dex
     6102   E0 08        7624   	cpx #8
     6104   90 03        7625   	bcc 10$		;ok
     6106   4C 7DC5      7626   	jmp fcerr	;exit - key number invalid
                         7627   
     6109   86 77        7628   10$	stx z_p_temp_1	;save key number
     610B   20 79F9      7629   	jsr chkcom	;look for comma
     610E   20 877B      7630   	jsr frmstr	;do frmevl, frestr. returns len in .a, addr in 'index'
     6111   A8           7631   	tay		;set up for call to do-a-key
     6112   A9 01        7632   	lda #1		;tell do-a-key that string is in bank 1
     6114   85 26        7633   	sta index+2
     6116   A9 24        7634   	lda #index	;now .A points to (adr lo, adr hi, bank #)
     6118   A6 77        7635   	ldx z_p_temp_1
     611A   E8           7636   	inx
     611B   20 A855      7637   	jsr put_io_in_map
     611E   20 FF65      7638   	jsr _doakey	;re-define the key
     6121   B0 01        7639   	bcs 20$		;bad return (.c=1)
     6123   60           7640   	rts		;ok return (.c=0)
                         7641   
     6124   4C 4D57      7642   20$	jmp omerr	
                         7643   
                         7644   
                         7645   ;*************************************************************
                         7646   ;
                         7647   ;   key  --  programmable key functions
                         7648   ;
                         7649   ;*************************************************************
                         7650   
     6127   F0 15        7651   key	beq 10$			;no arg, show all keys
     6129   C9 91        7652   	cmp #ontk
     612B   F0 0E        7653   	beq 5$
                         7654   
     612D   C9 FE        7655   	cmp #esc_cmd_tk
     612F   D0 CD        7656   	bne chgkey		;must be 'change key defn's'
                         7657   
     6131   20 0380      7658   	jsr chrget
     6134   C9 24        7659   	cmp #off_tk
     6136   F0 03        7660   	beq 5$
     6138   4C 7A09      7661   	jmp snerr		;syntax error
     613B   4C 4863      7662   5$	jmp bad_command		;they're using the KEY OFF or KEY ON command
                         7663   
     613E   A2 00        7664   10$	ldx #0
     6140   A0 00        7665   	ldy #0
                         7666   
     6142   E8           7667   lstky1	inx			;get key number = 1-8
     6143   BD 0FFF      7668   	lda _pky_lengths-1,x	;get key size

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 107-1
KEY Command   KEY.SRC

Error Addr  Code          Seq   Source statement

     6146   F0 53        7669   	beq lstest		;skip if key not defined
     6148   85 78        7670   	sta keysiz		;save size
     614A   86 77        7671   	stx z_p_temp_1		;save key number
     614C   A2 05        7672   	ldx #5
                         7673   
     614E   BD A83A      7674   20$	lda preamb,x  		;print key preamble
     6151   CA           7675   	dex
     6152   D0 02        7676   	bne 30$
     6154   05 77        7677   	ora z_p_temp_1		;if last char of preamble, "or" in key number
     6156   20 9269      7678   30$	jsr k_bsout		;print character
     6159   8A           7679   	txa
     615A   10 F2        7680   	bpl 20$
                         7681   
                         7682   
     615C   A2 07        7683   	ldx #7
     615E   B9 100A      7684   lsloop	lda _pky_buffer,y	;print key definition
     6161   C8           7685   	iny
     6162   48           7686   	pha			;save character
                         7687   
     6163   86 79        7688   	stx syntmp		;check for special (non-printable) characters
     6165   A2 04        7689   	ldx #4
     6167   DD 61C0      7690   50$	cmp keychr-1,x		;is character a special one?
     616A   F0 34        7691   	beq list_special	;yes...display it as 'chr$(...)'
     616C   CA           7692   	dex
     616D   D0 F8        7693   	bne 50$
                         7694   
     616F   A6 79        7695   	ldx syntmp		;restore .x
     6171   E0 08        7696   	cpx #8
     6173   90 07        7697   	bcc 60$			;1st time thru - display leading quote
     6175   D0 0A        7698   	bne 70$			;previous was a character - no additions needed
     6177   A9 2B        7699   	lda #'+'		;add since previous was quote or return
     6179   20 9269      7700   	jsr k_bsout
     617C   A9 22        7701   60$	lda #'"'
     617E   20 9269      7702   	jsr k_bsout		;add leading quote
     6181   68           7703   70$	pla			;restore character
     6182   20 9269      7704   	jsr k_bsout		;display it
     6185   A2 09        7705   	ldx #9
                         7706   
                         7707   
     6187   C6 78        7708   lstnd	dec keysiz
     6189   D0 D3        7709   	bne lsloop		;loop to end of definition
     618B   E0 09        7710   	cpx #9
     618D   90 05        7711   	bcc 10$			;skip if previous not normal character
     618F   A9 22        7712   	lda #'"'
     6191   20 9269      7713   	jsr k_bsout		;add ending quote
     6194   A9 8D        7714   10$	lda #$8d
     6196   20 9269      7715   	jsr k_bsout		;add ending return (shifted)
     6199   A6 77        7716   	ldx z_p_temp_1
                         7717   
     619B   E0 08        7718   lstest	cpx #8
     619D   D0 A3        7719   	bne lstky1		;loop for all keys
     619F   60           7720   	rts
                         7721   
                         7722   
     61A0                7723   list_special

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 107-2
KEY Command   KEY.SRC

Error Addr  Code          Seq   Source statement

     61A0   A6 79        7724   	ldx syntmp	;restore .x
     61A2   BD 61B7      7725   10$	lda keydat-3,x	;display something like  ' "+chr$( '
     61A5   20 9269      7726   	jsr k_bsout
     61A8   CA           7727   	dex
     61A9   E0 03        7728   	cpx #3
     61AB   B0 F5        7729   	bcs 10$
     61AD   68           7730   	pla		;restore character
     61AE   20 A840      7731   	jsr prtdec	;display decimal value of chr in .a
     61B1   A9 29        7732   	lda #')'	;finish off with closing paren.
     61B3   20 9269      7733   	jsr k_bsout
     61B6   A2 08        7734   	ldx #8
     61B8   D0 CD        7735   	bne lstnd	;..always
                         7736   
                         7737   
     61BA   28 24 52     7738   keydat .byte '($RHC+"'
     61BD   48 43 2B            
     61C0   22                  
                         7739   
     61C1   0D 8D 22     7740   keychr .byte cr, $8d, $22, $1b
     61C4   1B                  
                         7741   
                         7742   
                         7743   
                         7744   
                         7745   ;.end
                         7746   	.include paint		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 108
PAINT Command   PAINT.SRC

Error Addr  Code          Seq   Source statement

                         7748   	.subttl PAINT Command
                         7749   
                         7750   ;******************************************************************
                         7751   ;
                         7752   ;  paint (s) (,(p)(,m)) -  fill a shape with a specified color
                         7753   ;                  shape is defined by all points within a
                         7754   ;                        colored border (see m below)
                         7755   ;                  s = color of filled area (1-4) (default=1(fg))
                         7756   ;                  p = optional starting coordinate position
                         7757   ;                  m = mode: 0=shape defined by (s) color (default)
                         7758   ;                            1=shape defined by any non-bgnd color
                         7759   ;
                         7760   ;******************************************************************
                         7761   
     61C5   20 9E38      7762   paint	jsr grpcol	;make sure a graphic area has been allocated, get color
     61C8   A2 04        7763   	ldx #xdest-vwork
     61CA   20 9E5B      7764   	jsr incor2	;get x & y coordinates
     61CD   20 9DFB      7765   	jsr dstpos	;move xdest/ydest to xpos/ypos
     61D0   20 9E25      7766   	jsr optzer	;look for mode: default is 0
     61D3   E0 02        7767   	cpx #2
     61D5   90 03        7768   	bcc paint2	;branch if legal number
     61D7   4C 7DC5      7769   	jmp fcerr	;...else illegal qty error
                         7770   
     61DA   8A           7771   paint2	txa
     61DB   4A           7772   	lsr a
     61DC   6A           7773   	ror a
     61DD   85 8B        7774   	sta stopnb	;flag is now $00 for 'stop on same', $80 for 'stop on any'
     61DF   10 04        7775   	bpl pntok1	;test for stopnb=1 & colsel=0 ... just quit if found
     61E1   A5 83        7776   	lda colsel
     61E3   F0 07        7777   	beq pnterr
     61E5                7778   pntok1
     61E5   20 9C4C      7779   	jsr readpt	;test if 1st point is off
     61E8   B0 02        7780   	bcs pnterr	;abort if 1st point out of bounds
     61EA   D0 01        7781   	bne pntok2	;skip if point is not = color
     61EC                7782   pnterr
     61EC   60           7783   	rts
                         7784   
                         7785   ; a large block of ram is necessary for the stack required by 'paint'.
                         7786   ; rather than allocate a fixed block of ram just for paint, it would
                         7787   ; be more frugal to use any free ram in basic's area. this would be
                         7788   ; the area between the end of arrays (strend) and the bottom of
                         7789   ; strings (fretop).
                         7790   ;
                         7791   ; to guarantee the largest block possible, we will call the garbage
                         7792   ; collect routine first.
                         7793   
     61ED                7794   pntok2
     61ED   20 92EA      7795   	jsr garba2
     61F0   8D FF03      7796   	sta sw_rom_ram0			;tidy up after garbage collect
                         7797   
                         7798   ; now we'll set up our pointers. index1 will be the top of stack pointer, and
                         7799   ; tempst will be fretop-3 (at or after this address, it is no longer possible
                         7800   ; to push any more 4 byte addresses on the stack).
                         7801   
     61F3   A5 33        7802   	lda strend

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 108-1
PAINT Command   PAINT.SRC

Error Addr  Code          Seq   Source statement

     61F5   85 24        7803   	sta index1
     61F7   A5 34        7804   	lda strend+1
     61F9   85 25        7805   	sta index1+1
                         7806   
     61FB   38           7807   	sec
     61FC   A5 35        7808   	lda fretop
     61FE   E9 03        7809   	sbc #3
     6200   85 1B        7810   	sta tempst
     6202   A5 36        7811   	lda fretop+1
     6204   E9 00        7812   	sbc #0
     6206   85 1C        7813   	sta tempst+1
                         7814   
                         7815   ;to fill the shape:
                         7816   ;  1) move current position down until a dot is found that is on
                         7817   ;  2) move up until a dot is found that is on
                         7818   ;     a. set each dot that is off to the color specified
                         7819   ;     b. test the dot to the right and save each coordinate
                         7820   ;that begins a string of reset points
                         7821   ;     c. test each dot on the left in the same way as (b)
                         7822   ;  3) remove a saved coordinate and repeat from (1)
                         7823   ;  4) done when there are no more saved coordinates
                         7824   
     6208                7825   ptloop
     6208   A2 00        7826   	ldx #0
     620A   86 63        7827   	stx left_flag	;init flags = 0 - prev point set
     620C   86 64        7828   	stx right_flag	;use to test if previous point was on or off
                         7829   
     620E                7830   ptdown			;move down until a point is found is found that is set.
     620E   AE 1133      7831   	ldx ypos
     6211   D0 03        7832   	bne ptdwn2
     6213   CE 1134      7833   	dec ypos+1
     6216                7834   ptdwn2
     6216   CE 1133      7835   	dec ypos
     6219   20 9C4C      7836   	jsr readpt	;test if point set or reset
     621C   B0 02        7837   	bcs ptbotm	;skip if ypos < 0
     621E   D0 EE        7838   	bne ptdown	;loop if point is not = colsel
     6220                7839   ptbotm
     6220   EE 1133      7840   	inc ypos
     6223   D0 03        7841   	bne ptfill
     6225   EE 1134      7842   	inc ypos+1
     6228                7843   ptfill
     6228   20 9C19      7844   	jsr plot01	;set the point
     622B   AE 1131      7845   	ldx xpos
     622E   D0 03        7846   	bne ptfil2
     6230   CE 1132      7847   	dec xpos+1
     6233                7848   ptfil2
     6233   CE 1131      7849   	dec xpos
     6236   A5 63        7850   	lda left_flag	;get left flag value
     6238   20 6299      7851   	jsr tstval	;test if need to save coordinates, crash if overflow
     623B   85 63        7852   	sta left_flag	;save new flag value
     623D   18           7853   	clc	      	;move to xpos 2 to the right
     623E   AD 1131      7854   	lda xpos
     6241   69 02        7855   	adc #2
     6243   8D 1131      7856   	sta xpos
     6246   90 03        7857   	bcc ptfil3

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 108-2
PAINT Command   PAINT.SRC

Error Addr  Code          Seq   Source statement

     6248   EE 1132      7858   	inc xpos+1
     624B                7859   ptfil3
     624B   A5 64        7860   	lda right_flag	;get right flag value
     624D   20 6299      7861   	jsr tstval	;test if need to save coordinates, crash if overflow
     6250   85 64        7862   	sta right_flag	;save new flag value
                         7863   
     6252   AE 1131      7864   	ldx xpos	;decrement xpos, increment ypos
     6255   D0 03        7865   	bne ptfil4
     6257   CE 1132      7866   	dec xpos+1
     625A                7867   ptfil4
     625A   CE 1131      7868   	dec xpos
     625D   EE 1133      7869   	inc ypos
     6260   D0 03        7870   	bne ptfil6
     6262   EE 1134      7871   	inc ypos+1
     6265                7872   ptfil6
     6265   20 9C4C      7873   	jsr readpt	;test if set
     6268   B0 02        7874   	bcs ptmax	;skip if ypos >= max
     626A   D0 BC        7875   	bne ptfill	;loop if point is not equal to colsel
     626C                7876   ptmax
     626C   A2 03        7877   	ldx #3
     626E   A0 00        7878   	ldy #0
                         7879   ;
                         7880   ; test if stack empty. if so, done. else continue.
                         7881   ;
     6270   A5 25        7882   	lda index1+1
     6272   C5 34        7883   	cmp strend+1
     6274   D0 06        7884   	bne ptmax2
     6276   A5 24        7885   	lda index1
     6278   C5 33        7886   	cmp strend
     627A   F0 1A        7887   	beq ptdone	;empty..exit.
     627C                7888   ptmax2
     627C   A5 24        7889   	lda index1
     627E   D0 02        7890   	bne 30$
     6280   C6 25        7891   	dec index1+1
     6282   C6 24        7892   30$	dec index1
     6284   20 03B7      7893   	jsr indin1_ram1	;move 4 byte addr into xpos/ypos
     6287   8D FF03      7894   	sta sw_rom_ram0
     628A   9D 1131      7895   	sta xpos,x
     628D   CA           7896   	dex
     628E   10 EC        7897   	bpl ptmax2
                         7898   
     6290   20 4BD2      7899   	jsr is_stop_key_down
     6293   4C 6208      7900   	jmp ptloop	;loop for another pass
     6296                7901   ptdone
     6296   4C 9DFB      7902   	jmp dstpos	;restore original coordinates,do rts
                         7903   
                         7904   
                         7905   
                         7906   ;tstval - test value of position
                         7907   ;  if set then set flag to zero
                         7908   ;  if reset and flag = 1 then do nothing
                         7909   ;  if reset and flag = 0 then save position on stack
                         7910   ;     and set flag = 1
                         7911   
     6299                7912   tstval

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 108-3
PAINT Command   PAINT.SRC

Error Addr  Code          Seq   Source statement

     6299   48           7913   	pha		;save flag value
     629A   20 9C4C      7914   	jsr readpt	;test position is set
     629D   B0 18        7915   	bcs tstgo	;skip if position out of bounds
     629F   F0 16        7916   	beq tstgo	;exit if point equal colsel
     62A1   68           7917   	pla
     62A2   D0 16        7918   	bne tstxit	;exit if previous point reset
                         7919   
     62A4   AA           7920   	tax		;make x & y =0 for later use
     62A5   A8           7921   	tay
     62A6   A5 25        7922   	lda index1+1    ;test if there is room on stack for another 4 bytes.
     62A8   C5 1C        7923   	cmp tempst+1
     62AA   90 0F        7924   	bcc ptsave	;..ok
     62AC   D0 06        7925   	bne pterr	;..full
     62AE   A5 24        7926   	lda index1	;..ms byte equal, test ls byte
     62B0   C5 1B        7927   	cmp tempst
     62B2   90 07        7928   	bcc ptsave	;..ok
     62B4   4C 4D57      7929   pterr	jmp omerr	;out of memory error
                         7930   
     62B7   68           7931   tstgo	pla
     62B8   A9 00        7932   	lda #0		;set flag - last point set
     62BA   60           7933   tstxit	rts
                         7934   
                         7935   
     62BB   BD 1131      7936   ptsave	lda xpos,x	;save 4 bytes of address on stack
     62BE   8D FF04      7937   	sta sw_rom_ram1
     62C1   91 24        7938   	sta (index1),y
     62C3   8D FF03      7939   	sta sw_rom_ram0
     62C6   E6 24        7940   	inc index1
     62C8   D0 02        7941   	bne 20$
     62CA   E6 25        7942   	inc index1+1
     62CC   E8           7943   20$	inx
     62CD   E0 04        7944   	cpx #4
     62CF   D0 EA        7945   	bne ptsave
     62D1   A9 80        7946   	lda #$80	;set flag - last point reset
     62D3   60           7947   	rts
                         7948   
                         7949   ;.end
                         7950   	.include box		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 109
BOX Command   BOX.SRC

Error Addr  Code          Seq   Source statement

                         7952   	.subttl BOX Command
                         7953   
                         7954   ;**************************************************************
                         7955   ;
                         7956   ;  box  (s), p1 ( , (p2) (, (ang) , fill ) )  --  draw a box
                         7957   ;          s = color (1-4) (default=fg (1))
                         7958   ;          p1 = a corner coordinate
                         7959   ;          x2,y2 = opposite diagonal coordinate
                         7960   ;                 (default = current xpos/ypos)
                         7961   ;          ang = rotation angle (default = 0)
                         7962   ;          fill = fill with color (default = 0)
                         7963   ;
                         7964   ;*************************************************************
                         7965   
     62D4   20 9E38      7966   box	jsr grpcol      ;make sure a graphics area has been allocated, get color
     62D7   A2 1F        7967   	ldx #xcord1-vwork
     62D9   20 9E76      7968   	jsr incor3      ;get x/y coordinates
     62DC   A2 2B        7969   	ldx #xcord2-vwork
     62DE   20 9E5B      7970   	jsr incor2      ;get optional 2nd x/y coordinates
     62E1   20 9E0F      7971   	jsr optwrd      ;get 2 byte angle, or 0,0 if no arg.
     62E4   8C 1154      7972   	sty boxang
     62E7   8D 1155      7973   	sta boxang+1    ;save rotation angle
     62EA   20 9E25      7974   	jsr optzer
     62ED   E0 02        7975   	cpx #2
     62EF   90 03        7976   	bcc 1$		;good arg
     62F1   4C 7DC5      7977   	jmp fcerr	;illegal value
                         7978   
     62F4   8E 116C      7979   1$	stx filflg
     62F7   8A           7980   	txa
     62F8   48           7981   	pha
     62F9   20 63A6      7982   	jsr boxsub      ;set up values & get 1st side
     62FC   68           7983   	pla
     62FD   D0 1C        7984   	bne boxfil      ;skip if to be filled
     62FF   F0 03        7985   	beq box15
                         7986   
     6301                7987   box10
     6301   20 6428      7988   	jsr boxpnt      ;get next position
     6304                7989   box15
     6304   20 9B30      7990   	jsr drawln      ;connect to last position
     6307   AD 114E      7991   	lda angcnt
     630A   D0 F5        7992   	bne box10	;loop 4 times
     630C                7993   box20
     630C   A2 04        7994   	ldx #4
     630E                7995   box30
     630E   BD 115B      7996   	lda xcord2-1,x  ;reset xpos/ypos to x2,y2
     6311   9D 1130      7997   	sta xpos-1,x
     6314   CA           7998   	dex
     6315   D0 F7        7999   	bne box30
     6317   8E 116C      8000   	stx filflg      ;clear fill flag
     631A   60           8001   	rts
                         8002   
                         8003   
                         8004   
                         8005   ;***********************************************************
                         8006   ;

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 109-1
BOX Command   BOX.SRC

Error Addr  Code          Seq   Source statement

                         8007   ;  boxfil  --  same as box except fill rectangle with color
                         8008   ;
                         8009   ;***********************************************************
                         8010   
     631B                8011   boxfil
     631B   A2 00        8012   	ldx #0
     631D   AD 1149      8013   	lda angsgn
     6320   4A           8014   	lsr a
     6321   90 02        8015   	bcc boxf05
     6323   A2 02        8016   	ldx #2
     6325                8017   boxf05
     6325   BD 1160      8018   	lda xcord1+16,x
     6328   8D 115A      8019   	sta bxleng      ;save absolute difference
     632B   BD 1161      8020   	lda xcord1+17,x
     632E   8D 115B      8021   	sta bxleng+1
     6331   A9 00        8022   	lda #0
     6333   A2 03        8023   	ldx #3
     6335                8024   boxf10
     6335   9D 1156      8025   	sta xcount,x    ;init values to zero
     6338   CA           8026   	dex
     6339   10 FA        8027   	bpl boxf10
                         8028   ;
                         8029   ;  fill box by drawing lines connecting opposite sides of the box
                         8030   ;
     633B                8031   boxf20
     633B   A2 07        8032   	ldx #7
     633D                8033   boxf25
     633D   BD 1131      8034   	lda xpos,x      ;save coordinates
     6340   48           8035   	pha
     6341   CA           8036   	dex
     6342   10 F9        8037   	bpl boxf25
     6344   20 9B30      8038   	jsr drawln      ;connect the two points
     6347   A2 00        8039   	ldx #0
     6349                8040   boxf28
     6349   68           8041   	pla
     634A   9D 1131      8042   	sta xpos,x      ;restore coordinates
     634D   E8           8043   	inx
     634E   E0 08        8044   	cpx #8
     6350   D0 F7        8045   	bne boxf28
     6352                8046   boxf30
     6352   AD 115A      8047   	lda bxleng
     6355   D0 05        8048   	bne boxf40      ;check count
     6357   CE 115B      8049   	dec bxleng+1
     635A   30 B0        8050   	bmi box20	;exit if down to zero
     635C                8051   boxf40
     635C   CE 115A      8052   	dec bxleng      ;decrement count
     635F   A2 25        8053   	ldx #xcount-vwork
     6361   A0 1B        8054   	ldy #cosval-vwork
     6363   AD 1149      8055   	lda angsgn
     6366   4A           8056   	lsr a
     6367   90 02        8057   	bcc boxf45
     6369   A0 19        8058   	ldy #sinval-vwork
     636B                8059   boxf45
     636B   A9 00        8060   	lda #0
     636D                8061   boxf50

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 109-2
BOX Command   BOX.SRC

Error Addr  Code          Seq   Source statement

     636D   4A           8062   	lsr a
     636E   48           8063   	pha
     636F   20 9D76      8064   	jsr addtwo      ;add inc value to count of increment
     6372   9D 1131      8065   	sta vwork,x
     6375   98           8066   	tya		;save sum to count of increment
     6376   9D 1132      8067   	sta vwork+1,x
     6379   68           8068   	pla
     637A   90 02        8069   	bcc boxf60
     637C   09 A0        8070   	ora #$a0	 ;flag to show to increment position
     637E                8071   boxf60
     637E   E8           8072   	inx
     637F   E8           8073   	inx
     6380   A0 19        8074   	ldy #sinval-vwork
     6382   4E 1149      8075   	lsr angsgn
     6385   90 02        8076   	bcc boxf65
     6387   A0 1B        8077   	ldy #cosval-vwork
     6389                8078   boxf65
     6389   2E 1149      8079   	rol angsgn
     638C   E0 27        8080   	cpx #ycount-vwork
     638E   F0 DD        8081   	beq boxf50      ;loop to do y-increment
     6390   A2 06        8082   	ldx #6
     6392   0A           8083   	asl a
     6393   F0 BD        8084   	beq boxf30      ;loop if neither position incremented
     6395                8085   boxf70
     6395   90 08        8086   	bcc boxf80      ;skip increment to position
     6397   FE 1131      8087   	inc xpos,x
     639A   D0 03        8088   	bne boxf80
     639C   FE 1132      8089   	inc xpos+1,x
     639F                8090   boxf80
     639F   0A           8091   	asl a
     63A0   CA           8092   	dex
     63A1   CA           8093   	dex
     63A2   10 F1        8094   	bpl boxf70      ;loop 4 times
     63A4   30 95        8095   	bmi boxf20      ;loop to connect points
                         8096   
                         8097   
                         8098   
                         8099   ;**************************************************************
                         8100   ;
                         8101   ;  boxsub  -  set up coordinate positions for box drawing
                         8102   ;	      get first coordinate point
                         8103   ;
                         8104   ;*************************************************************
                         8105   
     63A6                8106   boxsub
     63A6   A0 23        8107   	ldy #boxang-vwork
     63A8   20 9A74      8108   	jsr getang      ;set up sine & cosine values for rotation angle
     63AB   A2 1F        8109   	ldx #xcord1-vwork
     63AD   A0 2B        8110   	ldy #xcord2-vwork
     63AF                8111   boxs10
     63AF   98           8112   	tya
     63B0   48           8113   	pha
     63B1   20 9DA2      8114   	jsr abstwo
     63B4   9D 1135      8115   	sta vwork+4,x   ;set distance = abs(coord1-coord2)
     63B7   9D 1139      8116   	sta vwork+8,x

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 109-3
BOX Command   BOX.SRC

Error Addr  Code          Seq   Source statement

     63BA   9D 1141      8117   	sta vwork+16,x
     63BD   98           8118   	tya
     63BE   9D 1136      8119   	sta vwork+5,x   ;save high byte
     63C1   9D 113A      8120   	sta vwork+9,x
     63C4   9D 1142      8121   	sta vwork+17,x
     63C7   68           8122   	pla
     63C8   A8           8123   	tay
     63C9   20 9D76      8124   	jsr addtwo
     63CC   9D 1131      8125   	sta vwork,x     ;set center pts = coord1+coord2
     63CF   98           8126   	tya
     63D0   9D 1132      8127   	sta vwork+1,x
     63D3   A0 2D        8128   	ldy #ycord2-vwork
     63D5   E8           8129   	inx
     63D6   E8           8130   	inx
     63D7   E0 21        8131   	cpx #ycord1-vwork
     63D9   F0 D4        8132   	beq boxs10      ;loop to do y values
     63DB   A9 90        8133   	lda #$90
     63DD   20 9AF3      8134   	jsr angdst      ;set up xang1-4
     63E0   AD 1149      8135   	lda angsgn
     63E3   29 03        8136   	and #03
     63E5   8D 1149      8137   	sta angsgn      ;mask to 1 of four angle phases
     63E8   AA           8138   	tax
     63E9   BD 640A      8139   	lda boxtab,x    ;get values for 1st points
     63EC   20 6428      8140   	jsr boxpnt      ;set pt1 = xctr-xd*cos+yd*sin , yctr-xd*sin-yd*cos
     63EF   20 9DFB      8141   	jsr dstpos      ;move to xpos/ypos
     63F2   AD 114E      8142   	lda angcnt
     63F5   20 6428      8143   	jsr boxpnt      ;get next coordinate counter clockwise
     63F8   AE 1149      8144   	ldx angsgn
     63FB   BD 640A      8145   	lda boxtab,x
     63FE   29 F0        8146   	and #$f0
     6400   8D 114F      8147   	sta angcnt+1
     6403   BD 640E      8148   	lda boxtab+4,x
     6406   8D 114E      8149   	sta angcnt
     6409   60           8150   	rts
                         8151   
     640A                8152   boxtab
     640A   BE E4 41     8153   	.byte $be,$e4,$41,$1b,$41,$1b,$be,$e4
     640D   1B 41 1B            
     6410   BE E4               
     6412   46 52 45     8154   	.byte $46,$52,$45,$44,$20,$42,$0d
     6415   44 20 42            
     6418   0D                  
     6419   54 45 52     8155   	.byte $54,$45,$52,$52,$59,$20,$52,$0d
     641C   52 59 20            
     641F   52 0D               
     6421   4D 49 4B     8156   	.byte $4d,$49,$4b,$45,$20,$49,$0d
     6424   45 20 49            
     6427   0D                  
                         8157   
                         8158   
                         8159   
                         8160   ;*************************************************************
                         8161   ;
                         8162   ;  boxpnt  --  get the next box corner point
                         8163   ;		pt(x) = xcenter +/- xd*cos +/- yd*sin

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 109-4
BOX Command   BOX.SRC

Error Addr  Code          Seq   Source statement

                         8164   ;		pt(y) = ycenter +/- xd*sin +/- yd*cos
                         8165   ;		a = +/-,+/-,+/-,+/-
                         8166   ;
                         8167   ;*************************************************************
                         8168   
     6428                8169   boxpnt
     6428   20 6784      8170   	jsr anglpt      ;get coordinate point
     642B   A2 04        8171   	ldx #4
     642D                8172   boxp10
     642D   BD 1132      8173   	lda xpos+1,x
     6430   0A           8174   	asl a		;carry sign into shift
     6431   7E 1132      8175   	ror xpos+1,x    ;divide by 2 to scale
     6434   7E 1131      8176   	ror xpos,x
     6437   90 08        8177   	bcc boxp20
     6439   FE 1131      8178   	inc xpos,x      ;add 1 for rounding
     643C   D0 03        8179   	bne boxp20
     643E   FE 1132      8180   	inc xpos+1,x
     6441                8181   boxp20
     6441   E8           8182   	inx
     6442   E8           8183   	inx
     6443   E0 06        8184   	cpx #6
     6445   F0 E6        8185   	beq boxp10      ;loop to divide ydest
     6447   60           8186   	rts
                         8187   
                         8188   ;.end
                         8189   	.include sshape		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 110
SSHAPE Command   SSHAPE.SRC

Error Addr  Code          Seq   Source statement

                         8191   	.subttl SSHAPE Command
                         8192   
                         8193   ;******************************************************************
                         8194   ;
                         8195   ;  sshape str , p1 (,p2)  --  save a shape into string ( str )
                         8196   ;	    str  =  string to hold shape
                         8197   ;	     p1  =  one corner coordinate of the shape to be saved
                         8198   ;	     p2  =  opposite diagonal coordinate of the shape
                         8199   ;		      default = current coordinate position
                         8200   ;
                         8201   ;******************************************************************
                         8202   
     6448   20 A07D      8203   sshape	jsr isgrap      	;make sure graphics area is allocated
     644B   20 7B4C      8204   	jsr ptrget
     644E   8D FF03      8205   	sta sw_rom_ram0
     6451   8D 115F      8206   	sta stradr
     6454   8C 1160      8207   	sty stradr+1    	;save symbol table address
     6457   24 0F        8208   	bit valtyp
     6459   30 03        8209   	bmi havstr      	;skip if a string
     645B   4C 7884      8210   	jmp chkerr      	;exit - type mismatch
                         8211   
     645E   A2 28        8212   havstr	ldx #xsize-vwork
     6460   20 9E76      8213   	jsr incor3      	;get first coordinates
                         8214   
     6463   A2 04        8215   	ldx #xdest-vwork
     6465   20 9E5B      8216   	jsr incor2      	;get optional second coordinate pair
                         8217   
     6468   A2 2A        8218   	ldx #ysize-vwork
     646A   A0 06        8219   	ldy #ydest-vwork
     646C   A9 02        8220   	lda #2
     646E   85 8E        8221   	sta vtemp1
                         8222   
     6470   20 9DA2      8223   3$	jsr abstwo      	;get top left coordinates of rectangle
     6473   AA           8224   	tax
     6474   98           8225   	tya			;save column/row length
     6475   48           8226   	pha
     6476   A4 8E        8227   	ldy vtemp1
     6478   20 9E02      8228   	jsr dstmov      	;move dest into pos
     647B   90 0C        8229   	bcc 4$			;skip if x/y-cord > x/y-dest
     647D   B9 1159      8230   	lda xsize,y
     6480   99 1131      8231   	sta xpos,y      	;else use x/y-cord as lower value
     6483   B9 115A      8232   	lda xsize+1,y
     6486   99 1132      8233   	sta xpos+1,y
                         8234   
     6489   8A           8235   4$	txa			;save low byte of size
     648A   99 1159      8236   	sta xsize,y
     648D   99 03DB      8237   	sta savsiz,y
     6490   68           8238   	pla			;save high byte of size
     6491   99 115A      8239   	sta xsize+1,y
     6494   99 03DC      8240   	sta savsiz+1,y
     6497   A2 28        8241   	ldx #xsize-vwork
     6499   A0 04        8242   	ldy #xdest-vwork
     649B   C6 8E        8243   	dec vtemp1
     649D   C6 8E        8244   	dec vtemp1
     649F   F0 CF        8245   	beq 3$			;loop to test x-positions

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 110-1
SSHAPE Command   SSHAPE.SRC

Error Addr  Code          Seq   Source statement

     64A1   A0 FF        8246   	ldy #$ff		;init byte counter into shape string
     64A3   8C 1155      8247   	sty strptr
     64A6   AD 1131      8248   	lda xpos
     64A9   8D 115D      8249   	sta xsave		;save xpos in temp location
     64AC   AD 1132      8250   	lda xpos+1
     64AF   8D 115E      8251   	sta xsave+1
     64B2   98           8252   	tya			;($ff)
     64B3   20 8690      8253   	jsr strspa		;reserve string space for shape buffer (dsctmp)
     64B6   8D FF03      8254   	sta sw_rom_ram0
                         8255   
     64B9   20 9CEC      8256   10$	jsr getpos      	;get bit map position
     64BC   B1 8C        8257   	lda (grapnt),y  	;get bit map byte
     64BE   90 0E        8258   	bcc 30$			;skip if addr in bounds
     64C0   AD 1131      8259   	lda xpos
     64C3   24 D8        8260   	bit _graphm
     64C5   10 02        8261   	bpl 20$			;skip if not multicolor mode
     64C7   38           8262   	sec			;mult xpos*2 & add 1
     64C8   2A           8263   	rol a
     64C9   29 07        8264   20$	and #07			;get bit offset into bit map byte
     64CB   AA           8265   	tax
     64CC   A9 00        8266   	lda #0			;set up null bit map byte
     64CE   24 D8        8267   30$	bit _graphm
     64D0   10 01        8268   	bpl 40$			;skip if not multicolor mode
     64D2   CA           8269   	dex			;move bit position back
     64D3   8E 1161      8270   40$	stx bitidx		;save bit offset into bit map byte
     64D6   0A           8271   50$	asl a			;left justify the bit map byte
     64D7   CA           8272   	dex
     64D8   10 FC        8273   	bpl 50$
     64DA   6A           8274   	ror a
     64DB   85 8E        8275   	sta vtemp1		;save the shifted byte
     64DD   A9 08        8276   	lda #8			;increment column position by 4 or 8
     64DF   24 D8        8277   	bit _graphm
     64E1   10 01        8278   	bpl 55$
     64E3   4A           8279   	lsr a
     64E4   18           8280   55$	clc
     64E5   6D 1131      8281   	adc xpos
     64E8   8D 1131      8282   	sta xpos
     64EB   90 03        8283   	bcc 56$
     64ED   EE 1132      8284   	inc xpos+1
     64F0   20 9CEC      8285   56$	jsr getpos      	;get bit map position
     64F3   A9 00        8286   	lda #0
     64F5   B0 02        8287   	bcs 60$			;skip if position out of bounds
     64F7   B1 8C        8288   	lda (grapnt),y  	;- else get bit map byte
     64F9   85 8F        8289   60$	sta vtemp2      	;save bit map byte
     64FB   AE 1161      8290   	ldx bitidx      	;get bit index into byte
     64FE   4A           8291   70$	lsr a			;right justify bits
     64FF   E8           8292   	inx
     6500   E0 08        8293   	cpx #8
     6502   D0 FA        8294   	bne 70$
     6504   05 8E        8295   	ora vtemp1      	;get left bits
     6506   EE 1155      8296   	inc strptr      	;increment pointer into string area
     6509   AC 1155      8297   	ldy strptr
     650C   C0 FC        8298   	cpy #252
     650E   90 03        8299   	bcc 80$			;skip if string not filled
     6510   4C A5FD      8300   	jmp errlen      	;string too long error

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 110-2
SSHAPE Command   SSHAPE.SRC

Error Addr  Code          Seq   Source statement

                         8301   
     6513   8D FF04      8302   80$	sta sw_rom_ram1
     6516   91 64        8303   	sta (dsctmp+1),y 	;save byte into string
     6518   8D FF03      8304   	sta sw_rom_ram0
     651B   AE 1161      8305   	ldx bitidx      	;get bit index into bit map byte
     651E   AD 1159      8306   	lda xsize
     6521   38           8307   	sec
     6522   24 D8        8308   	bit _graphm
     6524   10 03        8309   	bpl 85$
     6526   E9 04        8310   	sbc #4
     6528   2C           8311   	.byte $2c
     6529   E9 08        8312   85$	sbc #8			;subtract 8 from column length count
     652B   8D 1159      8313   	sta xsize
     652E   A5 8F        8314   	lda vtemp2      	;restore bit map byte
     6530   B0 A4        8315   	bcs 50$			;loop if not done with row
     6532   CE 115A      8316   	dec xsize+1
     6535   10 9F        8317   	bpl 50$			;loop if not done with row
     6537   AE 115B      8318   	ldx ysize
     653A   D0 48        8319   	bne 100$		;skip if not done
     653C   CE 115C      8320   	dec ysize+1
     653F   10 43        8321   	bpl 100$		;skip if not done
                         8322   
     6541   24 D8        8323   	bit _graphm		;if multicolor mode, multiply x by 2
     6543   10 06        8324   	bpl 88$
     6545   0E 03DB      8325   	asl savsiz
     6548   2E 03DC      8326   	rol savsiz+1
     654B   A2 00        8327   88$	ldx #0
                         8328   
     654D   BD 03DB      8329   90$	lda savsiz,x    	;move column & row lengths
     6550   C8           8330   	iny			;- to end of string area
     6551   8D FF04      8331   	sta sw_rom_ram1
     6554   91 64        8332   	sta (dsctmp+1),y
     6556   8D FF03      8333   	sta sw_rom_ram0
     6559   E8           8334   	inx
     655A   E0 04        8335   	cpx #4
     655C   D0 EF        8336   	bne 90$
                         8337   
     655E   C8           8338   	iny
     655F   8C 03DB      8339   	sty savsiz      	;save string length
     6562   A5 64        8340   	lda dsctmp+1
     6564   8D 03DC      8341   	sta savsiz+1    	;save low byte of string start
     6567   A5 65        8342   	lda dsctmp+2
     6569   8D 03DD      8343   	sta savsiz+2    	;save high byte of string start
     656C   A9 DB        8344   	lda #<savsiz
     656E   85 66        8345   	sta facmo		;set addr of string descriptor
     6570   A9 03        8346   	lda #>savsiz
     6572   85 67        8347   	sta facmo+1
     6574   AD 115F      8348   	lda stradr
     6577   85 4B        8349   	sta forpnt      	;set symbol table addr of dest. string
     6579   AD 1160      8350   	lda stradr+1
     657C   85 4C        8351   	sta forpnt+1
     657E   20 54B1      8352   	jsr copy		;move string
     6581   4C 9DFB      8353   	jmp dstpos      	;restore coordinates,do rts
                         8354   
     6584   CE 115B      8355   100$	dec ysize		;decrement row count

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 110-3
SSHAPE Command   SSHAPE.SRC

Error Addr  Code          Seq   Source statement

     6587   EE 1133      8356   	inc ypos		;increment row position
     658A   D0 03        8357   	bne 110$
     658C   EE 1134      8358   	inc ypos+1
     658F   AD 115D      8359   110$	lda xsave
     6592   8D 1131      8360   	sta xpos		;restore starting column address
     6595   AD 115E      8361   	lda xsave+1
     6598   8D 1132      8362   	sta xpos+1
     659B   AD 03DB      8363   	lda savsiz
     659E   8D 1159      8364   	sta xsize		;restore column length count
     65A1   AD 03DC      8365   	lda savsiz+1
     65A4   8D 115A      8366   	sta xsize+1
     65A7   4C 64B9      8367   	jmp 10$
                         8368   
                         8369   	;.end
                         8370   	.include gshape		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 111
GSHAPE Command   GSHAPE.SRC

Error Addr  Code          Seq   Source statement

                         8372   	.subttl GSHAPE Command
                         8373   
                         8374   ;*******************************************************************
                         8375   ;
                         8376   ;  gshape str (, ( p ) , l )  -- place a stored shape on the screen
                         8377   ;           str = string variable defining the shape
                         8378   ;             p = top left corner of where to restore shape
                         8379   ;                  default = current position
                         8380   ;             l = type of replacement
                         8381   ;                 0 : replace ( default )
                         8382   ;                 1 : invert and replace
                         8383   ;                 2 : 'or' with current screen data
                         8384   ;                 3 : 'and' with current screen data
                         8385   ;                 4 : 'xor' with current screen data
                         8386   ;
                         8387   ;*******************************************************************
                         8388   
     65AA   20 A07D      8389   gshape	jsr isgrap      ;make sure graphics area is allocated
     65AD   20 877B      8390   	jsr frmstr      ;do frmevl, frestr
     65B0   8D FF03      8391   	sta sw_rom_ram0
     65B3   8D 1153      8392   	sta strsz	;save string length
     65B6   86 26        8393   	stx index2      ;save string address
     65B8   84 27        8394   	sty index2+1
                         8395   
     65BA   A2 04        8396   	ldx #xdest-vwork
     65BC   20 9E5B      8397   	jsr incor2      ;get starting bit-map address
                         8398   
     65BF   20 9E25      8399   	jsr optzer	;get type of replacement (default is 0, 'replace')
     65C2   E0 05        8400   	cpx #5
     65C4   90 03        8401   	bcc 5$		;branch if ok,
     65C6   4C 7DC5      8402   	jmp fcerr	;otherwise illegal value
                         8403   
     65C9   8E 1154      8404   5$	stx gettyp
     65CC   A2 03        8405   	ldx #3		;find x, y sizes in last 4 bytes
     65CE   AC 1153      8406   	ldy strsz
     65D1   C0 05        8407   	cpy #5		;compare with minimum string size
     65D3   B0 01        8408   	bcs 20$
     65D5   60           8409   	rts		;string too small: just exit
                         8410   
     65D6   88           8411   20$	dey
     65D7   A9 26        8412   	lda #index2
     65D9   20 03AB      8413   	jsr indsub_ram1
     65DC   8D FF03      8414   	sta sw_rom_ram0
     65DF   9D 1159      8415   	sta xsize,x     ;store in xsize,ysize
     65E2   CA           8416   	dex
     65E3   10 F1        8417   	bpl 20$
                         8418   
     65E5   8E 1155      8419   	stx strptr	;initialize pointer to position in string
     65E8   20 9DFB      8420   	jsr dstpos      ;copy xdest,ydest to xpos,ypos
                         8421   
     65EB   AD 1159      8422   	lda xsize	;make a copy of x length
     65EE   8D 115D      8423   	sta xsave
     65F1   AD 115A      8424   	lda xsize+1
     65F4   8D 115E      8425   	sta xsave+1
                         8426   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 111-1
GSHAPE Command   GSHAPE.SRC

Error Addr  Code          Seq   Source statement

     65F7   A9 08        8427   gsa	lda #8		;read fresh character from string
     65F9   8D 1169      8428   	sta bitcnt
     65FC   EE 1155      8429   	inc strptr
     65FF   AC 1155      8430   	ldy strptr
     6602   A9 26        8431   	lda #index2
     6604   20 03AB      8432   	jsr indsub_ram1
     6607   8D FF03      8433   	sta sw_rom_ram0
     660A   8D 1157      8434   	sta newbyt
                         8435   
     660D   20 9C4C      8436   gsb	jsr readpt      ;get color at xpos,ypos
     6610   8D 1156      8437   	sta oldbyt	;old byte with bit(s) of interest right justified
     6613   0E 1157      8438   	asl newbyt	;move leftmost bit(s) of new value into acc.
     6616   2A           8439   	rol a
     6617   CE 1169      8440   	dec bitcnt
     661A   24 D8        8441   	bit _graphm
     661C   10 07        8442   	bpl 30$		;branch if not multicolor
     661E   0E 1157      8443   	asl newbyt
     6621   2A           8444   	rol a
     6622   CE 1169      8445   	dec bitcnt
                         8446   
     6625   AE 1154      8447   30$	ldx gettyp	;how shall this new value be used?
     6628   E0 03        8448   	cpx #3
     662A   90 0C        8449   	bcc 40$		;branch if 0,1,or 2
     662C   F0 05        8450   	beq 35$		;branch if 3
     662E   4D 1156      8451   	eor oldbyt      ;here for 4,'xor with current value'
     6631   B0 11        8452   	bcs 60$		;always
     6633   2D 1156      8453   35$	and oldbyt	;here for 3,'and with current value'
     6636   B0 0C        8454   	bcs 60$		;always
     6638   E0 01        8455   40$	cpx #1
     663A   90 08        8456   	bcc 60$		;branch if 0,'use new value'
     663C   F0 04        8457   	beq 50$		;branch if 1
     663E   0D 1156      8458   	ora oldbyt      ;here for 2,'or with current value'
     6641   2C           8459   	.byte $2c
     6642   49 FF        8460   50$	eor #$ff	;here for 1,'invert & replace'
     6644   29 03        8461   60$	and #3		;isolate bit(s) of interest
     6646   24 D8        8462   	bit _graphm
     6648   30 02        8463   	bmi *+4		;branch if mcm
     664A   29 01        8464   	and #1		;if hi-res, just 1 bit is necessary
     664C   85 83        8465   	sta colsel
     664E   20 9C19      8466   	jsr plot01	;use plot to re-install bit & update color
                         8467   
     6651   EE 1131      8468   	inc xpos
     6654   D0 03        8469   	bne 65$
     6656   EE 1132      8470   	inc xpos+1
     6659   38           8471   65$	sec		;decrement x counter 1 or 2
     665A   AD 115D      8472   	lda xsave
     665D   24 D8        8473   	bit _graphm
     665F   10 03        8474   	bpl 66$		;branch if not multicolor
     6661   E9 02        8475   	sbc #2
     6663   2C           8476   	.byte $2c
     6664   E9 01        8477   66$	sbc #1
     6666   8D 115D      8478   	sta xsave
     6669   AD 115E      8479   	lda xsave+1
     666C   E9 00        8480   	sbc #0
     666E   8D 115E      8481   	sta xsave+1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 111-2
GSHAPE Command   GSHAPE.SRC

Error Addr  Code          Seq   Source statement

     6671   B0 2D        8482   	bcs 80$		;if xsave >= 0, keep going
                         8483   
     6673   A2 01        8484   	ldx #1		;else move xsize to xsave, xdest to xpos, & inc ypos
     6675   BD 1159      8485   70$	lda xsize,x
     6678   9D 115D      8486   	sta xsave,x
     667B   BD 1135      8487   	lda xdest,x
     667E   9D 1131      8488   	sta xpos,x
     6681   CA           8489   	dex
     6682   10 F1        8490   	bpl 70$
                         8491   
     6684   EE 1133      8492   	inc ypos
     6687   D0 03        8493   	bne 75$
     6689   EE 1134      8494   	inc ypos+1
     668C   38           8495   75$	sec		;dec ysize, exit if done
     668D   AD 115B      8496   	lda ysize
     6690   E9 01        8497   	sbc #1
     6692   8D 115B      8498   	sta ysize
     6695   AD 115C      8499   	lda ysize+1
     6698   E9 00        8500   	sbc #0
     669A   8D 115C      8501   	sta ysize+1
     669D   B0 09        8502   	bcs 90$		;keep going if not < 0 (carry clear)
     669F   60           8503   	rts		;bye!
                         8504   
     66A0   AD 1169      8505   80$	lda bitcnt	;if count=0 then get new character
     66A3   F0 03        8506   	beq 90$
     66A5   4C 660D      8507   	jmp gsb		;else just loop
                         8508   
     66A8   4C 65F7      8509   90$	jmp gsa
                         8510   
                         8511   ;end
                         8512   	.include circle		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 112
CIRCLE Command   CIRCLE.SRC

Error Addr  Code          Seq   Source statement

                         8514   	.subttl CIRCLE Command
                         8515   
                         8516   ;*************************************************************
                         8517   ;
                         8518   ;  circle s,(pc),xr(,(yr)(,(as)(,(ae)(,(rot) (,inc) ) ) ) )
                         8519   ;				  --  draw an ellipse
                         8520   ;	     s = color selection (1-4) (default = fg (1))
                         8521   ;	     pc = center coordinates (default = xpos,ypos)
                         8522   ;	     xr = x-radius  -  yr = y-radius (default = xr)
                         8523   ;	     as,ae = arc start & arc end (defalut = 0)
                         8524   ;	     rot = rotation angle (default = 0)
                         8525   ;	     inc = increment to next point (default = 2)
                         8526   ;
                         8527   ;*************************************************************
                         8528   
     66AB   20 9E38      8529   circle	jsr grpcol	;make sure graphics area has been allocated, get color
     66AE   A2 1F        8530   	ldx #xcircl-vwork
     66B0   20 9E5B      8531   	jsr incor2      ;get optional center coordinates
     66B3   20 9E0F      8532   	jsr optwrd      ;get 2-byte x-radius (default to zero?)
     66B6   8C 1154      8533   	sty xradus
     66B9   8D 1155      8534   	sta xradus+1
     66BC   20 9E0F      8535   	jsr optwrd	;get 2-byte y-radius (.c=0 if not given)
     66BF   8C 1156      8536   	sty yradus
     66C2   B0 11        8537   	bcs 10$		;branch if y-radius given (318018-03 mod; fab)
                         8538   
     66C4   AD 1154      8539   	lda xradus      ;else use x radius for y as well
     66C7   8D 1156      8540   	sta yradus
     66CA   AD 1155      8541   	lda xradus+1
     66CD   24 D8        8542   	bit _graphm
     66CF   10 04        8543   	bpl 10$		;skip if not multicolor mode
     66D1   0E 1156      8544   	asl yradus      ;double it for circle
     66D4   2A           8545   	rol a
     66D5   8D 1157      8546   10$	sta yradus+1
                         8547   
     66D8   A2 23        8548   	ldx #xradus-vwork
     66DA   20 9D53      8549   	jsr scalxy      ;scale the values	;(318018-03 mod; fab)
     66DD   EA EA EA     8550   	.byte $ea,$ea,$ea,$ea,$ea		;(318018-03 placeholder; fab)
     66E0   EA EA               
                         8551   
     66E2   20 9E0F      8552   	jsr optwrd      ;get optional 2-byte arc start
     66E5   8C 115C      8553   	sty angbeg
     66E8   8D 115D      8554   	sta angbeg+1
                         8555   
     66EB   20 9E0F      8556   	jsr optwrd      ;get optional 2-byte arc end
     66EE   8C 115E      8557   	sty angend
     66F1   8D 115F      8558   	sta angend+1
                         8559   
     66F4   20 9E0F      8560   	jsr optwrd      ;get optional 2-byte rotation angle
     66F7   85 77        8561   	sta z_p_temp_1	;swap y and a
     66F9   98           8562   	tya
     66FA   A4 77        8563   	ldy z_p_temp_1
     66FC   20 9A77      8564   	jsr gtang1      ;set sine & cosine for rotation angle
                         8565   
     66FF   A2 2D        8566   	ldx #angend-vwork ;test if angend>angbeg
     6701   A0 2B        8567   	ldy #angbeg-vwork

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 112-1
CIRCLE Command   CIRCLE.SRC

Error Addr  Code          Seq   Source statement

     6703   20 9D85      8568   	jsr subtwo
     6706   90 0E        8569   	bcc circ10      ;skip if yes
     6708   A9 68        8570   	lda #104
     670A   A0 01        8571   	ldy #1
     670C   20 9D79      8572   	jsr addtw2      ;add 360 to arc-end
     670F   9D 1131      8573   	sta vwork,x
     6712   98           8574   	tya
     6713   9D 1132      8575   	sta vwork+1,x
     6716                8576   circ10
     6716   A2 03        8577   	ldx #3
     6718                8578   circ20
     6718   BD 1154      8579   	lda xradus,x    ;duplicate x-rad/y-rad in xdist2/ydist2
     671B   9D 1158      8580   	sta xdist2,x
     671E   CA           8581   	dex
     671F   10 F7        8582   	bpl circ20
     6721   A9 90        8583   	lda #$90
     6723   20 9AF3      8584   	jsr angdst      ;get distances * rotation angle
                         8585   
                         8586   ;  xdist1 = xr*cos   --   ydist1 = yr*sin
                         8587   ;  xdist2 = xr*sin   --   ydist2 = yr*cos
                         8588   
     6726   A2 07        8589   	ldx #7
     6728                8590   circ30
     6728   BD 1154      8591   	lda xdist1,x    ;move for later use
     672B   9D 1160      8592   	sta xrcos,x
     672E   CA           8593   	dex
     672F   10 F7        8594   	bpl circ30
     6731   20 676D      8595   	jsr cirsub      ;get 1st point on circle
     6734   20 9DFB      8596   	jsr dstpos      ;move to xpos/ypos
                         8597   
                         8598   ;  draw circle with connected lines
                         8599   ;      incrementing angbeg by cirinc for each point
                         8600   
     6737   A2 02        8601   	ldx #2
     6739   20 9E27      8602   	jsr optbyt	;get optional 1 byte increment value (default is 2)
     673C   8A           8603   	txa		;must be >0
     673D   D0 03        8604   	bne 40$		;ok
     673F   4C 7DC5      8605   	jmp fcerr	;bad
                         8606   
     6742   8E 1220      8607   40$	stx circle_segment
     6745   18           8608   	clc
                         8609   
     6746   AD 1220      8610   circ45	lda circle_segment
     6749   6D 115C      8611   	adc angbeg      ;add increment (carry assumed clear)
     674C   8D 115C      8612   	sta angbeg
     674F   90 03        8613   	bcc circ50
     6751   EE 115D      8614   	inc angbeg+1
     6754   A2 2D        8615   circ50	ldx #angend-vwork ;test if angend>angbeg
     6756   A0 2B        8616   	ldy #angbeg-vwork
     6758   20 9D85      8617   	jsr subtwo
     675B   B0 08        8618   	bcs cirend      ;yes - do once more
     675D   20 676D      8619   	jsr cirsub      ;get next point on circle
     6760   20 9B30      8620   	jsr drawln      ;connect to last point
     6763   90 E1        8621   	bcc circ45      ;loop always
     6765                8622   cirend

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 112-2
CIRCLE Command   CIRCLE.SRC

Error Addr  Code          Seq   Source statement

     6765   A0 2D        8623   	ldy #angend-vwork
     6767   20 676F      8624   	jsr cirs10      ;get last point for arc-end
     676A   4C 9B30      8625   	jmp drawln
                         8626   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 113
CIRCLE Command   CIRCLE.SRC

Error Addr  Code          Seq   Source statement

                         8628   
                         8629   ;***********************************************************
                         8630   ;
                         8631   ;  cirsub  --  find the next point on the circle
                         8632   ;     x = xctr + xr*cos(a)*sin(b) + yr*sin(a)*cos(b)
                         8633   ;     y = yctr + xr*sin(a)*sin(b) - yr*cos(a)*cos(b)
                         8634   ;     where: a = rotation angle  --  b = circle arc angle
                         8635   ;
                         8636   ;***********************************************************
                         8637   
     676D   A0 2B        8638   cirsub	ldy #angbeg-vwork
                         8639   
     676F   20 9A74      8640   cirs10	jsr getang      ;get sine & cosine values for arc angle
                         8641   
     6772   A2 07        8642   	ldx #7
     6774   BD 1160      8643   1$	lda xrcos,x	;move radius * rotation-angle values to xdist
     6777   9D 1154      8644   	sta xdist1,x
     677A   CA           8645   	dex
     677B   10 F7        8646   	bpl 1$
                         8647   
     677D   A9 50        8648   	lda #$50
     677F   20 9AF3      8649   	jsr angdst      ;multiply times arc-angle values
     6782   A9 10        8650   	lda #$10	;fall thru to angplt
                         8651   
                         8652   
                         8653   ;**************************************************************
                         8654   ;
                         8655   ;  anglpt  --  determine a point on the screen
                         8656   ;		xdest = xcentr +/- xdist1 +/- ydist1
                         8657   ;		ydest = ycentr +/- xdist2 +/- ydist2
                         8658   ;		a = signs: +/-,+/-,+/-,+/-,0,0,0,0
                         8659   ;
                         8660   ;**************************************************************
                         8661   
     6784   8D 114E      8662   anglpt	sta angcnt      ;save plus or minus signs
     6787   A0 1F        8663   	ldy #xcentr-vwork
     6789   A2 23        8664   	ldx #xdist1-vwork
                         8665   
     678B   0E 114F      8666   10$	asl angcnt+1
     678E   2E 114E      8667   	rol angcnt      ;get sign
     6791   20 9D74      8668   	jsr dotwo	;add or subtract 1st value to center pt
     6794   E8           8669   	inx
     6795   E8           8670   	inx		;point to next value
     6796   0E 114F      8671   	asl angcnt+1
     6799   2E 114E      8672   	rol angcnt      ;get next sign
     679C   20 9D70      8673   	jsr dotwo2      ;add or subtract to previous result
     679F   48           8674   	pha
     67A0   98           8675   	tya		;save 2-byte result on stack
     67A1   48           8676   	pha
     67A2   A0 21        8677   	ldy #ycentr-vwork ;set to do y-point
     67A4   E8           8678   	inx
     67A5   E8           8679   	inx		;point to next value
     67A6   E0 27        8680   	cpx #xdist2-vwork
     67A8   F0 E1        8681   	beq 10$		;loop to do y-point
                         8682   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 113-1
CIRCLE Command   CIRCLE.SRC

Error Addr  Code          Seq   Source statement

     67AA   A2 03        8683   	ldx #3
     67AC   68           8684   20$	pla
     67AD   9D 1135      8685   	sta xdest,x	;move results to xdest/ydest
     67B0   CA           8686   	dex
     67B1   10 F9        8687   	bpl 20$
     67B3   60           8688   	rts
                         8689   
                         8690   ;.end
                         8691   	.include draw		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 114
DRAW Command   DRAW.SRC

Error Addr  Code          Seq   Source statement

                         8693   	.subttl DRAW Command
                         8694   ;********************************************************
                         8695   ;
                         8696   ;  draw {s} { ,p !  to p }
                         8697   ;
                         8698   ;	   where:
                         8699   ;		  s    = optional color selection (1-4)
                         8700   ;		  p    = point to plot
                         8701   ;		  to p = draw a line to the point p
                         8702   ;
                         8703   ;********************************************************
                         8704   
     67B4   20 A07D      8705   draw	jsr isgrap		;make sure graphics area has been allocated
                         8706   
     67B7   A2 01        8707   	ldx #1
     67B9   86 83        8708   	stx colsel		;set default color selection
                         8709   
     67BB   20 0386      8710   	jsr chrgot
     67BE   C9 A4        8711   	cmp #totk		;check if of the form 'draw to'
     67C0   F0 0B        8712   	beq 10$			;yes, use defaults
                         8713   
     67C2   20 9E3B      8714   	jsr incolr		;get color, or set up default
     67C5   20 0386      8715   	jsr chrgot		;eol?
     67C8   D0 03        8716   	bne 10$			;no, go on.
     67CA   4C 9BFB      8717   	jmp gplot		;form is 'DRAW' : plot one point at xpos,ypos
                         8718   
     67CD   20 0386      8719   10$	jsr chrgot
     67D0   C9 2C        8720   	cmp #','
     67D2   F0 05        8721   	beq 20$			;statement of form ',p'
     67D4   C9 A4        8722   	cmp #totk
     67D6   F0 01        8723   	beq 20$			;'to p'
     67D8   60           8724   	rts			;ok if end of statement, anything else will crash
                         8725   
     67D9   48           8726   20$	pha
     67DA   20 0380      8727   	jsr chrget		;skip over comma or semicolon
     67DD   A2 04        8728   	ldx #xdest-vwork
     67DF   20 9E79      8729   	jsr incord
     67E2   68           8730   	pla
     67E3   10 06        8731   	bpl 40$			;branch if ','
     67E5   20 9B30      8732   	jsr drawln
     67E8   4C 67CD      8733   	jmp 10$
                         8734   
     67EB   20 9DFB      8735   40$	jsr dstpos
     67EE   20 9BFB      8736   	jsr gplot		;plot to the point
     67F1   4C 67CD      8737   	jmp 10$
                         8738   
                         8739   
                         8740   ;.end
                         8741   	.include char		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 115
CHAR Command   CHAR.SRC

Error Addr  Code          Seq   Source statement

                         8743   	.subttl CHAR Command
                         8744   
                         8745   ;*****************************************************************
                         8746   ;
                         8747   ;   char (s),x,y,str(,r) -- display a character string
                         8748   ;	s = color selection (1-4) (default is foreground (1))
                         8749   ;	x,y = column/row position for 1st character
                         8750   ;	str = character string (1-255)
                         8751   ;	r = normal(0) or reverse(1)
                         8752   ;
                         8753   ;*****************************************************************
                         8754   
     67F4   20 9E3B      8755   char	jsr incolr		;get color selection
                         8756   
     67F7   A2 29        8757   	ldx #llen+1		;set up screen size. assume graphics
     67F9   A0 1A        8758   	ldy #nlines+1
     67FB   A5 D8        8759   	lda _graphm		;test if assumption correct
     67FD   D0 05        8760   	bne 10$			;..it's twooo! it's twooo!
     67FF   20 FFED      8761   	jsr _screen_org		;it's text. test how large the virtual window is
     6802   E8           8762   	inx
     6803   C8           8763   	iny
                         8764   
     6804   8E 115E      8765   10$	stx colcnt
     6807   8C 115F      8766   	sty rowcnt
                         8767   
     680A   20 8809      8768   	jsr combyt		;check comma, get column number
     680D   EC 115E      8769   	cpx colcnt
     6810   B0 0B        8770   	bcs charer		;exit - col number too large
     6812   8E 115E      8771   	stx colcnt
                         8772   
     6815   20 8809      8773   	jsr combyt		;check comma, get row number
     6818   EC 115F      8774   	cpx rowcnt
     681B   90 03        8775   	bcc char10		;skip if okay
                         8776   
     681D   4C 7DC5      8777   charer	jmp fcerr		;exit - illegal value
                         8778   
     6820   8E 115F      8779   char10	stx rowcnt		;initialize column counter
     6823   20 0386      8780   	jsr chrgot		;end of line?
     6826   D0 04        8781   	bne 10$			;no, go get string
                         8782   
     6828   A9 00        8783   	lda #0			;force a length of zero,
     682A   F0 06        8784   	beq 20$			;..and skip over string handler
                         8785   
     682C   20 79F9      8786   10$	jsr chkcom		;check for comma
                         8787   
     682F   20 877B      8788   	jsr frmstr		;do frmevl, frestr. returns len in a, index points to string
     6832   8D FF03      8789   20$	sta sw_rom_ram0
     6835   8D 116E      8790   	sta numcnt		;save length
     6838   98           8791   	tya
     6839   48           8792   	pha			;save index
     683A   8A           8793   	txa
     683B   48           8794   	pha
                         8795   
     683C   20 9E25      8796   	jsr optzer		;look for optional invert (def. is 0, normal)
     683F   8A           8797   	txa			;move .x's lsb to xysgn's msb

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 115-1
CHAR Command   CHAR.SRC

Error Addr  Code          Seq   Source statement

     6840   6A           8798   	ror a
     6841   6E 113D      8799   	ror xysgn
                         8800   
     6844   68           8801   	pla			;restore 'index' (ptr to string)
     6845   85 24        8802   	sta index
     6847   68           8803   	pla
     6848   85 25        8804   	sta index+1
     684A   A5 D8        8805   	lda _graphm
     684C   D0 32        8806   	bne char20		;skip if not text screen
                         8807   
                         8808   ; case: printing to text screen
                         8809   
     684E   AE 115F      8810   	ldx rowcnt		;text mode: treat like 'print at x,y,string'
     6851   AC 115E      8811   	ldy colcnt
     6854   18           8812   	clc
     6855   20 7F1F      8813   	jsr char_patch		;move cursor (318018-03 mod: fab; call plot w/IO in)
     6858   A0 00        8814   	ldy #0
                         8815   
     685A   2C 113D      8816   	bit xysgn		;test if reverse flag set
     685D   10 05        8817   	bpl 30$			;branch if not
     685F   A9 12        8818   	lda #18			; (318018-03 mod: FAB; call print w/IO in)
     6861   20 7F25      8819   	jsr k_print		;otherwise send 'reverse on' character
                         8820   
     6864   CC 116E      8821   30$	cpy numcnt
     6867   F0 0C        8822   	beq 40$
     6869   20 03B7      8823   	jsr indin1_ram1		;get the character from the string
     686C   20 A855      8824   	jsr put_io_in_map
     686F   20 C00C      8825   	jsr _print		;print to text screen
     6872   C8           8826   	iny
     6873   D0 EF        8827   	bne 30$
                         8828   
     6875   2C 113D      8829   40$	bit xysgn		;test if reverse flag set
     6878   10 05        8830   	bpl 50$			;branch if not
     687A   A9 92        8831   	lda #146		; (318018-03 mod: FAB; call print w/IO in)
     687C   20 7F25      8832   	jsr k_print		;else send 'reverse off' char, do rts
     687F   60           8833   50$	rts
                         8834   
                         8835   
                         8836   ; case: printing to bit mapped screen
                         8837   
     6880   20 A07D      8838   char20	jsr isgrap		;make sure a graphic area has been allocated
                         8839   
     6883   AD 11EC      8840   	lda upper_graphic
     6886   8D 1168      8841   	sta character_rom	;set up pointer to upper/graphic character base
                         8842   
     6889   A5 86        8843   	lda foreground
     688B   AA           8844   	tax
     688C   48           8845   	pha			;save foreground color
     688D   A5 83        8846   	lda colsel
     688F   48           8847   	pha
     6890   24 D8        8848   	bit _graphm
     6892   10 0E        8849   	bpl char25		;skip if not multicolor mode
     6894   68           8850   	pla			;colsel
     6895   F0 16        8851   	beq char27		;use fgnd color (feature)
     6897   4A           8852   	lsr a

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 115-2
CHAR Command   CHAR.SRC

Error Addr  Code          Seq   Source statement

     6898   F0 13        8853   	beq char27		;use fgnd color
     689A   A6 84        8854   	ldx multicolor_1
     689C   90 0F        8855   	bcc char27		;use multicolor-1
     689E   A6 85        8856   	ldx multicolor_2
     68A0   B0 0B        8857   	bcs char27		;use multicolor-2
                         8858   
     68A2   A6 86        8859   char25	ldx foreground		;high-res mode
     68A4   68           8860   	pla			;colsel
     68A5   D0 06        8861   	bne char27		;use foreground color
     68A7   20 A855      8862   	jsr put_io_in_map
     68AA   AE D021      8863   	ldx vic_background
                         8864   
     68AD   86 86        8865   char27	stx foreground
     68AF   AE 115F      8866   	ldx rowcnt
     68B2   A0 00        8867   	ldy #0
     68B4   8C 1160      8868   	sty strcnt		;initialize string counter
                         8869   
     68B7   AC 1160      8870   char30	ldy strcnt		;get string offset
     68BA   EE 1160      8871   	inc strcnt		;increment offset
     68BD   20 03B7      8872   	jsr indin1_ram1		;get string character
     68C0   8D FF03      8873   	sta sw_rom_ram0
     68C3   CE 116E      8874   	dec numcnt
     68C6   30 2C        8875   	bmi char50		;exit if end of string
                         8876   
     68C8   C9 0E        8877   	cmp #14			;is character 'go to upper/lower'?
     68CA   D0 05        8878   	bne 10$			;no, go on.
     68CC   AD 11EB      8879   	lda upper_lower
     68CF   D0 07        8880   	bne 20$
                         8881   
     68D1   C9 8E        8882   10$	cmp #142		;is character 'go to upper/graphic'?
     68D3   D0 08        8883   	bne 30$			;no, go on.
     68D5   AD 11EC      8884   	lda upper_graphic
     68D8   8D 1168      8885   20$	sta character_rom	;point to correct rom
     68DB   D0 09        8886   	bne 40$			;always
                         8887   
     68DD   AC 115E      8888   30$	ldy colcnt
     68E0   20 68F8      8889   	jsr chrdsp		;not special, so display the character
     68E3   EE 115E      8890   	inc colcnt		;increment column count
                         8891   
     68E6   C0 27        8892   40$	cpy #llen-1     	;check if at end
     68E8   90 CD        8893   	bcc char30		;loop if not
     68EA   A0 00        8894   	ldy #0
     68EC   8C 115E      8895   	sty colcnt		;set to start of next line
     68EF   E8           8896   	inx
     68F0   E0 18        8897   	cpx #24
     68F2   90 C3        8898   	bcc char30		;loop if not at end of screen
                         8899   
     68F4   68           8900   char50	pla
     68F5   85 86        8901   	sta foreground		;restore color
     68F7   60           8902   	rts
                         8903   
                         8904   
                         8905   
                         8906   ;*****************************************************************
                         8907   ;

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 115-3
CHAR Command   CHAR.SRC

Error Addr  Code          Seq   Source statement

                         8908   ;	chrdsp - display a character
                         8909   ;	   x = row number
                         8910   ;	   y = column number
                         8911   ;	   a = character
                         8912   ;
                         8913   ;*****************************************************************
                         8914   
     68F8   48           8915   chrdsp	pha			;save character
     68F9   20 9C76      8916   	jsr docolr		;set colors
                         8917   
     68FC   98           8918   	tya			;get addr for row (X) and col (Y) in grapnt
     68FD   18           8919   	clc
     68FE   7D C033      8920   	adc _ldtb2,x		;add column position to low byte offset
     6901   85 8C        8921   	sta grapnt
     6903   BD C04C      8922   	lda _ldtb1,x		;get high byte screen address
     6906   69 00        8923   	adc #0			;add any carry
     6908   06 8C        8924   	asl grapnt
     690A   2A           8925   	rol a
     690B   06 8C        8926   	asl grapnt		;mult by 8 to get offset into 8k area
     690D   2A           8927   	rol a
     690E   06 8C        8928   	asl grapnt
     6910   2A           8929   	rol a
     6911   85 8D        8930   	sta grapnt+1
                         8931   
     6913   8D FF03      8932   	sta sw_rom_ram0		;mostly here to take i/o out of map
     6916   A9 00        8933   	lda #0
     6918   85 77        8934   	sta z_p_temp_1
     691A   68           8935   	pla			;recall character
     691B   48           8936   	pha
     691C   0A           8937   	asl a			;multiply by 8 to get char rom addr
     691D   26 77        8938   	rol z_p_temp_1
     691F   0A           8939   	asl a
     6920   0A           8940   	asl a
     6921   26 77        8941   	rol z_p_temp_1
     6923   85 26        8942   	sta index2
     6925   A5 77        8943   	lda z_p_temp_1
     6927   6D 1168      8944   	adc character_rom	;get char rom base
     692A   85 27        8945   	sta index2+1
     692C   98           8946   	tya
     692D   48           8947   	pha			;save column number
     692E   A0 07        8948   	ldy #7
                         8949   
     6930   AD 113D      8950   movchr	lda xysgn		;rvs fld flag
     6933   0A           8951   	asl a
     6934   B1 26        8952   	lda (index2),y		;get char byte (was jsr charin)
     6936   90 02        8953   	bcc movch0		;invert fields if carry set
     6938   49 FF        8954   	eor #$ff
                         8955   
     693A   24 D8        8956   movch0	bit _graphm		;get graphic mode
     693C   10 2B        8957   	bpl dochr0		;skip if not multicolor
                         8958   
     693E   29 AA        8959   	and #$aa		;remove every other bit
     6940   85 77        8960   	sta z_p_temp_1
     6942   A5 83        8961   	lda colsel		;what is color source?
     6944   D0 0F        8962   	bne movch1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 115-4
CHAR Command   CHAR.SRC

Error Addr  Code          Seq   Source statement

     6946   A5 77        8963   	lda z_p_temp_1
     6948   B0 07        8964   	bcs movrvs		;bgnd: is it rvs fld?
     694A   4A           8965   	lsr a			;bgnd (do fgnd on mc#1)
     694B   45 77        8966   	eor z_p_temp_1
     694D   49 AA        8967   	eor #$aa
     694F   D0 18        8968   	bne dochr0
     6951                8969   movrvs
     6951   09 55        8970   	ora #$55	 	;bgnd rvs (do fgnd on mc#2)
     6953   D0 14        8971   	bne dochr0
     6955                8972   movch1
     6955   C9 02        8973   	cmp #2
     6957   D0 04        8974   	bne movch2
     6959   A5 77        8975   	lda z_p_temp_1		;mc#1 pattern '10'
     695B   B0 0C        8976   	bcs dochr0
     695D                8977   movch2
     695D   90 07        8978   	bcc movch3
     695F   A5 77        8979   	lda z_p_temp_1		;mc#2 pattern '11'
     6961   4A           8980   	lsr a
     6962   45 77        8981   	eor z_p_temp_1
     6964   90 03        8982   	bcc dochr0
     6966                8983   movch3
     6966   A5 77        8984   	lda z_p_temp_1		;fgnd pattern '01'
     6968   4A           8985   	lsr a
                         8986   
     6969                8987   dochr0
     6969   91 8C        8988   	sta (grapnt),y  	;save into graphic bit map
     696B   88           8989   	dey
     696C   10 C2        8990   	bpl movchr
     696E   68           8991   	pla
     696F   A8           8992   	tay			;restore colnum
     6970   68           8993   	pla			;restore character
     6971   60           8994   	rts
                         8995   
                         8996   ;end
                         8997   	.include locate		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 116
LOCATE Command   LOCATE.SRC

Error Addr  Code          Seq   Source statement

                         8999   	.subttl LOCATE Command
                         9000   
                         9001   ;*************************************************************
                         9002   ;
                         9003   ; set the current xpos, ypos
                         9004   ;
                         9005   ;	   locate p
                         9006   ;
                         9007   ;*************************************************************
                         9008   
     6972                9009   locate
     6972   20 A07D      9010   	jsr isgrap	;make sure graphics area has been allocated
     6975   A2 04        9011   	ldx #xdest-vwork
     6977   20 9E79      9012   	jsr incord      ;get the coordinates
     697A   4C 9DFB      9013   	jmp dstpos      ;set the pos'n, do rts
                         9014   
                         9015   ;end
                         9016   	.include scale		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 117
SCALE Command   SCALE.SRC

Error Addr  Code          Seq   Source statement

                         9018   	.subttl SCALE Command
                         9019   
                         9020   ;*************************************************************************
                         9021   ;
                         9022   ;  scale : turn the scale mode on or off, and optionally set scale factor
                         9023   ;
                         9024   ;	syntax : SCALE n {,x_max,y_max}
                         9025   ;
                         9026   ;	where : n = 0 (off) or 1 (on)
                         9027   ;		x_max >= 320
                         9028   ;		y_max >= 200
                         9029   ;
                         9030   ;*************************************************************************
                         9031   
     697D   20 87F4      9032   scale	jsr getbyt
     6980   E0 02        9033   	cpx #2
     6982   90 03        9034   	bcc 1$
     6984   4C 7DC5      9035   	jmp fcerr		;illegal value
                         9036   
     6987   8E 116A      9037   1$	stx scalem      	;0 if off, 1 if on
     698A   20 0386      9038   	jsr chrgot		;end of statement?
     698D   D0 14        9039   	bne 10$			;no, go get x & y arg's
     698F   A2 00        9040   	ldx #0			;yes, supply defaults
     6991   A9 50        9041   	lda #llen+llen
     6993   A0 32        9042   	ldy #nlines+nlines
     6995   24 D8        9043   	bit _graphm
     6997   10 01        9044   	bpl 5$			;branch if not mcm,
     6999   4A           9045   	lsr a			;..else divide # of rows by 2
     699A   86 87        9046   5$	stx scale_x
     699C   85 88        9047   	sta scale_x+1
     699E   86 89        9048   	stx scale_y
     69A0   84 8A        9049   	sty scale_y+1
     69A2   60           9050   	rts
                         9051   
     69A3   20 69E1      9052   10$	jsr get_lt_32768	;check for comma, get positive integer < 32768
     69A6   A9 F5        9053   	lda #<n20971200
     69A8   A0 69        9054   	ldy #>n20971200
     69AA   20 8A89      9055   	jsr romupk		;put 320*65535 in arg
     69AD   20 8B4C      9056   	jsr fdivt		;fac=320*65535 / x_max
     69B0   20 8815      9057   	jsr getadr		;get int(fac) : must be 0 < x =< 65535
     69B3   C9 00        9058   	cmp #0
     69B5   D0 04        9059   	bne 20$
     69B7   C0 00        9060   	cpy #0
     69B9   F0 37        9061   	beq bad_bad_value
     69BB   48           9062   20$	pha			;save msb of x
     69BC   98           9063   	tya
     69BD   48           9064   	pha			;save lsb of x
                         9065   
     69BE   20 69E1      9066   	jsr get_lt_32768	;check for comma, get positive integer < 32768
     69C1   A9 FA        9067   	lda #<n13107000
     69C3   A0 69        9068   	ldy #>n13107000
     69C5   20 8A89      9069   	jsr romupk		;arg = 200*65535
     69C8   20 8B4C      9070   	jsr fdivt		;fac = arg / y_max
     69CB   20 8815      9071   	jsr getadr		;get int(fac) : must be 0 < y =< 65535
     69CE   C9 00        9072   	cmp #0

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 117-1
SCALE Command   SCALE.SRC

Error Addr  Code          Seq   Source statement

     69D0   D0 04        9073   	bne 30$
     69D2   C0 00        9074   	cpy #0
     69D4   F0 1C        9075   	beq bad_bad_value	;bad value! bad bad value!
                         9076   
     69D6   84 89        9077   30$	sty scale_y		;save lsb of y
     69D8   85 8A        9078   	sta scale_y+1		;.and msb of y
     69DA   68           9079   	pla
     69DB   85 87        9080   	sta scale_x		;.and lsb of x
     69DD   68           9081   	pla
     69DE   85 88        9082   	sta scale_x+1		;.and msb of x
                         9083   
     69E0   60           9084   	rts
                         9085   
                         9086   
                         9087   
     69E1                9088   get_lt_32768
     69E1   20 79F9      9089   	jsr chkcom		;get second arg
     69E4   20 7874      9090   	jsr frmnum		;put their arg in fac
     69E7   A5 68        9091   	lda facsgn
     69E9   30 07        9092   	bmi bad_bad_value	;error if negative
     69EB   A5 63        9093   	lda facexp
     69ED   C9 90        9094   	cmp #$90
     69EF   B0 01        9095   	bcs bad_bad_value	;error if >= 32768
     69F1   60           9096   	rts
                         9097   
     69F2                9098   bad_bad_value
     69F2   4C 7DC5      9099   	jmp fcerr
                         9100   
                         9101   
     69F5                9102   n20971200
     69F5   99 1F FF     9103   	.byte $99,$1f,$ff,$60,$00
     69F8   60 00               
     69FA                9104   n13107000
     69FA   98 47 FF     9105   	.byte $98,$47,$ff,$38,$00
     69FD   38 00               
                         9106   ;end
                         9107   	.include color		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 118
COLOR Command   COLOR.SRC

Error Addr  Code          Seq   Source statement

                         9109   	.subttl COLOR Command
                         9110   
                         9111   ;*************************************************************
                         9112   ;
                         9113   ; set a color
                         9114   ;
                         9115   ;	  color n, v [,lum ] (trashed, but in for ted compatability)
                         9116   ;
                         9117   ;      where:
                         9118   ;	      n =  0 for vic background color
                         9119   ;		   1     graphic foreground
                         9120   ;		   2         "   multicolor 1
                         9121   ;		   3         "   multicolor 2
                         9122   ;		   4     vic border
                         9123   ;		   5     text color (for current text screen)
                         9124   ;		   6	 8563 background color
                         9125   ;
                         9126   ;	      v = color (1-16)
                         9127   ;
                         9128   ;************************************************************
                         9129   
     69FF   20 87F4      9130   color	jsr getbyt      	;get selection in x
     6A02   E0 07        9131   	cpx #7
     6A04   B0 60        9132   	bcs sclerr      	;illegal value
     6A06   86 77        9133   	stx z_p_temp_1		;save temp
                         9134   
     6A08   20 8809      9135   	jsr combyt      	;comma, color in x
     6A0B   CA           9136   	dex
     6A0C   E0 10        9137   	cpx #16
     6A0E   B0 56        9138   	bcs sclerr
     6A10   20 A855      9139   	jsr put_io_in_map
                         9140   
     6A13   8A           9141   	txa			;color in .a
     6A14   A6 77        9142   	ldx z_p_temp_1		;where does this color/lum go?
     6A16   E0 01        9143   	cpx #1
     6A18   F0 07        9144   	beq 10$
     6A1A   B0 09        9145   	bcs 20$
                         9146   
     6A1C   8D D021      9147   	sta vic_background	;**0** vic background
     6A1F   D0 3F        9148   	bne 99$			;always
                         9149   
     6A21   85 86        9150   10$	sta foreground		;**1** graphic foreground
     6A23   F0 3B        9151   	beq 99$			;always
                         9152   
     6A25   E0 03        9153   20$	cpx #3
     6A27   F0 06        9154   	beq 30$
     6A29   B0 08        9155   	bcs 40$
                         9156   
     6A2B   85 84        9157   	sta multicolor_1	;**2** multicolor 1
     6A2D   D0 31        9158   	bne 99$			;always
                         9159   
     6A2F   85 85        9160   30$	sta multicolor_2	;**3** multicolor 2
     6A31   F0 2D        9161   	beq 99$			;always
                         9162   
     6A33   E0 05        9163   40$	cpx #5

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 118-1
COLOR Command   COLOR.SRC

Error Addr  Code          Seq   Source statement

     6A35   F0 07        9164   	beq 50$
     6A37   B0 16        9165   	bcs 60$
                         9166   
     6A39   8D D020      9167   	sta vic_border		;**4** vic border
     6A3C   D0 22        9168   	bne 99$			;always
                         9169   
     6A3E   24 D7        9170   50$	bit _mode		;**5** current text screen's text color
     6A40   10 08        9171   	bpl 55$			;  if not 80 col, use arg 'as is'
     6A42   AA           9172   	tax
     6A43   A5 F1        9173   	lda _text_color
     6A45   29 F0        9174   	and #$f0
     6A47   1D 6A69      9175   	ora _8563_adjust,x
     6A4A   85 F1        9176   55$	sta _text_color
     6A4C   4C 6A60      9177   	jmp 99$
                         9178   
     6A4F   AA           9179   60$	tax			;**6** 8563's background color
     6A50   A9 1A        9180   	lda #26
     6A52   8D D600      9181   	sta _8563_addr
     6A55   AD D601      9182   	lda _8563_data
     6A58   29 F0        9183   	and #$f0
     6A5A   1D 6A69      9184   	ora _8563_adjust,x
     6A5D   8D D601      9185   	sta _8563_data
                         9186   
     6A60   20 6A79      9187   99$	jsr set_packed_color	;update packed fg/bg and fg/mc1 bytes
     6A63   4C 9E27      9188   	jmp optbyt		;in case they are running a ted program (lum)
                         9189   
     6A66   4C 7DC5      9190   sclerr	jmp fcerr		;illegal value error
                         9191   
     6A69                9192   _8563_adjust
     6A69   00 0F 08     9193   	.byte $0,$f,$8,$7,$b,$4,$2,$d
     6A6C   07 0B 04            
     6A6F   02 0D               
     6A71   0A 0C 09     9194   	.byte $a,$c,$9,$6,$1,$5,$3,$e
     6A74   06 01 05            
     6A77   03 0E               
                         9195   
     6A79                9196   set_packed_color		;set up packed fg/bg & fg/mc1 bytes
     6A79   A5 86        9197   	lda foreground
     6A7B   0A           9198   	asl a
     6A7C   0A           9199   	asl a
     6A7D   0A           9200   	asl a
     6A7E   0A           9201   	asl a
     6A7F   85 77        9202   	sta z_p_temp_1
     6A81   20 A855      9203   	jsr put_io_in_map
     6A84   AD D021      9204   	lda vic_background
     6A87   29 0F        9205   	and #$0f
     6A89   05 77        9206   	ora z_p_temp_1
     6A8B   8D 03E2      9207   	sta fg_bg
     6A8E   A5 84        9208   	lda multicolor_1
     6A90   05 77        9209   	ora z_p_temp_1
     6A92   8D 03E3      9210   	sta fg_mc1
     6A95   60           9211   	rts
                         9212   
                         9213   ;end
                         9214   	.include scnclr		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 119
SCNCLR Command   SCNCLR.SRC

Error Addr  Code          Seq   Source statement

                         9216   	.subttl SCNCLR Command
                         9217   
                         9218   ;*********************************************************
                         9219   ;
                         9220   ; scnclr...   clear a screen
                         9221   ;
                         9222   ;  Syntax : SCNCLR [n]
                         9223   ;
                         9224   ;  where : n follows the GRAPHIC command conventions
                         9225   ;
                         9226   ;*********************************************************
                         9227   
     6A96   D0 17        9228   scnclr	bne 20$		;if there is an argument, go process it
                         9229   
                         9230   ; no argument : clear all currently visable screens
                         9231   
     6A98   20 AAEB      9232   	jsr scnclr_80		;clear 80-col bmm
     6A9B   20 818C      9233   	jsr unpack_graphm	;convert _graphm back to SCNCLR args
     6A9E   C9 05        9234   	cmp #5
     6AA0   90 09        9235   	bcc 10$
     6AA2   E9 05        9236   	sbc #5			;factor out 80 column text...
     6AA4   F0 5F        9237   	beq clear_80		;...that's all there was- go do it & rts
     6AA6   48           9238   	pha
     6AA7   20 6B05      9239   	jsr clear_80		;...clear it, but come back- there's more
     6AAA   68           9240   	pla
     6AAB   AA           9241   10$	tax
     6AAC   4C 6AC2      9242   	jmp scnclr_2		;continue on as if user entered arg
                         9243   
                         9244   
                         9245   
     6AAF   20 87F4      9246   20$	jsr getbyt		;evaluate users argument
                         9247   
                         9248   
     6AB2                9249   scnclr_1			;entry from 'GRAPHIC' with clear
     6AB2   E0 06        9250   	cpx #6
     6AB4   D0 03        9251   	bne 10$
     6AB6   4C AAEB      9252   	jmp scnclr_80		;clear 80-col graphic screen & rts
     6AB9   E0 05        9253   10$	cpx #5
     6ABB   F0 48        9254   	beq clear_80
     6ABD   90 03        9255   	bcc scnclr_2
     6ABF   4C 7DC5      9256   	jmp fcerr		;illegal value
                         9257   
     6AC2                9258   scnclr_2
     6AC2   8A           9259   	txa
     6AC3   F0 54        9260   	beq clear_40
     6AC5   20 A07D      9261   	jsr isgrap		;verify that there is a graphics area allocated
     6AC8   8A           9262   	txa
     6AC9   48           9263   	pha
     6ACA   29 01        9264   	and #1			;split screen?
     6ACC   D0 21        9265   	bne 10$			;branch if not
     6ACE   20 6B19      9266   	jsr clear_40
                         9267   
     6AD1   A5 D7        9268   	lda _mode		;set cursor pos'n for 40 col screen to current
     6AD3   48           9269   	pha			;..split value. first make sure 40 col screen
     6AD4   10 03        9270   	bpl 5$			;..is swapped in.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 119-1
SCNCLR Command   SCNCLR.SRC

Error Addr  Code          Seq   Source statement

     6AD6   20 FF5F      9271   	jsr _swapper
     6AD9   AD 0A34      9272   5$	lda _split		;get current split position...
     6ADC   38           9273   	sec
     6ADD   E9 30        9274   	sbc #$30
     6ADF   4A           9275   	lsr a
     6AE0   4A           9276   	lsr a
     6AE1   4A           9277   	lsr a			;..convert to line number...
     6AE2   AA           9278   	tax
     6AE3   A0 00        9279   	ldy #0
     6AE5   18           9280   	clc
     6AE6   20 928D      9281   	jsr k_jplot		;..and put cursor at the start of that line.
     6AE9   68           9282   	pla
     6AEA   10 03        9283   	bpl 10$
     6AEC   20 FF5F      9284   	jsr _swapper		;restore 80 col., if necessary.
     6AEF   68           9285   10$	pla
     6AF0   29 02        9286   	and #2			;multi color?
     6AF2   F0 03        9287   	beq 20$			;branch if not
     6AF4   20 6B3E      9288   	jsr clear_high_color
     6AF7   20 6B57      9289   20$	jsr clear_graphics
                         9290   
     6AFA   A9 00        9291   	lda #0
     6AFC   A2 03        9292   	ldx #3
     6AFE   9D 1131      9293   50$	sta xpos,x      	;set current pos to top left
     6B01   CA           9294   	dex
     6B02   10 FA        9295   	bpl 50$
     6B04   60           9296   	rts
                         9297   
                         9298   
                         9299   
     6B05                9300   clear_80
     6B05   A5 D7        9301   	lda _mode
     6B07   48           9302   	pha
     6B08   30 03        9303   	bmi 10$
     6B0A   20 FF5F      9304   	jsr _swapper
     6B0D   A9 93        9305   10$	lda #$93
     6B0F   20 9269      9306   	jsr k_bsout
     6B12   68           9307   	pla
     6B13   30 03        9308   	bmi 20$
     6B15   20 FF5F      9309   	jsr _swapper
     6B18   60           9310   20$	rts
                         9311   
                         9312   
                         9313   
     6B19                9314   clear_40
     6B19   A5 D7        9315   	lda _mode
     6B1B   48           9316   	pha
     6B1C   10 03        9317   	bpl 10$
     6B1E   20 FF5F      9318   	jsr _swapper
     6B21   A9 93        9319   10$	lda #$93
     6B23   20 9269      9320   	jsr k_bsout
     6B26   68           9321   	pla
     6B27   10 03        9322   	bpl 20$
     6B29   20 FF5F      9323   	jsr _swapper
     6B2C   60           9324   20$	rts
                         9325   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 119-2
SCNCLR Command   SCNCLR.SRC

Error Addr  Code          Seq   Source statement

                         9326   
                         9327   
                         9328   
                         9329   
                         9330   ;general fill sub.: save a for x pages, starting at (0,y)
                         9331   
     6B2D                9332   screen_fill
     6B2D   84 8D        9333   	sty grapnt+1
     6B2F   A0 00        9334   	ldy #0
     6B31   84 8C        9335   	sty grapnt
     6B33   91 8C        9336   70$	sta (grapnt),y
     6B35   88           9337   	dey
     6B36   D0 FB        9338   	bne 70$
     6B38   E6 8D        9339   	inc grapnt+1
     6B3A   CA           9340   	dex
     6B3B   D0 F6        9341   	bne 70$
     6B3D   60           9342   	rts
                         9343   
     6B3E                9344   clear_high_color
     6B3E   20 A855      9345   	jsr put_io_in_map
     6B41   78           9346   	sei
     6B42   A5 01        9347   	lda _6510_data_reg
     6B44   48           9348   	pha
     6B45   29 FE        9349   	and #%11111110
     6B47   85 01        9350   	sta _6510_data_reg
     6B49   A5 85        9351   	lda multicolor_2
     6B4B   A0 D8        9352   	ldy #>color_ram_hi
     6B4D   A2 04        9353   	ldx #4
     6B4F   20 6B2D      9354   	jsr screen_fill
     6B52   68           9355   	pla
     6B53   85 01        9356   	sta _6510_data_reg
     6B55   58           9357   	cli
     6B56   60           9358   	rts
                         9359   
                         9360   
                         9361   
     6B57                9362   clear_graphics
     6B57   A9 00        9363   	lda #0
     6B59   A0 20        9364   	ldy #>graphic_base
     6B5B   A2 20        9365   	ldx #32
     6B5D   20 6B2D      9366   	jsr screen_fill		;fill 8k bit map area with 0
                         9367   
     6B60   AD 03E2      9368   	lda fg_bg		;get packed byte of colors for current mode
     6B63   24 D8        9369   	bit _graphm
     6B65   10 03        9370   	bpl 10$
     6B67   AD 03E3      9371   	lda fg_mc1
     6B6A   20 A855      9372   10$	jsr put_io_in_map
     6B6D   A0 1C        9373   	ldy #>color_ram_lo
     6B6F   A2 04        9374   	ldx #4
     6B71   20 6B2D      9375   	jsr screen_fill		;fill 1k vm area with color info.
                         9376   
                         9377   ; set up sprite pointers
                         9378   
     6B74   A2 3F        9379   	ldx #sprite_base/64+7
     6B76   A0 07        9380   	ldy #7

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 119-3
SCNCLR Command   SCNCLR.SRC

Error Addr  Code          Seq   Source statement

     6B78   8A           9381   35$	txa
     6B79   99 1FF8      9382   	sta color_ram_lo+$3f8,y
     6B7C   CA           9383   	dex
     6B7D   88           9384   	dey
     6B7E   10 F8        9385   	bpl 35$
     6B80   60           9386   	rts
                         9387   
                         9388   ;end
                         9389   	.include graphic	;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 120
GRAPHIC Command   GRAPHIC.SRC

Error Addr  Code          Seq   Source statement

                         9391   	.subttl GRAPHIC Command
                         9392   
                         9393   ;*************************************************************
                         9394   ;
                         9395   ;  set graphic mode
                         9396   ;
                         9397   ; syntax:	 graphic n [[,c] ,s]
                         9398   ;	     or
                         9399   ;		  graphic clr
                         9400   ;
                         9401   ;	where :	 n = 0  for 40 column text mode
                         9402   ;		 n = 1  for hi res mode
                         9403   ;		 n = 2  for hi res split screen mode
                         9404   ;		 n = 3  for multicolor mode
                         9405   ;		 n = 4  for multicolor split screen mode
                         9406   ;		 n = 5  for 80 column text mode
                         9407   ;		 n = 6	for 80 column bit map mode
                         9408   ;
                         9409   ;    optionally, c = 0  for 'don't clear screen' (default)
                         9410   ;		 c = 1  for 'clear screen'
                         9411   ;
                         9412   ;		 s = number of first line of text in split screen modes (0..24).
                         9413   ;		     (default = 19)
                         9414   ;
                         9415   ; If 'graphic n' is executed, where 0<n<5, a 10k block of memory for bit map
                         9416   ; screen and color bytes is allocated, if it has not previously been allocated.
                         9417   ; This ram remains reserved until a 'graphic clear' command is executed.
                         9418   ;
                         9419   ;*****************************************************************
                         9420   
     6B81   C9 9C        9421   graphic	cmp #clrtk		;test if hi-res ram is to be de-allocated
     6B83   D0 30        9422   	bne graphic01		;no, go on to set up new mode
                         9423   
     6B85   20 A02B      9424   	jsr clrhir		;de-allocate ram
     6B88   20 0380      9425   	jsr chrget		;skip over clr token
     6B8B   A9 00        9426   	lda #0			;force to text screen
     6B8D   85 D8        9427   	sta _graphm
     6B8F                9428   graph80_clr
     6B8F   20 4269      9429   	jsr init_plot_vec	;install vic indirects
     6B92   20 A855      9430   	jsr put_io_in_map
     6B95   A2 19        9431   	ldx #25			;put 8563 into text mode
     6B97   20 CDDA      9432   	jsr vdcin
     6B9A   29 7F        9433   	and #$7f
     6B9C   20 CDCC      9434   	jsr vdcout
     6B9F   A2 0D        9435   	ldx #13			;start of text display data: $0000
     6BA1   A9 00        9436   	lda #<$0000
     6BA3   20 CDCC      9437   	jsr vdcout
     6BA6   CA           9438   	dex
     6BA7   20 CDCC      9439   	jsr vdcout
     6BAA   A2 15        9440   	ldx #21
     6BAC   20 CDCC      9441   	jsr vdcout		;start of attribute data: $0800
     6BAF   CA           9442   	dex
     6BB0   A9 08        9443   	lda #>$0800
     6BB2   4C CDCC      9444   	jmp vdcout		;rts
                         9445   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 120-1
GRAPHIC Command   GRAPHIC.SRC

Error Addr  Code          Seq   Source statement

     6BB5                9446   graphic01
     6BB5   20 87F4      9447   	jsr getbyt		;get new mode
     6BB8   E0 06        9448   	cpx #6
     6BBA   F0 60        9449   	beq graph80		;branch if 'go to 80 col bmm' wedge
     6BBC   8A           9450   	txa
     6BBD   48           9451   	pha			;save in case there is a 'clear'
     6BBE   E0 05        9452   	cpx #5			;in range?
     6BC0   F0 42        9453   	beq 50$			;branch if 'go to 80 col'
     6BC2   B0 50        9454   	bcs graper		;illegal value
                         9455   
     6BC4   BD 6C17      9456   	lda modes,x		;set up for one of the graphic modes
     6BC7   85 D8        9457   20$	sta _graphm
     6BC9   F0 07        9458   	beq 26$			;branch if 'goto 40'
     6BCB   20 9F58      9459   	jsr sethir		;..else set up graphic area
                         9460   
     6BCE   24 D8        9461   25$	bit _graphm		;is this a split screen mode?
     6BD0   50 07        9462   	bvc 30$			;no, don't force into 40 column
     6BD2   24 D7        9463   26$	bit _mode
     6BD4   10 03        9464   	bpl 30$			;branch if already in 40 column
     6BD6   20 FF5F      9465   22$	jsr _swapper
                         9466   
     6BD9   20 9E25      9467   30$	jsr optzer		;get optional clear flag (def=0)
     6BDC   E0 02        9468   	cpx #2
     6BDE   B0 34        9469   	bcs graper		;arg can only be 0 or 1
     6BE0   8A           9470   	txa
     6BE1   48           9471   	pha			;save it
                         9472   
     6BE2   A2 14        9473   40$	ldx #20			;get (optional) line to start text
     6BE4   20 9E27      9474   	jsr optbyt
     6BE7   E0 1A        9475   	cpx #26
     6BE9   B0 29        9476   	bcs graper		;bad value
     6BEB   8A           9477   	txa
     6BEC   0A           9478   	asl a			;multiply times 8
     6BED   0A           9479   	asl a
     6BEE   0A           9480   	asl a
     6BEF   69 30        9481   	adc #$30		;add offset to first line
     6BF1   8D 0A34      9482   	sta _split
                         9483   
     6BF4   68           9484   	pla			;get back clear flag
     6BF5   A8           9485   	tay			;..hold on a sec...
     6BF6   68           9486   	pla			;get original mode argument
     6BF7   AA           9487   	tax			;set up for scnclr
     6BF8   98           9488   	tya			;test clear arg
     6BF9   F0 03        9489   	beq 45$			;if zero, don't clear screen
     6BFB   20 6AB2      9490   	jsr scnclr_1		;special entry into screen clear routine
                         9491   
     6BFE   A9 00        9492   45$	lda #0
     6C00   8D 116A      9493   	sta scalem		;turn off scaling to force new defaults
     6C03   60           9494   	rts
                         9495   
     6C04   20 6B8F      9496   50$	jsr graph80_clr		;put 8563 into text mode, reset indirects
     6C07   24 D7        9497   	bit _mode		;test if already 80 column
     6C09   30 CE        9498   	bmi 30$			;yes, don't do anything
     6C0B   A5 D8        9499   	lda _graphm		;if we're in a split mode, force mode to all graphic
     6C0D   29 BF        9500   	and #%10111111

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 120-2
GRAPHIC Command   GRAPHIC.SRC

Error Addr  Code          Seq   Source statement

     6C0F   85 D8        9501   	sta _graphm
     6C11   4C 6BD6      9502   	jmp 22$
                         9503   
                         9504   
     6C14   4C 7DC5      9505   graper	jmp fcerr
                         9506   
     6C17   00 20 60     9507   modes	.byte 0,$20,$60,$a0,$e0 	;text,hir,hir/s,mcm,mcm/s
     6C1A   A0 E0               
                         9508   
                         9509   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 121
GRAPHIC Command   GRAPHIC.SRC

Error Addr  Code          Seq   Source statement

     6C1C                9511   graph80
     6C1C   A2 05        9512   	ldx #20$-10$-1		;install 80-col graphic indirects
     6C1E   BD 6C60      9513   1$	lda 10$,x
     6C21   9D 03E4      9514   	sta plot_point,x
     6C24   CA           9515   	dex
     6C25   10 F7        9516   	bpl 1$
                         9517   
     6C27   20 9E25      9518   	jsr optzer		;clear it?
     6C2A   E0 00        9519   	cpx #0
     6C2C   F0 03        9520   	beq  2$			;...no
     6C2E   20 AAEB      9521   	jsr scnclr_80		;...yes
                         9522   
     6C31   20 9E27      9523   2$	jsr optbyt		;eat last param
     6C34   A9 00        9524   	lda #0
     6C36   8D 116A      9525   	sta scalem		;reset scaling
                         9526   
     6C39   20 A855      9527   	jsr put_io_in_map
     6C3C   A2 19        9528   	ldx #25			;put 8563 into bit map mode
     6C3E   20 CDDA      9529   	jsr vdcin
     6C41   09 80        9530   	ora #$80
     6C43   20 CDCC      9531   	jsr vdcout
     6C46   A2 0D        9532   	ldx #13			;start of bit map data: $8000
     6C48   A9 00        9533   	lda #<$8000
     6C4A   20 CDCC      9534   	jsr vdcout
     6C4D   CA           9535   	dex
     6C4E   A9 80        9536   	lda #>$8000
     6C50   20 CDCC      9537   	jsr vdcout
     6C53   A2 15        9538   	ldx #21			;start of bit map color data: $c000
     6C55   A9 00        9539   	lda #<$c000
     6C57   20 CDCC      9540   	jsr vdcout
     6C5A   CA           9541   	dex
     6C5B   A9 C0        9542   	lda #>$c000
     6C5D   4C CDCC      9543   	jmp vdcout		;rts
                         9544   
                         9545   
     6C60   AA78 AA8B    9546   10$	.wor plot_80,color_80,read_80
     6C64   AADC                
     6C66                9547   20$
                         9548   
                         9549   ;.end
                         9550   	.include bank		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 122
BANK Command   BANK.SRC

Error Addr  Code          Seq   Source statement

                         9552   	.subttl BANK Command
                         9553   
                         9554   ;********************************************************
                         9555   ;*
                         9556   ;*  Set Context Bank for SYS, PEEK, POKE.
                         9557   ;*
                         9558   ;*  Syntax:	BANK n
                         9559   ;*  Where:
                         9560   ;*	    n=0  ==> ram 0
                         9561   ;*	    n=1  ==> ram 1
                         9562   ;*	    n=14 ==> system rom / io out (charrom in)
                         9563   ;*	    n=15 ==> system rom / io in
                         9564   ;*
                         9565   ;********************************************************
                         9566   
     6C66   20 87F4      9567   bank	jsr getbyt	;get bank number in .x
     6C69   E0 10        9568   	cpx #16
     6C6B   B0 04        9569   	bcs 10$		;bank >15 is an error
     6C6D   8E 03D5      9570   	stx current_bank
     6C70   60           9571   	rts
                         9572   
     6C71   4C 7DC5      9573   10$	jmp fcerr	;illegal value error
                         9574   
                         9575   ;end
                         9576   	.include sleep		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 123
SLEEP Command   SLEEP.SRC

Error Addr  Code          Seq   Source statement

                         9578   	.subttl SLEEP Command
                         9579   
                         9580   ;*****************************************************************************
                         9581   ;*
                         9582   ;*	SLEEP Command - postpone all activity for a specified period of time.
                         9583   ;*
                         9584   ;*	Syntax: SLEEP n
                         9585   ;*
                         9586   ;*	Where n is the number of seconds to remain inactive,
                         9587   ;*	expressed as a positive value < 65536.
                         9588   ;*
                         9589   ;*****************************************************************************
                         9590   
     6C74   20 8812      9591   sleep	jsr getwrd	;get argument in (y,a)
                         9592   
                         9593   ; multiply # of seconds to sleep by 60. this will be the number of 'jiffys'
                         9594   ; to hibernate. store this value in 3 consecutive loc'ns the kernal knows to
                         9595   ; decrement as a 24 bit value, and wait for an underflow.
                         9596   
     6C77   A2 00        9597   	ldx #0
     6C79   78           9598   	sei			;silence, please!
     6C7A   8C 0A1D      9599   	sty _sleep_counter
     6C7D   8D 0A1E      9600   	sta _sleep_counter+1
     6C80   8E 0A1F      9601   	stx _sleep_counter+2	;sleep_counter = n
                         9602   
     6C83   20 6CA9      9603   	jsr sleep_times_2	;sleep_counter = 2n
     6C86   20 6CB3      9604   	jsr add_xay_to_sleep	;sleep_counter = 3n
     6C89   20 6CA6      9605   	jsr sleep_times_4	;sleep_counter = 12n
                         9606   
     6C8C   AC 0A1D      9607   	ldy _sleep_counter
     6C8F   AD 0A1E      9608   	lda _sleep_counter+1
     6C92   AE 0A1F      9609   	ldx _sleep_counter+2	;(xay) = 12n
                         9610   
     6C95   20 6CA6      9611   	jsr sleep_times_4	;sleep_counter = 48n
     6C98   20 6CB3      9612   	jsr add_xay_to_sleep	;sleep_counter = 60n !!!!!
                         9613   
     6C9B   58           9614   	cli
     6C9C   20 4BD2      9615   1$	jsr is_stop_key_down
     6C9F   AE 0A1F      9616   	ldx _sleep_counter+2
     6CA2   E8           9617   	inx			;underflow?
     6CA3   D0 F7        9618   	bne 1$			;no, loop.
     6CA5   60           9619   	rts
                         9620   
                         9621   
     6CA6                9622   sleep_times_4
     6CA6   20 6CA9      9623   	jsr sleep_times_2
     6CA9                9624   sleep_times_2
     6CA9   0E 0A1D      9625   	asl _sleep_counter
     6CAC   2E 0A1E      9626   	rol _sleep_counter+1
     6CAF   2E 0A1F      9627   	rol _sleep_counter+2
     6CB2   60           9628   	rts
                         9629   
     6CB3                9630   add_xay_to_sleep
     6CB3   48           9631   	pha
     6CB4   98           9632   	tya

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 123-1
SLEEP Command   SLEEP.SRC

Error Addr  Code          Seq   Source statement

     6CB5   6D 0A1D      9633   	adc _sleep_counter
     6CB8   8D 0A1D      9634   	sta _sleep_counter
     6CBB   68           9635   	pla
     6CBC   6D 0A1E      9636   	adc _sleep_counter+1
     6CBF   8D 0A1E      9637   	sta _sleep_counter+1
     6CC2   8A           9638   	txa
     6CC3   6D 0A1F      9639   	adc _sleep_counter+2
     6CC6   8D 0A1F      9640   	sta _sleep_counter+2
     6CC9   60           9641   	rts
                         9642   
                         9643   ;end
                         9644   	.include wait		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 124
WAIT function   WAIT.SRC

Error Addr  Code          Seq   Source statement

                         9646   	.subttl WAIT function
                         9647   
                         9648   ; The wait location mask1,mask2 statement waits until the contents of location
                         9649   ; is nonzero when xored with mask2 and then added with mask1. If mask2 is not
                         9650   ; present, it is assumed to be zero.
                         9651   
     6CCA   20 8803      9652   wait	jsr getnum
     6CCD   86 4B        9653   	stx andmsk
     6CCF   A2 00        9654   	ldx #0
     6CD1   20 0386      9655   	jsr chrgot
     6CD4   F0 03        9656   	beq 10$
     6CD6   20 8809      9657   	jsr combyt	;get mask2.
     6CD9   86 4C        9658   10$	stx eormsk
                         9659   
                         9660   
     6CDB   A0 00        9661   20$	ldy #0			;set up index for _fetch routine,
     6CDD   AE 03D5      9662   	ldx current_bank	;..and bank number,
     6CE0   A9 16        9663   	lda #poker		;..and address of address
     6CE2   20 FF74      9664   	jsr _fetch
     6CE5   45 4C        9665   	eor eormsk
     6CE7   25 4B        9666   	and andmsk
     6CE9   F0 F0        9667   	beq 20$
     6CEB   60           9668   	rts			;got a nonzero.
                         9669   
                         9670   ;end
                         9671   	.include sprite		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 125
SPRITE Command   SPRITE.SRC

Error Addr  Code          Seq   Source statement

                         9673   	.subttl SPRITE Command
                         9674   
                         9675   ;*********************************************************************
                         9676   ;
                         9677   ;	SPRITE n [,e [,c [,p [,x [,y [,r] ] ] ] ] ]
                         9678   ;
                         9679   ;	where:	n :== sprite number (1-8)
                         9680   ;		e :== enable (0 off, 1 on)
                         9681   ;		c :== color (1-16)
                         9682   ;		p :== priority over background (0 no, 1 yes)
                         9683   ;		x :== expand in x direction (0 no, 1 yes)
                         9684   ;		y :== expand in y direction (0 no, 1 yes)
                         9685   ;		r :== resolution (0 hires, 1 multicolor)
                         9686   ;
                         9687   ;*********************************************************************
                         9688   
     6CEC   20 6D58      9689   sprite	jsr get_sprite_number	;get sprite number in z_p_temp_1
                         9690   
     6CEF   20 9E27      9691   	jsr optbyt		;look for (optional) enable
     6CF2   90 05        9692   	bcc 10$			;none here, don't change
     6CF4   A0 15        9693   	ldy #21
     6CF6   20 6D38      9694   	jsr sprbit		;set/clear sprite bit
                         9695   
     6CF9   20 9E27      9696   10$	jsr optbyt		;get (optional) color
     6CFC   90 0E        9697   	bcc 20$			;branch if no arg
     6CFE   CA           9698   	dex			;adjust 1..16 to 0..15
     6CFF   E0 10        9699   	cpx #16
     6D01   B0 32        9700   	bcs sprite_error	;too big
     6D03   8A           9701   	txa
     6D04   A6 77        9702   	ldx z_p_temp_1		;get back sprite number
     6D06   20 A855      9703   	jsr put_io_in_map
     6D09   9D D027      9704   	sta vic+39,x
                         9705   
     6D0C   20 9E27      9706   20$	jsr optbyt		;look for (optional) priority
     6D0F   90 05        9707   	bcc 30$
     6D11   A0 1B        9708   	ldy #27
     6D13   20 6D38      9709   	jsr sprbit
                         9710   
     6D16   20 9E27      9711   30$	jsr optbyt		;look for (optional) x expansion
     6D19   90 05        9712   	bcc 40$
     6D1B   A0 1D        9713   	ldy #29
     6D1D   20 6D38      9714   	jsr sprbit
                         9715   
     6D20   20 9E27      9716   40$	jsr optbyt		;look for (optional) y expansion
     6D23   90 05        9717   	bcc 50$
     6D25   A0 17        9718   	ldy #23
     6D27   20 6D38      9719   	jsr sprbit
                         9720   
     6D2A   20 9E27      9721   50$	jsr optbyt		;look for (optional) resolution
     6D2D   90 05        9722   	bcc 60$
     6D2F   A0 1C        9723   	ldy #28
     6D31   20 6D38      9724   	jsr sprbit
                         9725   
     6D34   60           9726   60$	rts
                         9727   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 125-1
SPRITE Command   SPRITE.SRC

Error Addr  Code          Seq   Source statement

     6D35   4C 7DC5      9728   sprite_error	jmp fcerr		;bad value
                         9729   
                         9730   
                         9731   
                         9732   
                         9733   ;  set or clear a bit in the vic's registers
                         9734   ;	.X = 1 to set, 0 to clear
                         9735   ;	.Y = register in vic to operate on
                         9736   
     6D38   8A           9737   sprbit	txa
     6D39   4A           9738   	lsr a			;put lsb in .C (0 clear, 1 set sprite bit)
     6D3A   D0 F9        9739   	bne sprite_error	;only 0 or 1, please.
     6D3C   A6 77        9740   	ldx z_p_temp_1		;get sprite number
     6D3E   BD 6D50      9741   	lda sbits,x
     6D41   20 A855      9742   	jsr put_io_in_map
     6D44   19 D000      9743   	ora vic,y
     6D47   B0 03        9744   	bcs 10$
     6D49   5D 6D50      9745   	eor sbits,x
     6D4C   99 D000      9746   10$	sta vic,y
     6D4F   60           9747   	rts
                         9748   
                         9749   
     6D50   01 02 04     9750   sbits	.byte $01,$02,$04,$08,$10,$20,$40,$80
     6D53   08 10 20            
     6D56   40 80               
                         9751   
                         9752   
                         9753   
                         9754   
                         9755   
                         9756   
     6D58                9757   get_sprite_number
     6D58   20 87F4      9758   	jsr getbyt
     6D5B   CA           9759   	dex
     6D5C   E0 08        9760   	cpx #8
     6D5E   B0 D5        9761   	bcs sprite_error
     6D60   86 77        9762   	stx z_p_temp_1
     6D62   60           9763   	rts
                         9764   
                         9765   ;.end
                         9766   	.include movspr		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 126
MOVSPR Command   MOVSPR.SRC

Error Addr  Code          Seq   Source statement

                         9768   	.subttl MOVSPR Command
                         9769   
                         9770   
                         9771   ;****************************************************************
                         9772   ;
                         9773   ;  movspr n , [ p | x # y ]  --  position sprite
                         9774   ; 	n = sprite number (1-8)
                         9775   ;	p = x/y coordinate  --  relative and angular distances
                         9776   ;		 are relative to current sprite position and
                         9777   ;		 scaled if scaling is on
                         9778   ;	x # y = constant movement at an angle-x with a speed-y
                         9779   ;
                         9780   ;****************************************************************
                         9781   
     6D63   20 6D58      9782   movspr	jsr get_sprite_number
     6D66   20 6E3B      9783   	jsr sprcor		;get first coordinate
     6D69   2C 116E      9784   	bit numcnt		;test coordinate type
     6D6C   50 03        9785   	bvc 10$			;skip if was a comma
     6D6E   4C 7A09      9786   	jmp snerr		;syntax error
                         9787   
     6D71   8C 1135      9788   10$	sty xdest		;save coordinate value
     6D74   8C 1137      9789   	sty xdest+2
     6D77   8D 1136      9790   	sta xdest+1
     6D7A   8D 1138      9791   	sta xdest+3
     6D7D   20 6E3B      9792   	jsr sprcor		;get second coordinate
     6D80   2C 116E      9793   	bit numcnt		;test type of input
     6D83   50 61        9794   	bvc 61$			;skip if normal coordinates
     6D85   30 3A        9795   	bmi 50$			;skip if angular coordinates
                         9796   
     6D87   98           9797   	tya
     6D88   48           9798   	pha			;must be speed - save value
     6D89   A0 04        9799   	ldy #xdest-vwork
     6D8B   20 9A74      9800   	jsr getang		;get angle of movement
     6D8E   A6 77        9801   	ldx z_p_temp_1		;get sprite number
     6D90   BC 6E76      9802   	ldy sproff,x		;get offset to speed data
     6D93   A9 00        9803   	lda #0
     6D95   99 117E      9804   	sta sprite_data,y	;turn off sprite speed
     6D98   C8           9805   	iny
     6D99   A2 03        9806   	ldx #3
                         9807   
     6D9B   5E 114A      9808   20$	lsr sinval,x
     6D9E   CA           9809   	dex
     6D9F   7E 114A      9810   	ror sinval,x
     6DA2   CA           9811   	dex
     6DA3   10 F6        9812   	bpl 20$
                         9813   
     6DA5   E8           9814   30$	inx
     6DA6   BD 1149      9815   	lda angsgn,x		;move angle data to speed data
     6DA9   C8           9816   	iny
     6DAA   99 117E      9817   	sta sprite_data,y
     6DAD   E0 04        9818   	cpx #4
     6DAF   D0 F4        9819   	bne 30$
     6DB1   A9 00        9820   	lda #0			;clear speed angle counts
                         9821   
     6DB3   C8           9822   40$	iny

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 126-1
MOVSPR Command   MOVSPR.SRC

Error Addr  Code          Seq   Source statement

     6DB4   99 117E      9823   	sta sprite_data,y
     6DB7   CA           9824   	dex
     6DB8   D0 F9        9825   	bne 40$
     6DBA   68           9826   	pla			;restore speed value
     6DBB   29 0F        9827   	and #$0f		;limit range (0-15)
     6DBD   99 1174      9828   	sta sprite_data-10,y 	;start sprite movement
     6DC0   60           9829   	rts
                         9830   
                         9831   ; _ ._. : ._ _.. _.. . _.. ..... _... _.__ _ . ... .... . ._. .
                         9832   
     6DC1   20 8139      9833   50$	jsr swapxy		;swap y and a (eventually) : y ==> x
     6DC4   A8           9834   	tay			;			     a ==> y
     6DC5   8A           9835   	txa			;			     x ==> a
     6DC6   20 9A77      9836   	jsr gtang1		;get angle values
     6DC9   A2 04        9837   	ldx #xdest-vwork
     6DCB   20 9D53      9838   	jsr scalxy		;scale lengths
     6DCE   A2 04        9839   	ldx #xdest-vwork
     6DD0   18           9840   	clc
                         9841   
     6DD1   20 9ACE      9842   60$	jsr angmlt		;multiply lengths * angles
     6DD4   9D 1131      9843   	sta vwork,x
     6DD7   98           9844   	tya
     6DD8   9D 1132      9845   	sta vwork+1,x
     6DDB   E8           9846   	inx
     6DDC   E8           9847   	inx
     6DDD   E0 06        9848   	cpx #ydest-vwork
     6DDF   F0 F0        9849   	beq 60$			;loop to do y-position
     6DE1   6E 116E      9850   	ror numcnt		;shift in carry to set msb
     6DE4   30 0B        9851   	bmi 70$			;...always
                         9852   
     6DE6   8C 1137      9853   61$	sty xdest+2		;save second coordinate
     6DE9   8D 1138      9854   	sta xdest+3
     6DEC   A2 04        9855   	ldx #xdest-vwork
     6DEE   20 9D53      9856   	jsr scalxy		;scale the coordinates
                         9857   
     6DF1   A5 77        9858   70$	lda z_p_temp_1		;get sprite number
     6DF3   AA           9859   	tax			;use as an index
     6DF4   0A           9860   	asl a
     6DF5   A8           9861   	tay			;get sprite-number * 2 as another index
     6DF6   AD 1137      9862   	lda xdest+2		;get y-coordinate
     6DF9   0E 116E      9863   	asl numcnt		;test if relative
     6DFC   90 09        9864   	bcc 80$			;skip if absolute
     6DFE   18           9865   	clc
     6DFF   10 03        9866   	bpl 75$			;skip if normal coordinates
     6E01   49 FF        9867   	eor #$ff
     6E03   38           9868   	sec			;invert to subtract if angular
     6E04   79 11D7      9869   75$	adc vic_save+1,y	;add to current sprite y-value
                         9870   
     6E07   78           9871   80$	sei
     6E08   99 11D7      9872   	sta vic_save+1,y	;save new sprite y-position
     6E0B   AD 1135      9873   	lda xdest		;get low byte of x-coordinate
     6E0E   0E 116E      9874   	asl numcnt		;test if relative
     6E11   10 12        9875   	bpl 95$			;skip if absolute
     6E13   18           9876   	clc
     6E14   79 11D6      9877   	adc vic_save,y		;add current sprite x-position

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 126-2
MOVSPR Command   MOVSPR.SRC

Error Addr  Code          Seq   Source statement

     6E17   99 11D6      9878   	sta vic_save,y		;save sprite x-position
     6E1A   B0 03        9879   	bcs 90$			;skip if carry
     6E1C   EE 1136      9880   	inc xdest+1		;invert lsb
                         9881   
     6E1F   AD 11E6      9882   90$	lda vic_save+16		;get x-position msb bits
     6E22   4C 6E2E      9883   	jmp 97$			;test if need to invert msb bit
                         9884   
     6E25   99 11D6      9885   95$	sta vic_save,y		;save new sprite x-position
     6E28   AD 11E6      9886   	lda vic_save+16
     6E2B   1D 6D50      9887   	ora sbits,x		;set x-position msb bit
                         9888   
     6E2E   4E 1136      9889   97$	lsr xdest+1		;match to lsb of x-coordinate high byte
     6E31   B0 03        9890   	bcs 100$		;skip if should be set
     6E33   5D 6D50      9891   	eor sbits,x		;reset bit
                         9892   
     6E36   8D 11E6      9893   100$	sta vic_save+16		;save position msb bits
     6E39   58           9894   	cli
     6E3A   60           9895   	rts
                         9896   
                         9897   
                         9898   
                         9899   ;	sprcor	--	get sprite position coordinate parameter
                         9900   
     6E3B   20 6E63      9901   sprcor	jsr chkcom_1		;check for a comma
     6E3E   6E 116E      9902   	ror numcnt		;reset msb if comma else set msb
     6E41   10 0B        9903   	bpl 10$			;skip if got a comma
     6E43   C9 3B        9904   	cmp #';'		;test if angular data
     6E45   F0 13        9905   	beq 30$			;skip if yes - 2 msb's = 1 1
     6E47   C9 23        9906   	cmp #'#'		;test if speed type
     6E49   F0 0E        9907   	beq 20$			;skip if yes - 2 msb's = 0 1
     6E4B   4C 7A09      9908   	jmp snerr		;syntax error if none of above
                         9909   
     6E4E   20 0386      9910   10$	jsr chrgot		;test for relative coordinate
     6E51   C9 AA        9911   	cmp #plustk		;test if plus sign
     6E53   F0 05        9912   	beq 30$			;skip if yes - show relative
     6E55   C9 AB        9913   	cmp #minutk		;test if minus sign
     6E57   F0 01        9914   	beq 30$			;skip if yes - show relative
     6E59   18           9915   20$	clc			;reset to show absolute
     6E5A   6E 116E      9916   30$	ror numcnt		;shift in second flag bit
                         9917   
     6E5D                9918   cordsb_patch			; (318018-03 mod; fab: fixes relative coords)
     6E5D   20 7874      9919   	jsr frmnum
     6E60   4C 8819      9920   	jmp getsad		;get signed 2 byte coordinate,do rts
                         9921   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 127
MOVSPR Command   MOVSPR.SRC

Error Addr  Code          Seq   Source statement

                         9923   
                         9924   ;*************************************************************
                         9925   ;
                         9926   ;  chkcom_1  --- check for a comma
                         9927   ;      carry set & eq = end of string
                         9928   ;      carry set & neq = not a comma
                         9929   ;      carry clear = a comma
                         9930   ;
                         9931   ;*************************************************************
                         9932   
     6E63                9933   chkcom_1
     6E63   20 0386      9934   	jsr chrgot		;get character in input stream
     6E66   F0 0D        9935   	beq 20$			;skip if end of string
     6E68   C9 2C        9936   	cmp #','		;check if a comma
     6E6A   18           9937   	clc
     6E6B   F0 01        9938   	beq 10$			;skip if yes
     6E6D   38           9939   	sec             	;set carry if not
     6E6E   08           9940   10$	php
     6E6F   48           9941   	pha
     6E70   20 0380      9942   	jsr chrget      	;move to next non-space character
     6E73   68           9943   	pla
     6E74   28           9944   	plp
     6E75   60           9945   20$	rts
                         9946   	
                         9947   
     6E76                9948   sproff	;sprite offsets into speed table
     6E76   00 0B 16     9949   	.byte 0,11,22,33,44,55,66,77
     6E79   21 2C 37            
     6E7C   42 4D               
                         9950   ;end
                         9951   	.include play		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 128
PLAY Command   PLAY.SRC

Error Addr  Code          Seq   Source statement

                         9953   	.subttl PLAY Command
                         9954   
                         9955   ; music interpreter
                         9956   ;
                         9957   ; syntax : PLAY music_string
                         9958   ;
                         9959   ; where : music_string is a string of characters composed of:
                         9960   ;
                         9961   ;	A..G	  : notes to play
                         9962   ;	W,H,Q,I,S : set note lengths to whole,half,quarter,eighth,sixteenth
                         9963   ;	"."	  : dot the next note
                         9964   ;	U	  : set volume level
                         9965   ;	O	  : set octave
                         9966   ;	T	  : set current envelope
                         9967   ;	V	  : select voice to play
                         9968   ;	X	  : filter
                         9969   ;	R	  : rest
                         9970   ;	M	  : measure
                         9971   ;	#	  : sharp
                         9972   ;	$	  : flat
                         9973   
                         9974   
     6E7E   20 877B      9975   play	jsr frmstr		;frmevl,frestr,return w/ .A=len, (index)=>string
     6E81   8D FF03      9976   	sta sw_rom_ram0
     6E84   85 77        9977   	sta z_p_temp_1		;save number of characters
     6E86   20 706B      9978   	jsr clear_play_flags	;set 'dot' and 'sharp' to 0. return with Acc=0
     6E89   85 78        9979   	sta hulp		;zero counter
                         9980   
     6E8B   A4 78        9981   10$	ldy hulp
     6E8D   C4 77        9982   	cpy z_p_temp_1
     6E8F   F0 0D        9983   	beq 20$			;done!
     6E91   20 03B7      9984   	jsr indin1_ram1
     6E94   8D FF03      9985   	sta sw_rom_ram0
     6E97   20 6E9F      9986   	jsr play_one_character
     6E9A   E6 78        9987   	inc hulp
     6E9C   D0 ED        9988   	bne 10$			;always
     6E9E   60           9989   20$	rts
                         9990   
                         9991   
                         9992   
     6E9F                9993   play_one_character
     6E9F   C9 20        9994   	cmp #' '
     6EA1   D0 01        9995   	bne 5$
     6EA3   60           9996   	rts			;spaces are a 'no-op'
                         9997   
     6EA4   C9 41        9998   5$	cmp #'A'		;note name a-g?
     6EA6   90 07        9999   	bcc 10$
     6EA8   C9 48       10000   	cmp #'H'
     6EAA   B0 03       10001   	bcs 10$
     6EAC   4C 6FBB     10002   	jmp play_note		;yes...play it
                        10003   
     6EAF   A2 04       10004   10$	ldx #4			;test for notes,'w,h,q,i,s'
     6EB1   DD 7084     10005   20$	cmp notes,x
     6EB4   D0 03       10006   	bne 22$
     6EB6   4C 6FA4     10007   	jmp set_note_length

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 128-1
PLAY Command   PLAY.SRC

Error Addr  Code          Seq   Source statement

     6EB9   CA          10008   22$	dex
     6EBA   10 F5       10009   	bpl 20$
                        10010   
     6EBC   C9 52       10011   	cmp #'R'		;rest?
     6EBE   D0 03       10012   	bne 25$
     6EC0   4C 7015     10013   	jmp play_rest
                        10014   
     6EC3   C9 2E       10015   25$	cmp #'.'		;dotted note?
     6EC5   D0 03       10016   	bne 27$
     6EC7   4C 6FA0     10017   	jmp play_dot
                        10018   
     6ECA   A2 05       10019   27$	ldx #5			;test for v,o,t,x,u,m commands
     6ECC   DD 7089     10020   30$	cmp mutabl,x
     6ECF   D0 03       10021   	bne 40$
     6ED1   4C 6FEF     10022   	jmp play_command
     6ED4   CA          10023   40$	dex
     6ED5   10 F5       10024   	bpl 30$			;test all 5 characters in table
                        10025   
     6ED7   C9 23       10026   	cmp #'#'		;sharp?
     6ED9   D0 03       10027   	bne 50$
     6EDB   4C 7006     10028   	jmp play_sharp
                        10029   
     6EDE   C9 24       10030   50$	cmp #'$'		;flat?
     6EE0   D0 03       10031   	bne 60$
     6EE2   4C 7009     10032   	jmp play_flat
                        10033   
                        10034   ;must be a digit here for
                        10035   ;octave , voice , music envelope or filter
                        10036   
     6EE5   38          10037   60$	sec
     6EE6   E9 30       10038   	sbc #'0'		;mask nybble
     6EE8   C9 0A       10039   	cmp #10			;must be in range 0..9
     6EEA   90 03       10040   	bcc 70$
     6EEC   4C 6F9A     10041   	jmp play_bad_value
                        10042   
     6EEF   0E 0126     10043   70$	asl flag		;octave, voice, music envelope, filter, or vol?
     6EF2   B0 46       10044   	bcs set_voice
                        10045   
     6EF4   0E 0126     10046   	asl flag		;octave, music envelope, filter, or volume?
     6EF7   B0 4C       10047   	bcs set_octave
                        10048   
     6EF9   0E 0126     10049   	asl flag		;music envelope, filter, or volume?
     6EFC   B0 50       10050   	bcs set_envelope
                        10051   
     6EFE   0E 0126     10052   	asl flag		;filter or volume?
     6F01   90 77       10053   	bcc set_volume
                        10054   
     6F03               10055   set_filter
     6F03   C9 02       10056   	cmp #2
     6F05   90 03       10057   	bcc 5$
     6F07   4C 6F9A     10058   	jmp play_bad_value	;value too large
     6F0A   4A          10059   5$	lsr a
     6F0B   AC 122F     10060   	ldy voice
     6F0E   BE 7081     10061   	ldx times2,y    	;0,2, & 4 for voice 0,1, & 2
     6F11   BD 1224     10062   10$	lda voices+1,x  	;test if voice is active

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 128-2
PLAY Command   PLAY.SRC

Error Addr  Code          Seq   Source statement

     6F14   10 FB       10063   	bpl 10$			;if so, loop.
     6F16   B9 6D50     10064   	lda sbits,y     	;get bit to change
     6F19   0D 1273     10065   	ora filters+2    	;set filter on
     6F1C   B0 03       10066   	bcs 20$			;skip - turn filter on
     6F1E   59 6D50     10067   	eor sbits,y     	;turn off filter
     6F21   8D 1273     10068   20$	sta filters+2
     6F24   AD 1274     10069   	lda filters+3
     6F27   8D 1275     10070   	sta filters+4    	;save new filter-type/volume
                        10071   
     6F2A   A2 03       10072   	ldx #3
     6F2C   BD 1271     10073   30$	lda filters,x    	;set filter value
     6F2F   20 A855     10074   	jsr put_io_in_map
     6F32   9D D415     10075   	sta sid+21,x
     6F35   CA          10076   	dex
     6F36   10 F4       10077   	bpl 30$
     6F38   30 5A       10078   	bmi clear_flag		;always
                        10079   
     6F3A               10080   set_voice
     6F3A   AA          10081   	tax
     6F3B   CA          10082   	dex
     6F3C   E0 03       10083   	cpx #3
     6F3E   B0 5A       10084   	bcs play_bad_value
     6F40   8E 122F     10085   	stx voice
     6F43   90 4F       10086   	bcc clear_flag		;always
                        10087   
                        10088   
     6F45               10089   set_octave
     6F45   C9 07       10090   	cmp #7
     6F47   B0 51       10091   	bcs play_bad_value	;too big octave
     6F49   8D 122B     10092   	sta octave      	;set octave
     6F4C   90 46       10093   	bcc clear_flag		;always
                        10094   
                        10095   
     6F4E               10096   set_envelope
     6F4E   AA          10097   	tax
     6F4F               10098   set_envelope_1			;entry for initialization code
     6F4F   20 A855     10099   	jsr put_io_in_map
     6F52   AC 122F     10100   	ldy voice
     6F55   BD 1253     10101   	lda wavtab,x
     6F58   99 1230     10102   	sta wave0,y     	;set waveform
     6F5B   B9 70D6     10103   	lda offtab,y    	;get sid offset
     6F5E   A8          10104   	tay
     6F5F   BD 123F     10105   	lda atktab,x
     6F62   99 D405     10106   	sta sid+5,y  		;set attack/decay
     6F65   BD 1249     10107   	lda sustab,x
     6F68   99 D406     10108   	sta sid+6,y  		;set sustain/release
     6F6B   BD 125D     10109   	lda pulslw,x
     6F6E   99 D402     10110   	sta sid+2,y  		;set pulse width - low byte
     6F71   BD 1267     10111   	lda pulshi,x
     6F74   99 D403     10112   	sta sid+3,y  		;set pulse width - high byte
     6F77   4C 6F94     10113   	jmp clear_flag
                        10114   
                        10115   
     6F7A               10116   set_volume
     6F7A   AA          10117   	tax

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 128-3
PLAY Command   PLAY.SRC

Error Addr  Code          Seq   Source statement

     6F7B   AD 1274     10118   	lda filters+3
     6F7E   29 F0       10119   	and #$f0	 	;mask out old volume
     6F80   1D 70D9     10120   	ora voltab,x    	;add new volume
     6F83   8D 1274     10121   	sta filters+3    	;save for filter change
     6F86   AD 1275     10122   	lda filters+4    	;get current filter-type/volume
     6F89   29 F0       10123   	and #$f0
     6F8B   1D 70D9     10124   	ora voltab,x
     6F8E   20 A855     10125   	jsr put_io_in_map
     6F91   8D D418     10126   	sta sid+24   		;set new volume
                        10127   
     6F94               10128   clear_flag
     6F94   A9 00       10129   	lda #0
     6F96   8D 0126     10130   	sta flag
     6F99   60          10131   	rts
                        10132   
                        10133   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 129
PLAY Command   PLAY.SRC

Error Addr  Code          Seq   Source statement

                        10135   
     6F9A               10136   play_bad_value
     6F9A   20 6F94     10137   	jsr clear_flag
     6F9D   4C 7DC5     10138   	jmp fcerr		;illegal quantity
                        10139   
     6FA0               10140   play_dot
     6FA0   8D 1233     10141   	sta dnote
     6FA3   60          10142   	rts
                        10143   
                        10144   
                        10145   
     6FA4               10146   set_note_length
     6FA4   A0 80       10147   	ldy #<beats		;found note, divide beats accordingly
     6FA6   8C 1229     10148   	sty ntime
     6FA9   A0 04       10149   	ldy #>beats
     6FAB   8C 122A     10150   	sty ntime+1
     6FAE   CA          10151   10$	dex
     6FAF   30 09       10152   	bmi 20$			;finished dividing, exit
     6FB1   4E 122A     10153   	lsr ntime+1
     6FB4   6E 1229     10154   	ror ntime
     6FB7   4C 6FAE     10155   	jmp 10$
     6FBA   60          10156   20$	rts
                        10157   
                        10158   
                        10159   
                        10160   
                        10161   
                        10162   
     6FBB               10163   play_note
     6FBB   38          10164   	sec
     6FBC   E9 41       10165   	sbc #'A'
     6FBE   AA          10166   	tax
     6FBF   BD 708F     10167   	lda scalen,x    	;note #0-11
     6FC2   AA          10168   	tax
     6FC3   A9 06       10169   	lda #6
     6FC5   38          10170   	sec
     6FC6   ED 122B     10171   	sbc octave
     6FC9   A8          10172   	tay
     6FCA   8A          10173   	txa
     6FCB   18          10174   	clc
     6FCC   6D 122C     10175   	adc sharp
     6FCF   10 03       10176   	bpl 10$			;added sharp or nat
     6FD1   A9 0B       10177   	lda #11			;underflow
     6FD3   C8          10178   	iny	      		;bump octave down
     6FD4   C9 0C       10179   10$	cmp #12	  		;overflow?
     6FD6   90 03       10180   	bcc 20$			;no...
     6FD8   A9 00       10181   	lda #0
     6FDA   88          10182   	dey			;bump octave up
     6FDB   AA          10183   20$	tax
     6FDC   BD 7096     10184   	lda scalel,x
     6FDF   8D 122D     10185   	sta pitch
     6FE2   BD 70A2     10186   	lda scaleh,x
     6FE5   88          10187   30$	dey
     6FE6   30 27       10188   	bmi play_rest_1
     6FE8   4A          10189   	lsr a

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 129-1
PLAY Command   PLAY.SRC

Error Addr  Code          Seq   Source statement

     6FE9   6E 122D     10190   	ror pitch
     6FEC   4C 6FE5     10191   	jmp 30$
                        10192   
                        10193   
                        10194   
     6FEF               10195   play_command
     6FEF   C9 4D       10196   	cmp #'M'		;measure?
     6FF1   F0 07       10197   	beq 10$
                        10198   
     6FF3   BD 9D25     10199   	lda rbits,x		;all others, set flag for next number
     6FF6   8D 0126     10200   	sta flag
     6FF9   60          10201   	rts
                        10202   
                        10203   ; wait for msb of all 3 voice counters to underflow
                        10204   
     6FFA   A0 05       10205   10$	ldy #5
     6FFC   B9 1223     10206   20$	lda voices,y
     6FFF   10 FB       10207   	bpl 20$
     7001   88          10208   	dey
     7002   88          10209   	dey
     7003   10 F7       10210   	bpl 20$
     7005   60          10211   	rts
                        10212   
                        10213   
                        10214   
     7006               10215   play_sharp
     7006   A9 01       10216   	lda #1
     7008   2C          10217   	.byte $2c
     7009               10218   play_flat
     7009   A9 FF       10219   	lda #$ff
     700B   8D 122C     10220   	sta sharp
     700E   60          10221   	rts
                        10222   
                        10223   
                        10224   
                        10225   
     700F               10226   play_rest_1
     700F   8D 122E     10227   	sta pitch+1
     7012   A9 00       10228   	lda #0			;flag 'not rest'
     7014   2C          10229   	.byte $2c	 	;hop
     7015               10230   play_rest
     7015   A9 FF       10231   	lda #$ff	 	;flag 'rest'
     7017   48          10232   	pha			;save flag
     7018   AE 122F     10233   	ldx voice
     701B   BC 7081     10234   	ldy times2,x    	;y=x*2
                        10235   
     701E   B9 1224     10236   10$	lda voices+1,y  	;test if there is a note playing
     7021   10 FB       10237   	bpl 10$			;and loop if so.
                        10238   
     7023   AD 1229     10239   	lda ntime		;load counter for current length
     7026   99 1223     10240   	sta voices,y
     7029   AD 122A     10241   	lda ntime+1
     702C   99 1224     10242   	sta voices+1,y
     702F   AD 1233     10243   	lda dnote		;test if this is a dotted note
     7032   F0 17       10244   	beq 20$			;no

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 129-2
PLAY Command   PLAY.SRC

Error Addr  Code          Seq   Source statement

     7034   AD 122A     10245   	lda ntime+1
     7037   4A          10246   	lsr a		    	;duration is 1.5 x current length
     7038   48          10247   	pha
     7039   AD 1229     10248   	lda ntime
     703C   6A          10249   	ror a
     703D   18          10250   	clc
     703E   79 1223     10251   	adc voices,y
     7041   99 1223     10252   	sta voices,y
     7044   68          10253   	pla
     7045   79 1224     10254   	adc voices+1,y
     7048   99 1224     10255   	sta voices+1,y
                        10256   
     704B   68          10257   20$	pla		      	;test if this is a rest
     704C   30 1D       10258   	bmi clear_play_flags	;and branch if so
                        10259   
     704E   20 A855     10260   	jsr put_io_in_map
     7051   BC 70D6     10261   	ldy offtab,x    	;y=x*7
     7054   AD 122D     10262   	lda pitch
     7057   99 D400     10263   	sta sid,y
     705A   AD 122E     10264   	lda pitch+1
     705D   99 D401     10265   	sta sid+1,y
     7060   A9 08       10266   	lda #$08	 	;reset this voice
     7062   99 D404     10267   	sta sid+4,y
     7065   BD 1230     10268   	lda wave0,x     	;and finally, turn on gate
     7068   99 D404     10269   	sta sid+4,y
                        10270   
     706B               10271   clear_play_flags
     706B   A9 00       10272   	lda #0
     706D   8D 122C     10273   	sta sharp		;clear flags
     7070   8D 1233     10274   	sta dnote
     7073   60          10275   	rts
                        10276   
                        10277   
     7074   20 87F4     10278   tempo	jsr getbyt
     7077   8A          10279   	txa
     7078   F0 04       10280   	beq 1$			;can't be zero
     707A   8E 1222     10281   	stx tempo_rate
     707D   60          10282   	rts
     707E   4C 7DC5     10283   1$	jmp fcerr		;bad value error
                        10284   
                        10285   
                        10286   
     7081   00 02 04    10287   times2	.byte 0,2,4
                        10288   
     7084   57 48 51    10289   notes  .byte 'WHQIS'   	;sixteenth,eigth,quarter,half,and whole notes
     7087   49 53               
                        10290   
     7089   56 4F 54    10291   mutabl .byte 'VOTXUM'   ;voice,octave,envelope,filter,volume,& measure
     708C   58 55 4D            
                        10292   
     708F   09 0B 00    10293   scalen	.byte 9,11,0,2,4,5,7 	;a,b,c,d,e,f,g
     7092   02 04 05            
     7095   07                  
                        10294   
     7096   2F B6 83    10295   scalel	.byte 47,182,131,153,252,177

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 129-3
PLAY Command   PLAY.SRC

Error Addr  Code          Seq   Source statement

     7099   99 FC B1            
     709C   BD 25 EF    10296   	.byte 189,37,239,32,190,209
     709F   20 BE D1            
                        10297   
     70A2   4C 50 55    10298   scaleh	.byte 76,80,85,90,95,101
     70A5   5A 5F 65            
     70A8   6B 72 78    10299   	.byte 107,114,120,128,135,143
     70AB   80 87 8F            
                        10300   ;
                        10301   ;  music envelope tables
                        10302   ; 0: piano   1: accordion    2: calliope  3: drum     4: flute
                        10303   ; 5: guitar  6: harpsichord  7: organ  8: trumpet  9: xylophone
                        10304   ;
                        10305   ;  attack/decay rates
                        10306   ;
     70AE   09 C0 00    10307   atkmus	.byte $09,$c0,$00,$05,$94,$09,$09,$09,$89,$09
     70B1   05 94 09            
     70B4   09 09 89            
     70B7   09                  
                        10308   ;
                        10309   ;  sustain/release rates
                        10310   ;
     70B8   00 C0 F0    10311   susmus	.byte $00,$c0,$f0,$50,$40,$21,$00,$90,$41,$00
     70BB   50 40 21            
     70BE   00 90 41            
     70C1   00                  
                        10312   ;
                        10313   ;  wave forms
                        10314   ;
     70C2   41 21 11    10315   wavmus	.byte $41,$21,$11,$81,$11,$21,$41,$41,$41,$11
     70C5   81 11 21            
     70C8   41 41 41            
     70CB   11                  
                        10316   ;
                        10317   ;  pulse width hi table
                        10318   ;
     70CC   06 00 00    10319   pwhmus	.byte $06,$00,$00,$00,$00,$00,$02,$08,$02,$00
     70CF   00 00 00            
     70D2   02 08 02            
     70D5   00                  
                        10320   ;
                        10321   ;  offset table
                        10322   ;
     70D6   00 07 0E    10323   offtab	.byte 0,7,14
                        10324   ;
                        10325   ;  volume levels
                        10326   ;
     70D9   00 01 03    10327   voltab	.byte 0,1,3,5,7,8,10,12,14,15
     70DC   05 07 08            
     70DF   0A 0C 0E            
     70E2   0F                  
                        10328   
                        10329   ;end
                        10330   	.include filter		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 130
FILTER Command   FILTER.SRC

Error Addr  Code          Seq   Source statement

                        10332   	.subttl FILTER Command
                        10333   
                        10334   ;******************************************************************
                        10335   ;
                        10336   ;  filter  freq, lp, bp, hp, res
                        10337   ;      --  set values for filter
                        10338   ;          freq =  filter frequency (0-1023)
                        10339   ;            lp =  low pass filter on (1) or off (0)
                        10340   ;            bp =  band pass filter on (1) or off (0)
                        10341   ;            hp =  high pass filter on (1) or off (0)
                        10342   ;           res =  resonance (0-15)
                        10343   ;
                        10344   ;******************************************************************
                        10345   
     70E3   48          10346   filter	pha
     70E4   A0 03       10347   	ldy #3
     70E6   B9 1271     10348   10$	lda filters,y    	;save filter values
     70E9   99 1234     10349   	sta fltsav,y
     70EC   88          10350   	dey
     70ED   10 F7       10351   	bpl 10$
                        10352   
     70EF   68          10353   	pla			;check first character of arg
     70F0   C9 2C       10354   	cmp #','
     70F2   F0 19       10355   	beq 20$			;skip if no value given
     70F4   20 8812     10356   	jsr getwrd		;get filter frequency
     70F7   C9 08       10357   	cmp #8			;test m.s. byte
     70F9   B0 60       10358   	bcs 90$			;error if > 2047
     70FB   8C 1234     10359   	sty fltsav		;save lower byte
                        10360   
                        10361   ; idea: shift lower 3 bits of upper byte into lower byte, forming bits 10-3
                        10362   
     70FE   8C 1235     10363   	sty fltsav+1
     7101   4A          10364   	lsr a
     7102   6E 1235     10365   	ror fltsav+1
     7105   4A          10366   	lsr a
     7106   6E 1235     10367   	ror fltsav+1    	;save upper 7 bits (10-3)
     7109   4A          10368   	lsr a
     710A   6E 1235     10369   	ror fltsav+1
                        10370   
     710D   A9 10       10371   20$	lda #$10
     710F   8D 1238     10372   	sta fltflg
                        10373   
     7112   20 9E27     10374   30$	jsr optbyt		;get filter value
     7115   90 17       10375   	bcc 50$			;skip if no value input
     7117   E0 01       10376   	cpx #1
     7119   90 05       10377   	bcc 35$			;..0 is ok,
     711B   F0 03       10378   	beq 35$			;..and so is 1,
     711D   4C 7DC5     10379   	jmp fcerr		;..but >1 isn't!
                        10380   
     7120   AD 1237     10381   35$	lda fltsav+3    	;get filter flags byte
     7123   0D 1238     10382   	ora fltflg      	;set filter on
     7126   B0 03       10383   	bcs 40$			;skip if should be on
     7128   4D 1238     10384   	eor fltflg      	;turn filter off
     712B   8D 1237     10385   40$	sta fltsav+3    	;save value
                        10386   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 130-1
FILTER Command   FILTER.SRC

Error Addr  Code          Seq   Source statement

     712E   0E 1238     10387   50$	asl fltflg      	;shift for next filter
     7131   10 DF       10388   	bpl 30$			;loop 3 times
                        10389   
                        10390   
     7133   20 9E27     10391   	jsr optbyt		;get resonance value
     7136   90 17       10392   	bcc 70$			;skip if no value given
     7138   E0 10       10393   	cpx #16
     713A   B0 1F       10394   	bcs 90$			;error if >15
     713C   8A          10395   	txa
     713D   0A          10396   	asl a
     713E   0A          10397   	asl a		    	;shift to upper nibble
     713F   0A          10398   	asl a
     7140   0A          10399   	asl a
     7141   8D 1239     10400   	sta nibble
     7144   AD 1236     10401   	lda fltsav+2    	;get current value
     7147   29 0F       10402   	and #$0f	 	;mask it out
     7149   0D 1239     10403   	ora nibble      	;add new value
     714C   8D 1236     10404   	sta fltsav+2    	;save it
                        10405   
     714F   A0 03       10406   70$	ldy #3
     7151   B9 1234     10407   80$	lda fltsav,y    	;resave values
     7154   99 1271     10408   	sta filters,y
     7157   88          10409   	dey
     7158   10 F7       10410   	bpl 80$
     715A   60          10411   	rts
                        10412   
     715B   4C 7DC5     10413   90$	jmp fcerr		;illegal quantity error
                        10414   ;end
                        10415   	.include envelope	;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 131
ENVELOPE Command   ENVELOPE.SRC

Error Addr  Code          Seq   Source statement

                        10417   	.subttl ENVELOPE Command
                        10418   
                        10419   ;****************************************************************
                        10420   ;
                        10421   ;  envelope n, attack, decay, sustain, release, waveform, pulse width
                        10422   ;        set music envelope
                        10423   ;                n = envelope number (0-9)
                        10424   ;            wave  =   0 : triangle waveform
                        10425   ;                      1 : sawtooth waveform
                        10426   ;                      2 : pulse waveform
                        10427   ;                      3 : noise waveform
                        10428   ;                      4 : ring modulation
                        10429   ;            pulse = pulse width if pulse waveform is selected (0-4095)
                        10430   ;
                        10431   ;******************************************************************
                        10432   
     715E               10433   envelope
     715E   20 87F4     10434   	jsr getbyt		;get envelope number
     7161   E0 0A       10435   	cpx #10
     7163   90 03       10436   	bcc tone10      	;exit if number in bounds
                        10437   
     7165   4C 7DC5     10438   tonerr	jmp fcerr		;exit - invalid tone number
                        10439   
     7168   8E 123A     10440   tone10	stx tonnum      	;save number
     716B   BD 123F     10441   	lda atktab,x    	;get attack/decay rates
     716E   8D 123B     10442   	sta tonval
     7171   BD 1249     10443   	lda sustab,x    	;get sustain/release rates
     7174   8D 123C     10444   	sta tonval+1
     7177   BD 1253     10445   	lda wavtab,x    	;get waveform and filter
     717A   8D 123D     10446   	sta tonval+2
     717D   A2 00       10447   	ldx #0
                        10448   
     717F   8E 123E     10449   tone20	stx parcnt
     7182   20 9E27     10450   	jsr optbyt      	;get parameter - attack or sustain
     7185   90 16       10451   	bcc tone30      	;skip if no input
     7187   8A          10452   	txa
     7188   0A          10453   	asl a
     7189   0A          10454   	asl a			;shift to upper nibble
     718A   0A          10455   	asl a
     718B   0A          10456   	asl a
     718C   8D 1239     10457   	sta nibble      	;save it
     718F   AE 123E     10458   	ldx parcnt
     7192   BD 123B     10459   	lda tonval,x    	;get current value
     7195   29 0F       10460   	and #$0f		;mask it out
     7197   0D 1239     10461   	ora nibble      	;add new value
     719A   9D 123B     10462   	sta tonval,x    	;save it
                        10463   
     719D   20 9E27     10464   tone30	jsr optbyt      	;get decay or release rate
     71A0   90 14       10465   	bcc tone40      	;skip if no input
     71A2   8A          10466   	txa
     71A3   29 0F       10467   	and #$0f		;use only lower nibble
     71A5   8D 1239     10468   	sta nibble      	;save it
     71A8   AE 123E     10469   	ldx parcnt
     71AB   BD 123B     10470   	lda tonval,x    	;get current value
     71AE   29 F0       10471   	and #$f0		;mask it out

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 131-1
ENVELOPE Command   ENVELOPE.SRC

Error Addr  Code          Seq   Source statement

     71B0   0D 1239     10472   	ora nibble      	;add new value
     71B3   9D 123B     10473   	sta tonval,x    	;save it
                        10474   
     71B6   AE 123E     10475   tone40	ldx parcnt
     71B9   E8          10476   	inx
     71BA   E0 01       10477   	cpx #1
     71BC   F0 C1       10478   	beq tone20      	;loop to do sustain/release rates
     71BE   20 9E27     10479   	jsr optbyt      	;get waveform
     71C1   90 10       10480   	bcc tone90      	;skip if no value
     71C3   A9 15       10481   	lda #$15		;assume ring modulation
     71C5   E0 04       10482   	cpx #4
     71C7   F0 07       10483   	beq tone80      	;skip if correct
     71C9   B0 9A       10484   	bcs tonerr		;error if >4
     71CB   BD 6D54     10485   	lda sbits+4,x		;get waveform bit
     71CE   09 01       10486   	ora #1			;set gate bit
                        10487   
     71D0   8D 123D     10488   tone80	sta tonval+2    	;save waveform
                        10489   
     71D3   20 9E0F     10490   tone90	jsr optwrd		;is there a pulse width arg?
     71D6   90 13       10491   	bcc ton110		;nope, done
                        10492   
     71D8   AA          10493   	tax			;save msb
     71D9   AD 123D     10494   	lda tonval+2    	;get waveform
     71DC   29 40       10495   	and #$40
     71DE   F0 0B       10496   	beq ton110      	;skip if not pulse waveform
     71E0   8A          10497   	txa
     71E1   AE 123A     10498   	ldx tonnum      	;get envelope number
     71E4   9D 1267     10499   	sta pulshi,x    	;save high byte of pulse width
     71E7   98          10500   	tya
     71E8   9D 125D     10501   	sta pulslw,x    	;save low byte 
                        10502   
     71EB   AE 123A     10503   ton110	ldx tonnum
     71EE   AD 123B     10504   	lda tonval      	;set inputted values
     71F1   9D 123F     10505   	sta atktab,x
     71F4   AD 123C     10506   	lda tonval+1
     71F7   9D 1249     10507   	sta sustab,x
     71FA   AD 123D     10508   	lda tonval+2
     71FD   9D 1253     10509   	sta wavtab,x
     7200   60          10510   	rts
                        10511   
                        10512   ;end
                        10513   	.include collision	;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 132
COLLISION Command   COLLISION.SRC

Error Addr  Code          Seq   Source statement

                        10515   	.subttl COLLISION Command
                        10516   
                        10517   ;*****************************************************************
                        10518   ;
                        10519   ; COLLISION Command
                        10520   ;
                        10521   ;   syntax : COLLISION n [,address]
                        10522   ;
                        10523   ;   where : n = 1 ==> sprite / sprite
                        10524   ;		2 ==> sprite / background
                        10525   ;		3 ==> light pen
                        10526   ;
                        10527   ;	    address == BASIC line number to trap to on interrupt
                        10528   ;
                        10529   ; 	    no address ==> disable trapping
                        10530   ;
                        10531   ;*****************************************************************
                        10532   
     7201               10533   collision
     7201   20 87F4     10534   	jsr getbyt		;get type in .X
     7204   CA          10535   	dex			;adjust 1..3 to 0..2
     7205   E0 03       10536   	cpx #3
     7207   B0 21       10537   	bcs 99$			;value error
                        10538   
     7209   8E 1280     10539   	stx coltyp
     720C   20 9E0F     10540   	jsr optwrd		;get (optional) address in .Y,.A
     720F   08          10541   	php			;save .C (.C == 1 ==> real value)
     7210   AE 1280     10542   	ldx coltyp
     7213   9D 127C     10543   	sta int_adr_hi,x	;save address given
     7216   98          10544   	tya
     7217   9D 1279     10545   	sta int_adr_lo,x
                        10546   
     721A   AD 127F     10547   	lda intval		;this records valid interrupts
     721D   1D 6D50     10548   	ora sbits,x		;set correct bit
     7220   28          10549   	plp
     7221   B0 03       10550   	bcs 10$			;..unless this is a 'clear',
     7223   5D 6D50     10551   	eor sbits,x		;..in which case we'll reset bit
     7226   8D 127F     10552   10$	sta intval
     7229   60          10553   	rts
                        10554   
     722A   4C 7DC5     10555   99$	jmp fcerr		;illegal value error
                        10556   
                        10557   ;end
                        10558   	.include sprcolor	;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 133
SPRCOLOR Command   SPRCOLOR.SRC

Error Addr  Code          Seq   Source statement

                        10560   	.subttl SPRCOLOR Command
                        10561   
                        10562   ;**************************************************************
                        10563   ;*
                        10564   ;*   SPRCOLOR - Set sprite multicolor registers
                        10565   ;*
                        10566   ;*	syntax : SPRCOLOR [multicolor_1] [,multicolor_2]
                        10567   ;*
                        10568   ;**************************************************************
                        10569   
     722D               10570   sprcolor
     722D   C9 2C       10571   	cmp #','		;is there a first arg?
     722F   F0 0E       10572   	beq 10$			;nope, skip to second
                        10573   
     7231   20 87F4     10574   	jsr getbyt		;get 1 byte arg in .X
     7234   CA          10575   	dex			;adjust 1..16 to 0..15
     7235   E0 10       10576   	cpx #16
     7237   B0 17       10577   	bcs 98$			;too big
     7239   20 A855     10578   	jsr put_io_in_map
     723C   8E D025     10579   	stx vic+37
                        10580   
     723F   20 9E27     10581   10$	jsr optbyt		;get (optional) 1 byte arg in .X
     7242   90 0B       10582   	bcc 20$
                        10583   
     7244   CA          10584   	dex
     7245   E0 10       10585   	cpx #16
     7247   B0 07       10586   	bcs 98$			;too big
     7249   20 A855     10587   	jsr put_io_in_map
     724C   8E D026     10588   	stx vic+38
                        10589   
     724F   60          10590   20$	rts
                        10591   
     7250   4C 7DC5     10592   98$	jmp fcerr		;illegal value error
                        10593   
                        10594   ;end
                        10595   	.include width		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 134
WIDTH Command   WIDTH.SRC

Error Addr  Code          Seq   Source statement

                        10597   	.subttl WIDTH Command
                        10598   
                        10599   ;***********************************************************
                        10600   ;*
                        10601   ;*   WIDTH - set single/double line drawing width
                        10602   ;*
                        10603   ;*	syntax : WIDTH arg
                        10604   ;*
                        10605   ;*	where  : arg :== 1(single) | 2(double)
                        10606   ;*
                        10607   ;***********************************************************
                        10608   
     7253               10609   set_width
     7253   20 87F4     10610   	jsr getbyt		;get 1 byte arg in .X
     7256   CA          10611   	dex			;adjust 1..2 to 0..1
     7257   E0 02       10612   	cpx #2
     7259   B0 04       10613   	bcs 98$
     725B   8E 116B     10614   	stx width
     725E   60          10615   	rts
                        10616   
     725F   4C 7DC5     10617   98$	jmp fcerr		;illegal value error
                        10618   	.include volume		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 135
VOLUME Command   VOLUME.SRC

Error Addr  Code          Seq   Source statement

                        10620   	.subttl	VOLUME Command
                        10621   
                        10622   ;***************************************************************
                        10623   ;*
                        10624   ;*  VOLUME - set volume of SID
                        10625   ;*
                        10626   ;*	syntax : VOLUME vol
                        10627   ;*
                        10628   ;*	where  : vol in 0..15
                        10629   ;*
                        10630   ;***************************************************************
                        10631   
     7262   20 87F4     10632   volume	jsr getbyt		;get 1 byte arg in .X
     7265   E0 10       10633   	cpx #16
     7267   B0 1D       10634   	bcs 98$			;too large
     7269   86 77       10635   	stx z_p_temp_1		;a temp (sorry fred)
                        10636   
                        10637   ; the way this is done must work with 'PLAY' without too much conflict.
                        10638   ; so, along with setting the SID 'volume' reg, we'll also set up 'PLAY's
                        10639   ; record of current volume, as well.
                        10640   
     726B   AD 1274     10641   	lda filters+3
     726E   29 F0       10642   	and #$f0
     7270   05 77       10643   	ora z_p_temp_1
     7272   8D 1274     10644   	sta filters+3
                        10645   
     7275   AD 1275     10646   	lda filters+4
     7278   29 F0       10647   	and #$f0
     727A   05 77       10648   	ora z_p_temp_1
     727C   8D 1275     10649   	sta filters+4
                        10650   
     727F   20 A855     10651   	jsr put_io_in_map
     7282   8D D418     10652   	sta sid+24
     7285   60          10653   	rts
                        10654   
     7286   4C 7DC5     10655   98$	jmp fcerr		;illegal value error
                        10656   
                        10657   ;end
                        10658   	.include sound		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 136
SOUND Command   SOUND.SRC

Error Addr  Code          Seq   Source statement

                        10660   	.subttl SOUND Command
                        10661   
                        10662   ;*****************************************************************************
                        10663   ;*
                        10664   ;*  SOUND - Produce sound effects
                        10665   ;*
                        10666   ;*	Syntax : SOUND v, f, d [,[dir] [,[m] [,[s] [,[w] [,p] ]]]]
                        10667   ;*
                        10668   ;*	where : v = voice (1..3)
                        10669   ;*		f = frequency value (0..65535)
                        10670   ;*		d = duration (0..32767 jiffys)
                        10671   ;*		dir = step direction (0(up) ,1(down) or 2(oscillate)) default=0
                        10672   ;*		m = minimum frequency (if sweep is used) (0..65535) default=0
                        10673   ;*		s = step value for effects (0..32767) default=0
                        10674   ;*		w = waveform (0=triangle,1=saw,2=square,3=noise) default=2
                        10675   ;*		p = pulse width (0..4095) default=2048 (50% duty cycle)
                        10676   ;*
                        10677   ;*****************************************************************************
                        10678   
     7289   20 87F4     10679   sound	jsr getbyt		;get voice number in .X
     728C   CA          10680   	dex			;adjust 1..3 to 0..2
     728D   E0 03       10681   	cpx #3
     728F   90 03       10682   	bcc 10$
     7291   4C 7DC5     10683   98$	jmp fcerr		;illegal value
                        10684   
     7294   8E 1281     10685   10$	stx sound_voice
                        10686   
                        10687   ; get frequency
                        10688   
     7297   20 880F     10689   	jsr comwrd		;eat comma, get frequency in y,a
     729A   8C 12A5     10690   	sty temp_max_lo		;save our copy of max, also set up as current
     729D   8D 12A6     10691   	sta temp_max_hi
     72A0   8C 12AC     10692   	sty temp_freq_lo
     72A3   8D 12AD     10693   	sta temp_freq_hi
                        10694   
                        10695   ; get duration
                        10696   
     72A6   20 880F     10697   	jsr comwrd		;eat comma, get number of jiffys to play
     72A9   C9 80       10698   	cmp #$80
     72AB   B0 E4       10699   	bcs 98$
     72AD   8C 12A3     10700   	sty temp_time_lo
     72B0   8D 12A4     10701   	sta temp_time_hi
                        10702   
                        10703   
                        10704   ; get sweep direction
                        10705   
     72B3   20 9E25     10706   	jsr optzer		;get optional sweep (default = 0, up)
     72B6   E0 03       10707   	cpx #3
     72B8   B0 D7       10708   97$	bcs 98$
     72BA   8A          10709   	txa
     72BB   8D 12A9     10710   	sta temp_direction
     72BE   29 01       10711   	and #1			;set .Z if sweep up or oscillate
     72C0   08          10712   	php			;save .Z for step (below)
                        10713   
                        10714   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 136-1
SOUND Command   SOUND.SRC

Error Addr  Code          Seq   Source statement

                        10715   ; get minimum frequency value (sweep lo)
                        10716   
     72C1   20 9E0F     10717   	jsr optwrd
     72C4   8C 12A7     10718   	sty temp_min_lo
     72C7   8D 12A8     10719   	sta temp_min_hi
                        10720   
                        10721   ; get step value for sweep
                        10722   
     72CA   20 9E0F     10723   	jsr optwrd		;get optional step, default is zero
     72CD   28          10724   	plp			;get flags from direction
     72CE   F0 0D       10725   	beq 75$			;branch if 'up' or oscillate
     72D0   48          10726   	pha			;if 'down', make step 2's complement
     72D1   98          10727   	tya
     72D2   49 FF       10728   	eor #$ff
     72D4   18          10729   	clc
     72D5   69 01       10730   	adc #1
     72D7   A8          10731   	tay
     72D8   68          10732   	pla
     72D9   49 FF       10733   	eor #$ff
     72DB   69 00       10734   	adc #0
     72DD   8D 12AB     10735   75$	sta temp_step_hi
     72E0   98          10736   	tya
     72E1   8D 12AA     10737   	sta temp_step_lo
                        10738   
                        10739   ; get waveform
                        10740   
     72E4   A2 02       10741   	ldx #2			;get waveform. default is square (2)
     72E6   20 9E27     10742   	jsr optbyt
     72E9   E0 04       10743   	cpx #4
     72EB   B0 CB       10744   	bcs 97$			;illegal value
     72ED   BD 6D54     10745   	lda sbits+4,x		;get bit pattern for selected waveform
     72F0   09 01       10746   	ora #1			;add in the gate bit
     72F2   8D 12B0     10747   	sta temp_waveform
                        10748   
                        10749   ; get pulse width
                        10750   
     72F5   20 9E0F     10751   	jsr optwrd		;get optional pulse width in y,a
     72F8   B0 04       10752   	bcs 80$
     72FA   A9 08       10753   	lda #8			;no arg's given, use default pusle width
     72FC   A0 00       10754   	ldy #0
     72FE   C9 10       10755   80$	cmp #16
     7300   B0 8F       10756   	bcs 98$
     7302   8C 12AE     10757   	sty temp_pulse_lo
     7305   8D 12AF     10758   	sta temp_pulse_hi
                        10759   
                        10760   ; all arg's in, time to get to work
                        10761   
     7308   AD 12A3     10762   	lda temp_time_lo
     730B   0D 12A4     10763   	ora temp_time_hi
     730E   F0 46       10764   	beq 100$		;special case: time=0 means 'kill it NOW'
                        10765   
                        10766   ; wait for all current uses of this voice to time out
                        10767   
     7310   AE 1281     10768   	ldx sound_voice		;first test 'PLAY'
     7313   8A          10769   	txa			;make an index into PLAY's tables

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 136-2
SOUND Command   SOUND.SRC

Error Addr  Code          Seq   Source statement

     7314   0A          10770   	asl a
     7315   A8          10771   	tay
     7316   B9 1224     10772   60$	lda voices+1,y
     7319   10 FB       10773   	bpl 60$
                        10774   
     731B   BD 1285     10775   70$	lda sound_time_hi,x	;now test 'SOUND'
     731E   10 FB       10776   	bpl 70$
                        10777   
                        10778   ; all clear, now set up for current effect
                        10779   
     7320   A0 00       10780   	ldy #0			;download max freq l&h, min freq l&h,
     7322   B9 12A5     10781   90$	lda temp_max_lo,y	;..sweep direction, step value l&h, & freq l&h
     7325   9D 1288     10782   	sta sound_max_lo,x
     7328   E8          10783   	inx
     7329   E8          10784   	inx
     732A   E8          10785   	inx
     732B   C8          10786   	iny
     732C   C0 09       10787   	cpy #9
     732E   D0 F2       10788   	bne 90$
                        10789   
                        10790   ; now set up sid
                        10791   
     7330   AE 1281     10792   	ldx sound_voice
     7333   BC 70D6     10793   	ldy offtab,x		;get index to sid's voices
     7336   20 A855     10794   	jsr put_io_in_map
                        10795   
     7339   A9 08       10796   	lda #$08		;turn off sid's gate
     733B   99 D404     10797   	sta sid+4,y
                        10798   
     733E   A9 00       10799   	lda #0			;set up attack & decay,
     7340   99 D405     10800   	sta sid+5,y
     7343   A9 F0       10801   	lda #$f0		;..and sustain & release
     7345   99 D406     10802   	sta sid+6,y
                        10803   
     7348   A2 00       10804   	ldx #0			;set up freq (l&h), pulse width (l&h), & waveform
     734A   BD 12AC     10805   95$	lda temp_freq_lo,x
     734D   99 D400     10806   	sta sid,y
     7350   C8          10807   	iny
     7351   E8          10808   	inx
     7352   E0 05       10809   	cpx #5
     7354   D0 F4       10810   	bne 95$
                        10811   
                        10812   ; now set up time to play
                        10813   
     7356   AE 1281     10814   100$	ldx sound_voice
     7359   AC 12A3     10815   	ldy temp_time_lo
     735C   AD 12A4     10816   	lda temp_time_hi
                        10817   
     735F   78          10818   	sei
     7360   9D 1285     10819   	sta sound_time_hi,x
     7363   98          10820   	tya
     7364   9D 1282     10821   	sta sound_time_lo,x
     7367   58          10822   	cli
                        10823   
     7368   60          10824   	rts

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 136-3
SOUND Command   SOUND.SRC

Error Addr  Code          Seq   Source statement

                        10825   
                        10826   ;end
                        10827   
                        10828   	.include window		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 137
WINDOW Command   WINDOW.SRC

Error Addr  Code          Seq   Source statement

                        10830   	.subttl WINDOW Command
                        10831   
                        10832   ;****************************************************************
                        10833   ;*
                        10834   ;*  WINDOW Command
                        10835   ;*
                        10836   ;*  Syntax : WINDOW upper-left col, upper-left row,
                        10837   ;*		    lower-left col, lower-right row [,clear]
                        10838   ;*
                        10839   ;*  Where  :  0 <= row <= 24
                        10840   ;*	      0 <= column <= (80/40)
                        10841   ;*	      clear : 0 (no) or 1 (yes)
                        10842   ;*
                        10843   ;****************************************************************
                        10844   
     7369   20 87F4     10845   window	jsr getbyt		;get u.l. col
     736C   E0 28       10846   	cpx #40
     736E   24 D7       10847   	bit _mode
     7370   10 02       10848   	bpl 10$
     7372   E0 50       10849   	cpx #80
     7374   B0 59       10850   10$	bcs 98$
     7376   8E 12B3     10851   	stx window_temp
                        10852   
     7379   20 8809     10853   	jsr combyt		;get u.l. row
     737C   E0 19       10854   	cpx #25
     737E   B0 4F       10855   	bcs 98$
     7380   8E 12B4     10856   	stx window_temp+1
                        10857   
     7383   20 8809     10858   	jsr combyt		;get l.r. column
     7386   E0 28       10859   	cpx #40
     7388   24 D7       10860   	bit _mode
     738A   10 02       10861   	bpl 20$
     738C   E0 50       10862   	cpx #80
     738E   B0 3F       10863   20$	bcs 98$
     7390   8E 12B5     10864   	stx window_temp+2
     7393   EC 12B3     10865   	cpx window_temp		;can't be less than u.l. column
     7396   90 37       10866   	bcc 98$
                        10867   
     7398   20 8809     10868   	jsr combyt		;get l.r. row
     739B   E0 19       10869   	cpx #25
     739D   B0 30       10870   	bcs 98$
     739F   8E 12B6     10871   	stx window_temp+3
     73A2   EC 12B4     10872   	cpx window_temp+1	;can't be less than u.l. row
     73A5   90 28       10873   	bcc 98$
                        10874   
     73A7   20 9E25     10875   	jsr optzer		;get optional clear flag
     73AA   E0 02       10876   	cpx #2
     73AC   B0 21       10877   	bcs 98$
     73AE   8A          10878   	txa
     73AF   48          10879   	pha
                        10880   
     73B0   AE 12B3     10881   	ldx window_temp
     73B3   AD 12B4     10882   	lda window_temp+1
     73B6   18          10883   	clc
     73B7   20 C02D     10884   	jsr _set_window

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 137-1
WINDOW Command   WINDOW.SRC

Error Addr  Code          Seq   Source statement

                        10885   
     73BA   AE 12B5     10886   	ldx window_temp+2
     73BD   AD 12B6     10887   	lda window_temp+3
     73C0   38          10888   	sec
     73C1   20 C02D     10889   	jsr _set_window
                        10890   
     73C4   A2 13       10891   	ldx #19			;assume 'home', not 'cls'
     73C6   68          10892   	pla
     73C7   F0 02       10893   	beq 30$
     73C9   A2 93       10894   	ldx #147
     73CB   8A          10895   30$	txa
     73CC   4C 9269     10896   	jmp k_bsout
                        10897   
     73CF   4C 7DC5     10898   98$	jmp fcerr		;illegal value error
                        10899   
                        10900   ;end
                        10901   	.include boot		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 138
BOOT Command   BOOT.SRC

Error Addr  Code          Seq   Source statement

                        10903   	.subttl BOOT Command
                        10904   
                        10905   ;****************************************************************************
                        10906   ;
                        10907   ;  BOOT -  Boot a 'BOOT' disk, or 'BLOAD' a file, and SYS to it.
                        10908   ;
                        10909   ;  Syntax : Same as 'BLOAD'
                        10910   ;	if 'filename' present, assume 'BLOAD' and sys to starting addr.
                        10911   ;	else call kernal 'BOOT' routine, with our device & unit #'s as args.
                        10912   ;
                        10913   ;****************************************************************************
                        10914   
     73D2   A9 E6       10915   boot	lda #$e6		;set up parms for parse routine
     73D4   A2 FC       10916   	ldx #$fc
     73D6   20 A3D3     10917   	jsr dosprx		;parse
                        10918   
     73D9   A5 80       10919   	lda parsts		;was there a filename?
     73DB   4A          10920   	lsr a
     73DC   90 1D       10921   	bcc 20$			;no, do kernal BOOT
                        10922   
     73DE   20 A22F     10923   	jsr bload_1		;finish 'BLOAD' command
     73E1   B0 29       10924   	bcs 30$			;if error (c=1), tell 'em about it!
     73E3   AE 03D5     10925   	ldx current_bank	;assume no B(ank) arg was given
     73E6   A5 81       10926   	lda parstx
     73E8   4A          10927   	lsr a
     73E9   90 03       10928   	bcc 10$			;branch if no arg.
     73EB   AE 011F     10929   	ldx dosbnk		;..otherwise, get users bank number
     73EE   86 02       10930   10$	stx _bank
     73F0   A5 AC       10931   	lda _starting_addr	;set up address BLOAD loaded to
     73F2   85 04       10932   	sta _pclo
     73F4   A5 AD       10933   	lda _starting_addr+1
     73F6   85 03       10934   	sta _pchi
     73F8   4C FF6E     10935   	jmp _jjsr		;go do it!
                        10936   
     73FB   AD 0112     10937   20$	lda dosds1		;get drive number
     73FE   09 30       10938   	ora #'0'		;make ascii
     7400   AE 011C     10939   	ldx dosfa		;get unit number
     7403   20 A855     10940   	jsr put_io_in_map
     7406   20 FF53     10941   	jsr _boot_call
     7409   B0 01       10942   	bcs 30$			;branch if error
     740B   60          10943   	rts
                        10944   
     740C   4C 90D0     10945   30$	jmp erexit
                        10946   ;end
                        10947   	.include sprdef		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 139
SPRDEF Command   SPRDEF.SRC

Error Addr  Code          Seq   Source statement

                        10949   	.subttl SPRDEF Command
                        10950   
                        10951   ;***************************************************************
                        10952   ;
                        10953   ;  sprdef --  define a sprite interactively
                        10954   ;
                        10955   ;***************************************************************
                        10956   
     740F   20 9F58     10957   sprdef	jsr sethir		;make sure a graphics area is allocated
     7412   20 A855     10958   	jsr put_io_in_map
                        10959   
     7415   A9 D0       10960   	lda #$d0
     7417   8D 1168     10961   	sta character_rom	;set up address of character rom
                        10962   
     741A   A9 20       10963   	lda #%00100000
     741C   85 D8       10964   	sta _graphm		;make hires mode
     741E   20 6B57     10965   	jsr clear_graphics	;clear the screen
     7421   A0 80       10966   	ldy #$80		;to clear the screen
     7423   8C 113D     10967   	sty xysgn 		;for rvs fld
                        10968   
     7426   A0 18       10969   	ldy #24
     7428   A9 20       10970   	lda #' '		;space
     742A   A2 00       10971   	ldx #0
                        10972   
     742C   20 68F8     10973   10$	jsr chrdsp		;put down right edge for def'n area
     742F   E8          10974   	inx
     7430   E0 15       10975   	cpx #21
     7432   90 F8       10976   	bcc 10$
                        10977   
     7434   20 68F8     10978   20$	jsr chrdsp		;put down bottom border
     7437   88          10979   	dey
     7438   10 FA       10980   	bpl 20$
                        10981   
     743A   20 A855     10982   	jsr put_io_in_map
     743D   A5 F1       10983   	lda _text_color
     743F   48          10984   	pha			;save color
     7440   AD D021     10985   	lda vic+33
     7443   85 F1       10986   	sta _text_color
     7445   A9 2B       10987   	lda #'+'
     7447   A2 00       10988   	ldx #0
     7449   8E 113D     10989   	stx xysgn
                        10990   
     744C   A0 00       10991   30$	ldy #0
     744E   20 68F8     10992   40$	jsr chrdsp		;set up definition area
     7451   C8          10993   	iny
     7452   C0 18       10994   	cpy #24
     7454   90 F8       10995   	bcc 40$
     7456   E8          10996   	inx
     7457   E0 15       10997   	cpx #21
     7459   90 F1       10998   	bcc 30$
                        10999   
     745B   68          11000   	pla
     745C   85 F1       11001   	sta _text_color
     745E   20 7771     11002   	jsr def_clear		;clear the sprite def'n area
                        11003   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 139-1
SPRDEF Command   SPRDEF.SRC

Error Addr  Code          Seq   Source statement

     7461   A0 02       11004   defbeg	ldy #2
     7463   A2 17       11005   	ldx #23
                        11006   
     7465   B9 7709     11007   10$	lda stline-2,y		;sprite number request message
     7468   F0 06       11008   	beq 20$
     746A   20 68F8     11009   	jsr chrdsp
     746D   C8          11010   	iny
     746E   D0 F5       11011   	bne 10$
                        11012   
     7470   20 A855     11013   20$	jsr put_io_in_map
     7473   20 FFE4     11014   30$	jsr _getin
     7476   F0 FB       11015   	beq 30$			;wait for input
     7478   C9 0D       11016   	cmp #$0d
     747A   D0 08       11017   	bne 40$			;skip if not a return
     747C   20 6B57     11018   	jsr clear_graphics	;clear screen 
     747F   A9 00       11019   	lda #0
     7481   85 D8       11020   	sta _graphm		;set to text mode
     7483   60          11021   	rts
                        11022   
     7484   38          11023   40$	sec
     7485   E9 31       11024   	sbc #$31		;convert users 1-8 to 0-7
     7487   8D 12FC     11025   	sta sprite_number	;assume sprite number
     748A   C9 08       11026   	cmp #8
     748C   B0 E5       11027   	bcs 30$			;loop back if invalid
     748E   AA          11028   	tax
     748F   0A          11029   	asl a
     7490   A8          11030   	tay			;times 2 for indexing
     7491   BD 6D50     11031   	lda sbits,x
     7494   8D 116D     11032   	sta bitmsk		;save bit mask for sprite
     7497   2D D01C     11033   	and vic+28		;test if multicolor sprite
     749A   F0 02       11034   	beq 50$			;skip if not
     749C   A9 80       11035   	lda #$80
                        11036   
     749E   8D 12FA     11037   50$	sta defmod		;save mode of definition
     74A1   A9 08       11038   	lda #8
     74A3   99 11D6     11039   	sta vic_save+0,y	;set up address of where to show sprite
     74A6   A9 4A       11040   	lda #74
     74A8   99 11D7     11041   	sta vic_save+1,y
     74AB   AD 116D     11042   	lda bitmsk
     74AE   0D 11E6     11043   	ora vic_save+16
     74B1   8D 11E6     11044   	sta vic_save+16		;turn on msb for x-position
     74B4   AD 116D     11045   	lda bitmsk
     74B7   8D D015     11046   	sta vic+21		;enable only this sprite
                        11047   
     74BA   AE 12FC     11048   	ldx sprite_number	;turn off speed for this sprite
     74BD   BC 6E76     11049   	ldy sproff,x 		;get offset for this sprite to def'n area
     74C0   A9 00       11050   	lda #0
     74C2   99 117E     11051   	sta sprite_data,y
                        11052   
     74C5   8A          11053   	txa	  		;put sprite number into accumulator
     74C6   A0 11       11054   	ldy #15+2
     74C8   A2 17       11055   	ldx #23
     74CA   18          11056   	clc
     74CB   69 31       11057   	adc #$31
     74CD   20 68F8     11058   	jsr chrdsp		;show sprite number (0-7)

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 139-2
SPRDEF Command   SPRDEF.SRC

Error Addr  Code          Seq   Source statement

     74D0   20 A855     11059   	jsr put_io_in_map
     74D3   AD 12FC     11060   	lda sprite_number
     74D6   4A          11061   	lsr a
     74D7   6A          11062   	ror a
     74D8   6A          11063   	ror a
     74D9   85 4B       11064   	sta forpnt		;set up sprite base address
     74DB   A0 0E       11065   	ldy #>sprite_base
     74DD   90 01       11066   	bcc 60$
     74DF   C8          11067   	iny
     74E0   84 4C       11068   60$	sty forpnt+1
     74E2   20 766E     11069   	jsr show_sprite		;move sprite to definition area
                        11070   
     74E5   A0 3F       11071   	ldy #63
     74E7   B1 4B       11072   70$	lda (forpnt),y		;move sprite to save area
     74E9   99 12B7     11073   	sta savram,y
     74EC   88          11074   	dey
     74ED   10 F8       11075   	bpl 70$
                        11076   
     74EF   A2 00       11077   dohome	ldx #0
     74F1   8E 115F     11078   	stx rowcnt		;initialize cursor to top-left
     74F4   8E 115E     11079   	stx colcnt
                        11080   
     74F7   20 76E7     11081   dfloop	jsr togcur		;show cursor
     74FA   20 FFE4     11082   10$	jsr _getin		;get key input
     74FD   F0 FB       11083   	beq 10$			;loop till got a key
     74FF   48          11084   	pha
     7500   20 76E7     11085   	jsr togcur		;turn cursor off
     7503   68          11086   	pla
     7504   A2 10       11087   	ldx #colend-colnum
                        11088   
     7506   DD 7751     11089   dloop1	cmp colnum-1,x		;check if a color key was entered
     7509   D0 0D       11090   	bne 10$
     750B   CA          11091   	dex
     750C   8A          11092   	txa
     750D   AE 12FC     11093   	ldx sprite_number
     7510   9D D027     11094   	sta vic+39,x		;set new sprite color
     7513   20 766E     11095   	jsr show_sprite
     7516   B0 DF       11096   	bcs dfloop		;always
     7518   CA          11097   10$	dex
     7519   D0 EB       11098   	bne dloop1
                        11099   
     751B   A2 11       11100   	ldx #cmdend-cmdstr-1 	;check table of valid commands
     751D   DD 771C     11101   20$	cmp cmdstr,x
     7520   F0 05       11102   	beq 30$
     7522   CA          11103   	dex
     7523   10 F8       11104   	bpl 20$
     7525   30 D0       11105   	bmi dfloop		;no valid entry found
                        11106   
     7527   8A          11107   30$	txa
     7528   A8          11108   	tay			;save index for routines to use (if necessary)
     7529   0A          11109   	asl a			;find address of command
     752A   AA          11110   	tax
     752B   BD 772E     11111   	lda defjmp,x 		;address high
     752E   48          11112   	pha
     752F   BD 772F     11113   	lda defjmp+1,x 		;address low

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 139-3
SPRDEF Command   SPRDEF.SRC

Error Addr  Code          Seq   Source statement

     7532   48          11114   	pha
     7533   60          11115   	rts			;go to the routine requested through rts mechanisim.
                        11116   
                        11117   
     7534   98          11118   def040	tya			;alter color at cursor position
     7535   85 8F       11119   	sta vtemp2
     7537   20 76AD     11120   	jsr colbyt		;get color byte
     753A   48          11121   	pha
     753B   AC 115E     11122   	ldy colcnt
     753E   AE 115F     11123   	ldx rowcnt
     7541   20 7762     11124   	jsr getvm		;video matrix address for row
     7544   68          11125   	pla
     7545   20 76DC     11126   	jsr setcol		;set new color
     7548   AC 115E     11127   	ldy colcnt
     754B   98          11128   	tya
     754C   29 07       11129   	and #7			;mask column number
     754E   AA          11130   	tax			;use as bit index
     754F   98          11131   	tya
     7550   4A          11132   	lsr a
     7551   4A          11133   	lsr a
     7552   4A          11134   	lsr a
     7553   18          11135   	clc
     7554   6D 115F     11136   	adc rowcnt		;get offset into sprite
     7557   6D 115F     11137   	adc rowcnt
     755A   6D 115F     11138   	adc rowcnt
     755D   A8          11139   	tay
     755E   B1 4B       11140   	lda (forpnt),y		;get sprite byte
     7560   2C 12FA     11141   	bit defmod
     7563   10 18       11142   	bpl def044
     7565   85 8E       11143   	sta vtemp1
     7567   BD 9D25     11144   	lda rbits,x
     756A   1D 9D26     11145   	ora rbits+1,x 		;masks 2 bits for multicolor sprite
     756D   48          11146   	pha
     756E   05 8E       11147   	ora vtemp1		;set 2 bits in sprite byte
     7570   85 8E       11148   	sta vtemp1
     7572   68          11149   	pla
     7573   A6 8F       11150   	ldx vtemp2
     7575   3D 9F2E     11151   	and colval,x 		;get inverse bits of colors
     7578   45 8E       11152   	eor vtemp1
     757A   4C 7587     11153   	jmp def046
                        11154   
     757D   1D 9D25     11155   def044	ora rbits,x		;set bits
     7580   06 8F       11156   	asl vtemp2
     7582   D0 03       11157   	bne def046
     7584   5D 9D25     11158   	eor rbits,x
                        11159   
     7587   91 4B       11160   def046	sta (forpnt),y		;save sprite byte
     7589   2C 12FA     11161   	bit defmod		;see if cursor should auto-advance
     758C   50 4E       11162   	bvc def110		;yes, go to advance right routine
     758E   4C 74F7     11163   	jmp dfloop		;jump to next command
                        11164   
                        11165   
                        11166   ;here for cancel
                        11167   
     7591   A0 3F       11168   def050	ldy #63	 		;copy back original sprite

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 139-4
SPRDEF Command   SPRDEF.SRC

Error Addr  Code          Seq   Source statement

                        11169   
     7593   B9 12B7     11170   10$	lda savram,y
     7596   91 4B       11171   	sta (forpnt),y
     7598   88          11172   	dey
     7599   10 F8       11173   	bpl 10$
                        11174   
     759B   A9 00       11175   def060	lda #0			;part of cancel, also used for return
     759D   8D D015     11176   	sta vic+21		;disable sprites
     75A0   4C 7461     11177   	jmp defbeg
                        11178   
                        11179   
                        11180   
     75A3   AD 12FA     11181   def070	lda defmod		;toggle multicolor
     75A6   49 80       11182   	eor #$80
     75A8   8D 12FA     11183   	sta defmod
     75AB   20 766E     11184   	jsr show_sprite
     75AE   AD 115E     11185   	lda colcnt		;make sure cursor is on an even loc'n
     75B1   29 FE       11186   	and #$fe
     75B3   8D 115E     11187   	sta colcnt
     75B6   A0 1C       11188   	ldy #28
     75B8   2C          11189   	.byte $2c
                        11190   
     75B9   A0 17       11191   def080	ldy #23			;toggle y expand
     75BB   2C          11192   	.byte $2c
                        11193   
     75BC   A0 1D       11194   def090	ldy #29			;toggle x expand
     75BE   B9 D000     11195   	lda vic,y
     75C1   AE 12FC     11196   	ldx sprite_number
     75C4   5D 6D50     11197   	eor sbits,x
     75C7   99 D000     11198   	sta vic,y
     75CA   4C 74F7     11199   	jmp dfloop
                        11200   
                        11201   
                        11202   
     75CD   A0 3F       11203   def100	ldy #63			;clear sprite def'n area
     75CF   A9 00       11204   	lda #0
                        11205   
     75D1   91 4B       11206   def102	sta (forpnt),y		;clear sprite
     75D3   88          11207   	dey
     75D4   10 FB       11208   	bpl def102
                        11209   
     75D6   20 7771     11210   	jsr def_clear
     75D9   4C 74EF     11211   	jmp dohome		;home cursor
                        11212   
                        11213   
                        11214   
     75DC   A9 01       11215   def110	lda #1			;move cursor right
     75DE   2C          11216   	.byte $2c
                        11217   
     75DF   A9 FF       11218   def120	lda #$ff		;move cursor left
     75E1   2C 12FA     11219   	bit defmod
     75E4   10 01       11220   	bpl 5$
     75E6   0A          11221   	asl a			;multiply by 2 if multicolor
     75E7   18          11222   5$	clc
     75E8   6D 115E     11223   	adc colcnt		;net result: adds for right, subtracts for left

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 139-5
SPRDEF Command   SPRDEF.SRC

Error Addr  Code          Seq   Source statement

     75EB   30 09       11224   	bmi 10$			;too far left
     75ED   C9 18       11225   	cmp #24
     75EF   B0 2D       11226   	bcs def160		;too far right. go to beginning of next line
     75F1   8D 115E     11227   	sta colcnt		;must be good. ship it.
     75F4   90 25       11228   	bcc def155		;always
                        11229   
     75F6   A2 17       11230   10$	ldx #23			;too far left. wrap to right of next line up.
     75F8   2C 12FA     11231   	bit defmod
     75FB   10 01       11232   	bpl 20$
     75FD   CA          11233   	dex			;..one less if multicolor
     75FE   8E 115E     11234   20$	stx colcnt
                        11235   
                        11236   ; fall thru to 'move cursor up'
                        11237   
     7601   A9 FF       11238   def140	lda #$ff		;move cursor up
     7603   2C          11239   	.byte $2c
     7604   A9 01       11240   def130	lda #1			;move cursor down
     7606   18          11241   	clc
     7607   6D 115F     11242   	adc rowcnt
     760A   C9 15       11243   	cmp #21
     760C   B0 0D       11244   	bcs def155
     760E   8D 115F     11245   	sta rowcnt
     7611   90 08       11246   	bcc def155		;always
                        11247   
                        11248   
                        11249   
     7613   AD 12FA     11250   def150	lda defmod		;toggle auto-advance
     7616   49 40       11251   	eor #$40
     7618   8D 12FA     11252   	sta defmod
     761B   4C 74F7     11253   def155	jmp dfloop
                        11254   
     761E   A9 00       11255   def160	lda #0			;return - move to beginning of next line
     7620   8D 115E     11256   	sta colcnt
     7623   F0 DF       11257   	beq def130		;jump to 'down 1 line' routine
                        11258   
                        11259   
                        11260   
                        11261   
     7625               11262   def_copy		;copy a sprite into the one being edited
                        11263   
                        11264   ;set up to query 'copy from?'
                        11265   
     7625   A0 02       11266   	ldy #2
     7627   A2 18       11267   	ldx #24
     7629   B9 76FE     11268   5$	lda copy_line-2,y
     762C   F0 06       11269   	beq 10$			;done when null is found
     762E   20 68F8     11270   	jsr chrdsp
     7631   C8          11271   	iny
     7632   D0 F5       11272   	bne 5$			;always
                        11273   
                        11274   ; get number of sprite to copy from user
                        11275   
     7634   20 A855     11276   10$	jsr put_io_in_map
     7637   20 FFE4     11277   20$	jsr _getin
     763A   F0 FB       11278   	beq 20$			;loop until a key is pressed

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 139-6
SPRDEF Command   SPRDEF.SRC

Error Addr  Code          Seq   Source statement

     763C   C9 0D       11279   	cmp #$0d
     763E   F0 1F       11280   	beq 50$			;abort if a <cr> is pressed
     7640   38          11281   	sec
     7641   E9 31       11282   	sbc #$31		;convert '1'..'8' to 0..7
     7643   C9 08       11283   	cmp #8
     7645   B0 F0       11284   	bcs 20$			;ignore if not in range
                        11285   
                        11286   ; convert sprite # to index, and copy it
                        11287   
     7647   4A          11288   	lsr a
     7648   6A          11289   	ror a
     7649   6A          11290   	ror a
     764A   85 8E       11291   	sta vtemp1
     764C   A0 0E       11292   	ldy #>sprite_base
     764E   90 01       11293   	bcc 30$
     7650   C8          11294   	iny
     7651   84 8F       11295   30$	sty vtemp1+1
                        11296   
     7653   A0 3F       11297   	ldy #63
     7655   B1 8E       11298   40$	lda (vtemp1),y
     7657   91 4B       11299   	sta (forpnt),y
     7659   88          11300   	dey
     765A   10 F9       11301   	bpl 40$
                        11302   
                        11303   ; display new sprite
                        11304   
     765C   20 766E     11305   	jsr show_sprite
                        11306   
                        11307   ; clear prompt from screen
                        11308   
     765F   A9 00       11309   50$	lda #0
     7661   A8          11310   	tay
     7662   99 3E00     11311   60$	sta $3e00,y		;318018-02 patch (leaves IO in the map!)
     7665   88          11312   	dey
     7666   D0 FA       11313   	bne 60$
     7668   4C 74F7     11314   	jmp dfloop
                        11315   
     766B   FF FF FF    11316   	.byte $ff,$ff,$ff	;place holder
                        11317   
                        11318   
                        11319   ;*****************************************************************
                        11320   ;
                        11321   ;  show sprite in definition area
                        11322   ;
                        11323   ;*****************************************************************
                        11324   
     766E               11325   show_sprite
                        11326   
     766E   A2 00       11327   	ldx #0
     7670   8E 1160     11328   	stx strcnt		;init count of sprite bytes
                        11329   
     7673   8E 12FB     11330   10$	stx lincnt		;save pointer to area row
     7676   20 7762     11331   	jsr getvm		;get address to video matrix
     7679   A0 00       11332   	ldy #0			;init column count of area to 0
     767B   A2 08       11333   20$	ldx #8			;count of bits in sprite byte

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 139-7
SPRDEF Command   SPRDEF.SRC

Error Addr  Code          Seq   Source statement

     767D   8C 116E     11334   	sty numcnt		;save column number of area
     7680   AC 1160     11335   	ldy strcnt
     7683   B1 4B       11336   	lda (forpnt),y		;get next sprite byte
     7685   EE 1160     11337   	inc strcnt
     7688   AC 116E     11338   	ldy numcnt		;get column count
                        11339   
     768B   0A          11340   30$	asl a
     768C   2C 12FA     11341   	bit defmod
     768F   10 02       11342   	bpl 40$			;skip if not multicolor
     7691   2A          11343   	rol a
     7692   CA          11344   	dex
     7693   48          11345   40$	pha			;save shifted sprite byte
     7694   2A          11346   	rol a			;shift to get color selection
     7695   20 76AD     11347   	jsr colbyt		;get color byte
     7698   20 76DC     11348   	jsr setcol		;save into video matrix
     769B   C8          11349   	iny
     769C   68          11350   	pla			;get sprite byte
     769D   CA          11351   	dex
     769E   D0 EB       11352   	bne 30$			;more bits left
     76A0   C0 18       11353   	cpy #24
     76A2   90 D7       11354   	bcc 20$			;not done with row
     76A4   AE 12FB     11355   	ldx lincnt
     76A7   E8          11356   	inx			;point to next row
     76A8   E0 15       11357   	cpx #21
     76AA   90 C7       11358   	bcc 10$			;loop for next row
     76AC   60          11359   	rts
                        11360   
                        11361   
                        11362   ;*******************************************************************
                        11363   ;
                        11364   ;  colbyt  --  get byte = color / color  --  a = color selection
                        11365   ;
                        11366   ;*******************************************************************
                        11367   
     76AD   29 03       11368   colbyt	and #03
     76AF   4A          11369   	lsr a
     76B0   6A          11370   	ror a
     76B1   F0 0F       11371   	beq 10$			;skip if 0/2 selected
     76B3   2C 12FA     11372   	bit defmod
     76B6   10 0F       11373   	bpl 20$			;skip if not multicolor mode
     76B8   AD D025     11374   	lda vic+37		;get multicolor-1
     76BB   90 14       11375   	bcc colbyt_1			;skip if that is it
     76BD   AD D026     11376   	lda vic+38		;get multicolor-2
     76C0   B0 0F       11377   	bcs colbyt_1			;...always
                        11378   
     76C2   AD D021     11379   10$	lda vic+33		;get background color
     76C5   90 0A       11380   	bcc colbyt_1			;have it
                        11381   
     76C7   86 8E       11382   20$	stx vtemp1
     76C9   AE 12FC     11383   	ldx sprite_number
     76CC   BD D027     11384   	lda vic+39,x 		;get sprite foreground color
     76CF   A6 8E       11385   	ldx vtemp1
                        11386   
     76D1               11387   colbyt_1
     76D1   29 0F       11388   	and #$0f		;(subroutine entry)

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 139-8
SPRDEF Command   SPRDEF.SRC

Error Addr  Code          Seq   Source statement

     76D3   85 8E       11389   	sta vtemp1
     76D5   0A          11390   	asl a
     76D6   0A          11391   	asl a
     76D7   0A          11392   	asl a
     76D8   0A          11393   	asl a
     76D9   05 8E       11394   	ora vtemp1		;make both nibbles same color
     76DB   60          11395   	rts
                        11396   
                        11397   
                        11398   
     76DC   91 8C       11399   setcol	sta (grapnt),y		;put color into video matrix
     76DE   2C 12FA     11400   	bit defmod
     76E1   10 03       11401   	bpl 10$
     76E3   C8          11402   	iny
     76E4   91 8C       11403   	sta (grapnt),y		;again if multicolor
     76E6   60          11404   10$	rts
                        11405   
     76E7   AE 115F     11406   togcur	ldx rowcnt
     76EA   20 7762     11407   	jsr getvm		;get video matrix pointer
     76ED   AC 115E     11408   	ldy colcnt
     76F0   2C 12FA     11409   	bit defmod
     76F3   10 03       11410   	bpl makcr1		;do once for non-multicolor
     76F5   20 76F8     11411   	jsr makcr1
                        11412   
     76F8   B1 8C       11413   makcr1	lda (grapnt),y
     76FA   49 80       11414   	eor #$80
     76FC   91 8C       11415   	sta (grapnt),y
     76FE   C8          11416   	iny
     76FF   60          11417   	rts
                        11418   
     7700               11419   copy_line
     7700   43 4F 50    11420   	.byte 'COPY FROM?',0
     7703   59 20 46            
     7706   52 4F 4D            
     7709   3F 00               
                        11421   
     770B   53 50 52    11422   stline	.byte 'SPRITE NUMBER?  ',0
     770E   49 54 45            
     7711   20 4E 55            
     7714   4D 42 45            
     7717   52 3F 20            
     771A   20 00               
                        11423   
     771C               11424   cmdstr		;letter-commands
     771C   31 32 33    11425   	.byte '1234',$03,$8d,'XY'	:1,2,3,4,cancel,return,x,y
     771F   34 03 8D            
     7722   58 59               
     7724   4D 9D 1D    11426   	.byte 'M',$9d,$1d,$91,$11	;multicolor,left,right,up,down
     7727   91 11               
     7729   93 13 41    11427   	.byte $93,$13,'A',cr,'C'	;clear screen,home,auto,copy
     772C   0D 43               
     772E               11428   cmdend
                        11429   
     772E               11430   defjmp 	;table of addresses of each sprdef command
     772E   7533 7533   11431   	.dbyte def040-1,def040-1,def040-1,def040-1 ;colors 1,3,2,4

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 139-9
SPRDEF Command   SPRDEF.SRC

Error Addr  Code          Seq   Source statement

     7732   7533 7533           
     7736   7590 759A   11432   	.dbyte def050-1,def060-1 	;cancel, shifted return
     773A   75BB 75B8   11433   	.dbyte def090-1,def080-1,def070-1 ;x,y expand, multicolor toggle
     773E   75A2                
     7740   75DE 75DB   11434   	.dbyte def120-1,def110-1 	;left, right move
     7744   7600 7603   11435   	.dbyte def140-1,def130-1 	;up,down move
     7748   75CC 74EE   11436   	.dbyte def100-1,dohome-1 	;clear screen, home cursor
     774C   7612 761D   11437   	.dbyte def150-1,def160-1 	;toggle auto-advance, return
     7750   7624        11438   	.dbyte def_copy-1		;copy another sprite
                        11439   
                        11440   
                        11441   ;  valid ascii codes for colors
                        11442   ;
     7752   90 05 1C    11443   colnum	.byte $90,$05,$1c,$9f		;black   - white    - red     - cyan
     7755   9F                  
     7756   9C 1E 1F    11444   	.byte $9c,$1e,$1f,$9e		;purple  - green    - blue    - yellow
     7759   9E                  
     775A   81 95 96    11445   	.byte $81,$95,$96,$97		;orange  - brown    - lt red  - dk grey
     775D   97                  
     775E   98 99 9A    11446   	.byte $98,$99,$9a,$9b		;m. grey - lt green - lt blue - lt grey
     7761   9B                  
     7762               11447   colend

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 140
SPRDEF Command   SPRDEF.SRC

Error Addr  Code          Seq   Source statement

                        11449   
     7762   BD C033     11450   getvm	lda _ldtb2,x
     7765   85 8C       11451   	sta grapnt
     7767   BD C04C     11452   	lda _ldtb1,x
     776A   29 03       11453   	and #3
     776C   09 1C       11454   	ora #>color_ram_lo
     776E   85 8D       11455   	sta grapnt+1
     7770   60          11456   	rts
                        11457   
                        11458   
     7771               11459   def_clear			;clear sprite def'n area
     7771   AD D021     11460   	lda vic+33
     7774   20 76D1     11461   	jsr colbyt_1		;make both nybbles = bgnd
     7777   A2 14       11462   	ldx #20	 		;init bottom row of def'n area
                        11463   
     7779   48          11464   10$	pha
     777A   20 7762     11465   	jsr getvm
     777D   68          11466   	pla
     777E   A0 17       11467   	ldy #23
                        11468   
     7780   91 8C       11469   20$	sta (grapnt),y		;clear 1 line of def'n area
     7782   88          11470   	dey
     7783   10 FB       11471   	bpl 20$
     7785   CA          11472   	dex
     7786   10 F1       11473   	bpl 10$
     7788   60          11474   	rts
                        11475   
                        11476   ;end
                        11477   	.include sprsav		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 141
SPRSAV Command   SPRSAV.SRC

Error Addr  Code          Seq   Source statement

                        11479   	.subttl SPRSAV Command
                        11480   
                        11481   ;***************************************************************
                        11482   ;
                        11483   ;  sprsav ( n1 / s1$ ) , ( n2 / s2$ )
                        11484   ;   - move string(s1) or sprite(n1) to string(s2) or sprite(n2)
                        11485   ;               n1 & n2 = a sprite number (1-8)
                        11486   ;                   s1$ = a string variable or expression
                        11487   ;                   s2$ = a string variable
                        11488   ;
                        11489   ;***************************************************************
                        11490   
     7789   20 7819     11491   sprsav	jsr savinp      		;evaluate 1st expression
     778C   B0 2F       11492   	bcs 20$				;skip if source is a string
     778E   85 4B       11493   	sta forpnt
     7790   84 4C       11494   	sty forpnt+1    		;save sprite address
     7792   A0 3E       11495   	ldy #62
                        11496   
     7794   B1 4B       11497   10$	lda (forpnt),y			;move sprite def to save area
     7796   99 12B7     11498   	sta savram,y
     7799   88          11499   	dey
     779A   10 F8       11500   	bpl 10$
                        11501   
     779C   C8          11502   	iny
     779D   8C 12F7     11503   	sty savram+64   		;save sprite column length
     77A0   8C 12F9     11504   	sty savram+66   		;save sprite row length
     77A3   A9 17       11505   	lda #23
     77A5   8D 12F6     11506   	sta savram+63
     77A8   A9 14       11507   	lda #20
     77AA   8D 12F8     11508   	sta savram+65
     77AD   A2 B7       11509   	ldx #<savram    		;set ptr to start of sprite def
     77AF   A0 12       11510   	ldy #>savram
     77B1   86 70       11511   	stx strng1			;**
     77B3   84 71       11512   	sty strng1+1			;**
                        11513   
     77B5   A9 43       11514   	lda #67         		;set sprite length including lengths
     77B7   20 86CC     11515   	jsr strlit_1			;**get string space, copy savram to it
     77BA   20 7836     11516   	jsr desc_free			;**free up temp descriptor
                        11517   
     77BD   8E 03DB     11518   20$	stx savsiz      		;save source length
     77C0   8D 03DC     11519   	sta savsiz+1
     77C3   8C 03DD     11520   	sty savsiz+2    		;save source start address
                        11521   
     77C6   20 79F9     11522   	jsr chkcom      		;check for a comma
                        11523   
     77C9   A5 3D       11524   	lda txtptr      		;save basic text pointer
     77CB   8D 03E0     11525   	sta sprtmp_1
     77CE   A5 3E       11526   	lda txtptr+1
     77D0   8D 03E1     11527   	sta sprtmp_2
     77D3   20 7819     11528   	jsr savinp      		;get next destination parameter
     77D6   B0 25       11529   	bcs savs50      		;skip if string
                        11530   
     77D8   85 8C       11531   	sta grapnt
     77DA   84 8D       11532   	sty grapnt+1    		;save sprite address
     77DC   AD 03DC     11533   	lda savsiz+1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 141-1
SPRSAV Command   SPRSAV.SRC

Error Addr  Code          Seq   Source statement

     77DF   85 4B       11534   	sta forpnt      		;get source address
     77E1   AD 03DD     11535   	lda savsiz+2
     77E4   85 4C       11536   	sta forpnt+1
     77E6   A0 00       11537   	ldy #0
     77E8   CC 03DB     11538   40$	cpy savsiz      		;test index vs source length
     77EB   F0 0F       11539   	beq 45$				;exit if source depleted
     77ED   A9 4B       11540   	lda #forpnt			;move source byte to sprite
     77EF   20 03AB     11541   	jsr indsub_ram1			; (from ram bank 1)
     77F2   8D FF03     11542   	sta sw_rom_ram0
     77F5   91 8C       11543   	sta (grapnt),y
     77F7   C8          11544   	iny
     77F8   C0 3F       11545   	cpy #63
     77FA   D0 EC       11546   	bne 40$
     77FC   60          11547   45$	rts
                        11548   
                        11549   
     77FD   AD 03E0     11550   savs50	lda sprtmp_1			;restore basic text pointer
     7800   85 3D       11551   	sta txtptr
     7802   AD 03E1     11552   	lda sprtmp_2
     7805   85 3E       11553   	sta txtptr+1
     7807   20 7B4C     11554   	jsr ptrget      		;get symbol table descriptor for string dest.
     780A   85 4B       11555   	sta forpnt
     780C   84 4C       11556   	sty forpnt+1    		;save symbol table address
     780E   A9 DB       11557   	lda #<savsiz
     7810   85 66       11558   	sta facmo       		;save descriptor address of source
     7812   A9 03       11559   	lda #>savsiz
     7814   85 67       11560   	sta facmo+1
     7816   4C 5422     11561   	jmp inpcom      		;move source to dest, do rts (snerr if not eol)
                        11562   
                        11563   
     7819   20 788C     11564   savinp	jsr frmevl      		;evaluate expression
     781C   24 0F       11565   	bit valtyp
     781E   30 16       11566   	bmi desc_free			;exit if a string variable
     7820   20 87F7     11567   	jsr conint			;get one byte integer in .X
     7823   CA          11568   	dex				;adjust sprite 1..8 to 0..7
     7824   E0 08       11569   	cpx #8
     7826   B0 0B       11570   	bcs 20$				;bad value
     7828   8A          11571   	txa				;move sprite number to .A
     7829   4A          11572   	lsr a
     782A   6A          11573   	ror a
     782B   6A          11574   	ror a           		;get sprite address
     782C   A0 0E       11575   	ldy #>sprite_base
     782E   90 01       11576   	bcc 5$
     7830   C8          11577   	iny
     7831   18          11578   5$	clc             		;flag 'sprite'
     7832   60          11579   	rts
                        11580   
     7833   4C 7DC5     11581   20$	jmp fcerr
                        11582   
     7836               11583   desc_free				;free up temporary descriptor,
                        11584   					;set up pointers to string.
     7836   A5 66       11585   	lda facmo			;get address of temp descriptor
     7838   A4 67       11586   	ldy facmo+1
     783A   20 87E0     11587   	jsr fretms
                        11588   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 141-2
SPRSAV Command   SPRSAV.SRC

Error Addr  Code          Seq   Source statement

     783D   A0 00       11589   	ldy #0				;get len, addr of string
     783F   20 4304     11590   	jsr indfmo
     7842   AA          11591   	tax
     7843   C8          11592   	iny
     7844   20 4304     11593   	jsr indfmo
     7847   48          11594   	pha
     7848   C8          11595   	iny
     7849   20 4304     11596   	jsr indfmo
     784C   A8          11597   	tay
     784D   68          11598   	pla
     784E   38          11599   	sec				;flag 'string found'
     784F   60          11600   	rts				;return w/ x=len, (a,y)==> string
                        11601   ;end
                        11602   	.include fast		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 142
FAST Command   FAST.SRC

Error Addr  Code          Seq   Source statement

                        11604   	.subttl FAST Command
                        11605   
                        11606   ;***********************************************************************
                        11607   ;
                        11608   ;    FAST - put the system in 2 MHz. mode, and blank the VIC screen
                        11609   ;
                        11610   ;***********************************************************************
                        11611   
     7850   20 A855     11612   fast	jsr put_io_in_map
                        11613   
     7853   AD D011     11614   	lda vic+17		;blank the 40 column screen
     7856   29 6F       11615   	and #$6f
     7858   8D D011     11616   	sta vic+17
                        11617   
     785B   A9 01       11618   	lda #1
     785D   8D D030     11619   	sta vic+48		;set 2 MHz. mode
                        11620   
     7860   60          11621   	rts
                        11622   ;end
                        11623   	.include slow		;command

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 143
SLOW Command   SLOW.SRC

Error Addr  Code          Seq   Source statement

                        11625   	.subttl SLOW Command
                        11626   
                        11627   ;***********************************************************************
                        11628   ;
                        11629   ;    SLOW - put the system in 1 MHz. mode, and un-blank the VIC screen
                        11630   ;
                        11631   ;***********************************************************************
                        11632   
     7861   20 A855     11633   slow	jsr put_io_in_map
                        11634   
     7864   A9 00       11635   	lda #0
     7866   8D D030     11636   	sta vic+48		;slow down there, lil' processor!
                        11637   
     7869   AD D011     11638   	lda vic+17		;enable screen
     786C   29 7F       11639   	and #$7f
     786E   09 10       11640   	ora #$10
     7870   8D D011     11641   	sta vic+17
                        11642   
     7873   60          11643   	rts
                        11644   ;end
                        11645   	.include checkval

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 144
form/check value types   CHECKVAL.SRC

Error Addr  Code          Seq   Source statement

                        11647   	.subttl form/check value types
                        11648   ;
                        11649   ; these routines check for certain "valtyp".
                        11650   ; (c) is not preserved.
                        11651   ;
                        11652   
                        11653   
     7874   20 788C     11654   frmnum	jsr frmevl
                        11655   
     7877   18          11656   chknum	clc
     7878   90 01       11657   	bcc chkval
                        11658   
     787A   38          11659   chkstr	sec		;set carry.
                        11660   
     787B   24 0F       11661   chkval	bit valtyp	
     787D   30 03       11662   	bmi docstr
     787F   B0 03       11663   	bcs chkerr
     7881   60          11664   chkok	rts
                        11665   
     7882   B0 FD       11666   docstr	bcs chkok
     7884   A2 16       11667   chkerr	ldx #errtm
     7886   2C          11668   	.byte $2c
     7887   A2 19       11669   sterr	ldx #errst
     7889   4C 4D59     11670   	jmp error
                        11671   
                        11672   ;.end
                        11673   
                        11674   	.include formeval

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 145
formula evaluator   FORMEVAL.SRC

Error Addr  Code          Seq   Source statement

                        11676   	.subttl formula evaluator
                        11677   ; 
                        11678   ; formula evaluator routine
                        11679   ; 
                        11680   ; the formula evaluator starts with (txtptr) pointing to the first character
                        11681   ; in the formula. at the end (txtptr) points to the terminator.
                        11682   ; the result is left in the fac. on return (a) does not reflect the terminator.
                        11683   ; 
                        11684   ; the formula evaluator uses the operator (optab) to determine precedence and
                        11685   ; dispatch addresses for each operator.
                        11686   ; a temporary result on the stack has the following format.
                        11687   ;
                        11688   ;     the address of the operator routine.
                        11689   ;     the floating point temporary result.
                        11690   ;     the precedence of the operator.
                        11691   ; 
                        11692   
                        11693   
     788C   A6 3D       11694   frmevl	ldx txtptr		;txtptr points to 1st char. in formula
     788E   D0 02       11695   	bne 1$
     7890   C6 3E       11696   	dec txtptr+1
     7892   C6 3D       11697   1$	dec txtptr
     7894   A2 00       11698   	ldx #0	   		;dummy precedence = 0
     7896   24          11699   	.byte $24
     7897   48          11700   lpoper	pha			;save precedence
     7898   8A          11701   	txa
     7899   48          11702   	pha
                        11703   
     789A   BA          11704   	tsx			;confirm enough system stack available (recursive calls)
     789B   E0 63       11705   	cpx #<sysstk+44		;bottom of stack + room for error handling
     789D   90 E8       11706   	bcc sterr		;formula too complex
     789F   20 7974     11707   	jsr eval
     78A2   A9 00       11708   	lda #0
     78A4   85 4F       11709   	sta opmask
     78A6               11710   tstop
     78A6   20 0386     11711   	jsr chrgot		;last char
     78A9               11712   loprel
     78A9   38          11713   	sec			;prepare to subtract.
     78AA   E9 B1       11714   	sbc #greatk		;is current character a relation?
     78AC   90 17       11715   	bcc endrel		;no, relations all through.
     78AE   C9 03       11716   	cmp #lesstk-greatk+1	;really relational?
     78B0   B0 13       11717   	bcs endrel		;no, just big.
     78B2   C9 01       11718   	cmp #1			;reset carry for zero only.
     78B4   2A          11719   	rol a			;0 to 1, 1 to 2, 2 to 4.
     78B5   49 01       11720   	eor #1
     78B7   45 4F       11721   	eor opmask		;bring in the old bits.
     78B9   C5 4F       11722   	cmp opmask		;make sure that the new mask is bigger. 
     78BB   90 61       11723   	bcc snerr5		;syntax error, because two of the same.
     78BD   85 4F       11724   	sta opmask		;save mask.
     78BF   20 0380     11725   	jsr chrget
     78C2   4C 78A9     11726   	jmp loprel		;get the next candidate.
     78C5               11727   endrel
     78C5   A6 4F       11728   	ldx opmask		;were there any?
     78C7   D0 2C       11729   	bne finrel		;yes, handle as special op.
     78C9   B0 7E       11730   	bcs qop			;not an operator.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 145-1
formula evaluator   FORMEVAL.SRC

Error Addr  Code          Seq   Source statement

     78CB   69 07       11731   	adc #greatk-plustk
     78CD   90 7A       11732   	bcc qop			;not an operator.
     78CF   65 0F       11733   	adc valtyp		;(c)=1.
     78D1   D0 03       11734   	bne *+5
     78D3   4C 870D     11735   	jmp cat			;only if (a)=0 and (valtyp)=-1 (a str).
                        11736   
     78D6   69 FF       11737   	adc #$ff		;get back original (a).
     78D8   85 24       11738   	sta index1
     78DA   0A          11739   	asl a			;multiply by two.
     78DB   65 24       11740   	adc index1		;by three.
     78DD   A8          11741   	tay			;set up for later.
     78DE               11742   qprec
     78DE   68          11743   	pla			;get previous precedence.
     78DF   D9 4845     11744   	cmp optab,y		;is old precedence greater or equal?
     78E2   B0 6A       11745   	bcs qchnum		;yes, go operate.
     78E4   20 7877     11746   	jsr chknum		;can't be string here.
     78E7               11747   doprec
     78E7   48          11748   	pha			;save old precedence.
     78E8               11749   negprc
     78E8   20 790E     11750   	jsr dopre1		;save a return for op.
     78EB   68          11751   	pla			;pull off previous precedence.
     78EC   A4 4D       11752   	ldy opptr		;get pointer to op.
     78EE   10 17       11753   	bpl qprec1		;that' a real operator.
     78F0   AA          11754   	tax			;done?
     78F1   F0 59       11755   	beq qopgo		;done!
     78F3   D0 62       11756   	bne pulstk
     78F5               11757   finrel
     78F5   46 0F       11758   	lsr valtyp		;get value type into "c".
     78F7   8A          11759   	txa
     78F8   2A          11760   	rol a			;put valtyp into low order bit of mask.
     78F9   A6 3D       11761   	ldx txtptr		;decrement text pointer.
     78FB   D0 02       11762   	bne finre2
     78FD   C6 3E       11763   	dec txtptr+1
     78FF               11764   finre2
     78FF   C6 3D       11765   	dec txtptr
     7901   A0 1B       11766   	ldy #ptdorl-optab	;make (yreg) point at operator entry.
     7903   85 4F       11767   	sta opmask		;save the operation mask.
     7905   D0 D7       11768   	bne qprec		;branch always
                        11769   
     7907               11770   qprec1				;note b7(valtyp)=0 so chknum call is ok.
     7907   D9 4845     11771   	cmp optab,y		;last precedence is greater?
     790A   B0 4B       11772   	bcs pulstk		;yes, go operate.
     790C   90 D9       11773   	bcc doprec		;no, save argument and get other operand.
     790E               11774   dopre1
     790E   B9 4847     11775   	lda optab+2,y	
     7911   48          11776   	pha			;disp addr goes on stack.
     7912   B9 4846     11777   	lda optab+1,y
     7915   48          11778   	pha
     7916   20 7921     11779   	jsr pushf1		;save fac on stack unpacked.
     7919   A5 4F       11780   	lda opmask		;(acca) may be mask for rel.
     791B   4C 7897     11781   	jmp lpoper
                        11782   
     791E               11783   snerr5
     791E   4C 7A09     11784   	jmp snerr		;go to an error.
                        11785   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 145-2
formula evaluator   FORMEVAL.SRC

Error Addr  Code          Seq   Source statement

     7921               11786   pushf1
     7921   A5 68       11787   	lda facsgn		;save fac on stack unpacked
     7923   BE 4845     11788   	ldx optab,y		;precedence
     7926   A8          11789   	tay
     7927   18          11790   	clc
     7928   68          11791   	pla			;pointer into stack
     7929   69 01       11792   	adc #1
     792B   85 24       11793   	sta index1
     792D   68          11794   	pla
     792E   69 00       11795   	adc #0
     7930   85 25       11796   	sta index1+1
     7932   98          11797   	tya
     7933   48          11798   	pha
     7934   20 8C47     11799   	jsr round		;put rounded fac on stack
     7937   A5 67       11800   	lda faclo
     7939   48          11801   	pha
     793A   A5 66       11802   	lda facmo
     793C   48          11803   	pha
     793D   A5 65       11804   	lda facmoh
     793F   48          11805   	pha
     7940   A5 64       11806   	lda facho
     7942   48          11807   	pha
     7943   A5 63       11808   	lda facexp
     7945   48          11809   	pha
     7946   6C 0024     11810   	jmp (index1)		;return
                        11811   
     7949               11812   qop
     7949   A0 FF       11813   	ldy #255
     794B   68          11814   	pla			;get high precedence of last op.
     794C               11815   qopgo
     794C   F0 23       11816   	beq qoprts		;done!
     794E               11817   qchnum
     794E   C9 64       11818   	cmp #100		;relational operator?
     7950   F0 03       11819   	beq unpstk		;yes, don't check operand.
     7952   20 7877     11820   	jsr chknum		;must be number
     7955               11821   unpstk
     7955   84 4D       11822   	sty opptr		;save operator's pointer fro next time.
     7957               11823   pulstk
     7957   68          11824   	pla			;get mask for rel. op. if it is one
     7958   4A          11825   	lsr a	    		;setup c for dorel's chkval
     7959   85 14       11826   	sta domask		;save for "docmp".
     795B   68          11827   	pla			;unpack stack into arg
     795C   85 6A       11828   	sta argexp
     795E   68          11829   	pla
     795F   85 6B       11830   	sta argho
     7961   68          11831   	pla
     7962   85 6C       11832   	sta argmoh
     7964   68          11833   	pla
     7965   85 6D       11834   	sta argmo
     7967   68          11835   	pla
     7968   85 6E       11836   	sta arglo
     796A   68          11837   	pla
     796B   85 6F       11838   	sta argsgn
     796D   45 68       11839   	eor facsgn		;get probable result sign.
     796F   85 70       11840   	sta arisgn		;sign used by add, sub, mul, div

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 145-3
formula evaluator   FORMEVAL.SRC

Error Addr  Code          Seq   Source statement

     7971               11841   qoprts
     7971   A5 63       11842   	lda facexp		;get it and set codes.
     7973   60          11843   	rts			;return

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 146
formula evaluator   FORMEVAL.SRC

Error Addr  Code          Seq   Source statement

     7974               11845   eval
     7974   6C 030A     11846   	jmp (ieval)
     7977               11847   neval
     7977   A9 00       11848   	lda #0
     7979   85 0F       11849   	sta valtyp		;assume numeric
     797B               11850   eval0
     797B   20 0380     11851   	jsr chrget		;get a character
     797E   B0 05       11852   	bcs eval2
     7980               11853   eval1
     7980   A2 00       11854   	ldx #0			;flag 'bank 0' (text bank)
     7982   4C 8D22     11855   	jmp fin	  		;it is a number
     7985               11856   eval2
     7985   20 7BD9     11857   	jsr isletc		;variable name?
     7988   90 03       11858   	bcc *+5
     798A   4C 7A15     11859   	jmp is_variable		;yes.
     798D   C9 FF       11860   	cmp #pi	  		;pi?
     798F   D0 0F       11861   	bne qdot
     7991   A9 9B       11862   	lda #<pival
     7993   A0 79       11863   	ldy #>pival
     7995   20 8BD4     11864   	jsr movfm		;put value in for p1.
     7998   4C 0380     11865   	jmp chrget
     799B               11866   pival
     799B   82 49 0F    11867   	.byte @202,@111,@017,@332,@241
     799E   DA A1               
                        11868   
     79A0               11869   qdot
     79A0   C9 2E       11870   	cmp #'.'		;constant?
     79A2   F0 DC       11871   	beq eval1
     79A4   C9 AB       11872   	cmp #minutk		;negation?
     79A6   F0 66       11873   	beq domin		;yes.
     79A8   C9 AA       11874   	cmp #plustk
     79AA   F0 CF       11875   	beq eval0
     79AC   C9 22       11876   	cmp #'"'		;string?
     79AE   D0 15       11877   	bne eval3
     79B0               11878   strtxt
     79B0   A5 3D       11879   	lda txtptr
     79B2   A4 3E       11880   	ldy txtptr+1
     79B4   69 00       11881   	adc #0	   		;c=1
     79B6   90 01       11882   	bcc strtx2
     79B8   C8          11883   	iny
     79B9   20 869A     11884   strtx2	jsr strlit		;process string
                        11885   
     79BC   A6 72       11886   st2txt	ldx strng2
     79BE   A4 73       11887   	ldy strng2+1
     79C0   86 3D       11888   	stx txtptr
     79C2   84 3E       11889   	sty txtptr+1
     79C4   60          11890   	rts
                        11891   
     79C5               11892   eval3
     79C5   C9 A8       11893   	cmp #nottk		;not?
     79C7   D0 16       11894   	bne eval4
     79C9   A0 18       11895   	ldy #24
     79CB   D0 43       11896   	bne gonprc		;branch always
                        11897   
     79CD               11898   notop

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 146-1
formula evaluator   FORMEVAL.SRC

Error Addr  Code          Seq   Source statement

     79CD   20 84B4     11899   	jsr ayint		;integerize
     79D0   A5 67       11900   	lda faclo		;get argument
     79D2   49 FF       11901   	eor #$ff
     79D4   A8          11902   	tay
     79D5   A5 66       11903   	lda facmo
     79D7   49 FF       11904   	eor #$ff
     79D9               11905   givayf
     79D9   20 84E5     11906   	jsr stoint		;integer to float routine
     79DC   4C 8C70     11907   	jmp floats
     79DF               11908   eval4
     79DF   C9 A5       11909   	cmp #fntk		;user defined function?
     79E1   D0 03       11910   	bne *+5
     79E3   4C 853B     11911   	jmp fndoer
                        11912   
     79E6   C9 B4       11913   	cmp #onefun		;function name?
     79E8   90 03       11914   	bcc parchk		;functions are the highest numbered.
     79EA   4C 4C14     11915   	jmp isfun		;characters so no need to check.
                        11916   
     79ED               11917   parchk
     79ED   20 79F6     11918   	jsr chkopn		;only thing left is formula in parens
     79F0   20 788C     11919   	jsr frmevl		;a formula in parens
     79F3               11920   chkcls
     79F3   A9 29       11921   	lda #')'		;close paren?
     79F5   2C          11922   	.byte   $2c
     79F6               11923   chkopn
     79F6   A9 28       11924   	lda #'('		;open paren?
     79F8   2C          11925   	.byte $2c
     79F9               11926   chkcom
     79F9   A9 2C       11927   	lda #','		;comma?
                        11928   				;
                        11929   				;synchr routine
                        11930   				;
                        11931   			;"synchr" looks at the current character to make sure 
                        11932   			;it is the specific thing loaded into acca just before
                        11933   			;the call to "synchr", if not, it calls the "syntax
                        11934   			;error" routine. otherwise it gobbles the next char
                        11935   			;and returns.
                        11936   			;
                        11937   			; (a)=new char and txtptr is advanced by"chrget".
                        11938   			;
     79FB               11939   synchr
     79FB   A0 00       11940   	ldy #0
     79FD   85 79       11941   	sta syntmp
     79FF   20 03C9     11942   	jsr indtxt
     7A02   C5 79       11943   	cmp syntmp
     7A04   D0 03       11944   	bne snerr
     7A06   4C 0380     11945   	jmp chrget		;ok
                        11946   
     7A09               11947   snerr
     7A09   A2 0B       11948   	ldx #errsn		;'syntax error'
     7A0B   4C 4D59     11949   	jmp error
                        11950   
            =0015       11951   negoff	=negtab-optab
                        11952   
     7A0E               11953   domin

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 146-2
formula evaluator   FORMEVAL.SRC

Error Addr  Code          Seq   Source statement

     7A0E   A0 15       11954   	ldy #negoff		;precedence below '-'
     7A10               11955   gonprc
     7A10   68          11956   	pla			;get rid of rts addr.
     7A11   68          11957   	pla
     7A12   4C 78E8     11958   	jmp negprc		;do negation
                        11959   ;end
                        11960   	.include variables

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 147
Variable Assignment   VARIABLES.SRC

Error Addr  Code          Seq   Source statement

                        11962   	.subttl Variable Assignment
                        11963   
     7A15               11964   is_variable
     7A15   20 7B4C     11965   	jsr ptrget	;parse variable name, put name in varnam
                        11966   
     7A18   85 66       11967   isvret	sta facmo	;save pointer to variable
     7A1A   84 67       11968   	sty facmo+1
     7A1C   A6 47       11969   	ldx varnam
     7A1E   A4 48       11970   	ldy varnam+1
     7A20   A5 0F       11971   	lda valtyp	;test if numeric or string
     7A22   F0 63       11972   	beq is_numeric	;branch if numeric
     7A24   A9 00       11973   	lda #0
     7A26   85 71       11974   	sta facov
     7A28   E0 54       11975   	cpx #'T'	;'ti$' is a special case. look for it.
     7A2A   D0 25       11976   	bne isvds	;go test for ds$
     7A2C   C0 C9       11977   	cpy #$c9	;shifted 'i'
     7A2E   D0 20       11978   	bne strrts_1
                        11979   
                        11980   ; variable name is 'ti$'. to see if this is 'the' ti$, and not an
                        11981   ; array ti$(), test to see if it has a pointer to the zero in rom.
                        11982   ; if it is an array item, it's pointer will be to a real value, or
                        11983   ; a real zero. if it isn't an array item, it's pointer will point
                        11984   ; to a dummy zero in rom.
                        11985   ;
     7A30   A5 66       11986   	lda facmo
     7A32   C9 D2       11987   	cmp #<zero
     7A34   D0 1A       11988   	bne strrts_1	;not ti$
     7A36   A5 67       11989   	lda facmo+1
     7A38   C9 03       11990   	cmp #>zero
     7A3A   D0 14       11991   	bne strrts_1	;not ti$
                        11992   
     7A3C   20 7AB7     11993   	jsr gettim	;it is ti$, create a string.
     7A3F   84 60       11994   	sty tenexp	;y=0.
     7A41   88          11995   	dey
     7A42   84 72       11996   	sty fbufpt
     7A44   A0 06       11997   	ldy #6		;six digits to print.
     7A46   84 5F       11998   	sty deccnt
     7A48   A0 24       11999   	ldy #fdcend-foutbl
     7A4A   20 8ECD     12000   	jsr foutim	;convert to ascii.
     7A4D   4C 85B8     12001   	jmp timstr
                        12002   
     7A50   60          12003   strrts_1 rts
                        12004   
     7A51   E0 44       12005   isvds	cpx #'D'	;is this ds$?
     7A53   D0 FB       12006   	bne strrts_1
     7A55   C0 D3       12007   	cpy #$d3	;'s'+$80
     7A57   D0 F7       12008   	bne strrts_1
     7A59   20 7A80     12009   	jsr chkds
     7A5C   A0 FF       12010   	ldy #$ff
                        12011   
     7A5E   C8          12012   10$	iny			;copy ds string to a temp. first get length
     7A5F   A9 7B       12013   	lda #dsdesc+1
     7A61   20 03AB     12014   	jsr indsub_ram1
     7A64   C9 00       12015   	cmp #0			;look for end-of-string null
     7A66   D0 F6       12016   	bne 10$

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 147-1
Variable Assignment   VARIABLES.SRC

Error Addr  Code          Seq   Source statement

                        12017   
     7A68   98          12018   	tya
     7A69   20 8688     12019   	jsr strini		;get temp string space (len in .A)
     7A6C   A8          12020   	tay
     7A6D   F0 0E       12021   	beq 30$			;don't bother copying if len is 0
                        12022   
     7A6F   88          12023   20$	dey
     7A70   A9 7B       12024   	lda #dsdesc+1
     7A72   20 03AB     12025   	jsr indsub_ram1
     7A75   91 37       12026   	sta (frespc),y
     7A77   98          12027   	tya
     7A78   D0 F5       12028   	bne 20$
                        12029   
     7A7A   20 8771     12030   	jsr mvdone
     7A7D   4C 86E3     12031   30$	jmp putnew
                        12032   
                        12033   
                        12034   
                        12035   
                        12036   
                        12037   
     7A80   A5 7A       12038   chkds	lda dsdesc
     7A82   D0 40       12039   	bne strrts
     7A84   4C A788     12040   	jmp errchl	;get status
                        12041   
                        12042   
                        12043   
     7A87               12044   is_numeric
     7A87   24 10       12045   	bit intflg	;is this an integer?
     7A89   10 0F       12046   	bpl is_floating	;no, branch.
     7A8B   A0 00       12047   	ldy #0
     7A8D   20 4304     12048   	jsr indfmo	;fetch high 
     7A90   AA          12049   	tax
     7A91   C8          12050   	iny
     7A92   20 4304     12051   	jsr indfmo	fetch low
     7A95   A8          12052   	tay		;put low in y.
     7A96   8A          12053   	txa		;get high in a.
     7A97   4C 79D9     12054   	jmp givayf	;float and return.
                        12055   
                        12056   ;screen out ti,st,er, and el, and assign values to them.
                        12057   ;first test if pointer points to rom zero. if not, it can't
                        12058   ;be any of the above.
                        12059   ;
     7A9A               12060   is_floating
     7A9A   A5 67       12061   	lda facmo+1
     7A9C   C9 03       12062   	cmp #>zero
     7A9E   D0 7E       12063   	bne gomovf	;not ti,st,....
     7AA0   A5 66       12064   	lda facmo
     7AA2   C9 D2       12065   	cmp #<zero
     7AA4   D0 78       12066   	bne gomovf	;not ti,st,....
                        12067   ;
                        12068   ; pointer does point to the rom zero. now it is necessary to
                        12069   ; examine the actual variable name case by case.
                        12070   ;
     7AA6   E0 54       12071   	cpx #'T'

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 147-2
Variable Assignment   VARIABLES.SRC

Error Addr  Code          Seq   Source statement

     7AA8   D0 1B       12072   	bne qstatv
     7AAA   C0 49       12073   	cpy #'I'
     7AAC   D0 70       12074   	bne gomovf
     7AAE   20 7AB7     12075   	jsr gettim
     7AB1   98          12076   	tya		;for floats.
     7AB2   A2 A0       12077   	ldx #160	;set exponent.
     7AB4   4C 8C7B     12078   	jmp floatb
                        12079   
     7AB7   20 FFDE     12080   gettim	jsr _rdtim
     7ABA   86 66       12081   	stx facmo
     7ABC   84 65       12082   	sty facmoh
     7ABE   85 67       12083   	sta faclo
     7AC0   A0 00       12084   	ldy #0
     7AC2   84 64       12085   	sty facho	;zero highest.
     7AC4   60          12086   strrts	rts
                        12087   
     7AC5   E0 53       12088   qstatv	cpx #'S'	;'st'?
     7AC7   D0 0A       12089   	bne qdsav	;no, go test 'ds'
     7AC9   C0 54       12090   	cpy #'T'
     7ACB   D0 51       12091   	bne gomovf
     7ACD   20 9251     12092   	jsr k_readst	; (318018-03 fix; fab: system bank for rs232 st)
     7AD0   4C 8C68     12093   	jmp float
                        12094   
                        12095   
                        12096   
     7AD3               12097   qdsav
     7AD3   E0 44       12098   	cpx #'D'	;'ds'?
     7AD5   D0 26       12099   	bne qerlin	;no, go test 'er' & 'el'
     7AD7   C0 53       12100   	cpy #'S'
     7AD9   D0 43       12101   	bne gomovf
                        12102   
                        12103   ; get disk status - make the first two characters of ds$ string into a number.
                        12104   
     7ADB   20 7A80     12105   	jsr chkds	;get a ds$ string if one doesn't exist already
     7ADE   A0 00       12106   	ldy #0
     7AE0   A9 7B       12107   	lda #dsdesc+1	;lda (dsdesc+1),y
     7AE2   20 03AB     12108   	jsr indsub_ram1	;..indirectly from string bank.
     7AE5   29 0F       12109   	and #$0f
     7AE7   0A          12110   	asl a
     7AE8   85 11       12111   	sta garbfl
     7AEA   0A          12112   	asl a
     7AEB   0A          12113   	asl a
     7AEC   65 11       12114   	adc garbfl
     7AEE   85 11       12115   	sta garbfl
     7AF0   C8          12116   	iny
     7AF1   A9 7B       12117   	lda #dsdesc+1	;lda (dsdesc+1),y
     7AF3   20 03AB     12118   	jsr indsub_ram1	;..indirectly from string bank.
     7AF6   29 0F       12119   	and #$0f
     7AF8   65 11       12120   	adc garbfl
     7AFA   4C 8C68     12121   	jmp float
                        12122   
     7AFD   E0 45       12123   qerlin	cpx #'E'
     7AFF   D0 1D       12124   	bne gomovf
     7B01   C0 52       12125   	cpy #'R'
     7B03   F0 10       12126   	beq qnumer

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 147-3
Variable Assignment   VARIABLES.SRC

Error Addr  Code          Seq   Source statement

     7B05   C0 4C       12127   	cpy #'L'
     7B07   D0 15       12128   	bne gomovf
                        12129   
     7B09   8D FF03     12130   	sta sw_rom_ram0		;they want the last error line #
     7B0C   AD 120A     12131   	lda errlin+1
     7B0F   AC 1209     12132   	ldy errlin
     7B12   4C 84C9     12133   	jmp nosflt
                        12134   
     7B15   8D FF03     12135   qnumer	sta sw_rom_ram0		;'er', or type number of last error
     7B18   AD 1208     12136   	lda errnum
     7B1B   4C 8C68     12137   	jmp float
                        12138   
     7B1E   A5 66       12139   gomovf	lda facmo
     7B20   A4 67       12140   	ldy facmo+1
     7B22   85 24       12141   movfrm	sta index1
     7B24   84 25       12142   	sty index1+1
                        12143   
                        12144   ; move value from ram
                        12145   
     7B26   A0 00       12146   	ldy #0
     7B28   20 03B7     12147   	jsr indin1_ram1
     7B2B   85 63       12148   	sta facexp
     7B2D   84 71       12149   	sty facov
                        12150   
     7B2F   C8          12151   	iny ;y=1
     7B30   20 03B7     12152   	jsr indin1_ram1
     7B33   85 68       12153   	sta facsgn
     7B35   09 80       12154   	ora #$80
     7B37   85 64       12155   	sta facho
                        12156   
     7B39   C8          12157   	iny ;=2
     7B3A   20 03B7     12158   	jsr indin1_ram1
     7B3D   85 65       12159   	sta facmoh
                        12160   
     7B3F   C8          12161   	iny ;=3
     7B40   20 03B7     12162   	jsr indin1_ram1
     7B43   85 66       12163   	sta facmo
                        12164   
     7B45   C8          12165   	iny ;=4
     7B46   20 03B7     12166   	jsr indin1_ram1
     7B49   85 67       12167   	sta faclo
     7B4B   60          12168   	rts
                        12169   
                        12170   ;end
                        12171   	.include getpointr

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 148
variable searching   GETPOINTR.SRC

Error Addr  Code          Seq   Source statement

                        12173   	.subttl variable searching
                        12174   
                        12175   ;	Routine to read the variable name at the current text position
                        12176   ;	and put a pointer to it's value in VARPNT.
                        12177   ;	[TXTPTR] points to the terminating character.
                        12178   ;	Note that evaluating subscripts in a variable name can cause recursive
                        12179   ;	calls to 'ptrget', so at that point all values must be stored on the stack.
                        12180   
     7B4C   A2 00       12181   ptrget	ldx #0
     7B4E   20 0386     12182   	jsr chrgot
     7B51   86 0E       12183   ptrgt1	stx dimflg	;store flag away
     7B53   85 47       12184   ptrgt2	sta varnam
     7B55   20 0386     12185   	jsr chrgot	;get current character
     7B58   20 7BD9     12186   	jsr isletc	;check for a letter
     7B5B   B0 03       12187   	bcs ptrgt3	;must be a letter
     7B5D   4C 7A09     12188   interr	jmp snerr
                        12189   
                        12190   
                        12191   
     7B60   A2 00       12192   ptrgt3	ldx #0		;assume no second character
     7B62   86 0F       12193   	stx valtyp	;default is numeric
     7B64   86 10       12194   	stx intflg	;assume floating
     7B66   20 0380     12195   	jsr chrget	;get following character
     7B69   90 05       12196   	bcc issec	;branch if numeric
     7B6B   20 7BD9     12197   	jsr isletc	;is it alpha?
     7B6E   90 0B       12198   	bcc nosec	;no, no second character. branch.
     7B70   AA          12199   issec	tax		;save second character of name
                        12200   
     7B71   20 0380     12201   eatem	jsr chrget	;skip over remainder of name. we only care about 2 chars.
     7B74   90 FB       12202   	bcc eatem	;..eat numbers,
     7B76   20 7BD9     12203   	jsr isletc
     7B79   B0 F6       12204   	bcs eatem	;..and alphas, too!
                        12205   
     7B7B   C9 24       12206   nosec	cmp #'$'	;is this a string?
     7B7D   D0 06       12207   	bne notstr	;if not, [VALTYP] = 0
     7B7F   A9 FF       12208   	lda #$ff
     7B81   85 0F       12209   	sta valtyp	;..else, flag 'string'
     7B83   D0 10       12210   	bne turnon
                        12211   
     7B85   C9 25       12212   notstr	cmp #'%'	;isn't string. is it integer?
     7B87   D0 13       12213   	bne strnam	;branch if not.
     7B89   A5 12       12214   	lda subflg
     7B8B   D0 D0       12215   	bne interr
     7B8D   A9 80       12216   	lda #$80	;flag integer by turning on both high bits
     7B8F   85 10       12217   	sta intflg
     7B91   05 47       12218   	ora varnam
     7B93   85 47       12219   	sta varnam
                        12220   
     7B95   8A          12221   turnon	txa		;turn on msb of second character
     7B96   09 80       12222   	ora #$80
     7B98   AA          12223   	tax
     7B99   20 0380     12224   	jsr chrget	;get character after $ or %
                        12225   
     7B9C   86 48       12226   strnam	stx varnam+1	;store away second character
     7B9E   38          12227   	sec

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 148-1
variable searching   GETPOINTR.SRC

Error Addr  Code          Seq   Source statement

     7B9F   05 12       12228   	ora subflg	;add flag whether to allow arrays
     7BA1   E9 28       12229   	sbc #'('
     7BA3   D0 03       12230   	bne 1$
     7BA5   4C 7D48     12231   	jmp is_array	;note: won'y match if 'subflg' set
                        12232   
     7BA8   A0 00       12233   1$	ldy #0
     7BAA   84 12       12234   	sty subflg	;allow subscripts again
     7BAC   A5 2F       12235   	lda vartab	;place to start search
     7BAE   A6 30       12236   	ldx vartab+1
                        12237   
     7BB0   86 62       12238   stxfnd	stx lowtr+1
     7BB2   85 61       12239   lopfnd	sta lowtr
     7BB4   E4 32       12240   	cpx arytab+1	;at end of table yet?
     7BB6   D0 04       12241   	bne lopfn
     7BB8   C5 31       12242   	cmp arytab
     7BBA   F0 27       12243   	beq notfns	;yes, we couldn't find it.
                        12244   
     7BBC   20 431D     12245   lopfn	jsr indlow_ram1	;(lowtr),y
     7BBF   C5 47       12246   	cmp varnam	;compare high orders
     7BC1   D0 0C       12247   	bne notit
     7BC3   C8          12248   	iny
     7BC4   20 431D     12249   	jsr indlow_ram1
     7BC7   C5 48       12250   	cmp varnam+1	;and the low part?
     7BC9   D0 03       12251   	bne 1$
     7BCB   4C 7CF4     12252   	jmp finptr	;!!that's it!!
                        12253   
     7BCE   88          12254   1$	dey
     7BCF   18          12255   notit	clc
     7BD0   A5 61       12256   	lda lowtr
     7BD2   69 07       12257   	adc #7		;makes no difference among types
     7BD4   90 DC       12258   	bcc lopfnd
     7BD6   E8          12259   	inx
     7BD7   D0 D7       12260   	bne stxfnd	;branch always
                        12261   
                        12262   
                        12263   
                        12264   
                        12265   ; test for a letter.            / carry off=not a letter
                        12266   ;                                 carry on= a letter
                        12267   
     7BD9   C9 41       12268   isletc	cmp #'A'
     7BDB   90 05       12269   	bcc 1$		;if less than "a", return.
     7BDD   E9 5B       12270   	sbc #$5b
     7BDF   38          12271   	sec
     7BE0   E9 A5       12272   	sbc #@245	;reset carry if (a) .gt. "z".
     7BE2   60          12273   1$	rts
                        12274   
                        12275   
     7BE3   BA          12276   notfns	tsx		;check who's calling
     7BE4   BD 0102     12277   	lda $102,x
     7BE7   C9 83       12278   	cmp #>pointer_ret
     7BE9   F0 04       12279   	beq ldzr	;special case if called by pointer function
            =7A17       12280   20$=isvret-1
     7BEB   C9 7A       12281   	cmp #>20$	;is eval calling???
     7BED   D0 2A       12282   	bne notevl	;no, carry on.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 148-2
variable searching   GETPOINTR.SRC

Error Addr  Code          Seq   Source statement

                        12283   
     7BEF   A9 D2       12284   ldzr	lda #<zero	;set up pointer to simulated zero
     7BF1   A0 03       12285   	ldy #>zero
     7BF3   60          12286   	rts		;for strings or numeric.
                        12287   
                        12288   
     7BF4   C0 C9       12289   qst001	cpy #$c9	 ;we know first is 't', is second shift i?
     7BF6   F0 F7       12290   	beq ldzr
     7BF8   C0 49       12291   	cpy #$49	;or 'i'?
     7BFA   D0 31       12292   	bne varok
     7BFC   F0 18       12293   	beq gobadv
     7BFE               12294   qst004
     7BFE   C0 D3       12295   	cpy #$d3	;check for 'ds$'
     7C00   F0 14       12296   	beq gobadv
     7C02   C0 53       12297   	cpy #'S'	;check for 'ds'
     7C04   D0 27       12298   	bne varok
     7C06   F0 0E       12299   	beq gobadv
     7C08               12300   qst002
     7C08   C0 54       12301   	cpy #'T'	;check for 'st'
     7C0A   D0 21       12302   	bne varok
     7C0C   F0 08       12303   	beq gobadv
     7C0E               12304   qst003
     7C0E   C0 52       12305   	cpy #'R'	;check for 'er'
     7C10   F0 04       12306   	beq gobadv
     7C12   C0 4C       12307   	cpy #'L'	;check for 'el'
     7C14   D0 17       12308   	bne varok
     7C16               12309   gobadv
     7C16   4C 7A09     12310   	jmp snerr
                        12311   
                        12312   
                        12313   
     7C19   A5 47       12314   notevl	lda varnam
     7C1B   A4 48       12315   	ldy varnam+1
     7C1D   C9 54       12316   	cmp #'T'	;screen out 'ti',
     7C1F   F0 D3       12317   	beq qst001
     7C21   C9 53       12318   	cmp #'S'	;...and 'st',
     7C23   F0 E3       12319   	beq qst002
     7C25   C9 45       12320   	cmp #'E'	;...and er and el,
     7C27   F0 E5       12321   	beq qst003
     7C29   C9 44       12322   	cmp #'D'	;...and ds.
     7C2B   F0 D1       12323   	beq qst004
                        12324   
     7C2D   A5 31       12325   varok	lda arytab
     7C2F   A4 32       12326   	ldy arytab+1
     7C31   85 61       12327   	sta lowtr
     7C33   84 62       12328   	sty lowtr+1
     7C35   A5 33       12329   	lda strend
     7C37   A4 34       12330   	ldy strend+1
     7C39   85 5C       12331   	sta hightr
     7C3B   84 5D       12332   	sty hightr+1
     7C3D   18          12333   	clc
     7C3E   69 07       12334   	adc #7
     7C40   90 01       12335   	bcc noteve
     7C42   C8          12336   	iny
     7C43               12337   noteve

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 148-3
variable searching   GETPOINTR.SRC

Error Addr  Code          Seq   Source statement

     7C43   85 5A       12338   	sta highds
     7C45   84 5B       12339   	sty highds+1
     7C47   20 7D03     12340   	jsr bltu
     7C4A   A5 5A       12341   	lda highds
     7C4C   A4 5B       12342   	ldy highds+1
     7C4E   C8          12343   	iny
     7C4F   85 31       12344   	sta arytab
     7C51   84 32       12345   	sty arytab+1
                        12346   
                        12347   
                        12348   ; scan thru array entries, looking for string arrays. if any
                        12349   ; are found, it will be necessary to adjust the back-links
                        12350   ; on the strings in that array, since the array descriptor
                        12351   ; block itself was moved
                        12352   
     7C53   85 5A       12353   	sta arypnt	;set pointer to arrays
     7C55   84 5B       12354   	sty arypnt+1
     7C57               12355   aryva2
     7C57   A5 5A       12356   	lda arypnt
     7C59   A6 5B       12357   	ldx arypnt+1
     7C5B               12358   aryva3
     7C5B   E4 34       12359   	cpx strend+1	;end of arrays ?
     7C5D   D0 06       12360   	bne aryvgo
     7C5F   C5 33       12361   	cmp strend
     7C61   D0 02       12362   	bne aryvgo
     7C63   F0 78       12363   	beq arydon	;always..finished
                        12364   
     7C65               12365   aryvgo
     7C65   85 24       12366   	sta index1
     7C67   86 25       12367   	stx index1+1
     7C69   A0 00       12368   	ldy #0
     7C6B   20 03B7     12369   	jsr indin1_ram1	;look at array name
     7C6E   AA          12370   	tax
     7C6F   C8          12371   	iny
     7C70   20 03B7     12372   	jsr indin1_ram1	;name 2nd char
     7C73   08          12373   	php		;save status reg
     7C74   C8          12374   	iny
     7C75   20 03B7     12375   	jsr indin1_ram1	;point to offset to next array
     7C78   65 5A       12376   	adc arypnt
     7C7A   85 5A       12377   	sta arypnt	;save start of next array in arypnt
     7C7C   C8          12378   	iny
     7C7D   20 03B7     12379   	jsr indin1_ram1
     7C80   65 5B       12380   	adc arypnt+1
     7C82   85 5B       12381   	sta arypnt+1
     7C84   28          12382   	plp		;restore status
     7C85   10 D0       12383   	bpl aryva2	;not a string type
     7C87   8A          12384   	txa
     7C88   30 CD       12385   	bmi aryva2	;not a string array
     7C8A   C8          12386   	iny		;ok we have a string array
     7C8B   20 03B7     12387   	jsr indin1_ram1	;get number of dimensions
     7C8E   A0 00       12388   	ldy #0
     7C90   0A          12389   	asl a	    	;move index to ptr to 1st string (add 2*number of dims + 5)
     7C91   69 05       12390   	adc #5
     7C93   65 24       12391   	adc index1
     7C95   85 24       12392   	sta index1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 148-4
variable searching   GETPOINTR.SRC

Error Addr  Code          Seq   Source statement

     7C97   90 02       12393   	bcc aryget
     7C99   E6 25       12394   	inc index1+1
                        12395   
     7C9B               12396   aryget
     7C9B   A6 25       12397   	ldx index1+1
     7C9D   E4 5B       12398   	cpx arypnt+1	;done with this array?
     7C9F   D0 04       12399   	bne gogo
     7CA1   C5 5A       12400   	cmp arypnt
     7CA3   F0 B6       12401   	beq aryva3	;yes
     7CA5               12402   gogo
     7CA5   A0 00       12403   	ldy #0	   	;process string pointer
     7CA7   20 03B7     12404   	jsr indin1_ram1	;get length of string
     7CAA   F0 24       12405   	beq dvarts	;skip if null string
     7CAC   85 79       12406   	sta syntmp
     7CAE   C8          12407   	iny
     7CAF   20 03B7     12408   	jsr indin1_ram1	;get lo byte of string ptr
     7CB2   18          12409   	clc
     7CB3   65 79       12410   	adc syntmp	;and add string length
     7CB5   85 5C       12411   	sta hightr
     7CB7   C8          12412   	iny
     7CB8   20 03B7     12413   	jsr indin1_ram1	;get hi byte of string ptr
     7CBB   69 00       12414   	adc #0	   	;adjust high byte
     7CBD   85 5D       12415   	sta hightr+1
                        12416   
                        12417   
                        12418   
                        12419   ; fix backwards pointer by adding
                        12420   ; move length to it
                        12421   
     7CBF   A0 00       12422   	ldy #0
     7CC1   20 42FF     12423   	jsr indhtr_ram1	;lda (hightr),y
     7CC4   69 07       12424   	adc #7		;carry clear (careful!)
     7CC6   91 5C       12425   	sta (hightr),y
     7CC8   C8          12426   	iny
     7CC9   20 42FF     12427   	jsr indhtr_ram1	;lda (hightr),y
     7CCC   69 00       12428   	adc #0
     7CCE   91 5C       12429   	sta (hightr),y	;done with this string
                        12430   ;
                        12431   ; fix the next string in the array
                        12432   ;
     7CD0   A9 03       12433   dvarts	lda #strsiz
     7CD2   18          12434   	clc
     7CD3   65 24       12435   	adc index1
     7CD5   85 24       12436   	sta index1
     7CD7   90 C2       12437   	bcc aryget
     7CD9   E6 25       12438   	inc index1+1
     7CDB   D0 BE       12439   	bne aryget	;branch always
                        12440   
                        12441   
     7CDD   A0 00       12442   arydon	ldy #0
     7CDF   A5 47       12443   	lda varnam
     7CE1   8D FF04     12444   	sta sw_rom_ram1
     7CE4   91 61       12445   	sta (lowtr),y
     7CE6   C8          12446   	iny		;.y=1
     7CE7   A5 48       12447   	lda varnam+1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 148-5
variable searching   GETPOINTR.SRC

Error Addr  Code          Seq   Source statement

     7CE9   91 61       12448   	sta (lowtr),y
     7CEB   A9 00       12449   	lda #0
     7CED   C8          12450   10$	iny
     7CEE   91 61       12451   	sta (lowtr),y
     7CF0   C0 06       12452   	cpy #6
     7CF2   D0 F9       12453   	bne 10$
                        12454   
     7CF4   A5 61       12455   finptr	lda lowtr
     7CF6   18          12456   	clc
     7CF7   69 02       12457   	adc #2
     7CF9   A4 62       12458   	ldy lowtr+1
     7CFB   90 01       12459   	bcc 10$
     7CFD   C8          12460   	iny
     7CFE   85 49       12461   10$	sta varpnt
     7D00   84 4A       12462   	sty varpnt+1
     7D02   60          12463   	rts
                        12464   
                        12465   
                        12466   
                        12467   
     7D03   20 5034     12468   bltu	jsr reason
     7D06   85 33       12469   	sta strend
     7D08   84 34       12470   	sty strend+1
     7D0A   38          12471   	sec
     7D0B   A5 5C       12472   	lda hightr
     7D0D   E5 61       12473   	sbc lowtr
     7D0F   85 24       12474   	sta index
     7D11   A8          12475   	tay
     7D12   A5 5D       12476   	lda hightr+1
     7D14   E5 62       12477   	sbc lowtr+1
     7D16   AA          12478   	tax
     7D17   E8          12479   	inx
     7D18   98          12480   	tya
     7D19   F0 25       12481   	beq decblt
     7D1B   A5 5C       12482   	lda hightr
     7D1D   38          12483   	sec
     7D1E   E5 24       12484   	sbc index
     7D20   85 5C       12485   	sta hightr
     7D22   B0 03       12486   	bcs 10$
     7D24   C6 5D       12487   	dec hightr+1
     7D26   38          12488   	sec
     7D27   A5 5A       12489   10$	lda highds
     7D29   E5 24       12490   	sbc index
     7D2B   85 5A       12491   	sta highds
     7D2D   B0 09       12492   	bcs moren1
     7D2F   C6 5B       12493   	dec highds+1
     7D31   90 05       12494   	bcc moren1
                        12495   
     7D33   20 42FF     12496   bltlp	jsr indhtr_ram1	;lda (hightr),y
     7D36   91 5A       12497   	sta (highds),y
                        12498   
     7D38   88          12499   moren1	dey
     7D39   D0 F8       12500   	bne bltlp
     7D3B   20 42FF     12501   	jsr indhtr_ram1	;lda (hightr),y
     7D3E   91 5A       12502   	sta (highds),y

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 148-6
variable searching   GETPOINTR.SRC

Error Addr  Code          Seq   Source statement

                        12503   
     7D40   C6 5D       12504   decblt	dec hightr+1
     7D42   C6 5B       12505   	dec highds+1
     7D44   CA          12506   	dex
     7D45   D0 F1       12507   	bne moren1
     7D47   60          12508   	rts
                        12509   
                        12510   ;end
                        12511   	.include array

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 149
Array Routines   ARRAY.SRC

Error Addr  Code          Seq   Source statement

                        12513   	.subttl Array Routines
                        12514   
                        12515   ; 
                        12516   ; format of arrays in core:
                        12517   ; 
                        12518   ; descriptor:
                        12519   ;	lowbyte = first character.
                        12520   ;	high byte = second character (m.s.bit is string flag).
                        12521   ; length of array in core in bytes (includes everything).
                        12522   ; number of dimensions.
                        12523   ; for each dimension starting with the first a list (2 bytes each)
                        12524   ;	of the max indice+1
                        12525   ; the values
                        12526   ; 
                        12527   
                        12528   
     7D48               12529   is_array
     7D48   A5 0E       12530   	lda dimflg
     7D4A   05 10       12531   	ora intflg
     7D4C   48          12532   	pha		;save (dimflg) for recursion.
     7D4D   A5 0F       12533   	lda valtyp
     7D4F   48          12534   	pha		;save (valtyp) for recursion.
     7D50   A0 00       12535   	ldy #0		;set number of dimensions to zero.
                        12536   
     7D52   98          12537   indlop	tya		;save number of dims.
     7D53   48          12538   	pha
     7D54   A5 48       12539   	lda varnam+1
     7D56   48          12540   	pha
     7D57   A5 47       12541   	lda varnam
     7D59   48          12542   	pha		;save looks.
     7D5A   20 84A7     12543   	jsr intidx	;evaluate indice into facmo&lo.
     7D5D   68          12544   	pla
     7D5E   85 47       12545   	sta varnam
     7D60   68          12546   	pla
     7D61   85 48       12547   	sta varnam+1	;get back all...we're home.
     7D63   68          12548   	pla		;(# of units).
     7D64   A8          12549   	tay
     7D65   BA          12550   	tsx
     7D66   BD 0102     12551   	lda 258,x
     7D69   48          12552   	pha		;push dimflg and valtyp further.
     7D6A   BD 0101     12553   	lda 257,x
     7D6D   48          12554   	pha
     7D6E   A5 66       12555   	lda indice	;put indice onto stack.
     7D70   9D 0102     12556   	sta 258,x	;under dimflg and valtyp.
     7D73   A5 67       12557   	lda indice+1
     7D75   9D 0101     12558   	sta 257,x
     7D78   C8          12559   	iny		;y counts # of subscripts
     7D79   84 0D       12560   	sty count	;protect y from chrget
     7D7B   20 0386     12561   	jsr chrgot	;get terminating character.
     7D7E   A4 0D       12562   	ldy count
     7D80   C9 2C       12563   	cmp #','	;more subscripts?
     7D82   F0 CE       12564   	beq indlop	;yes.
                        12565   
     7D84   20 79F3     12566   	jsr chkcls	;must be closed paren.
     7D87   68          12567   	pla

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 149-1
Array Routines   ARRAY.SRC

Error Addr  Code          Seq   Source statement

     7D88   85 0F       12568   	sta valtyp	;get valtyp and
     7D8A   68          12569   	pla
     7D8B   85 10       12570   	sta intflg
     7D8D   29 7F       12571   	and #$7f
     7D8F   85 0E       12572   	sta dimflg	;dimflg off stack.
     7D91   A6 31       12573   	ldx arytab	;place to start search.
     7D93   A5 32       12574   	lda arytab+1
     7D95               12575   lopfda
     7D95   86 61       12576   	stx lowtr
     7D97   85 62       12577   	sta lowtr+1
     7D99   C5 34       12578   	cmp strend+1	;end of arrays?
     7D9B   D0 04       12579   	bne lopfdv
     7D9D   E4 33       12580   	cpx strend
     7D9F   F0 42       12581   	beq notfdd	;a fine thing! no array!
     7DA1               12582   lopfdv
     7DA1   A0 00       12583   	ldy #0
     7DA3   20 431D     12584   	jsr indlow_ram1 ;get high of name from array bank (ram1)
     7DA6   C8          12585   	iny
     7DA7   C5 47       12586   	cmp varnam	;compare high orders.
     7DA9   D0 07       12587   	bne nmary1	;no way is it this. get the bite outta here.
     7DAB   20 431D     12588   	jsr indlow_ram1
     7DAE   C5 48       12589   	cmp varnam+1	;low orders?
     7DB0   F0 18       12590   	beq gotary	;well here it is.
     7DB2               12591   nmary1
     7DB2   C8          12592   	iny
     7DB3   20 431D     12593   	jsr indlow_ram1	;get length.
     7DB6   18          12594   	clc
     7DB7   65 61       12595   	adc lowtr
     7DB9   AA          12596   	tax
     7DBA   C8          12597   	iny
     7DBB   20 431D     12598   	jsr indlow_ram1
     7DBE   65 62       12599   	adc lowtr+1
     7DC0   90 D3       12600   	bcc lopfda	;always branches.
     7DC2   A2 12       12601   bserr	ldx #errbs	;get bad sub error number.
     7DC4   2C          12602   	.byte $2c
                        12603   
     7DC5   A2 0E       12604   fcerr	ldx #errfc	;too big. Illegal Quantity error
     7DC7   4C 4D59     12605   errgo3	jmp error
                        12606   
                        12607   
                        12608   
     7DCA   A2 13       12609   gotary	ldx #errdd	;perhaps a "re-dimension" error.
     7DCC   A5 0E       12610   	lda dimflg	;test the dimflg.
     7DCE   D0 F7       12611   	bne errgo3
     7DD0   20 7F0E     12612   	jsr fmaptr
     7DD3   A0 04       12613   	ldy #4
     7DD5   20 431D     12614   	jsr indlow_ram1
     7DD8   85 79       12615   	sta syntmp
     7DDA   A5 0D       12616   	lda count	;get number of dims input.
     7DDC   C5 79       12617   	cmp syntmp	;# of dims the same?
     7DDE   D0 E2       12618   	bne bserr	;same so get definition.
     7DE0   4C 7E6F     12619   	jmp getdef

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 150
Array Routines   ARRAY.SRC

Error Addr  Code          Seq   Source statement

                        12621   ; 
                        12622   ; here when variable is not found in the array table.
                        12623   ; 
                        12624   ; building an entry.
                        12625   ; 
                        12626   ;      put down the descriptor.
                        12627   ;      setup number of dimensions.
                        12628   ;      make sure there is room for the new entry.
                        12629   ;      remember "varpnt".
                        12630   ;      tally=4.
                        12631   ;      skip two locs for later fill in of size.
                        12632   ; loop: get an indice
                        12633   ;       put down number+1 and increment varptr.
                        12634   ;       tally=tally*number+1
                        12635   ;       decrement number of dims
                        12636   ;       bne loop
                        12637   ;       call "reason" with (a,b) reflecting last loc
                        12638   ;                                of variable
                        12639   ;       update strend
                        12640   ;       zero all.
                        12641   ;       make tally include maxdims and descriptor
                        12642   ;       put down tally
                        12643   ;       if called by dimension, return.
                        12644   ;       otherwise index into the variable as if it
                        12645   ;       were found on the initial search.
                        12646   ; 
     7DE3               12647   notfdd
     7DE3   20 7F0E     12648   	jsr fmaptr	;form arypnt.
     7DE6   20 5034     12649   	jsr reason
     7DE9   A0 00       12650   	ldy #0
     7DEB   84 73       12651   	sty curtol+1
     7DED   A2 05       12652   	ldx #5
     7DEF   A5 47       12653   	lda varnam
     7DF1   8D FF04     12654   	sta sw_rom_ram1	;point to string/array bank
     7DF4   91 61       12655   	sta (lowtr),y
     7DF6   10 01       12656   	bpl notflt
     7DF8   CA          12657   	dex
     7DF9               12658   notflt
     7DF9   C8          12659   	iny
     7DFA   A5 48       12660   	lda varnam+1
     7DFC   91 61       12661   	sta (lowtr),y
     7DFE   10 02       12662   	bpl stomlt
     7E00   CA          12663   	dex
     7E01   CA          12664   	dex
     7E02               12665   stomlt
     7E02   86 72       12666   	stx curtol
     7E04   A5 0D       12667   	lda count
     7E06   C8          12668   	iny
     7E07   C8          12669   	iny
     7E08   C8          12670   	iny
     7E09   91 61       12671   	sta (lowtr),y	;save number of dimensions.
     7E0B               12672   loppta
     7E0B   A2 0B       12673   	ldx #11		;default size.
     7E0D   A9 00       12674   	lda #0
     7E0F   24 0E       12675   	bit dimflg

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 150-1
Array Routines   ARRAY.SRC

Error Addr  Code          Seq   Source statement

     7E11   50 08       12676   	bvc notdim	;not in a dim statement.
     7E13   68          12677   	pla		;get low order of indice.
     7E14   18          12678   	clc
     7E15   69 01       12679   	adc #1
     7E17   AA          12680   	tax
     7E18   68          12681   	pla		;get high order of indice.
     7E19   69 00       12682   	adc #0
     7E1B               12683   notdim
     7E1B   C8          12684   	iny
     7E1C   91 61       12685   	sta (lowtr),y	;store high part of indice.
     7E1E   C8          12686   	iny
     7E1F   8A          12687   	txa
     7E20   91 61       12688   	sta (lowtr),y	;store low part of indice.
     7E22   20 7EDB     12689   	jsr umult	;(a,x)+(curtol)*(lowtr,y).
     7E25   86 72       12690   	stx curtol	;save new tally.
     7E27   85 73       12691   	sta curtol+1
     7E29   A4 24       12692   	ldy index
     7E2B   C6 0D       12693   	dec count	;any more indices left?
     7E2D   D0 DC       12694   	bne loppta	;yes.
     7E2F   65 5B       12695   	adc arypnt+1
     7E31   B0 67       12696   	bcs omerr1	;overflow.
     7E33   85 5B       12697   	sta arypnt+1	;compute where to zero.
     7E35   A8          12698   	tay
     7E36   8A          12699   	txa
     7E37   65 5A       12700   	adc arypnt
     7E39   90 03       12701   	bcc grease
     7E3B   C8          12702   	iny
     7E3C   F0 5C       12703   	beq omerr1
     7E3E               12704   grease
     7E3E   20 5034     12705   	jsr reason	;get room.
     7E41   85 33       12706   	sta strend
     7E43   84 34       12707   	sty strend+1	;new end of storage.
     7E45   A9 00       12708   	lda #0		;storing (acca) is faster than clear.
     7E47   E6 73       12709   	inc curtol+1
                        12710   
     7E49   A4 72       12711   	ldy curtol
     7E4B   F0 05       12712   	beq deccur
                        12713   
     7E4D   88          12714   zerita	dey		;zero out new entry
     7E4E   91 5A       12715   	sta (arypnt),y
     7E50   D0 FB       12716   	bne zerita	;no. continue.
     7E52               12717   deccur
     7E52   C6 5B       12718   	dec arypnt+1
     7E54   C6 73       12719   	dec curtol+1
     7E56   D0 F5       12720   	bne zerita	;do another block.
     7E58   E6 5B       12721   	inc arypnt+1	;bump back up. will use later.
     7E5A   38          12722   	sec
     7E5B   A5 33       12723   	lda strend	;restore (acca).
     7E5D   E5 61       12724   	sbc lowtr	;determine length.
     7E5F   A0 02       12725   	ldy #2
     7E61   91 61       12726   	sta (lowtr),y	;low.
     7E63   A5 34       12727   	lda strend+1
     7E65   C8          12728   	iny
     7E66   E5 62       12729   	sbc lowtr+1
     7E68   91 61       12730   	sta (lowtr),y	;high.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 150-2
Array Routines   ARRAY.SRC

Error Addr  Code          Seq   Source statement

     7E6A   A5 0E       12731   	lda dimflg	;quit here if this is a dim statement
     7E6C   D0 6C       12732   	bne dimrts	;bye!
     7E6E   C8          12733   	iny
                        12734   
                        12735   
                        12736   ; At this point (lowtr,y) points beyond the size to the number of dimensions. strategy:
                        12737   ;     numdim=number of dimensions.
                        12738   ;     curtol=0.
                        12739   ;inlpnm:get a new indice.
                        12740   ;     make sure indice is not too big.
                        12741   ;     multiply curtol by curmax.
                        12742   ;     add indice to curtol.
                        12743   ;     numdim=numdim-1.
                        12744   ;     bne    inlpnm.
                        12745   ;     use (curtol)*4 as offset.
                        12746   
     7E6F   20 431D     12747   getdef	jsr indlow_ram1	;get # of dim's from ram bank 1
     7E72   85 0D       12748   	sta count	;save a counter.
     7E74   A9 00       12749   	lda #0		;zero (curtol).
     7E76   85 72       12750   	sta curtol
     7E78               12751   inlpnm
     7E78   85 73       12752   	sta curtol+1
     7E7A   C8          12753   	iny
     7E7B   68          12754   	pla		;get low indice.
     7E7C   AA          12755   	tax
     7E7D   85 66       12756   	sta indice
     7E7F   20 431D     12757   	jsr indlow_ram1
     7E82   85 79       12758   	sta syntmp
     7E84   68          12759   	pla		;and the high part.
     7E85   85 67       12760   	sta indice+1
     7E87   C5 79       12761   	cmp syntmp	;compare with max indice.
     7E89   90 12       12762   	bcc inlpn2
     7E8B   D0 0A       12763   	bne bserr7	;if greater, "bad subscript" error.
     7E8D   C8          12764   	iny
     7E8E   20 431D     12765   	jsr indlow_ram1
     7E91   85 79       12766   	sta syntmp
     7E93   E4 79       12767   	cpx syntmp
     7E95   90 07       12768   	bcc inlpn1
                        12769   
     7E97   4C 7DC2     12770   bserr7	jmp bserr
                        12771   
     7E9A   4C 4D57     12772   omerr1	jmp omerr
                        12773   
     7E9D               12774   inlpn2
     7E9D   C8          12775   	iny
     7E9E   A5 73       12776   inlpn1	lda curtol+1	;don't multiply if curtol=0.
     7EA0   05 72       12777   	ora curtol
     7EA2   18          12778   	clc		;prepare to get indice back.
     7EA3   F0 0A       12779   	beq addind	;get high part of indice back.
     7EA5   20 7EDB     12780   	jsr umult	;multiply (curtol) by (5&6,lowtr).
     7EA8   8A          12781   	txa
     7EA9   65 66       12782   	adc indice	;add in (indice).
     7EAB   AA          12783   	tax
     7EAC   98          12784   	tya
     7EAD   A4 24       12785   	ldy index1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 150-3
Array Routines   ARRAY.SRC

Error Addr  Code          Seq   Source statement

     7EAF               12786   addind
     7EAF   65 67       12787   	adc indice+1
     7EB1   86 72       12788   	stx curtol
     7EB3   C6 0D       12789   	dec count	;any more?
     7EB5   D0 C1       12790   	bne inlpnm	;yes.
     7EB7   85 73       12791   	sta curtol+1
     7EB9   A2 05       12792   	ldx #5
     7EBB   A5 47       12793   	lda varnam
     7EBD   10 01       12794   	bpl notfl1
     7EBF   CA          12795   	dex
     7EC0               12796   notfl1
     7EC0   A5 48       12797   	lda varnam+1
     7EC2   10 02       12798   	bpl 10$
     7EC4   CA          12799   	dex
     7EC5   CA          12800   	dex
     7EC6   86 2A       12801   10$	stx addend
     7EC8   A9 00       12802   	lda #0
     7ECA   20 7EE6     12803   	jsr umultd	;on rts, a & y = hi. x = lo.
     7ECD   8A          12804   	txa
     7ECE   65 5A       12805   	adc arypnt
     7ED0   85 49       12806   	sta varpnt
     7ED2   98          12807   	tya
     7ED3   65 5B       12808   	adc arypnt+1
     7ED5   85 4A       12809   	sta varpnt+1
     7ED7   A8          12810   	tay
     7ED8   A5 49       12811   	lda varpnt
     7EDA   60          12812   dimrts	rts

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 151
Array Routines   ARRAY.SRC

Error Addr  Code          Seq   Source statement

                        12814   
                        12815   			;integer arithmetic routines.
                        12816   			;
                        12817   			;two byte unsigned integer multiply.
                        12818   			;this is for multiply dimensioned arrays.
                        12819   			; (a,b)=(curtol)*(5&6,x).
     7EDB               12820   umult
     7EDB   84 24       12821   	sty index
     7EDD   20 431D     12822   	jsr indlow_ram1
     7EE0   85 2A       12823   	sta addend	;low, then high.
     7EE2   88          12824   	dey
     7EE3   20 431D     12825   	jsr indlow_ram1	;put (5&6,lowtr) in faster memory.
     7EE6               12826   umultd
     7EE6   85 2B       12827   	sta addend+1
     7EE8   A9 10       12828   	lda #16
     7EEA   85 5F       12829   	sta deccnt
     7EEC   A2 00       12830   	ldx #0		;clear the accs.
     7EEE   A0 00       12831   	ldy #0		;result initially zero.
     7EF0               12832   umultc
     7EF0   8A          12833   	txa
     7EF1   0A          12834   	asl a		;multiply by two.
     7EF2   AA          12835   	tax
     7EF3   98          12836   	tya
     7EF4   2A          12837   	rol a
     7EF5   A8          12838   	tay
     7EF6   B0 A2       12839   	bcs omerr1	;to much!
     7EF8   06 72       12840   	asl curtol
     7EFA   26 73       12841   	rol curtol+1
     7EFC   90 0B       12842   	bcc umlcnt	;nothing in this position to multiply.
     7EFE   18          12843   	clc
     7EFF   8A          12844   	txa
     7F00   65 2A       12845   	adc addend
     7F02   AA          12846   	tax
     7F03   98          12847   	tya
     7F04   65 2B       12848   	adc addend+1
     7F06   A8          12849   	tay
     7F07   B0 91       12850   	bcs omerr1	;man, just too much!
     7F09               12851   umlcnt
     7F09   C6 5F       12852   	dec deccnt	;done?
     7F0B   D0 E3       12853   	bne umultc	;keep it up.
     7F0D   60          12854   	rts		;yes, all done.
                        12855   
                        12856   
     7F0E   A5 0D       12857   fmaptr	lda count
     7F10   0A          12858   	asl a
     7F11   69 05       12859   	adc #5		;point to entries. c cleared by asl. 
     7F13   65 61       12860   	adc lowtr
     7F15   A4 62       12861   	ldy lowtr+1
     7F17   90 01       12862   	bcc 1$
     7F19   C8          12863   	iny
     7F1A   85 5A       12864   1$	sta arypnt
     7F1C   84 5B       12865   	sty arypnt+1
     7F1E   60          12866   	rts
                        12867   
                        12868   ;end

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 151-1
Array Routines   ARRAY.SRC

Error Addr  Code          Seq   Source statement

                        12869   
            =001F       12870   	.ifge *-$7f00			;put a break of AT LEAST 1 page for patch code
                        12871   	.messg "*** ADDRESS CHECK ***"	;..before next rom starts (at $8000) 
                        12872   	.endif
                        12873   
                        12874   	.include patcheslo

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 152
PATCHES to BASIC ($4000-$7FFF)   PATCHESLO.SRC

Error Addr  Code          Seq   Source statement

                        12876   	.subttl  PATCHES to BASIC ($4000-$7FFF)
                        12877   
                        12878   ;  CHAR_PATCH  fixes CHAR with 80-column text screen
                        12879   ;
                        12880   
     7F1F               12881   char_patch
     7F1F   20 A855     12882   	jsr put_io_in_map	;must enable I/O to move 80-col cursor!
     7F22   4C FFF0     12883   	jmp _jplot		;move cursor (k_jplot does not bring in I/O)
                        12884   	
                        12885   
                        12886   
                        12887   ;  K_PRINT  fixes CHAR with 80-column text screen
                        12888   ;
                        12889   
     7F25               12890   k_print
     7F25   20 A855     12891   	jsr put_io_in_map	;must enable I/O to print to 80-col screen
     7F28   4C C00C     12892   	jmp _print		;print character in .A
                        12893   
                        12894   
                        12895   
                        12896   ;  P2CODE_PATCH  fixes RENUMBER 'out of memory' check
                        12897   ;
                        12898   
     7F2B               12899   p2code_patch
     7F2B   20 5CAC     12900   	jsr p2code		;renumber 'pass two': trial run to see if enough room
     7F2E   4C 0386     12901   	jmp chrgot		;re-get last character from BASIC text & rts
                        12902   
                        12903   
                        12904   
                        12905   ;  DELETE_PATCH  fixes DELETE top of text check
                        12906   ;
                        12907   
     7F31               12908   delete_patch
     7F31   E6 26       12909   	inc index2		;increment destination address
     7F33   D0 02       12910   	bne 10$
     7F35   E6 27       12911   	inc index2+1
                        12912   
     7F37   38          12913   10$	sec			;compare destination ptr with new text_top ptr
     7F38   A5 26       12914   	lda index2
     7F3A   ED 1210     12915   	sbc text_top
     7F3D   A5 27       12916   	lda index2+1
     7F3F   ED 1211     12917   	sbc text_top+1		;.C=1 if done, .C=0 if more
     7F42   60          12918   	rts
                        12919   
                        12920   ;.end
                        12921   
            =FF43       12922   	.ifge *-$8000			;..next rom starts at $8000
                        12923   	.messg "*** ADDRESS CHECK ***"
                        12924   	.endif
                        12925   
            =8000       12926   	*=$8000
                        12927   
                        12928   	.include fre		;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 153
FRE Function   FRE.SRC

Error Addr  Code          Seq   Source statement

                        12930   	.subttl FRE Function
                        12931   
                        12932   ;*****************************************************************************
                        12933   ; fre(n) function
                        12934   ;
                        12935   ;   where:
                        12936   ;	n=0 returns amount of free ram in bank 0. This is the area between
                        12937   ;	    top of text (TEXT_TOP) and top of available ram (MAX_MEM_0).
                        12938   ;	n=1 returns amount of free ram in bank 1. This is the area
                        12939   ;	    between top of arrays (STREND) and bottom of strings (FRETOP)
                        12940   ;
                        12941   ;*****************************************************************************
                        12942   
     8000   20 87F7     12943   fre	jsr conint	;get integer argument in .x
     8003   E0 01       12944   	cpx #1		;which bank?
     8005   90 05       12945   	bcc 1$		;go do bank zero
     8007   F0 31       12946   	beq 2$		;go do bank one
     8009   4C 7DC5     12947   	jmp fcerr	;any other is unpleasant to talk about
                        12948   
     800C   38          12949   1$	sec
     800D   AD 1212     12950   	lda max_mem_0
     8010   ED 1210     12951   	sbc text_top
     8013   A8          12952   	tay		;set up result for nosflt
     8014   AD 1213     12953   	lda max_mem_0+1
     8017   ED 1211     12954   	sbc text_top+1
     801A   B0 2B       12955   	bcs 3$
     801C   A6 35       12956   	ldx fretop
     801E   E8          12957   	inx
     801F   C8          12958   	iny
     8020   85 70       12959   	sta arisgn
     8022   98          12960   	tya
     8023   38          12961   	sec
     8024   E9 05       12962   	sbc #5
     8026   85 71       12963   	sta facov
     8028   A5 71       12964   4$	lda facov
     802A   5D AE37     12965   	eor $ae37,x
     802D   45 70       12966   	eor arisgn
     802F   F0 44       12967   	beq val_2
     8031   20 FFD2     12968   	jsr $ffd2
     8034   E6 71       12969   	inc facov
     8036   E8          12970   	inx
     8037   D0 EF       12971   	bne 4$
     8039   60          12972   	rts
                        12973   
     803A   20 92EA     12974   2$	jsr garba2	;do garbage collect
     803D   38          12975   	sec
     803E   A5 35       12976   	lda fretop
     8040   E5 33       12977   	sbc strend
     8042   A8          12978   	tay
     8043   A5 36       12979   	lda fretop+1
     8045   E5 34       12980   	sbc strend+1
     8047   4C 84C9     12981   3$	jmp nosflt	;go float the number
                        12982   
                        12983   ;end
                        12984   	.include val		;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 154
VAL function   VAL.SRC

Error Addr  Code          Seq   Source statement

                        12986   	.subttl VAL function
                        12987   
                        12988   ; The "val"function takes a string and turns it into a number by interpreting
                        12989   ; the ascii digits etc. Except for the problem that a terminator must be
                        12990   ; supplied by replacing the character beyond the string, VAL is merely a call
                        12991   ; to floating point input ("fin").
                        12992   
     804A   20 866E     12993   val	jsr len1	;get length
     804D   D0 03       12994   	bne val_1
     804F   4C 88D6     12995   	jmp zerofc	;return 0 if len=0
                        12996   ;
                        12997   ; use text to fp number code by faking a new text poiner
                        12998   ;
     8052   18          12999   val_1	clc
     8053   65 24       13000   	adc index1
     8055   85 72       13001   	sta strng2	;add len to index1 and put in strng2
     8057   A5 25       13002   	lda index1+1
     8059   69 00       13003   	adc #0
     805B   85 73       13004   	sta strng2+1
                        13005   
     805D   A0 00       13006   	ldy #0
     805F   A9 72       13007   	lda #strng2
     8061   20 03AB     13008   	jsr indsub_ram1	;replace character after string with $00 (fake eol)
     8064   48          13009   	pha		;save old character
     8065   98          13010   	tya		; (.A=0)
     8066   91 72       13011   	sta (strng2),y	;..and put in null.
     8068   20 8E03     13012   	jsr fin_chrget_2 ;get character pointed to and set flags.(sorta like chrgot)
     806B   A2 01       13013   	ldx #1			;flag 'bank 1'
     806D   20 8D22     13014   	jsr fin	  	;go do evaluation
     8070   68          13015   	pla		;get pres'd character.
     8071   A0 00       13016   	ldy #0
     8073   91 72       13017   	sta (strng2),y	;restore zeroed-out character
     8075   60          13018   val_2	rts
                        13019   
                        13020   ;end
                        13021   	.include dec		;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 155
DEC function   DEC.SRC

Error Addr  Code          Seq   Source statement

                        13023   	.subttl DEC function
                        13024   
                        13025   ;
                        13026   ; dec... convert a hex string representing
                        13027   ;	 a 2 byte integer into decimal
                        13028   
     8076   20 866E     13029   dcml	jsr len1	;find length of string
     8079   85 26       13030   	sta index2	;len ret. in a
     807B   A0 00       13031   	ldy #0
     807D   84 27       13032   	sty index2+1	;zero char counter
     807F   84 72       13033   	sty strng2	;zero out value
     8081   84 73       13034   	sty strng2+1
     8083               13035   dec010
     8083   C4 26       13036   	cpy index2	;evaluated all characters?
     8085   F0 34       13037   	beq dec050	;branch if so
     8087   20 03B7     13038   	jsr indin1_ram1	;get next character from string
     808A   C8          13039   	iny
     808B   C9 20       13040   	cmp #' '	;ignore spaces
     808D   F0 F4       13041   	beq dec010
     808F   E6 27       13042   	inc index2+1
     8091   A6 27       13043   	ldx index2+1
     8093   E0 05       13044   	cpx #5
     8095   F0 2B       13045   	beq decbad	;can't have more than 4 characters
                        13046   
     8097   C9 30       13047   	cmp #'0'
     8099   90 27       13048   	bcc decbad	;bad if < '0'
     809B   C9 3A       13049   	cmp #':'	;'9'+1
     809D   90 0A       13050   	bcc dec030	;ok if in '0'..'9'
     809F   C9 41       13051   	cmp #'A'
     80A1   90 1F       13052   	bcc decbad	;bad if > '9' & < 'a'
     80A3   C9 47       13053   	cmp #'G'
     80A5   B0 1B       13054   	bcs decbad	;bad if > 'f'
                        13055   
     80A7   E9 07       13056   	sbc #7	   	;adjust if in 'a'..'f'
     80A9               13057   dec030
     80A9   E9 2F       13058   	sbc #$2f	;adjust to $00..$0f
     80AB   0A          13059   	asl a	    	;shift low nibble to high
     80AC   0A          13060   	asl a
     80AD   0A          13061   	asl a
     80AE   0A          13062   	asl a
     80AF   A2 04       13063   	ldx #4	   	;mult. old val. by 16, add new
     80B1               13064   dec040
     80B1   0A          13065   	asl a
     80B2   26 72       13066   	rol strng2
     80B4   26 73       13067   	rol strng2+1
     80B6   CA          13068   	dex
     80B7   D0 F8       13069   	bne dec040
     80B9   F0 C8       13070   	beq dec010
                        13071   
     80BB               13072   dec050
     80BB   A4 72       13073   	ldy strng2	;get lsb of value,
     80BD   A5 73       13074   	lda strng2+1	;& msb,
     80BF   4C 84C9     13075   	jmp nosflt	;go float 2 byte unsigned integer
                        13076   
     80C2               13077   decbad

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 155-1
DEC function   DEC.SRC

Error Addr  Code          Seq   Source statement

     80C2   4C 7DC5     13078   	jmp fcerr	;illegal qty error
                        13079   
                        13080   ;.end
                        13081   	.include peekpoke

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 156
PEEK and POKE   PEEKPOKE.SRC

Error Addr  Code          Seq   Source statement

                        13083   	.subttl PEEK and POKE
                        13084    
                        13085   
     80C5   A5 17       13086   peek	lda poker+1		;..also happens to be LINNUM !
     80C7   48          13087   	pha
     80C8   A5 16       13088   	lda poker
     80CA   48          13089   	pha
     80CB   20 7877     13090   	jsr chknum
     80CE   20 8815     13091   	jsr getadr
     80D1   AE 03D5     13092   	ldx current_bank	;set up bank number for kernal's fetch
     80D4   A0 00       13093   	ldy #0			;..and index,
     80D6   A9 16       13094   	lda #poker		;..and address
     80D8   20 FF74     13095   	jsr _fetch		;doo-it too-it
     80DB   A8          13096   	tay
     80DC   68          13097   	pla
     80DD   85 16       13098   	sta poker	;get that byte.
     80DF   68          13099   	pla
     80E0   85 17       13100   	sta poker+1
     80E2   4C 84D4     13101   	jmp sngflt	;float it.
                        13102   
                        13103   
                        13104   
     80E5   20 8803     13105   poke	jsr getnum
     80E8   8A          13106   	txa		;set up value to store for kernal stash routine
     80E9   A0 00       13107   	ldy #0		;..and index
     80EB   A2 16       13108   	ldx #poker	;..and put address in _stash_vector
     80ED   8E 02B9     13109   	stx _stash_vector
     80F0   AE 03D5     13110   	ldx current_bank ;..finally, get the bank number		
     80F3   4C FF77     13111   	jmp _stash
                        13112   
                        13113   ;end
                        13114   	.include errfunc	;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 157
ERR$ Function   ERRFUNC.SRC

Error Addr  Code          Seq   Source statement

                        13116   	.subttl ERR$ Function
                        13117   
     80F6   20 87F7     13118   errd	jsr conint	;get integer arg in x
     80F9   CA          13119   	dex
     80FA   8A          13120   	txa
     80FB   C9 29       13121   	cmp #errlst	;check range
     80FD   B0 37       13122   	bcs errerr	;what would you call it?
     80FF   20 4A9F     13123   	jsr erstup
     8102   A0 FF       13124   	ldy #$ff
     8104   A2 00       13125   	ldx #0
                        13126   
     8106   E8          13127   1$	inx		;count printing characters
     8107   C8          13128   2$	iny
     8108   B1 26       13129   	lda (index2),y	;ind.ok
     810A   30 06       13130   	bmi 3$		;msb set means last
     810C   C9 20       13131   	cmp #$20
     810E   90 F7       13132   	bcc 2$		;don't count non-printers
     8110   B0 F4       13133   	bcs 1$		;count all others
                        13134   
     8112   8A          13135   3$	txa
     8113   20 8690     13136   	jsr strspa	;get space
     8116   A2 00       13137   	ldx #0
     8118   A0 FF       13138   	ldy #$ff
     811A   8D FF04     13139   	sta sw_rom_ram1	;set up string bank
                        13140   
     811D   C8          13141   4$	iny
     811E   B1 26       13142   	lda (index2),y	;this time, move chars
     8120   C9 20       13143   	cmp #$20
     8122   90 F9       13144   	bcc 4$
     8124   20 8139     13145   	jsr swapxy
     8127   48          13146   	pha
     8128   29 7F       13147   	and #$7f
     812A   91 64       13148   	sta (dsctmp+1),y
     812C   20 8139     13149   	jsr swapxy
     812F   E8          13150   	inx
     8130   68          13151   	pla		;test if msb was set
     8131   10 EA       13152   	bpl 4$
     8133   4C 85D1     13153   	jmp chrd1	;pla,pla,jmp putnew
                        13154   
     8136               13155   errerr
     8136   4C 7DC5     13156   	jmp fcerr	;bad value
                        13157   
     8139   48          13158   swapxy	pha
     813A   8A          13159   	txa
     813B   48          13160   	pha
     813C   98          13161   	tya
     813D   AA          13162   	tax
     813E   68          13163   	pla
     813F   A8          13164   	tay
     8140   68          13165   	pla
     8141   60          13166   	rts
                        13167   
                        13168   ;end
                        13169   	.include hexfunc	;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 158
HEX$ Function   HEXFUNC.SRC

Error Addr  Code          Seq   Source statement

                        13171   	.subttl HEX$ Function
                        13172   
     8142   20 7877     13173   hexd	jsr chknum
     8145   A5 16       13174   	lda poker
     8147   48          13175   	pha
     8148   A5 17       13176   	lda poker+1
     814A   48          13177   	pha
     814B   20 8815     13178   	jsr getadr	;2 byte val in (poker)
     814E   A9 04       13179   	lda #4
     8150   20 8690     13180   	jsr strspa
     8153   A0 00       13181   	ldy #0
     8155   A5 17       13182   	lda poker+1
     8157   8D FF04     13183   	sta sw_rom_ram1	;set up string bank
     815A   20 816B     13184   	jsr hexit
     815D   A5 16       13185   	lda poker
     815F   20 816B     13186   	jsr hexit
     8162   68          13187   	pla
     8163   85 17       13188   	sta poker+1
     8165   68          13189   	pla
     8166   85 16       13190   	sta poker
     8168   4C 85D1     13191   	jmp chrd1	;pla,pla,jmp putnew
                        13192   
     816B   48          13193   hexit	pha
     816C   4A          13194   	lsr a
     816D   4A          13195   	lsr a
     816E   4A          13196   	lsr a
     816F   4A          13197   	lsr a
     8170   20 8174     13198   	jsr dohex
     8173   68          13199   	pla
                        13200   
     8174   29 0F       13201   dohex	and #$0f
     8176   C9 0A       13202   	cmp #$0a
     8178   90 02       13203   	bcc 1$
     817A   69 06       13204   	adc #6
     817C   69 30       13205   1$	adc #'0'
     817E   91 64       13206   	sta (dsctmp+1),y
     8180   C8          13207   	iny
     8181   60          13208   	rts
                        13209   
                        13210   ;end
                        13211   	.include rgr		;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 159
RGR Function   RGR.SRC

Error Addr  Code          Seq   Source statement

                        13213   	.subttl RGR Function
                        13214   
                        13215   ;**********************************************************
                        13216   ;
                        13217   ;  rgr(n)  --  return graphic mode
                        13218   ;
                        13219   ;	result = graphm + mode*5
                        13220   ;
                        13221   ;**********************************************************
                        13222   
     8182   20 7877     13223   rgr	jsr chknum
     8185   20 818C     13224   	jsr unpack_graphm
     8188   A8          13225   	tay
     8189   4C 84D4     13226   	jmp sngflt	;return value (0-9)
                        13227   
                        13228   
                        13229   
                        13230   
     818C               13231   unpack_graphm
     818C   A5 D8       13232   	lda _graphm	;convert _graphm back to GRAPHIC args
     818E   18          13233   	clc
     818F   2A          13234   	rol a
     8190   2A          13235   	rol a
     8191   2A          13236   	rol a
     8192   69 00       13237   	adc #0
     8194   24 D7       13238   	bit _mode	;factor into this the current text screen (40/80)
     8196   10 02       13239   	bpl 10$
     8198   69 05       13240   	adc #5		;(it is 80)
     819A   60          13241   10$	rts
                        13242   
                        13243   ;end
                        13244   	.include rclr		;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 160
RCLR Function   RCLR.SRC

Error Addr  Code          Seq   Source statement

                        13246   	.subttl RCLR Function
                        13247   
                        13248   ;**********************************************************
                        13249   ;
                        13250   ;  rclr(n)  --  return color
                        13251   ;		 n = 0  :  vic background color
                        13252   ;		     1  :  graphic foreground color
                        13253   ;		     2  :  multicolor-1
                        13254   ;		     3  :  multicolor-2
                        13255   ;		     4  :  vic border color
                        13256   ;		     5  :  text color (of current screen)
                        13257   ;		     6  :  8563 background color
                        13258   ;
                        13259   ;**********************************************************
                        13260   
     819B   20 87F7     13261   rclr	jsr conint      	;evaluate integer argument, put in x
     819E   20 A855     13262   	jsr put_io_in_map
                        13263   
     81A1   CA          13264   	dex
     81A2   30 15       13265   	bmi 10$			;0, vic background
     81A4   CA          13266   	dex
     81A5   30 1A       13267   	bmi 20$			;1, graphic foreground
     81A7   CA          13268   	dex
     81A8   30 1C       13269   	bmi 30$			;2, graphic multicolor 1
     81AA   CA          13270   	dex
     81AB   30 1E       13271   	bmi 40$			;3, graphic multicolor 2
     81AD   CA          13272   	dex
     81AE   30 20       13273   	bmi 50$			;4, vic border
     81B0   CA          13274   	dex
     81B1   30 23       13275   	bmi 60$			;5, current text color
     81B3   CA          13276   	dex
     81B4   30 28       13277   	bmi 70$			;6, 8563 background
     81B6   4C 7DC5     13278   	jmp fcerr		;illegal value error
                        13279   
     81B9   AD D021     13280   10$	lda vic_background
     81BC   29 7F       13281   	and #$7f		;(msb is garbage)
     81BE   4C 81EC     13282   	jmp 100$
                        13283   
     81C1   A5 86       13284   20$	lda foreground 		;(1)
     81C3   4C 81EC     13285   	jmp 100$
                        13286   
     81C6   A5 84       13287   30$	lda multicolor_1 	;(2)
     81C8   4C 81EC     13288   	jmp 100$
                        13289   
     81CB   A5 85       13290   40$	lda multicolor_2 	;(3)
     81CD   4C 81EC     13291   	jmp 100$
                        13292   
     81D0   AD D020     13293   50$	lda vic_border		;border (4)
     81D3   4C 81EC     13294   	jmp 100$
                        13295   	
     81D6   A5 F1       13296   60$	lda _text_color		;(5)
     81D8   24 D7       13297   	bit _mode
     81DA   10 10       13298   	bpl 100$		; done if 40 col screen
     81DC   30 08       13299   	bmi 75$			; adjust if 80 column
                        13300   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 160-1
RCLR Function   RCLR.SRC

Error Addr  Code          Seq   Source statement

     81DE   A9 1A       13301   70$	lda #26			;(6)
     81E0   8D D600     13302   	sta _8563_addr
     81E3   AD D601     13303   	lda _8563_data
     81E6   29 0F       13304   75$	and #$0f
     81E8   AA          13305   	tax
     81E9   BD 81F3     13306   	lda _8563_unadjust,x
                        13307   
                        13308   
     81EC   29 0F       13309   100$	and #$0f
     81EE   A8          13310   	tay
     81EF   C8          13311   	iny			;make color match keytops
     81F0   4C 84D4     13312   	jmp sngflt      	;float 1 byte arg. in y
                        13313   
                        13314   
     81F3               13315   _8563_unadjust
     81F3   00 0C 06    13316   	.byte $0,$c,$6,$e,$5,$d,$b,$3
     81F6   0E 05 0D            
     81F9   0B 03               
     81FB   02 0A 08    13317   	.byte $2,$a,$8,$4,$9,$7,$f,$1
     81FE   04 09 07            
     8201   0F 01               
                        13318   ;end
                        13319   	.include joy		;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 161
JOY Function   JOY.SRC

Error Addr  Code          Seq   Source statement

                        13321   	.subttl JOY Function
                        13322   
                        13323   ;*************************************************************
                        13324   ;
                        13325   ;  joy(n)  --  return joy-stick value
                        13326   ;	   n =  1 : joystick-1
                        13327   ;		2 : joystick-2
                        13328   ;	   result  =      0-8 : not triggered
                        13329   ;			128-136 : triggered
                        13330   ;	   result mod 128 =  0 : no joystick reading
                        13331   ;
                        13332   ;				      1
                        13333   ;				   8     2
                        13334   ;				7	    3
                        13335   ;				   6     4
                        13336   ;				      5
                        13337   ;
                        13338   ;*************************************************************
                        13339   
     8203   20 87F7     13340   joy	jsr conint		;get 1 byte arg in x
     8206   CA          13341   	dex
     8207   E0 02       13342   	cpx #2			;make sure arg. is valid
     8209   B0 34       13343   	bcs 30$			;>1, error
                        13344   
     820B   8A          13345   	txa
     820C   49 01       13346   	eor #1
     820E   AA          13347   	tax			;invert to match legends on case
                        13348   
     820F   08          13349   	php			;save status
     8210   20 A855     13350   	jsr put_io_in_map
     8213   78          13351   	sei			;disable irq to inhibit kybd
     8214   AD DC00     13352   	lda d1pra
     8217   48          13353   	pha			;save kybd output lines
     8218   A0 FF       13354   	ldy #$ff
     821A   8C DC00     13355   	sty d1pra		;set to not read any kybd inputs
                        13356   
     821D   BD DC00     13357   10$	lda d1pra,x		;read joystick values
     8220   DD DC00     13358   	cmp d1pra,x		;debounce
     8223   D0 F8       13359   	bne 10$
                        13360   
     8225   AA          13361   	tax			;save joystick values
     8226   68          13362   	pla
     8227   8D DC00     13363   	sta d1pra		;reset kybd output lines
     822A   8A          13364   	txa			;restore joystick values
     822B   28          13365   	plp			;restore status
     822C   29 0F       13366   	and #$0f 		;test which direction
     822E   A8          13367   	tay
     822F   B9 823D     13368   	lda joytab-5,y		;get direction indicator
     8232   A8          13369   	tay			;save direction : 0-8
     8233   8A          13370   	txa			;restore joystick value
     8234   29 10       13371   	and #$10		;test if button triggered
     8236   D0 04       13372   	bne 20$			;skip if not
     8238   98          13373   	tya
     8239   09 80       13374   	ora #$80 		;show trigger depressed
     823B   A8          13375   	tay

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 161-1
JOY Function   JOY.SRC

Error Addr  Code          Seq   Source statement

     823C   4C 84D4     13376   20$	jmp sngflt		;float 1 byte arg in y.
                        13377   
     823F   4C 7DC5     13378   30$	jmp fcerr
                        13379   
     8242   04 02 03    13380   joytab	.byte 4,2,3,0,6,8,7,0,5,1,0
     8245   00 06 08            
     8248   07 00 05            
     824B   01 00               
                        13381   
                        13382   ;end
                        13383   	.include penpot		;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 162
PEN / POT functions   PENPOT.SRC

Error Addr  Code          Seq   Source statement

                        13385   	.subttl PEN / POT functions
                        13386   
                        13387   ;***********************************************************
                        13388   ;
                        13389   ;	pot(n)  --  read paddles
                        13390   ;
                        13391   ;	   n =	1 : paddle-1 - x-position
                        13392   ;		2 : paddle-1 - y-position
                        13393   ;		3 : paddle-2 - x-position
                        13394   ;		4 : paddle-2 - y-position
                        13395   ;
                        13396   ;	    result >= 256 --  trigger set
                        13397   ;***********************************************************
                        13398   
     824D   20 79F3     13399   pot	jsr chkcls	;look for closing paren
     8250   20 87F7     13400   	jsr conint	;get 1 byte arg in .X
     8253   CA          13401   	dex
     8254   E0 04       13402   	cpx #4
     8256   B0 53       13403   	bcs pot_error	;value error
                        13404   
     8258   20 A855     13405   	jsr put_io_in_map
     825B   A0 00       13406   	ldy #0
     825D   8A          13407   	txa
     825E   A2 40       13408   	ldx #$40
     8260   4A          13409   	lsr a	    	;test if x-pos or y-pos
     8261   90 01       13410   	bcc 10$		;skip if x-position
     8263   C8          13411   	iny		;increment offset into sidreg
     8264   4A          13412   10$	lsr a
     8265   90 02       13413   	bcc 20$
     8267   A2 80       13414   	ldx #$80
     8269   8E 12B1     13415   20$	stx pot_temp_1	;a temp
     826C   08          13416   	php		;save status
     826D   78          13417   	sei		;disable irq - to inhibit keyboard
     826E   AD DC00     13418   	lda d1pra
     8271   48          13419   	pha		;save kybd output lines
     8272   8E DC00     13420   	stx d1pra		;turn on correct paddle
     8275   A2 00       13421   	ldx #0
                        13422   
     8277   E8          13423   30$	inx		;delay to let pots be read by sid
     8278   D0 FD       13424   	bne 30$
                        13425   
     827A   B9 D419     13426   40$	lda sid+25,y	;read x or y pot
     827D   D9 D419     13427   	cmp sid+25,y	;debounce
     8280   D0 F8       13428   	bne 40$
                        13429   
     8282   8D 12B2     13430   	sta pot_temp_2	;save pot value
     8285   A2 00       13431   	ldx #0	   	;set index to d1pra
     8287   2C 12B1     13432   	bit pot_temp_1	;test if pot-0,1 or pot-2,3
     828A   30 01       13433   	bmi 50$		;skip if pot 2,3
     828C   E8          13434   	inx		;index to d1prb
     828D   A9 04       13435   50$	lda #04	  	;use joy line-2
     828F   88          13436   	dey		;test if pot-x or pot-y
     8290   30 01       13437   	bmi 60$		;skip if pot-x
     8292   0A          13438   	asl a	    	;use joy line-3
     8293   A0 FF       13439   60$	ldy #$ff

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 162-1
PEN / POT functions   PENPOT.SRC

Error Addr  Code          Seq   Source statement

     8295   8C DC00     13440   	sty d1pra	;disable kybd inpts
     8298   C8          13441   	iny		;set to zero for no trigger
     8299   3D DC00     13442   	and d1pra,x     ;test if trigger set
     829C   D0 01       13443   	bne 70$		;skip if not trigger
     829E   C8          13444   	iny		;return value >255 for trigger
     829F   68          13445   70$	pla
     82A0   8D DC00     13446   	sta d1pra	;restore kybd output lines
     82A3   98          13447   	tya
     82A4   AC 12B2     13448   	ldy pot_temp_2	;restore pot value
     82A7   28          13449   	plp		;restore status
     82A8   4C 84C9     13450   	jmp nosflt	;output 2-byte result
                        13451   
     82AB               13452   pot_error
     82AB   4C 7DC5     13453   	jmp fcerr

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 163
PEN / POT functions   PENPOT.SRC

Error Addr  Code          Seq   Source statement

                        13455   
                        13456   ;*************************************************************
                        13457   ;
                        13458   ;  pen(n)  --  read light pen
                        13459   ;
                        13460   ;	n = 0	vic pen, x pos'n
                        13461   ;	    1	vic pen, y pos'n
                        13462   ;	    2	8563 pen, x pos'n
                        13463   ;	    3   8563 pen, y pos'n
                        13464   ;	    4   8563 trigger
                        13465   ;
                        13466   ;*************************************************************
                        13467   
     82AE   20 79F3     13468   pen	jsr chkcls		;look for closing parens
     82B1   20 87F7     13469   	jsr conint		;get 1 byte arg in .X
     82B4   E0 05       13470   	cpx #5
     82B6   B0 F3       13471   	bcs pot_error		;bad value
     82B8   E0 02       13472   	cpx #2
     82BA   B0 1A       13473   	bcs 20$			;8563
                        13474   
     82BC   BC 11E9     13475   	ldy vic_save+19,x	;get light pen value
     82BF   8C 12B1     13476   	sty pot_temp_1		;a temp
     82C2   A9 00       13477   	lda #0
     82C4   9D 11E9     13478   	sta vic_save+19,x	;reset to zero
     82C7   E0 00       13479   	cpx #0
     82C9   D0 05       13480   	bne 10$			;skip if y position
     82CB   0E 12B1     13481   	asl pot_temp_1    	;multiply * 2 if x position
     82CE   69 00       13482   	adc #0			;make .A = 1 iff a bit rippled out of lsb
     82D0   AC 12B1     13483   10$	ldy pot_temp_1		;get lsb in .Y, msb's in .A,...
     82D3   4C 84C9     13484   	jmp nosflt		;float it
                        13485   
     82D6   20 A855     13486   20$	jsr put_io_in_map
     82D9   E0 04       13487   	cpx #4
     82DB   F0 10       13488   	beq 40$
                        13489   
     82DD   A0 11       13490   	ldy #17			;assume x (2) (r17)
     82DF   E0 02       13491   	cpx #2
     82E1   F0 01       13492   	beq 30$
     82E3   88          13493   	dey			;el-wrongo. it was y (3) (r16)
     82E4   8C D600     13494   30$	sty _8563_addr
     82E7   AC D601     13495   	ldy _8563_data
     82EA   4C 84D4     13496   	jmp sngflt		;float 1 byte arg in .Y
                        13497   
     82ED   AD D600     13498   40$	lda _8563_addr		;read status
     82F0   A0 00       13499   	ldy #0			;assume no l.p. trigger
     82F2   29 40       13500   	and #64
     82F4   F0 01       13501   	beq 50$
     82F6   C8          13502   	iny			;wrong - bit was set. return 1
     82F7   4C 84D4     13503   50$	jmp sngflt
                        13504   
                        13505   ;end
                        13506   	.include pointer	;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 164
POINTER Command   POINTER.SRC

Error Addr  Code          Seq   Source statement

                        13508   	.subttl POINTER Command
                        13509   
                        13510   ;******************************************************************
                        13511   ;
                        13512   ; POINTER(var_name) - return address of descriptor for var_name
                        13513   ;
                        13514   ;******************************************************************
                        13515   
     82FA   20 0380     13516   pointer	jsr chrget		;skip over escape token
     82FD   20 79F6     13517   	jsr chkopn		;test for open paren
     8300   20 7BD9     13518   	jsr isletc		;test if character follows parens
     8303   90 16       13519   	bcc pointer_err		;...syntax error if not.
     8305   20 7B4C     13520   	jsr ptrget		;look for this varname in table
            =8307       13521   pointer_ret=*-1
     8308   AA          13522   	tax
     8309   98          13523   	tya
     830A   48          13524   	pha
     830B   20 79F3     13525   	jsr chkcls		;look for closing paren
     830E   8A          13526   	txa
     830F   A8          13527   	tay
     8310   68          13528   	pla
     8311   C9 03       13529   	cmp #>zero		;is this a dummy pointer?
     8313   D0 03       13530   	bne 10$
     8315   A9 00       13531   	lda #0			;if so, return 0
     8317   A8          13532   	tay
     8318   4C 84C9     13533   10$	jmp nosflt
                        13534   
     831B               13535   pointer_err
     831B   4C 7A09     13536   	jmp snerr		;syntax error
                        13537   
                        13538   ;end
                        13539   	.include rsprite	;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 165
RSPRITE Function   RSPRITE.SRC

Error Addr  Code          Seq   Source statement

                        13541   	.subttl RSPRITE Function
                        13542   
                        13543   ;******************************************************************
                        13544   ;*
                        13545   ;*	RSPRITE - Return sprite information
                        13546   ;*
                        13547   ;*	Syntax : RSPRITE (sprite_number, argument)
                        13548   ;*
                        13549   ;*	Where  : sprite_number = [1..8]
                        13550   ;*		 argument = [0..5]
                        13551   ;*			0 : enabled?	(y(1)/n(0))
                        13552   ;*			1 : color?  (1..16)
                        13553   ;*			2 : prioroty over background? (y(1)/n(0))
                        13554   ;*			3 : expand in x direction? (y(1)/n(0))
                        13555   ;*			4 : expand in Y direction? (y(1)/n(0))
                        13556   ;*			5 : multicolor sprite?     (y(1)/n(0))
                        13557   ;******************************************************************
                        13558   
     831E   20 87F7     13559   rsprite	jsr conint	;get first arg, sprite #, in .X
     8321   CA          13560   	dex		;adjust [1..8] to [0..7]
     8322   E0 08       13561   	cpx #8		; (318018-03 mod; fab)
     8324   B0 32       13562   	bcs 98$		;value error
     8326   8A          13563   	txa
     8327   48          13564   	pha		;save sprite number
                        13565   
     8328   20 79F9     13566   	jsr chkcom	;check for proper delimiter
     832B   20 87F4     13567   	jsr getbyt	;do frmevl, get 1 byte arg (arg) in .X
     832E   20 79F3     13568   	jsr chkcls	;look for closing paren
                        13569   
     8331   E0 06       13570   	cpx #6
     8333   B0 23       13571   	bcs 98$		;value error
                        13572   
     8335   68          13573   	pla		;sprite number
     8336   A8          13574   	tay
     8337   20 A855     13575   	jsr put_io_in_map
     833A   B9 D027     13576   	lda vic+39,y	;assume 'color'
     833D   29 0F       13577   	and #$0f
     833F   18          13578   	clc
     8340   69 01       13579   	adc #1		;adjust to 'keyboard' colors
     8342   E0 01       13580   	cpx #1
     8344   F0 0E       13581   	beq 10$		;it was color. set up for float
                        13582   
     8346   BD 835B     13583   	lda rspmod,x	;get index for this function
     8349   AA          13584   	tax
     834A   B9 6D50     13585   	lda sbits,y	;get mask for this sprite number
                        13586   
     834D   3D D000     13587   	and vic,x
     8350   F0 02       13588   	beq 10$
     8352   A9 01       13589   	lda #1		;return all non-zeros as '1'
                        13590   
     8354   A8          13591   10$	tay
     8355   4C 84D4     13592   	jmp sngflt	;go float 1 byte arg in .Y
                        13593   
                        13594   
     8358   4C 7DC5     13595   98$	jmp fcerr	;bad value error

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 165-1
RSPRITE Function   RSPRITE.SRC

Error Addr  Code          Seq   Source statement

                        13596   
     835B   15 27 1B    13597   rspmod .byte 21,39,27,29,23,28	;table in indices
     835E   1D 17 1C            
                        13598   
                        13599   ;end
                        13600   
                        13601   	.include rspcolor	;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 166
RSPCOLOR Function   RSPCOLOR.SRC

Error Addr  Code          Seq   Source statement

                        13603   	.subttl RSPCOLOR Function
                        13604   
                        13605   ;******************************************************************
                        13606   ;*
                        13607   ;*	RSPCOLOR - return sprite multicolor reg's
                        13608   ;*
                        13609   ;*	Syntax : RSPCOLOR (argument)
                        13610   ;*
                        13611   ;*	Where  : argument = [1..2]
                        13612   ;*			1 : return multicolor #1
                        13613   ;*			2 : return multicolor #2
                        13614   ;*
                        13615   ;******************************************************************
                        13616   
     8361               13617   rspcolor
     8361   20 79F3     13618   	jsr chkcls	;check for closing paren
     8364   20 87F7     13619   	jsr conint	;get arg in .X
     8367   CA          13620   	dex		;adjust [1..2] to [0..1
     8368   E0 02       13621   	cpx #2
     836A   B0 0D       13622   	bcs 98$		;value error
                        13623   
     836C   20 A855     13624   	jsr put_io_in_map
     836F   BD D025     13625   	lda vic+37,x
     8372   29 0F       13626   	and #$0f
     8374   A8          13627   	tay
     8375   C8          13628   	iny
     8376   4C 84D4     13629   	jmp sngflt	;float 1 byte arg in .Y
                        13630   
                        13631   
     8379   4C 7DC5     13632   98$	jmp fcerr	;bad value error
                        13633   
                        13634   ;end
                        13635   	.include bump		;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 167
BUMP Function   BUMP.SRC

Error Addr  Code          Seq   Source statement

                        13637   	.subttl BUMP Function
                        13638   
                        13639   ;******************************************************************
                        13640   ;*
                        13641   ;*	BUMP - read sprite collision
                        13642   ;*
                        13643   ;*	Syntax : BUMP (argument)
                        13644   ;*
                        13645   ;*	Where  : argument = [1..2]
                        13646   ;*			1 : sprite/sprite collision
                        13647   ;*			2 : sprite/background collision
                        13648   ;*
                        13649   ;******************************************************************
                        13650   
     837C   20 79F3     13651   bump	jsr chkcls
     837F   20 87F7     13652   	jsr conint		;get arg in .X
     8382   CA          13653   	dex			;adjust [1..2] to [0..1
     8383   E0 02       13654   	cpx #2
     8385   B0 0D       13655   	bcs 98$			;value error
                        13656   
     8387   78          13657   	sei
     8388   BC 11E7     13658   	ldy vic_save+17,x	;get collision info
     838B   A9 00       13659   	lda #0
     838D   9D 11E7     13660   	sta vic_save+17,x	;..and reset for next read
     8390   58          13661   	cli
                        13662   
     8391   4C 84D4     13663   	jmp sngflt	;float 1 byte arg in .Y
                        13664   
                        13665   
     8394   4C 7DC5     13666   98$	jmp fcerr	;bad value error
                        13667   
                        13668   ;end
                        13669   	.include rsppos		;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 168
RSPPOS Function   RSPPOS.SRC

Error Addr  Code          Seq   Source statement

                        13671   	.subttl RSPPOS Function
                        13672   
                        13673   ;******************************************************************
                        13674   ;*
                        13675   ;*	RSPPOS - Return sprite location / speed data
                        13676   ;*
                        13677   ;*	Syntax : RSPPOS (sprite_number, argument)
                        13678   ;*
                        13679   ;*	Where  : sprite_number = [1..8]
                        13680   ;*		 argument = [0..2]
                        13681   ;*			0 : return X position
                        13682   ;*			1 : return Y position
                        13683   ;*			2 : return current speed
                        13684   ;*
                        13685   ;******************************************************************
                        13686   
     8397   20 87F7     13687   rsppos	jsr conint	;get first arg, sprite #, in .X
     839A   CA          13688   	dex		;adjust [1..8] to [0..7]
     839B   E0 08       13689   	cpx #8		; (318018-03 mod; fab)
     839D   B0 3F       13690   	bcs 98$		;value error
     839F   8A          13691   	txa
     83A0   48          13692   	pha		;save sprite number
                        13693   
     83A1   20 79F9     13694   	jsr chkcom	;check for proper delimiter
     83A4   20 87F4     13695   	jsr getbyt	;do frmevl, get 1 byte arg (arg) in .X
     83A7   20 79F3     13696   	jsr chkcls	;look for closing paren
                        13697   
     83AA   E0 03       13698   	cpx #3
     83AC   B0 30       13699   	bcs 98$		;value error
                        13700   
     83AE   68          13701   	pla		;sprite number
     83AF   A8          13702   	tay
     83B0   E0 02       13703   	cpx #2
     83B2   D0 09       13704   	bne 10$		;branch if x or y position
                        13705   
     83B4   BE 6E76     13706   	ldx sproff,y	;get offset into speed data
     83B7   BC 117E     13707   	ldy sprite_data,x	;get speed data
     83BA   4C 84D4     13708   	jmp sngflt	;go float 1 byte arg in .Y
                        13709   
                        13710   ; get msb of sprite position (in case this is for x position)
                        13711   
     83BD   78          13712   10$	sei
     83BE   B9 6D50     13713   	lda sbits,y	;get bit mask for this sprite
     83C1   2D 11E6     13714   	and vic_save+16
     83C4   F0 02       13715   	beq 20$
     83C6   A9 01       13716   	lda #1		;change any non-zero to a '1'
     83C8   48          13717   20$	pha		;save msb
                        13718   
     83C9   98          13719   	tya		;y = sprite# * 2
     83CA   0A          13720   	asl a
     83CB   A8          13721   	tay
     83CC   8A          13722   	txa		;see if this is y position
     83CD   4A          13723   	lsr a		;.C = 0 for x pos'n, 1 for y pos'n
     83CE   90 05       13724   	bcc 30$		branch if x pos'n
                        13725   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 168-1
RSPPOS Function   RSPPOS.SRC

Error Addr  Code          Seq   Source statement

     83D0   C8          13726   	iny		;adjust pointer to point to y pos'n in register data
     83D1   68          13727   	pla
     83D2   A9 00       13728   	lda #0		;..and force 'msb' to be zero
     83D4   48          13729   	pha
                        13730   
     83D5   B9 11D6     13731   30$	lda vic_save,y	;get correct location lsb
     83D8   58          13732   	cli
     83D9   A8          13733   	tay
     83DA   68          13734   	pla		;..and get msb,
     83DB   4C 84C9     13735   	jmp nosflt	;..and go float 2 byte value in y,a
                        13736   
     83DE   4C 7DC5     13737   98$	jmp fcerr	;bad value error
                        13738   
                        13739   ;end
                        13740   	.include xor		;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 169
XOR Function   XOR.SRC

Error Addr  Code          Seq   Source statement

                        13742   	.subttl XOR Function
                        13743   
                        13744   ;**************************************************************
                        13745   ;*
                        13746   ;*   XOR - exclusive-or two 16 bit arguments
                        13747   ;*
                        13748   ;*	syntax : XOR (arg1, arg2)
                        13749   ;*
                        13750   ;**************************************************************
                        13751   
     83E1   A5 16       13752   xor	lda poker	;protect the $*^%$*^(? poker value (could be in use)
     83E3   48          13753   	pha
     83E4   A5 17       13754   	lda poker+1
     83E6   48          13755   	pha
                        13756   
     83E7   20 7877     13757   	jsr chknum
     83EA   20 8815     13758   	jsr getadr	;get first arg
     83ED   48          13759   	pha		;save MSB
     83EE   98          13760   	tya
     83EF   48          13761   	pha		;save LSB
                        13762   
     83F0   20 880F     13763   	jsr comwrd	;check for comma, get word
     83F3   20 79F3     13764   	jsr chkcls	;check for closing parens
                        13765   
     83F6   68          13766   	pla
     83F7   45 16       13767   	eor poker	;xor LSB (comwrd left a copy of it's arg in POKER)
     83F9   A8          13768   	tay
     83FA   68          13769   	pla
     83FB   45 17       13770   	eor poker+1	;..and MSB
     83FD   20 84C9     13771   	jsr nosflt	;..and go float 'em
                        13772   
     8400   68          13773   	pla
     8401   85 17       13774   	sta poker+1
     8403   68          13775   	pla
     8404   85 16       13776   	sta poker
                        13777   
     8406   60          13778   	rts
                        13779   
                        13780   ;end
                        13781   	.include rwindow	;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 170
RWINDOW Function   RWINDOW.SRC

Error Addr  Code          Seq   Source statement

                        13783   	.subttl RWINDOW Function
                        13784   
                        13785   ;******************************************************************************
                        13786   ;
                        13787   ; RWINDOW  - returns information about the current console display environment.
                        13788   ;
                        13789   ;   syntax : RWINDOW (n)
                        13790   ;
                        13791   ;   where:	n=0 : number of lines in the current window
                        13792   ;		 =1 : number of rows in the current window
                        13793   ;		 =2 : returns either 40 or 80, depending on the
                        13794   ;			current console device
                        13795   ;
                        13796   ;******************************************************************************
                        13797   
     8407   20 79F3     13798   rwindow	jsr chkcls
     840A   20 87F7     13799   	jsr conint
     840D   E0 02       13800   	cpx #2
     840F   F0 14       13801   	beq 50$			;return current console
     8411   B0 1E       13802   	bcs 98$
                        13803   
     8413   E0 00       13804   	cpx #0
     8415   D0 07       13805   	bne 10$
                        13806   
     8417   A5 E4       13807   	lda _screen_bottom
     8419   38          13808   	sec
     841A   E5 E5       13809   	sbc _screen_top
     841C   B0 0F       13810   	bcs 60$			;always
                        13811   
     841E   A5 E7       13812   10$	lda _screen_right
     8420   38          13813   	sec
     8421   E5 E6       13814   	sbc _screen_left
     8423   B0 08       13815   	bcs 60$			;always
                        13816   
                        13817   
     8425   A9 28       13818   50$	lda #40			;assume VIC
     8427   24 D7       13819   	bit _mode
     8429   10 02       13820   	bpl 60$
     842B   A9 50       13821   	lda #80
     842D   A8          13822   60$	tay
     842E   4C 84D4     13823   	jmp sngflt		;float 1 byte arg in .Y
                        13824   
     8431   4C 7DC5     13825   98$	jmp fcerr
                        13826   
                        13827   ;end
                        13828   	.include rnd		;function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 171
RND Function   RND.SRC

Error Addr  Code          Seq   Source statement

                        13830   	.subttl RND Function
                        13831   
                        13832   ;    random number function.  rnd(x) where:
                        13833   ;      x=0 ==> generate a random number based on hardware clock
                        13834   ;      x<0 ==> seed a reproducable, pseudo-random number generator
                        13835   ;      x>0 ==> generate a reproducable pseudo-random # based on
                        13836   ;		seed value above.
                        13837   
     8434               13838   rnd
     8434   20 8C57     13839   	jsr sign		;get sign into accb.
     8437   30 31       13840   rnd_0	bmi rnd1
     8439   D0 1A       13841   	bne qsetnr
                        13842   
                        13843   ; get value from hardware timers
                        13844   
     843B   20 A855     13845   	jsr put_io_in_map
     843E   AD DC06     13846   	lda d1pra+6		;timer b is free-running,
     8441   85 64       13847   	sta facho
     8443   AD DC07     13848   	lda d1pra+7
     8446   85 66       13849   	sta facmo
     8448   AD DC04     13850   	lda d1pra+4		;..timer a isn't
     844B   85 65       13851   	sta facmoh
     844D   AD DC05     13852   	lda d1pra+5
     8450   85 67       13853   	sta faclo
     8452   4C 847A     13854   	jmp strnex
                        13855   
                        13856   
     8455   A9 1B       13857   qsetnr	lda #<rndx		;get last one into fac.
     8457   A0 12       13858   	ldy #>rndx
     8459   20 8BD4     13859   	jsr movfm
     845C   A9 90       13860   	lda #<rmulc
     845E   A0 84       13861   	ldy #>rmulc		;fac was zero. restore last one
     8460   20 8A08     13862   	jsr rommlt		;multiply by random constant.
     8463   A9 95       13863   	lda #<raddc
     8465   A0 84       13864   	ldy #>raddc
     8467   20 8A12     13865   	jsr romadd		;add random constant.
                        13866   
     846A   A6 67       13867   rnd1	ldx faclo
     846C   A5 64       13868   	lda facho
     846E   85 67       13869   	sta faclo
     8470   86 64       13870   	stx facho		;reverse hi and lo.
     8472   A6 65       13871   	ldx facmoh
     8474   A5 66       13872   	lda facmo
     8476   85 65       13873   	sta facmoh
     8478   86 66       13874   	stx facmo
                        13875   
     847A   A9 00       13876   strnex	lda #0			;make number positive.
     847C   85 68       13877   	sta facsgn
     847E   A5 63       13878   	lda facexp		;put exp where it wil
     8480   85 71       13879   	sta facov		;be shifted in by normal.
     8482   A9 80       13880   	lda #@200
     8484   85 63       13881   	sta facexp		;make result between 0 and 1.
     8486   20 88B6     13882   	jsr normal		;normalize.
     8489   A2 1B       13883   	ldx #<rndx
     848B   A0 12       13884   	ldy #>rndx

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 171-1
RND Function   RND.SRC

Error Addr  Code          Seq   Source statement

     848D   4C 8C00     13885   	jmp movmf		;put new one into memory.
                        13886   
                        13887   
     8490   98 35 44    13888   rmulc  .byte @230,@65,@104,@172,0
     8493   7A 00               
     8495   68 28 B1    13889   raddc  .byte @150,@50,@261,@106,0
     8498   46 00               
                        13890   
                        13891   	;end
                        13892   	.include code12

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 172
'code12'   CODE12.SRC

Error Addr  Code          Seq   Source statement

                        13894   	.subttl 'code12'
     849A   90 80 00    13895   n32768	.byte 144,128,0,0,0
     849D   00 00               
                        13896   
     849F   20 84B4     13897   flpint	jsr ayint
     84A2   A5 66       13898   	lda facmo
     84A4   A4 67       13899   	ldy  faclo
     84A6   60          13900   	rts
                        13901   
     84A7   20 0380     13902   intidx	jsr chrget
     84AA   20 788C     13903   	jsr frmevl	;get a number
                        13904   
     84AD   20 7877     13905   posint	jsr chknum
     84B0   A5 68       13906   	lda facsgn
     84B2   30 0D       13907   	bmi nonono	;if negative, blow him out.
                        13908   
     84B4   A5 63       13909   ayint	lda facexp
     84B6   C9 90       13910   	cmp #144	;fac .gt. 32767?
     84B8   90 0C       13911   	bcc qintgo
     84BA   A9 9A       13912   	lda #<n32768	;get address of -32768.
     84BC   A0 84       13913   	ldy #>n32768
     84BE   20 8C87     13914   	jsr fcomp	;see if fac=((x)).
                        13915   
     84C1   F0 03       13916   nonono	beq qintgo
     84C3   4C 7DC5     13917   	jmp fcerr	;no, fac is too big.
                        13918   
     84C6   4C 8CC7     13919   qintgo	jmp qint	;go to wint and shove it.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 173
'code12'   CODE12.SRC

Error Addr  Code          Seq   Source statement

                        13921   
                        13922   ; float an unsigned double byte integer
                        13923   ; entry: msb in a, lsb in y
                        13924   
     84C9   20 84E5     13925   nosflt	jsr stoint
     84CC   38          13926   	sec	      	;sign is positive
     84CD   4C 8C75     13927   	jmp floatc
                        13928   
                        13929   
                        13930   
     84D0   38          13931   pos	sec
     84D1   20 928D     13932   	jsr k_jplot	;get tab pos in .y
                        13933   
     84D4   A9 00       13934   sngflt	lda #0
     84D6   4C 79D9     13935   	jmp givayf	;float it
                        13936   
                        13937   ;
                        13938   ;subroutine to see if we are in direct mode,
                        13939   ;and complain if so.
                        13940   
     84D9   24 7F       13941   errdir	bit runmod	;direct mode?
     84DB   30 12       13942   	bmi storts	;no
     84DD   A2 15       13943   	ldx #errid	;input direct error code.
     84DF   2C          13944   	.byte $2c
     84E0   A2 1B       13945   errguf	ldx #erruf
     84E2   4C 4D59     13946   	jmp error
                        13947   
                        13948   
                        13949   
     84E5   A2 00       13950   stoint	ldx #0		;move int to fac & compute proper exponents
     84E7   86 0F       13951   	stx valtyp
     84E9   85 64       13952   	sta facho
     84EB   84 65       13953   	sty facho+1
     84ED   A2 90       13954   	ldx #$90
     84EF   60          13955   storts	rts
                        13956   
                        13957   
                        13958   
                        13959   
     84F0   24 7F       13960   errind	bit runmod	;goto error if not in direct mode
     84F2   30 01       13961   	bmi 1$	;in run mode
     84F4   60          13962   	rts
                        13963   
     84F5   A2 22       13964   1$	ldx #erroid
     84F7   4C 4D59     13965   	jmp error
                        13966   
                        13967   ;.end
                        13968   	.include def

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 174
User Defined Function   DEF.SRC

Error Addr  Code          Seq   Source statement

                        13970   	.subttl User Defined Function
                        13971   
                        13972   ; simple user defined function code
                        13973   ;
                        13974   ; note only single arguments are allowed to functions,
                        13975   ; and functions must be of the single line form:
                        13976   ;      def fna(x)=x~2 + x-2
                        13977   ; no strings may be involved with these functions.
                        13978   ;
                        13979   ; idea: create a simple variable entry whose first
                        13980   ;	character has the msb set.
                        13981   ; the value will be:
                        13982   ;	a text pointer to the formula
                        13983   ;	a pointer to the argument variable
                        13984   
     84FA   20 8528     13985   def	jsr getfnm	;get a pointer to the function
     84FD   20 84D9     13986   	jsr errdir
     8500   20 79F6     13987   	jsr chkopn	;must have a (
     8503   A9 80       13988   	lda #$80	;prohibit subscripted variables
     8505   85 12       13989   	sta subflg
     8507   20 7B4C     13990   	jsr ptrget	;get pointer to argument
     850A   20 7877     13991   	jsr chknum	;is it a number?
     850D   20 79F3     13992   	jsr chkcls	;must have )
     8510   A9 B2       13993   	lda #equltk	;followed by =
     8512   20 79FB     13994   	jsr synchr
     8515   48          13995   	pha
     8516   A5 4A       13996   	lda varpnt+1
     8518   48          13997   	pha
     8519   A5 49       13998   	lda varpnt
     851B   48          13999   	pha
     851C   A5 3E       14000   	lda txtptr+1
     851E   48          14001   	pha
     851F   A5 3D       14002   	lda txtptr
     8521   48          14003   	pha
     8522   20 52AC     14004   	jsr data
     8525   4C 85A0     14005   	jmp deffin
                        14006   
                        14007   
                        14008   ; subroutine to get a pointer to a function name
                        14009   ;
     8528   A9 A5       14010   getfnm	lda #fntk	;must start with fn
     852A   20 79FB     14011   	jsr synchr
     852D   09 80       14012   	ora #$80	;put function bit on
     852F   85 12       14013   	sta subflg
     8531   20 7B53     14014   	jsr ptrgt2	;get pointer to function or create anew
     8534   85 50       14015   	sta defpnt
     8536   84 51       14016   	sty defpnt+1
     8538   4C 7877     14017   	jmp chknum      ;make sure it's not a string, and return
                        14018   
                        14019   
     853B   20 8528     14020   fndoer	jsr getfnm	;get the function's name
     853E   A5 51       14021   	lda defpnt+1
     8540   48          14022   	pha
     8541   A5 50       14023   	lda defpnt
     8543   48          14024   	pha

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 174-1
User Defined Function   DEF.SRC

Error Addr  Code          Seq   Source statement

     8544   20 79ED     14025   	jsr parchk	;evaluate parameter
     8547   20 7877     14026   	jsr chknum
     854A   68          14027   	pla
     854B   85 50       14028   	sta defpnt
     854D   68          14029   	pla
     854E   85 51       14030   	sta defpnt+1
     8550   A0 02       14031   	ldy #2
     8552   20 42EB     14032   	jsr inddef	;get pointer to the variable
     8555   85 49       14033   	sta varpnt	;save variable pointer.
     8557   AA          14034   	tax
     8558   C8          14035   	iny
     8559   20 42EB     14036   	jsr inddef
     855C   F0 82       14037   	beq errguf
     855E   85 4A       14038   	sta varpnt+1
     8560   C8          14039   	iny		;since def uses only 4.
                        14040   
     8561   A9 49       14041   defstf	lda #varpnt
     8563   20 03AB     14042   	jsr indsub_ram1
     8566   48          14043   	pha		;push it all on the stack, since we might be recursing
     8567   88          14044   	dey
     8568   10 F7       14045   	bpl defstf
     856A   A4 4A       14046   	ldy varpnt+1
                        14047   
     856C   8D FF04     14048   	sta sw_rom_ram1
     856F   20 8C00     14049   	jsr movmf	;put current fac into our argument variable
     8572   A5 3E       14050   	lda txtptr+1	;save variable pointer
     8574   48          14051   	pha
     8575   A5 3D       14052   	lda txtptr
     8577   48          14053   	pha
     8578   20 42EB     14054   	jsr inddef	;get pointer to function
     857B   85 3D       14055   	sta txtptr
     857D   C8          14056   	iny
     857E   20 42EB     14057   	jsr inddef
     8581   85 3E       14058   	sta txtptr+1
     8583   A5 4A       14059   	lda varpnt+1	;save variable pointer
     8585   48          14060   	pha
     8586   A5 49       14061   	lda varpnt
     8588   48          14062   	pha
     8589   20 7874     14063   	jsr frmnum	;evaluate variable, and check numeric
     858C   68          14064   	pla
     858D   85 50       14065   	sta defpnt
     858F   68          14066   	pla
     8590   85 51       14067   	sta defpnt+1
     8592   20 0386     14068   	jsr chrgot
     8595   F0 03       14069   	beq 1$
     8597   4C 7A09     14070   	jmp snerr	;it didn't terminate, syntax error
                        14071   
     859A   68          14072   1$	pla	      	;restore text pointer
     859B   85 3D       14073   	sta txtptr
     859D   68          14074   	pla
     859E   85 3E       14075   	sta txtptr+1
     85A0   A0 00       14076   deffin	ldy #0
     85A2   8D FF04     14077   	sta sw_rom_ram1
     85A5   68          14078   1$	pla	      	;get old arg value off stack,
     85A6   91 50       14079   	sta (defpnt),y	;and put it back in variable

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 174-2
User Defined Function   DEF.SRC

Error Addr  Code          Seq   Source statement

     85A8   C8          14080   	iny
     85A9   C0 05       14081   	cpy #5
     85AB   D0 F8       14082   	bne 1$
     85AD   60          14083   	rts
                        14084   
                        14085   ;.end
                        14086   	.include stringfns

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 175
String Functions - MID$, LEFT$, RIGHT$, ASC, STR$, LEN   STRINGFNS.SRC

Error Addr  Code          Seq   Source statement

                        14088   	.subttl String Functions - MID$, LEFT$, RIGHT$, ASC, STR$, LEN
                        14089   
                        14090   
                        14091   
                        14092   ; the str function takes a number and gives a string with
                        14093   ; the characters the output of the number would have given.
                        14094   
     85AE   20 7877     14095   strd	jsr chknum	;arg has to be numeric
     85B1   A0 00       14096   	ldy #0
     85B3   20 8E44     14097   	jsr foutc	;do it's output
     85B6   68          14098   	pla
     85B7   68          14099   	pla
                        14100   
     85B8   A9 FF       14101   timstr	lda #<lofbuf
     85BA   A0 00       14102   	ldy #>lofbuf
     85BC   4C 869A     14103   	jmp strlit
                        14104   
                        14105   
                        14106   ; chr($) creates a string which contains as its only character the ascii
                        14107   ; equivalent of the integer argument (#) which must be .lt. 255.
                        14108   
     85BF   20 87F7     14109   chrd	jsr conint	;get integer in range.
     85C2   8A          14110   	txa
     85C3   48          14111   	pha
     85C4   A9 01       14112   	lda #1		;one-character string.
     85C6   20 8690     14113   	jsr strspa	;get space for string.
     85C9   68          14114   	pla
     85CA   A0 00       14115   	ldy #0
     85CC   8D FF04     14116   	sta sw_rom_ram1	;set up string bank
     85CF   91 64       14117   	sta (dsctmp+1),y
                        14118   
     85D1   68          14119   chrd1	pla		;get rid of "chknum" return address.
     85D2   68          14120   	pla
     85D3   4C 86E3     14121   	jmp putnew	;setup fac to point to desc.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 176
String Functions - MID$, LEFT$, RIGHT$, ASC, STR$, LEN   STRINGFNS.SRC

Error Addr  Code          Seq   Source statement

                        14123   
                        14124   ; The following is the left$($,#) function. It takes the leftmost # characters
                        14125   ; of the string. If # .gt. the len of the string, it returns the whole string.
                        14126   
     85D6   20 864D     14127   leftd	jsr pream	;test parameters.
     85D9   48          14128   	pha
     85DA   20 42F5     14129   	jsr inddpt
     85DD   85 79       14130   	sta syntmp
     85DF   68          14131   	pla
     85E0   C5 79       14132   	cmp syntmp
     85E2   98          14133   	tya		;that's all there is to left$.
                        14134   
     85E3   90 05       14135   rleft	bcc 1$
     85E5   20 42F5     14136   	jsr inddpt
     85E8   AA          14137   	tax		;put length into x.
     85E9   98          14138   	tya		;zero a, the offset.
     85EA   48          14139   1$	pha		;save offset.
     85EB   8A          14140   rleft2	txa
     85EC   48          14141   rleft3	pha		;save length.
     85ED   20 8690     14142   	jsr strspa	;get space.
     85F0   A5 52       14143   	lda dscpnt
     85F2   A4 53       14144   	ldy dscpnt+1
     85F4   20 8785     14145   	jsr fretmp
     85F7   68          14146   	pla
     85F8   A8          14147   	tay
     85F9   68          14148   	pla
     85FA   18          14149   	clc
     85FB   65 24       14150   	adc index	;compute where to copy.
     85FD   85 24       14151   	sta index
     85FF   90 02       14152   	bcc 1$
     8601   E6 25       14153   	inc index+1
     8603   98          14154   1$	tya
     8604   20 8763     14155   	jsr movdo	;go move it.
     8607   4C 86E3     14156   	jmp putnew
                        14157   
                        14158   
                        14159   
     860A   20 864D     14160   rightd	jsr pream
     860D   48          14161   	pha
     860E   20 42F5     14162   	jsr inddpt
     8611   85 79       14163   	sta syntmp
     8613   68          14164   	pla
     8614   18          14165   	clc		;(length des'd)-(length)-1.
     8615   E5 79       14166   	sbc syntmp
     8617   49 FF       14167   	eor #$ff	;negate.
     8619   4C 85E3     14168   	jmp rleft
                        14169   
                        14170   ; MID$($,#) returns string with chars from # position onward. If # .gt. len($)
                        14171   ; then return null string. MID($,#,#) returns string with characters from
                        14172   ; # position for #2 characters. if #2 goes past end of string return as much
                        14173   ; as possible.
                        14174   
     861C   A9 FF       14175   midd	lda #255	;default.
     861E   85 67       14176   	sta faclo	;save for later compare.
     8620   20 0386     14177   	jsr chrgot	;get current character.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 176-1
String Functions - MID$, LEFT$, RIGHT$, ASC, STR$, LEN   STRINGFNS.SRC

Error Addr  Code          Seq   Source statement

     8623   C9 29       14178   	cmp #')'	;is it a right paren )?
     8625   F0 06       14179   	beq 1$		;no third paren. 
     8627   20 79F9     14180   	jsr chkcom	;must have comma.
     862A   20 87F4     14181   	jsr getbyt	;get the length into "faclo".
                        14182   
     862D   20 864D     14183   1$	jsr pream	;check it out.
     8630   F0 53       14184   	beq gofuc
     8632   CA          14185   	dex 		;compute offset.
     8633   8A          14186   	txa
     8634   48          14187   	pha		;preserve a while.
     8635   A2 00       14188   	ldx #0
     8637   48          14189   	pha
     8638   20 42F5     14190   	jsr inddpt	;get length of what's left.
     863B   85 79       14191   	sta syntmp
     863D   68          14192   	pla
     863E   18          14193   	clc
     863F   E5 79       14194   	sbc syntmp
     8641   B0 A8       14195   	bcs rleft2	;give null string.
     8643   49 FF       14196   	eor #$ff	;in sub c was 0 so just complement. 
     8645   C5 67       14197   	cmp faclo	;greater than what's desired.
     8647   90 A3       14198   	bcc rleft3	;no, just copy that much
     8649   A5 67       14199   	lda faclo	;get length of what's desired.
     864B   B0 9F       14200   	bcs rleft3	;copy it.
                        14201   
                        14202   
                        14203   
                        14204   
                        14205   ; common routine used by right$, left$, mid$, for parameter chk and setup.
                        14206   
     864D   20 79F3     14207   pream	jsr chkcls	;param list should end.
     8650   68          14208   	pla
     8651   A8          14209   	tay
     8652   68          14210   	pla
     8653   85 57       14211   	sta jmper+1	;get return address.
     8655   68          14212   	pla		;get rid of fingo's jsr ret addr.
     8656   68          14213   	pla
     8657   68          14214   	pla		;get length.
     8658   AA          14215   	tax
     8659   68          14216   	pla
     865A   85 52       14217   	sta dscpnt
     865C   68          14218   	pla
     865D   85 53       14219   	sta dscpnt+1
     865F   A5 57       14220   	lda jmper+1
     8661   48          14221   	pha
     8662   98          14222   	tya
     8663   48          14223   	pha
     8664   A0 00       14224   	ldy #0
     8666   8A          14225   	txa
     8667   60          14226   	rts
                        14227   
                        14228   
                        14229   
                        14230   ; The function len($) returns the length of the string passed as an argument.
                        14231   
     8668   20 866E     14232   len	jsr len1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 176-2
String Functions - MID$, LEFT$, RIGHT$, ASC, STR$, LEN   STRINGFNS.SRC

Error Addr  Code          Seq   Source statement

     866B   4C 84D4     14233   	jmp sngflt
                        14234   
     866E   20 877E     14235   len1	jsr frestr	;free up string
     8671   A2 00       14236   	ldx #0
     8673   86 0F       14237   	stx valtyp	;force numeric
     8675   A8          14238   	tay		;set condition codes
     8676   60          14239   	rts		;done.
                        14240   
                        14241   
                        14242   
                        14243   
                        14244   
                        14245   ; The following is the asc($) function. It returns an integer which is the
                        14246   ; decimal ascii equivalent of the string argument.
                        14247   
     8677   20 866E     14248   asc	jsr len1
     867A   F0 06       14249   	beq 1$		;it was null (zero length)
     867C   A0 00       14250   	ldy #0
     867E   20 03B7     14251   	jsr indin1_ram1	;get 1st character
     8681   A8          14252   	tay
     8682   4C 84D4     14253   1$	jmp sngflt
                        14254   
                        14255   
                        14256   
     8685   4C 7DC5     14257   gofuc	jmp fcerr	;'illegal quantity error'
                        14258   
                        14259   ;.end
                        14260   	.include strings

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 177
String Routines   STRINGS.SRC

Error Addr  Code          Seq   Source statement

                        14262   	.subttl String Routines
                        14263   ;
                        14264   ; strini gets string space for the creation of a string,
                        14265   ; and creates a descriptor for it in dsctmp
                        14266   ;
     8688               14267   strini
     8688   A6 66       14268   	ldx facmo	;get facmo to store in dscpnt
     868A   A4 67       14269   	ldy facmo+1
     868C   86 52       14270   	stx dscpnt	;retain the descriptor pointer
     868E   84 53       14271   	sty dscpnt+1
     8690               14272   strspa
     8690   20 9299     14273   	jsr getspa	;get string space
     8693   86 64       14274   	stx dsctmp+1	;save location
     8695   84 65       14275   	sty dsctmp+2
     8697   85 63       14276   	sta dsctmp	;save length
     8699   60          14277   	rts		;done
                        14278   
                        14279   
                        14280   
                        14281   
                        14282   ; strlt2 takes the string literal whose first character is pointed
                        14283   ; to by (xreg)+1 and builds a descriptor for it. the descriptor is
                        14284   ; initially built in 'dsctmp', but 'putnew' transfers it into a
                        14285   ; temporary, and leaves a pointer at the temporary in facmo & lo.
                        14286   ; the characters other than zero that terminates the string
                        14287   ; should be set up in 'charac' and 'endchr'. if the terminator
                        14288   ; is a quote, the quote is skipped over. leading quotes should
                        14289   ; be skipped before jsr. on return, the character after the string
                        14290   ; literal is pointed to by (strng2).
                        14291   
     869A               14292   strlit
     869A   A2 22       14293   	ldx #'"'	;assume string ends on quote
     869C   86 09       14294   	stx charac
     869E   86 0A       14295   	stx endchr
     86A0               14296   strlt2
     86A0   85 70       14297   	sta strng1	;save pointer to string
     86A2   84 71       14298   	sty strng1+1
     86A4   85 64       14299   	sta dsctmp+1	;in case no strcpy
     86A6   84 65       14300   	sty dsctmp+2
     86A8   A0 FF       14301   	ldy #255	;initialize character count
     86AA               14302   strget
     86AA   C8          14303   	iny
     86AB   20 430E     14304   	jsr indst1	;get character.
     86AE   F0 0C       14305   	beq strfi1	;if zero
     86B0   C5 09       14306   	cmp charac	;this terminator?
     86B2   F0 04       14307   	beq strfin	;yes.
     86B4   C5 0A       14308   	cmp endchr
     86B6   D0 F2       14309   	bne strget	;look further.
     86B8               14310   strfin
     86B8   C9 22       14311   	cmp #'"'	;quote?
     86BA   F0 01       14312   	beq strfi2
     86BC               14313   strfi1
     86BC   18          14314   	clc
     86BD               14315   strfi2
     86BD   84 63       14316   	sty dsctmp	;no, back up. retain count

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 177-1
String Routines   STRINGS.SRC

Error Addr  Code          Seq   Source statement

     86BF   98          14317   	tya
     86C0   65 70       14318   	adc strng1	;wishing to set (txtptr).
     86C2   85 72       14319   	sta strng2
     86C4   A6 71       14320   	ldx strng1+1
     86C6   90 01       14321   	bcc strst2
     86C8   E8          14322   	inx
     86C9               14323   strst2
     86C9   86 73       14324   	stx strng2+1
     86CB   98          14325   	tya
     86CC               14326   strlit_1
     86CC   20 8688     14327   	jsr strini
     86CF   A8          14328   	tay
     86D0   F0 11       14329   	beq putnew	;length=0, don't bother copying
     86D2   48          14330   	pha		;save length
     86D3   88          14331   10$	dey
     86D4   20 430E     14332   	jsr indst1	;get character from (strng1),y in bank 0
     86D7   8D FF04     14333   	sta sw_rom_ram1	;set up ram 1 for bleed-thru's
     86DA   91 37       14334   	sta (frespc),y
     86DC   98          14335   	tya
     86DD   D0 F4       14336   	bne 10$
     86DF   68          14337   	pla		;restore length
     86E0   20 8771     14338   	jsr mvdone	;finish up by updating frespc
                        14339   
                        14340   
                        14341   
                        14342   ; some string function is returning a result in dsctmp. Set up a temp
                        14343   ; descriptor with dsctmp in it. Put a pointer to the descriptor in facmo&lo
                        14344   ; and flag the result as type string.
                        14345   
     86E3   A6 18       14346   putnew	ldx temppt	;pointer to first free temp.
     86E5   E0 24       14347   	cpx #tempst+strsiz+strsiz+strsiz
     86E7   D0 05       14348   	bne 1$
     86E9   A2 19       14349   	ldx #errst	;string temporary error.
     86EB   4C 4D59     14350   	jmp error	;go tell him.
                        14351   
     86EE   A5 63       14352   1$	lda dsctmp
     86F0   95 00       14353   	sta 0,x
     86F2   A5 64       14354   	lda dsctmp+1
     86F4   95 01       14355   	sta 1,x
     86F6   A5 65       14356   	lda dsctmp+2
     86F8   95 02       14357   	sta 2,x
     86FA   A0 00       14358   	ldy #0
     86FC   86 66       14359   	stx facmo
     86FE   84 67       14360   	sty facmo+1
     8700   84 71       14361   	sty facov
     8702   88          14362   	dey
     8703   84 0F       14363   	sty valtyp	;type is "string".
     8705   86 19       14364   	stx lastpt	;set pointer to last-used temp.
     8707   E8          14365   	inx
     8708   E8          14366   	inx
     8709   E8          14367   	inx		;point further.
     870A   86 18       14368   	stx temppt	;save pointer to next temp if any.
     870C   60          14369   	rts		;all done.
                        14370   
                        14371   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 177-2
String Routines   STRINGS.SRC

Error Addr  Code          Seq   Source statement

                        14372   ;
                        14373   ; the following routine concatenates two strings.
                        14374   ; the fac contains the first one at this point.
                        14375   ; (txtptr) points to the + sign.
                        14376   
     870D   A5 67       14377   cat	lda faclo       ;push high order onto stack.
     870F   48          14378   	pha
     8710   A5 66       14379   	lda facmo	;and the low.
     8712   48          14380   	pha
     8713   20 7974     14381   	jsr eval	;can come back here since
     8716   20 787A     14382   	jsr chkstr	;operator is known. must be string
     8719   68          14383   	pla
     871A   85 70       14384   	sta strng1	;get high order of old descriptor.
     871C   68          14385   	pla
     871D   85 71       14386   	sta strng1+1
     871F   A0 00       14387   	ldy #0
     8721   20 4313     14388   	jsr indst1_ram1      ;get length of old string.
     8724   85 79       14389   	sta syntmp
     8726   20 4304     14390   	jsr indfmo
     8729   18          14391   	clc
     872A   65 79       14392   	adc syntmp
     872C   90 03       14393   	bcc sizeok	;result is less than 256.
     872E   4C A5FD     14394   	jmp errlen	;error "long string".
                        14395   
                        14396   
                        14397   
     8731   20 8688     14398   sizeok	jsr strini	;initialize string.
     8734   20 874E     14399   	jsr movins	;move it.
     8737   A5 52       14400   	lda dscpnt	;get pointer to second.
     8739   A4 53       14401   	ldy dscpnt+1
     873B   20 8785     14402   	jsr fretmp	;free it.
     873E   20 8763     14403   	jsr movdo	;move second string.
     8741   A5 70       14404   	lda strng1
     8743   A4 71       14405   	ldy strng1+1
     8745   20 8785     14406   	jsr fretmp
     8748   20 86E3     14407   	jsr putnew
     874B   4C 78A6     14408   	jmp tstop	;"cat" reentries form eval at tstop.
                        14409   
     874E   A0 00       14410   movins	ldy #0		;get address of string.
     8750   20 4313     14411   	jsr indst1_ram1
     8753   48          14412   	pha
     8754   C8          14413   	iny
     8755   20 4313     14414   	jsr indst1_ram1
     8758   AA          14415   	tax
     8759   C8          14416   	iny
     875A   20 4313     14417   	jsr indst1_ram1
     875D   A8          14418   	tay
     875E   68          14419   	pla
     875F               14420   movstr
     875F   86 24       14421   	stx index
     8761   84 25       14422   	sty index+1
     8763               14423   movdo
     8763   A8          14424   	tay
     8764   F0 0B       14425   	beq mvdone
     8766   48          14426   	pha

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 177-3
String Routines   STRINGS.SRC

Error Addr  Code          Seq   Source statement

     8767               14427   movlp
     8767   88          14428   	dey
     8768   20 03B7     14429   	jsr indin1_ram1
     876B   91 37       14430   	sta (frespc),y
     876D   98          14431   	tya
     876E   D0 F7       14432   	bne movlp
     8770   68          14433   	pla
     8771   18          14434   mvdone	clc
     8772   65 37       14435   	adc frespc
     8774   85 37       14436   	sta frespc
     8776   90 02       14437   	bcc mvstrt
     8778   E6 38       14438   	inc frespc+1
     877A   60          14439   mvstrt	rts
                        14440   ; 
                        14441   ; "fretmp" is passed a string descriptor pntr in (a,y). A check is made to see
                        14442   ; if the string descriptor points to the last temporary descriptor allocated by
                        14443   ; putnew. if so, the temporary is freed up by the updating of (temppt). If a
                        14444   ; string is freed up, a further check sees if the string data that if so,
                        14445   ; (fretop) is updated to reflect the fact that the space is no longer in use.
                        14446   ; the address of the actual string is returned in (x,y) and its length in acca.
                        14447   ; 
                        14448   
     877B   20 788C     14449   frmstr	jsr frmevl	
                        14450   
     877E   20 787A     14451   frestr	jsr chkstr	;make sure it's a string.
     8781   A5 66       14452   frefac	lda facmo	;free up string pointed to by fac.
     8783   A4 67       14453   	ldy facmo+1
     8785   85 24       14454   fretmp	sta index	;get length for later.
     8787   84 25       14455   	sty index+1
     8789   20 87E0     14456   	jsr fretms	;check desc. if last
     878C   D0 3C       14457   	bne fre02	;one then scratch it
     878E   20 5513     14458   	jsr stradj	;index points to link
     8791   90 37       14459   	bcc fre02	;literal no fix
     8793   88          14460   	dey		;.y=1
     8794   A9 FF       14461   	lda #$ff	;flag string as garbage
     8796   8D FF04     14462   	sta sw_rom_ram1	;set up string bank
     8799   91 24       14463   	sta (index),y
     879B   88          14464   	dey
     879C   8A          14465   	txa
     879D   91 24       14466   	sta (index),y	;put in length
     879F   48          14467   	pha		;save length on stack
                        14468   	
     87A0   49 FF       14469   	eor #$ff	;put index back
     87A2   38          14470   	sec		;to first byte
     87A3   65 24       14471   	adc index
     87A5   A4 25       14472   	ldy index+1
     87A7   B0 01       14473   	bcs res00
     87A9   88          14474   	dey
     87AA               14475   res00
     87AA   85 24       14476   	sta index
     87AC   84 25       14477   	sty index+1
     87AE   AA          14478   	tax		;lo into x
     87AF   68          14479   	pla		;pull length from stack
     87B0   C4 36       14480   	cpy fretop+1	;test for eq to fretop
     87B2   D0 3C       14481   	bne frerts

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 177-4
String Routines   STRINGS.SRC

Error Addr  Code          Seq   Source statement

     87B4   E4 35       14482   	cpx fretop
     87B6   D0 38       14483   	bne frerts
                        14484   	
                        14485   ;	string was last into string space
                        14486   ;	save garbage collection some time
                        14487   ;	by freeing up. (length + 2)
                        14488   	
     87B8   48          14489   	pha		;save length on stack
     87B9   38          14490   	sec		;plus one
     87BA   65 35       14491   	adc fretop
     87BC   85 35       14492   	sta fretop
     87BE   90 02       14493   	bcc 1$
     87C0   E6 36       14494   	inc fretop+1
     87C2   E6 35       14495   1$	inc fretop	;+ one more
     87C4   D0 02       14496   	bne frepla
     87C6   E6 36       14497   	inc fretop+1
     87C8   68          14498   frepla	pla		;pull length off stack
     87C9   60          14499   	rts
                        14500   
     87CA   A0 00       14501   fre02	ldy #0		;set up x,y,a and index
     87CC   20 03B7     14502   	jsr indin1_ram1	;length
     87CF   48          14503   	pha		;on stack
     87D0   C8          14504   	iny
     87D1   20 03B7     14505   	jsr indin1_ram1	;pointer lo
     87D4   AA          14506   	tax
     87D5   C8          14507   	iny
     87D6   20 03B7     14508   	jsr indin1_ram1	;pointer hi
     87D9   A8          14509   	tay
     87DA   86 24       14510   	stx index
     87DC   84 25       14511   	sty index+1
     87DE   68          14512   	pla		;get back length
     87DF   60          14513   	rts
                        14514   
                        14515   
                        14516   
     87E0   C4 1A       14517   fretms	cpy lastpt+1	;last entry to temp?
     87E2   D0 0C       14518   	bne frerts
     87E4   C5 19       14519   	cmp lastpt
     87E6   D0 08       14520   	bne frerts
     87E8   85 18       14521   	sta temppt
     87EA   E9 03       14522   	sbc #strsiz	;point ot lst one
     87EC   85 19       14523   	sta lastpt	;update temp pointer.
     87EE   A0 00       14524   	ldy #0		;also clears zflg so we do rest of fretmp.
     87F0   60          14525   frerts	rts		;all done.
                        14526   
                        14527   ;.end
                        14528   	.include code17

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 178
'code17'   CODE17.SRC

Error Addr  Code          Seq   Source statement

                        14530   	.subttl 'code17'
     87F1               14531   gtbytc
     87F1   20 0380     14532   	jsr chrget
     87F4               14533   getbyt
     87F4   20 7874     14534   	jsr frmnum	;read formula into fac.
     87F7               14535   conint
     87F7   20 84AD     14536   	jsr posint	;convert the fac to a single byte int.
     87FA   A6 66       14537   	ldx facmo
     87FC   D0 2D       14538   	bne go_fcerr	;result must be .le. 255.
     87FE   A6 67       14539   	ldx faclo
     8800   4C 0386     14540   	jmp chrgot	;set condition codes on terminator.
                        14541   
                        14542   
     8803               14543   getnum			;get 2 byte value in y,a : check for a comma, get 1 byte val in x
     8803   20 7874     14544   	jsr frmnum	;get address.
     8806   20 8815     14545   	jsr getadr	;get that location.
                        14546   
     8809               14547   combyt			;check for a comma, get a 1 byte value in x
     8809   20 79F9     14548   	jsr chkcom	;check for comma.
     880C   4C 87F4     14549   	jmp getbyt	;get something to store and return.
                        14550   
     880F   20 79F9     14551   comwrd	jsr chkcom
                        14552   
     8812   20 7874     14553   getwrd	jsr frmnum	;get a 2 byte value in y,a
                        14554   
     8815   A5 68       14555   getadr	lda facsgn	;for this entry, value can't be < 0
     8817   30 12       14556   	bmi go_fcerr	;function call error.
                        14557   
     8819               14558   getsad			;get signed 2 byte value in (y,a)
     8819   A5 63       14559   	lda facexp	;examine exponent.
     881B   C9 91       14560   	cmp #145
     881D   B0 0C       14561   	bcs go_fcerr	;function call error.
     881F   20 8CC7     14562   	jsr qint	;integerize it.
     8822   A5 66       14563   	lda facmo
     8824   A4 67       14564   	ldy facmo+1
     8826   84 16       14565   	sty poker
     8828   85 17       14566   	sta poker+1
     882A   60          14567   	rts		;it's all done.
                        14568   
     882B               14569   go_fcerr
     882B   4C 7DC5     14570   	jmp fcerr
                        14571   
                        14572   ;end
                        14573   	.include code18

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 179
'code18'   CODE18.SRC

Error Addr  Code          Seq   Source statement

                        14575   	.subttl 'code18'
                        14576   ;
                        14577   ; floating point math package configuration.
                        14578   ;
                        14579   ; Throughout the math package the floating point format is as follows:
                        14580   ;
                        14581   ;	the sign of the first bit of the mantissa.
                        14582   ;	the mantissa is 24 bits long.
                        14583   ;	the binary point is to the left of the msb.
                        14584   ;	number = mantissa * 2 ~ exponent.
                        14585   ;	the mantissa is positive with a 1 assumed to be where the sign bit is.
                        14586   ;	the sign of the exponent is the first bit of the exponent.
                        14587   ;	the exponent is stored in excess $80, i.e., with a bias of +$80.
                        14588   ;	so, the exponent is a signed 8 bit number with $80 added to it.
                        14589   ;	an exponent of zero means the number is zero.
                        14590   ;	the other bytes may not be assumed to be zero.
                        14591   ;	to keep the same number in the fac while shifting,
                        14592   ;	to shift right, exp:=exp+1.
                        14593   ;	to shift left,  exp:=exp-1.
                        14594   ;
                        14595   ; In memory the number looks like this:
                        14596   ;	the exponent as a signed number +$80.
                        14597   ;	the sign bit in 7, bits 2-8 of mantissa are bits 6-0.
                        14598   ;		remember bit 1 of mantissa is always a one.
                        14599   ;	bits 9-16 of the mantissa.
                        14600   ;	bits 17-24 of the mantisa.
                        14601   ;
                        14602   ; Arithmetic routine calling conventions
                        14603   ;
                        14604   ; For one argument functions:
                        14605   ;	the argument is in the fac.
                        14606   ;	the result is left in the fac.
                        14607   ; For two argument operations:
                        14608   ;	the first argument is in arg (argexp,ho,mo,lo and argsgn).
                        14609   ;       the second argument is in the fac.
                        14610   ;	the result is left in the fac.
                        14611   ;
                        14612   ; The "t" entry points to the two argument operations have both arguments setup
                        14613   ; in the respective registers. Before calling arg may have been popped off the
                        14614   ; stack and into arg, for example. The other entry point assumes (xreg) points
                        14615   ; to the argument somewhere in memory. it is unpacked into arg by "conupk".
                        14616   ;
                        14617   ; On the stack, the sgn is pushed on first, the lo,mo,ho, and finally exp.
                        14618   ; Note all things are kept unpacked in arg, fac and on the stack.
                        14619   ;
                        14620   ; It is only when something is stored away that it is packed to four bytes,
                        14621   ; the unpacked format has a sn byte reflecting the sign of the ho turned on.
                        14622   ; The exp is the same as stored format. This is done for speed of operation.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 180
'code18'   CODE18.SRC

Error Addr  Code          Seq   Source statement

                        14624   
     882E   20 8AB4     14625   fsub	jsr conupk
                        14626   
     8831   A5 68       14627   fsubt	lda facsgn
     8833   49 FF       14628   	eor #@377	;complement it.
     8835   85 68       14629   	sta facsgn
     8837   45 6F       14630   	eor argsgn	;complement arisgn.
     8839   85 70       14631   	sta arisgn
     883B   A5 63       14632   	lda facexp	;set codes on facexp.
     883D   4C 8848     14633   	jmp faddt	;(y)=argexp.
                        14634   
     8840   20 8979     14635   fadd5	jsr shiftr	;do a long shift.
     8843   90 3D       14636   	bcc fadd4	;continue with addition.
                        14637   
     8845   20 8AB4     14638   fadd	jsr conupk
     8848   D0 03       14639   faddt	bne 1$
     884A   4C 8C28     14640   	jmp movfa	;if fac=0, result is in arg.
                        14641   
     884D   A6 71       14642   1$	ldx facov
     884F   86 58       14643   	stx oldov
     8851   A2 6A       14644   	ldx #argexp	;default is shift argument.
     8853   A5 6A       14645   	lda argexp	;if arg=0, fac is result.
                        14646   
     8855   A8          14647   faddc	tay		;also copy acca into accy.
     8856   D0 01       14648   	bne 1$
     8858   60          14649   	rts		;return
     8859   38          14650   1$	sec
     885A   E5 63       14651   	sbc facexp
     885C   F0 24       14652   	beq fadd4	;no shifting.
     885E   90 12       14653   	bcc fadda	;branch if argexp .lt. facexp.
     8860   84 63       14654   	sty facexp	;resulting exponent.
     8862   A4 6F       14655   	ldy argsgn	;since arg is bigger, it's
     8864   84 68       14656   	sty facsgn	;sign is sign of result.
     8866   49 FF       14657   	eor #@377	;shift a negative number of palces.
     8868   69 00       14658   	adc #0		;complete negation, w/ c=1.
     886A   A0 00       14659   	ldy #0		;zero oldov.
     886C   84 58       14660   	sty oldov
     886E   A2 63       14661   	ldx #fac	;shift the fac instead.
     8870   D0 04       14662   	bne fadd1
                        14663   
     8872   A0 00       14664   fadda	ldy #0
     8874   84 71       14665   	sty facov
     8876   C9 F9       14666   fadd1	cmp #$f9	;for speed and necessity. gets
                        14667   			;most likely case to shiftr fastest
                        14668   			;and allows shifting of neg nums
                        14669   			;by "quint".
     8878   30 C6       14670   	bmi fadd5	;shift big.
     887A   A8          14671   	tay
     887B   A5 71       14672   	lda facov	;set facov.
     887D   56 01       14673   	lsr 1,x	 	;gets 0 in the msb.
     887F   20 8990     14674   	jsr rolshf	;do the rolling.
                        14675   
     8882   24 70       14676   fadd4	bit arisgn	;get resulting sign.
     8884   10 57       14677   	bpl fadd2	;if positive, add. carry is clear
     8886   A0 63       14678   	ldy #facexp	

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 180-1
'code18'   CODE18.SRC

Error Addr  Code          Seq   Source statement

     8888   E0 6A       14679   	cpx #argexp	;fac is bigger.
     888A   F0 02       14680   	beq subit
     888C   A0 6A       14681   	ldy #argexp	;arg is bigger.
                        14682   
     888E   38          14683   subit	sec
     888F   49 FF       14684   	eor #@377
     8891   65 58       14685   	adc oldov
     8893   85 71       14686   	sta facov
     8895   B9 0004     14687   	lda 4,y
     8898   F5 04       14688   	sbc 4,x
     889A   85 67       14689   	sta faclo
     889C   B9 0003     14690   	lda 3,y
     889F   F5 03       14691   	sbc 3,x
     88A1   85 66       14692   	sta facmo
     88A3   B9 0002     14693   	lda 2,y
     88A6   F5 02       14694   	sbc 2,x
     88A8   85 65       14695   	sta facmoh
     88AA   B9 0001     14696   	lda 1,y
     88AD   F5 01       14697   	sbc 1,x
     88AF   85 64       14698   	sta facho
     88B1               14699   fadflt
     88B1   B0 03       14700   	bcs normal	;here if signs differ. if carry, fac is set ok.
     88B3   20 8926     14701   	jsr negfac	;negate (fac)
     88B6               14702   normal
     88B6   A0 00       14703   	ldy #0
     88B8   98          14704   	tya
     88B9   18          14705   	clc
     88BA               14706   norm3
     88BA   A6 64       14707   	ldx facho
     88BC   D0 4A       14708   	bne norm1
     88BE   A6 65       14709   	ldx facho+1	;shift 8 bits at a time for speed.
     88C0   86 64       14710   	stx facho
     88C2   A6 66       14711   	ldx facmoh+1
     88C4   86 65       14712   	stx facmoh
     88C6   A6 67       14713   	ldx facmo+1
     88C8   86 66       14714   	stx facmo
     88CA   A6 71       14715   	ldx facov
     88CC   86 67       14716   	stx faclo
     88CE   84 71       14717   	sty facov
     88D0   69 08       14718   	adc #@10
                        14719   
     88D2   C9 20       14720   	cmp #$20
     88D4   D0 E4       14721   	bne norm3
                        14722   
     88D6   A9 00       14723   zerofc	lda #0		;not needed by normal but by others.
     88D8   85 63       14724   zerof1	sta facexp	;number must be zero.
     88DA   85 68       14725   zeroml	sta facsgn	;make sign positive.
     88DC   60          14726   	rts		;all done.
                        14727   
                        14728   
     88DD   65 58       14729   fadd2	adc oldov
     88DF   85 71       14730   	sta facov
     88E1   A5 67       14731   	lda faclo
     88E3   65 6E       14732   	adc arglo
     88E5   85 67       14733   	sta faclo

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 180-2
'code18'   CODE18.SRC

Error Addr  Code          Seq   Source statement

     88E7   A5 66       14734   	lda facmo
     88E9   65 6D       14735   	adc argmo
     88EB   85 66       14736   	sta facmo
     88ED   A5 65       14737   	lda facmoh
     88EF   65 6C       14738   	adc argmoh
     88F1   85 65       14739   	sta facmoh
     88F3   A5 64       14740   	lda facho
     88F5   65 6B       14741   	adc argho
     88F7   85 64       14742   	sta facho
     88F9   4C 8915     14743   	jmp squeez	;go round if signs same.
                        14744   
     88FC               14745   norm2
     88FC   69 01       14746   	adc #1		;decrement shift counter.
     88FE   06 71       14747   	asl facov	;shift all left one bit.
     8900   26 67       14748   	rol faclo
     8902   26 66       14749   	rol facmo
     8904   26 65       14750   	rol facmoh
     8906   26 64       14751   	rol facho
     8908               14752   norm1
     8908   10 F2       14753   	bpl norm2	;if msb=0 shift again.
     890A   38          14754   	sec
     890B   E5 63       14755   	sbc facexp
     890D   B0 C7       14756   	bcs zerofc
     890F   49 FF       14757   	eor #@377
     8911   69 01       14758   	adc #1		;complement.
     8913   85 63       14759   	sta facexp
     8915               14760   squeez
     8915   90 0E       14761   	bcc rndrts	;bits to shift?
     8917               14762   rndshf
     8917   E6 63       14763   	inc facexp
     8919   F0 42       14764   	beq overr
     891B   66 64       14765   	ror facho
     891D   66 65       14766   	ror facmoh
     891F   66 66       14767   	ror facmo
     8921   66 67       14768   	ror faclo
     8923   66 71       14769   	ror facov
     8925   60          14770   rndrts	rts		;all done adding.
                        14771   
     8926               14772   negfac
     8926   A5 68       14773   	lda facsgn
     8928   49 FF       14774   	eor #@377	;complement fac entirely.
     892A   85 68       14775   	sta facsgn
     892C               14776   negfch
     892C   A5 64       14777   	lda facho
     892E   49 FF       14778   	eor #@377	;complement just the number.
     8930   85 64       14779   	sta facho
     8932   A5 65       14780   	lda facmoh
     8934   49 FF       14781   	eor #@377
     8936   85 65       14782   	sta facmoh
     8938   A5 66       14783   	lda facmo
     893A   49 FF       14784   	eor #@377
     893C   85 66       14785   	sta facmo
     893E   A5 67       14786   	lda faclo
     8940   49 FF       14787   	eor #@377
     8942   85 67       14788   	sta faclo

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 180-3
'code18'   CODE18.SRC

Error Addr  Code          Seq   Source statement

     8944   A5 71       14789   	lda facov
     8946   49 FF       14790   	eor #@377
     8948   85 71       14791   	sta facov
     894A   E6 71       14792   	inc facov
     894C   D0 0E       14793   	bne incfrt
     894E               14794   incfac
     894E   E6 67       14795   	inc faclo
     8950   D0 0A       14796   	bne incfrt
     8952   E6 66       14797   	inc facmo
     8954   D0 06       14798   	bne incfrt	;if no carry, return.
     8956   E6 65       14799   	inc facmoh
     8958   D0 02       14800   	bne incfrt
     895A   E6 64       14801   	inc facho	;carry complement.
     895C   60          14802   incfrt	rts
                        14803   
     895D               14804   overr
     895D   A2 0F       14805   	ldx #errov
     895F   4C 4D59     14806   	jmp error	;tell user.
                        14807   
                        14808   
                        14809   ;"shiftr" shifts (x+1:x+3) (-acca) bits right.
                        14810   ;shifts bits to start with if possible.
                        14811   
     8962   A2 27       14812   mulshf	ldx #resho-1	;entry point for multiplier.
     8964   B4 04       14813   shftr2	ldy 4,x		;shift bits first.
     8966   84 71       14814   	sty facov
     8968   B4 03       14815   	ldy 3,x
     896A   94 04       14816   	sty 4,x
     896C   B4 02       14817   	ldy 2,x		;get mo.
     896E   94 03       14818   	sty 3,x		;store lo.
     8970   B4 01       14819   	ldy 1,x		;get ho.
     8972   94 02       14820   	sty 2,x		;store mo.
     8974   AC 03DF     14821   	ldy bits
     8977   94 01       14822   	sty 1,x		;store ho.
     8979               14823   shiftr
     8979   69 08       14824   	adc #@10
     897B   30 E7       14825   	bmi shftr2
     897D   F0 E5       14826   	beq shftr2
     897F   E9 08       14827   	sbc #@10	;c can be either 1,0 and it works.
     8981   A8          14828   	tay
     8982   A5 71       14829   	lda facov
     8984   B0 14       14830   	bcs shftrt	;equiv to beq here.
     8986               14831   shftr3
     8986   16 01       14832   	asl 1,x
     8988   90 02       14833   	bcc shftr4
     898A   F6 01       14834   	inc 1,x
     898C               14835   shftr4
     898C   76 01       14836   	ror 1,x
     898E   76 01       14837   	ror 1,x 	;yes, two of them.
     8990               14838   rolshf
     8990   76 02       14839   	ror 2,x
     8992   76 03       14840   	ror 3,x
     8994   76 04       14841   	ror 4,x		;one mo time.
     8996   6A          14842   	ror a
     8997   C8          14843   	iny

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 180-4
'code18'   CODE18.SRC

Error Addr  Code          Seq   Source statement

     8998   D0 EC       14844   	bne shftr3	;$$$ (most expensive!!!)
     899A               14845   shftrt
     899A   18          14846   	clc		;clear output of facov.
     899B   60          14847   	rts
                        14848   
                        14849   ;.end
                        14850   	.include code19

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 181
'code19'   CODE19.SRC

Error Addr  Code          Seq   Source statement

                        14852   	.subttl 'code19'
                        14853   
                        14854   ; Natural log function
                        14855   ;
                        14856   ; Calculation is by:
                        14857   ;	ln(f*2~n)=(n+log2(f))*ln(2)
                        14858   ; An approximation polynomial is used to calculate log2(f). 
                        14859   
                        14860   ; Constants used by log :
     899C   81 00 00    14861   fone	.byte @201,0,0,0,0
     899F   00 00               
     89A1   03 7F 5E    14862   logcn2	.byte 3,@177,@136,@126
     89A4   56                  
     89A5   CB 79 80    14863   	.byte @313,@171,@200,@23
     89A8   13                  
     89A9   9B 0B 64    14864   	.byte @233,@13,@144,@200
     89AC   80                  
     89AD   76 38 93    14865   	.byte @166,@70,@223,@26
     89B0   16                  
     89B1   82 38 AA    14866   	.byte @202,@70,@252,@73,@40
     89B4   3B 20               
     89B6   80 35 04    14867   sqr05	.byte @200,@65,4,@363,@64
     89B9   F3 34               
     89BB   81 35 04    14868   sqr20	.byte @201,@65,@4,@363,@64
     89BE   F3 34               
     89C0   80 80 00    14869   neghlf	.byte @200,@200,0,0,0
     89C3   00 00               
     89C5   80 31 72    14870   log2	.byte @200,@61,@162,@27,@370
     89C8   17 F8               
                        14871   
     89CA   20 8C57     14872   log	jsr sign	;is it positive?
     89CD   F0 02       14873   	beq logerr
     89CF   10 03       14874   	bpl log1
     89D1   4C 7DC5     14875   logerr	jmp fcerr	;can't tolerate neg or zero.
                        14876   
     89D4   A5 63       14877   log1	lda facexp	;get exponent into acca.
     89D6   E9 7F       14878   	sbc #@177	;remove bias. (carry is off).
     89D8   48          14879   	pha		;save a while.
     89D9   A9 80       14880   	lda #@200
     89DB   85 63       14881   	sta facexp	;result is fac in range (0.5,1).
     89DD   A9 B6       14882   	lda #<sqr05	;get pointer to sqr(0.5).
     89DF   A0 89       14883   	ldy #>sqr05
     89E1   20 8A12     14884   	jsr romadd
     89E4   A9 BB       14885   	lda #<sqr20
     89E6   A0 89       14886   	ldy #>sqr20
     89E8   20 8A1E     14887   	jsr romdiv
     89EB   A9 9C       14888   	lda #<fone
     89ED   A0 89       14889   	ldy #>fone
     89EF   20 8A18     14890   	jsr romsub
     89F2   A9 A1       14891   	lda #<logcn2
     89F4   A0 89       14892   	ldy #>logcn2
     89F6   20 9086     14893   	jsr polyx	;evaluate approximation polynomial.
     89F9   A9 C0       14894   	lda #<neghlf	;add in last constant.
     89FB   A0 89       14895   	ldy #>neghlf
     89FD   20 8A12     14896   	jsr romadd

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 181-1
'code19'   CODE19.SRC

Error Addr  Code          Seq   Source statement

     8A00   68          14897   	pla		;get exponent back.
     8A01   20 8DB0     14898   	jsr finlog
     8A04   A9 C5       14899   	lda #<log2	;multiply result by log(2.0).
     8A06   A0 89       14900   	ldy #>log2
                        14901   
     8A08               14902   rommlt
     8A08   20 8A89     14903   	jsr romupk
     8A0B   4C 8A27     14904   	jmp fmultt	;multiply together.
                        14905   
     8A0E               14906   faddh
     8A0E   A9 76       14907   	lda #<fhalf
     8A10   A0 8F       14908   	ldy #>fhalf
                        14909   
     8A12               14910   romadd
     8A12   20 8A89     14911   	jsr romupk
     8A15   4C 8848     14912   	jmp faddt
                        14913   
     8A18               14914   romsub
     8A18   20 8A89     14915   	jsr romupk
     8A1B   4C 8831     14916   	jmp fsubt
                        14917   
     8A1E               14918   romdiv
     8A1E   20 8A89     14919   	jsr romupk
     8A21   4C 8B4C     14920   	jmp fdivt
                        14921   			;
                        14922   			;multiplication        fac:=arg*fac.
                        14923   			;
                        14924   
     8A24               14925   fmult
     8A24   20 8AB4     14926   	jsr conupk	;unpack the constant into arg for use.
     8A27               14927   fmultt
     8A27   D0 03       14928   	bne *+5		;if fac=0, return. fac is set.
     8A29   4C 8A88     14929   	jmp multrt
                        14930   
     8A2C   20 8AEC     14931   	jsr muldiv	;fix up the exponents.
     8A2F   A9 00       14932   	lda #0		;to clear result.
     8A31   85 28       14933   	sta resho
     8A33   85 29       14934   	sta resmoh
     8A35   85 2A       14935   	sta resmo
     8A37   85 2B       14936   	sta reslo
     8A39   A5 71       14937   	lda facov
     8A3B   20 8A55     14938   	jsr mltply
     8A3E   A5 67       14939   	lda faclo	;multiply arg by faclo.
     8A40   20 8A55     14940   	jsr mltply
     8A43   A5 66       14941   	lda facmo	;multiply arg by facmo.
     8A45   20 8A55     14942   	jsr mltply
     8A48   A5 65       14943   	lda facmoh
     8A4A   20 8A55     14944   	jsr mltply
     8A4D   A5 64       14945   	lda facho	;multiply arr by facho.
     8A4F   20 8A5B     14946   	jsr mltpl1
     8A52   4C 8BC1     14947   	jmp movfr	;move result into fac.
                        14948   
     8A55               14949   mltply
     8A55   D0 04       14950   	bne *+6
     8A57   38          14951   	sec		;***FIXES THE 'DOUBLE ZERO' BUG!

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 181-2
'code19'   CODE19.SRC

Error Addr  Code          Seq   Source statement

     8A58   4C 8962     14952   	jmp mulshf	;normalize result and return. shift result right 1 byte
                        14953   
     8A5B               14954   mltpl1
     8A5B   4A          14955   	lsr a
     8A5C   09 80       14956   	ora #@200
     8A5E               14957   mltpl2
     8A5E   A8          14958   	tay
     8A5F   90 19       14959   	bcc mltpl3	;if mult bit=0, just shift.
     8A61   18          14960   	clc
     8A62   A5 2B       14961   	lda reslo
     8A64   65 6E       14962   	adc arglo
     8A66   85 2B       14963   	sta reslo
     8A68   A5 2A       14964   	lda resmo
     8A6A   65 6D       14965   	adc argmo
     8A6C   85 2A       14966   	sta resmo
     8A6E   A5 29       14967   	lda resmoh
     8A70   65 6C       14968   	adc argmoh
     8A72   85 29       14969   	sta resmoh
     8A74   A5 28       14970   	lda resho
     8A76   65 6B       14971   	adc argho
     8A78   85 28       14972   	sta resho
     8A7A               14973   mltpl3
     8A7A   66 28       14974   	ror resho
     8A7C   66 29       14975   	ror resmoh
     8A7E   66 2A       14976   	ror resmo
     8A80   66 2B       14977   	ror reslo
     8A82   66 71       14978   	ror facov	;save for rounding.
     8A84   98          14979   	tya
     8A85   4A          14980   	lsr a		;clear msb so we get a closer to 0.
     8A86   D0 D6       14981   	bne mltpl2	;slow as a turtle.
     8A88   60          14982   multrt	rts
                        14983   
                        14984   
                        14985   ; unpack a rom constant into the fac
                        14986   ;
     8A89               14987   romupk
     8A89   85 24       14988   	sta index1
     8A8B   84 25       14989   	sty index1+1
     8A8D   A0 04       14990   	ldy #4
     8A8F   B1 24       14991   	lda (index1),y	;it's in rom, so ok to use ind.
     8A91   85 6E       14992   	sta arglo
     8A93   88          14993   	dey
     8A94   B1 24       14994   	lda (index1),y
     8A96   85 6D       14995   	sta argmo
     8A98   88          14996   	dey
     8A99   B1 24       14997   	lda (index1),y
     8A9B   85 6C       14998   	sta argmoh
     8A9D   88          14999   	dey
     8A9E   B1 24       15000   	lda (index1),y
     8AA0   85 6F       15001   	sta argsgn
     8AA2   45 68       15002   	eor facsgn
     8AA4   85 70       15003   	sta arisgn
     8AA6   A5 6F       15004   	lda argsgn
     8AA8   09 80       15005   	ora #$80
     8AAA   85 6B       15006   	sta argho

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 181-3
'code19'   CODE19.SRC

Error Addr  Code          Seq   Source statement

     8AAC   88          15007   	dey
     8AAD   B1 24       15008   	lda (index1),y
     8AAF   85 6A       15009   	sta argexp
     8AB1   A5 63       15010   	lda facexp	;sets code of facexp.
     8AB3   60          15011   	rts
                        15012   
                        15013   
                        15014   
                        15015   ; unpack a ram constant into the fac
                        15016   ;
     8AB4               15017   conupk
     8AB4   85 24       15018   	sta index1
     8AB6   84 25       15019   	sty index1+1
                        15020   
     8AB8   AD FF00     15021   	lda mmu_config_reg
     8ABB   48          15022   	pha			;preserve caller's memory config
                        15023   
     8ABC   A0 04       15024   	ldy #4
     8ABE   20 03B7     15025   	jsr indin1_ram1
     8AC1   85 6E       15026   	sta arglo
     8AC3   88          15027   	dey
     8AC4   20 03B7     15028   	jsr indin1_ram1
     8AC7   85 6D       15029   	sta argmo
     8AC9   88          15030   	dey
     8ACA   20 03B7     15031   	jsr indin1_ram1
     8ACD   85 6C       15032   	sta argmoh
     8ACF   88          15033   	dey
     8AD0   20 03B7     15034   	jsr indin1_ram1
     8AD3   85 6F       15035   	sta argsgn
     8AD5   45 68       15036   	eor facsgn
     8AD7   85 70       15037   	sta arisgn
     8AD9   A5 6F       15038   	lda argsgn
     8ADB   09 80       15039   	ora #@200
     8ADD   85 6B       15040   	sta argho
     8ADF   88          15041   	dey
     8AE0   20 03B7     15042   	jsr indin1_ram1
     8AE3   85 6A       15043   	sta argexp
                        15044   
     8AE5   68          15045   	pla
     8AE6   8D FF00     15046   	sta mmu_config_reg	;restore caller's memory config
                        15047   
     8AE9   A5 63       15048   	lda facexp	;set codes of facexp.
     8AEB   60          15049   	rts
                        15050   
                        15051   
                        15052   			;check special cases and add exponents for fmult,fdiv.
     8AEC               15053   muldiv
     8AEC   A5 6A       15054   	lda argexp	;exp of arg=0?
     8AEE               15055   mldexp
     8AEE   F0 1F       15056   	beq zeremv	;so we get zero exponent.
     8AF0   18          15057   	clc
     8AF1   65 63       15058   	adc facexp	;result is in acca.
     8AF3   90 04       15059   	bcc tryoff	;find (c) xor (n).
     8AF5   30 1D       15060   	bmi goover	;overflow if bits match.
     8AF7   18          15061   	clc

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 181-4
'code19'   CODE19.SRC

Error Addr  Code          Seq   Source statement

     8AF8   2C          15062   	.byte $2c
                        15063   
     8AF9               15064   tryoff
     8AF9   10 14       15065   	bpl zeremv	;underflow.
     8AFB   69 80       15066   	adc #@200	;add bias.
     8AFD   85 63       15067   	sta facexp
     8AFF   D0 03       15068   	bne *+5
     8B01   4C 88DA     15069   	jmp zeroml	;zero the rest of it.
                        15070   
     8B04   A5 70       15071   	lda arisgn
     8B06   85 68       15072   	sta facsgn	;arisgn is result's sign.
     8B08   60          15073   	rts		;done
                        15074   
     8B09               15075   mldvex
     8B09   A5 68       15076   	lda facsgn	;get sign
     8B0B   49 FF       15077   	eor #@377	;complement it.
     8B0D   30 05       15078   	bmi goover
     8B0F               15079   zeremv
     8B0F   68          15080   	pla		;get addr off stack.
     8B10   68          15081   	pla
     8B11   4C 88D6     15082   	jmp zerofc	;underflow.
                        15083   
                        15084   
     8B14               15085   goover
     8B14   4C 895D     15086   	jmp overr	;overflow.
                        15087   			;multiply fac by 10.
     8B17               15088   mul10
     8B17   20 8C38     15089   	jsr movaf	;copy fac into arg.
     8B1A   AA          15090   	tax
     8B1B   F0 10       15091   	beq mul10r	;if (fac)=0, got answer.
     8B1D   18          15092   	clc
     8B1E   69 02       15093   	adc #2		;augment exp by 2.
     8B20   B0 F2       15094   	bcs goover	;overflow.
     8B22               15095   finml6
     8B22   A2 00       15096   	ldx #0
     8B24   86 70       15097   	stx arisgn	;signs are same.
     8B26   20 8855     15098   	jsr faddc	;add together.
     8B29   E6 63       15099   	inc facexp	;multiply by two.
     8B2B   F0 E7       15100   	beq goover	;overflow.
     8B2D   60          15101   mul10r	rts
                        15102   
     8B2E   84 20 00    15103   tenc	.byte @204,@40,0,0,0
     8B31   00 00               
                        15104   
                        15105   
                        15106   
     8B33               15107   doverr
     8B33   A2 14       15108   	ldx #errdvo
     8B35   4C 4D59     15109   	jmp error
                        15110   
                        15111   
     8B38               15112   div10
     8B38   20 8C38     15113   	jsr movaf	;move fac to arg.
     8B3B   A9 2E       15114   	lda #<tenc
     8B3D   A0 8B       15115   	ldy #>tenc	;point to constant of 10.0.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 181-5
'code19'   CODE19.SRC

Error Addr  Code          Seq   Source statement

     8B3F   A2 00       15116   	ldx #0		;signs are both positive.
     8B41               15117   fdivf
     8B41   86 70       15118   	stx arisgn
     8B43   20 8BD4     15119   	jsr movfm	;put it into fac.
     8B46   4C 8B4C     15120   	jmp fdivt	;skip over next two bytes.
                        15121   
                        15122   
                        15123   
     8B49               15124   fdiv
     8B49   20 8AB4     15125   	jsr conupk	;unpack constant.
     8B4C               15126   fdivt
     8B4C   F0 E5       15127   	beq doverr	;can't divide by zero.
                        15128   			;not enough room to store result.
     8B4E   20 8C47     15129   	jsr round	;take facov into account in fac.
     8B51   A9 00       15130   	lda #0		;negate facexp.
     8B53   38          15131   	sec
     8B54   E5 63       15132   	sbc facexp
     8B56   85 63       15133   	sta facexp
     8B58   20 8AEC     15134   	jsr muldiv	;fix up exponents.
     8B5B   E6 63       15135   	inc facexp	;scale it right.
     8B5D   F0 B5       15136   	beq goover	;overflow.
     8B5F   A2 FC       15137   	ldx #$fc	;set up procedure.
     8B61   A9 01       15138   	lda #1
     8B63               15139   divide			;this is the best code in the whole pile.
     8B63   A4 6B       15140   	ldy argho	;see what relation holds.
     8B65   C4 64       15141   	cpy facho
     8B67   D0 10       15142   	bne savquo	;(c)=0,1. n(c=0)=0.
     8B69   A4 6C       15143   	ldy argmoh
     8B6B   C4 65       15144   	cpy facmoh
     8B6D   D0 0A       15145   	bne savquo
     8B6F   A4 6D       15146   	ldy argmo
     8B71   C4 66       15147   	cpy facmo
     8B73   D0 04       15148   	bne savquo
     8B75   A4 6E       15149   	ldy arglo
     8B77   C4 67       15150   	cpy faclo
     8B79               15151   savquo
     8B79   08          15152   	php
     8B7A   2A          15153   	rol a		;save result.
     8B7B   90 09       15154   	bcc qshft	;if not done, continue.
     8B7D   E8          15155   	inx
     8B7E   95 2B       15156   	sta reslo,x
     8B80   F0 32       15157   	beq ld100
     8B82   10 34       15158   	bpl divnrm	;note this req 1 no ram then access.
     8B84   A9 01       15159   	lda #1
     8B86               15160   qshft
     8B86   28          15161   	plp		;return condition codes.
     8B87   B0 0E       15162   	bcs divsub	;fac .le. arg.
     8B89               15163   shfarg
     8B89   06 6E       15164   	asl arglo	;shift arg one place left.
     8B8B   26 6D       15165   	rol argmo
     8B8D   26 6C       15166   	rol argmoh
     8B8F   26 6B       15167   	rol argho
     8B91   B0 E6       15168   	bcs savquo	;save a result of one for this position.
                        15169   			;and divide.
     8B93   30 CE       15170   	bmi divide	;if msb on, go decide whether to sub.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 181-6
'code19'   CODE19.SRC

Error Addr  Code          Seq   Source statement

     8B95   10 E2       15171   	bpl savquo
                        15172   
     8B97               15173   divsub
     8B97   A8          15174   	tay		;notice c must be on here.
     8B98   A5 6E       15175   	lda arglo
     8B9A   E5 67       15176   	sbc faclo
     8B9C   85 6E       15177   	sta arglo
     8B9E   A5 6D       15178   	lda argmo
     8BA0   E5 66       15179   	sbc facmo
     8BA2   85 6D       15180   	sta argmo
     8BA4   A5 6C       15181   	lda argmoh
     8BA6   E5 65       15182   	sbc facmoh
     8BA8   85 6C       15183   	sta argmoh
     8BAA   A5 6B       15184   	lda argho
     8BAC   E5 64       15185   	sbc facho
     8BAE   85 6B       15186   	sta argho
     8BB0   98          15187   	tya
     8BB1   4C 8B89     15188   	jmp shfarg
                        15189   
                        15190   
     8BB4               15191   ld100
     8BB4   A9 40       15192   	lda #@100	;only want two more bits.
     8BB6   D0 CE       15193   	bne qshft	;always branches.
     8BB8               15194   divnrm	
     8BB8   0A          15195   	asl a		;get last two bits into msb and b6.
     8BB9   0A          15196   	asl a
     8BBA   0A          15197   	asl a
     8BBB   0A          15198   	asl a
     8BBC   0A          15199   	asl a
     8BBD   0A          15200   	asl a
     8BBE   85 71       15201   	sta facov
     8BC0   28          15202   	plp
                        15203   
                        15204   
                        15205   
     8BC1   A5 28       15206   movfr	lda resho	;move result to fac.
     8BC3   85 64       15207   	sta facho
     8BC5   A5 29       15208   	lda resmoh
     8BC7   85 65       15209   	sta facmoh
     8BC9   A5 2A       15210   	lda resmo
     8BCB   85 66       15211   	sta facmo
     8BCD   A5 2B       15212   	lda reslo	;move lo and sign.
     8BCF   85 67       15213   	sta faclo
     8BD1   4C 88B6     15214   	jmp normal	;all done.
                        15215   
                        15216   
                        15217   
     8BD4   85 24       15218   movfm	sta index1	;move memory into fac from rom (unpacked).
     8BD6   84 25       15219   	sty index1+1
     8BD8   A0 04       15220   	ldy #4
     8BDA   B1 24       15221   	lda (index1),y
     8BDC   85 67       15222   	sta faclo
     8BDE   88          15223   	dey
     8BDF   B1 24       15224   	lda (index1),y
     8BE1   85 66       15225   	sta facmo

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 181-7
'code19'   CODE19.SRC

Error Addr  Code          Seq   Source statement

     8BE3   88          15226   	dey
     8BE4   B1 24       15227   	lda (index1),y
     8BE6   85 65       15228   	sta facmoh
     8BE8   88          15229   	dey
     8BE9   B1 24       15230   	lda (index1),y
     8BEB   85 68       15231   	sta facsgn
     8BED   09 80       15232   	ora #@200
     8BEF   85 64       15233   	sta facho
     8BF1   88          15234   	dey
     8BF2   B1 24       15235   	lda (index1),y
     8BF4   85 63       15236   	sta facexp
     8BF6   84 71       15237   	sty facov
     8BF8   60          15238   	rts
                        15239   
                        15240   ; Move number from fac to memory.
                        15241   
     8BF9   A2 5E       15242   mov2f	ldx #tempf2	;move from fac to temp fac 2
     8BFB   2C          15243   	.byte $2c
                        15244   
     8BFC   A2 59       15245   mov1f	ldx #tempf1	;move from fac to temp fac 1
     8BFE   A0 00       15246   	ldy #0
                        15247   
     8C00   20 8C47     15248   movmf	jsr round
     8C03   86 24       15249   	stx index1
     8C05   84 25       15250   	sty index1+1
     8C07   A0 04       15251   	ldy #4
     8C09   A5 67       15252   	lda faclo
     8C0B   91 24       15253   	sta (index),y
     8C0D   88          15254   	dey
     8C0E   A5 66       15255   	lda facmo
     8C10   91 24       15256   	sta (index),y
     8C12   88          15257   	dey
     8C13   A5 65       15258   	lda facmoh
     8C15   91 24       15259   	sta (index),y
     8C17   88          15260   	dey
     8C18   A5 68       15261   	lda facsgn	;include sign in ho.
     8C1A   09 7F       15262   	ora #@177
     8C1C   25 64       15263   	and facho
     8C1E   91 24       15264   	sta (index),y
     8C20   88          15265   	dey
     8C21   A5 63       15266   	lda facexp
     8C23   91 24       15267   	sta (index),y
     8C25   84 71       15268   	sty facov	;zero it since rounded.
     8C27   60          15269   	rts		;(y)=0.
                        15270   
     8C28   A5 6F       15271   movfa	lda argsgn
                        15272   
     8C2A   85 68       15273   movfa1	sta facsgn
     8C2C   A2 05       15274   	ldx #5
                        15275   
     8C2E   B5 69       15276   1$	lda argexp-1,x
     8C30   95 62       15277   	sta facexp-1,x
     8C32   CA          15278   	dex
     8C33   D0 F9       15279   	bne 1$
     8C35   86 71       15280   	stx facov

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 181-8
'code19'   CODE19.SRC

Error Addr  Code          Seq   Source statement

     8C37   60          15281   	rts
                        15282   
     8C38   20 8C47     15283   movaf	jsr round
                        15284   
     8C3B   A2 06       15285   movef	ldx #6
                        15286   
     8C3D   B5 62       15287   movafl	lda facexp-1,x
     8C3F   95 69       15288   	sta argexp-1,x
     8C41   CA          15289   	dex
     8C42   D0 F9       15290   	bne movafl
     8C44   86 71       15291   	stx facov	;zero it since rounded.
     8C46   60          15292   movrts	rts
                        15293   
                        15294   
     8C47               15295   round
     8C47   A5 63       15296   	lda facexp	;zero?
     8C49   F0 FB       15297   	beq movrts	;yes, done rounding,
     8C4B   06 71       15298   	asl facov	;round?
     8C4D   90 F7       15299   	bcc movrts	;no, msb off.
     8C4F               15300   incrnd
     8C4F   20 894E     15301   	jsr incfac	;yes, add one to lsb(fac).
     8C52   D0 F2       15302   	bne movrts	;no carry means done.
     8C54   4C 8917     15303   	jmp rndshf	;squeez msb in and rts.
                        15304   			;	
                        15305   			; note (c) =1 since incpac doesn't touch c.
                        15306   			;
                        15307   			;put sign in fac in acca.
     8C57               15308   sign
     8C57   A5 63       15309   	lda facexp
     8C59   F0 09       15310   	beq signrt	;if number is zero, so is result.
     8C5B               15311   fcsign
     8C5B   A5 68       15312   	lda facsgn
     8C5D               15313   fcomps
     8C5D   2A          15314   	rol a
     8C5E   A9 FF       15315   	lda #$ff	;assume negative.
     8C60   B0 02       15316   	bcs signrt
     8C62   A9 01       15317   	lda #1		;get +1.
     8C64   60          15318   signrt	rts
                        15319   
                        15320   			;sgn function.
     8C65               15321   sgn
     8C65   20 8C57     15322   	jsr sign
                        15323   			;float the signed integer in accb.
     8C68               15324   float
     8C68   85 64       15325   	sta facho	;put (accb) in high order.
     8C6A   A9 00       15326   	lda #0
     8C6C   85 65       15327   	sta facho+1
     8C6E   A2 88       15328   	ldx #@210	;get the exponent.
                        15329   			;float the signed number in fac.
                        15330   
     8C70               15331   floats
     8C70   A5 64       15332   	lda facho
     8C72   49 FF       15333   	eor #@377
     8C74   2A          15334   	rol a		;get comp of sign in carry.
     8C75               15335   floatc

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 181-9
'code19'   CODE19.SRC

Error Addr  Code          Seq   Source statement

     8C75   A9 00       15336   	lda #0		;zero (acca) but not carry.
     8C77   85 67       15337   	sta faclo
     8C79   85 66       15338   	sta facmo
     8C7B               15339   floatb
     8C7B   86 63       15340   	stx facexp
     8C7D   85 71       15341   	sta facov
     8C7F   85 68       15342   	sta facsgn
     8C81   4C 88B1     15343   	jmp fadflt
                        15344   
                        15345   			;absolute value of fac.
     8C84               15346   abs
     8C84   46 68       15347   	lsr facsgn
     8C86   60          15348   	rts
                        15349   			;
                        15350   			;compare two numbers
                        15351   			;	
                        15352   			;a=1 if arg .lt. fac.
                        15353   			;a=0 if arg=fac.
                        15354   			;a=-1 if arg .gt. fac.
                        15355   			;
                        15356   
     8C87               15357   fcomp
     8C87   85 26       15358   	sta index2
     8C89   84 27       15359   	sty index2+1
     8C8B   A0 00       15360   	ldy #0
     8C8D   B1 26       15361   	lda (index2),y	;has argexp.
     8C8F   C8          15362   	iny		;bump pointer up.
     8C90   AA          15363   	tax		;save a in x and reset codes.
     8C91   F0 C4       15364   	beq sign
     8C93   B1 26       15365   	lda (index2),y
     8C95   45 68       15366   	eor facsgn	;signs the same.
     8C97   30 C2       15367   	bmi fcsign	;signs differ so result is 
     8C99   E4 63       15368   	cpx facexp	;sign of fac again.
     8C9B   D0 21       15369   	bne fcompc
                        15370   
     8C9D   B1 26       15371   	lda (index2),y
     8C9F   09 80       15372   	ora #@200
     8CA1   C5 64       15373   	cmp facho
     8CA3   D0 19       15374   	bne fcompc
     8CA5   C8          15375   	iny
     8CA6   B1 26       15376   	lda (index2),y
     8CA8   C5 65       15377   	cmp facmoh
     8CAA   D0 12       15378   	bne fcompc
     8CAC   C8          15379   	iny
     8CAD   B1 26       15380   	lda (index2),y
     8CAF   C5 66       15381   	cmp facmo
     8CB1   D0 0B       15382   	bne fcompc
     8CB3   C8          15383   	iny
     8CB4   A9 7F       15384   	lda #@177
     8CB6   C5 71       15385   	cmp facov
     8CB8   B1 26       15386   	lda (index2),y
     8CBA   E5 67       15387   	sbc faclo	;get zero if equal.
     8CBC   F0 2A       15388   	beq qintrt
                        15389   
     8CBE               15390   fcompc

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 181-10
'code19'   CODE19.SRC

Error Addr  Code          Seq   Source statement

     8CBE   A5 68       15391   	lda facsgn
     8CC0   90 02       15392   	bcc fcompd
     8CC2   49 FF       15393   	eor #@377
     8CC4   4C 8C5D     15394   fcompd	jmp fcomps	;a part of sign sets up acca.
                        15395   
                        15396   ;end
                        15397   	.include code21

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 182
'code21'   CODE21.SRC

Error Addr  Code          Seq   Source statement

                        15399   	.subttl 'code21'
                        15400   
                        15401   ;*********************************
                        15402   ; quick greatest integer function
                        15403   ;*********************************
                        15404   
                        15405   			;quick greatest integer function.
                        15406   			;leaves int(fac) in facho&mo&lo signed.
                        15407   			;assumes fac .lt.2~23 =8388608
                        15408   
     8CC7   A5 63       15409   qint	lda facexp
     8CC9   F0 4D       15410   	beq clrfac	;if zero, got it.
     8CCB   38          15411   	sec
     8CCC   E9 A0       15412   	sbc #$a0	;get number of palces to shift.
     8CCE   24 68       15413   	bit facsgn
     8CD0   10 0A       15414   	bpl qishft
     8CD2   AA          15415   	tax
     8CD3   A9 FF       15416   	lda #@377
     8CD5   8D 03DF     15417   	sta bits	;put 377 in when shftr shifts bytes.
     8CD8   20 892C     15418   	jsr negfch	;truly negate quantity in fac.
     8CDB   8A          15419   	txa
     8CDC               15420   qishft
     8CDC   A2 63       15421   	ldx #fac
     8CDE   C9 F9       15422   	cmp #$f9
     8CE0   10 07       15423   	bpl qint1	;if number of places .gt. 7.
                        15424   			;shift 1 place at a time.
     8CE2   20 8979     15425   	jsr shiftr	;start shifting bytes, then bits.
     8CE5   8C 03DF     15426   	sty bits	;zero bits since adder wants zero.
     8CE8   60          15427   qintrt	rts
                        15428   
     8CE9               15429   qint1
     8CE9   A8          15430   	tay		;put count in counter.
     8CEA   A5 68       15431   	lda facsgn
     8CEC   29 80       15432   	and #@200	;get sign bit.
     8CEE   46 64       15433   	lsr facho	;save first shifted byte.
     8CF0   05 64       15434   	ora facho
     8CF2   85 64       15435   	sta facho
     8CF4   20 8990     15436   	jsr rolshf	;shift the rest.
     8CF7   8C 03DF     15437   	sty bits	;zero (bits).
     8CFA   60          15438   	rts
                        15439   
                        15440   ;***************************
                        15441   ; greatest integer function
                        15442   ;***************************
                        15443   
     8CFB               15444   int
     8CFB   A5 63       15445   	lda facexp
     8CFD   C9 A0       15446   	cmp #$a0
     8CFF   B0 20       15447   	bcs intrts	;forget it.
     8D01   20 ABC1     15448   	jsr round_qint	;PATCH FIXES INT(.9+.1) TYPE BUGS  (04/08/85 FAB)
     8D04   84 71       15449   	sty facov	;clr overflow byte.
     8D06   A5 68       15450   	lda facsgn
     8D08   84 68       15451   	sty facsgn	;make fac look positive.
     8D0A   49 80       15452   	eor #@200	;get complement of sign in carry.
     8D0C   2A          15453   	rol a

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 182-1
'code21'   CODE21.SRC

Error Addr  Code          Seq   Source statement

     8D0D   A9 A0       15454   	lda #@230+8
     8D0F   85 63       15455   	sta facexp
     8D11   A5 67       15456   	lda faclo
     8D13   85 09       15457   	sta integr
     8D15   4C 88B1     15458   	jmp fadflt
                        15459   
     8D18               15460   clrfac
     8D18   85 64       15461   	sta facho	;make it really zero.
     8D1A   85 65       15462   	sta facmoh
     8D1C   85 66       15463   	sta facmo
     8D1E   85 67       15464   	sta faclo
     8D20   A8          15465   	tay
     8D21   60          15466   intrts	rts

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 183
'code21'   CODE21.SRC

Error Addr  Code          Seq   Source statement

                        15468   
                        15469   ; Floating point input routine.
                        15470   ;
                        15471   ; Number input is left in fac. at entry (txtptr) points to the first character
                        15472   ; in a text buffer. The first character is also in acca. Fin packs the digits
                        15473   ; into the fac as an integer and keeps track of where the decimal point is.
                        15474   ; (dptflg) tells whether a dp has been seen. (deccnt ) is the number of digits
                        15475   ; after the dp. At the end (deccnt) and the exponent are used to determine how
                        15476   ; many times to multiply or divide by ten to get the correct number.
                        15477   
     8D22   8E 03DA     15478   fin	stx fin_bank	;save bank number where string is stored
                        15479   
     8D25   A0 00       15480   	ldy #0		;zero facsgn&sgnflg.
     8D27   A2 0A       15481   	ldx #$0a	;zero exp and ho (and moh).
     8D29   94 5F       15482   10$	sty deccnt,x	;zero mo and lo.
     8D2B   CA          15483   	dex		;zero tenexp and expsgn.
     8D2C   10 FB       15484   	bpl 10$		;zero deccnt, dptflg.
                        15485   
     8D2E   90 0F       15486   	bcc findgq	;flags still set from chrget.
     8D30   C9 2D       15487   	cmp #'-'	;a negative sign?
     8D32   D0 04       15488   	bne qplus	;no, try plus sign.
     8D34   86 69       15489   	stx sgnflg	;it's negative. (x=377).
     8D36   F0 04       15490   	beq finc	;always branches.
                        15491   
     8D38   C9 2B       15492   qplus	cmp #'+'	;plus sign?
     8D3A   D0 05       15493   	bne fin1	;yes, skip it.
                        15494   
     8D3C   20 8DF5     15495   finc	jsr fin_chrget
                        15496   
     8D3F   90 5B       15497   findgq	bcc findig
                        15498   
     8D41   C9 2E       15499   fin1	cmp #'.'	;the dp?
     8D43   F0 2E       15500   	beq findp	;no kidding.
     8D45   C9 45       15501   	cmp #'E'	;exponent follows.
     8D47   D0 30       15502   	bne fine	;no.
                        15503   			;here is check for sign of exp.
     8D49   20 8DF5     15504   	jsr fin_chrget	;yes, get another.
     8D4C   90 17       15505   	bcc fnedg1	;is it a digit. (easier than backing up pointer).
     8D4E   C9 AB       15506   	cmp #minutk	;minus?
     8D50   F0 0E       15507   	beq finec1	;negate.
     8D52   C9 2D       15508   	cmp #'-'	;minus sign?
     8D54   F0 0A       15509   	beq finec1	
     8D56   C9 AA       15510   	cmp #plustk	;plus?
     8D58   F0 08       15511   	beq finec
     8D5A   C9 2B       15512   	cmp #'+'	;plus sign?
     8D5C   F0 04       15513   	beq finec
     8D5E   D0 07       15514   	bne finec2
                        15515   
     8D60   66 62       15516   finec1	ror expsgn	;turn it on.
                        15517   
     8D62   20 8DF5     15518   finec	jsr fin_chrget	;get another.
                        15519   
     8D65   90 5C       15520   fnedg1	bcc finedg	;it is a digit.
     8D67   24 62       15521   finec2	bit expsgn
     8D69   10 0E       15522   	bpl fine

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 183-1
'code21'   CODE21.SRC

Error Addr  Code          Seq   Source statement

     8D6B   A9 00       15523   	lda #0
     8D6D   38          15524   	sec
     8D6E   E5 60       15525   	sbc tenexp
     8D70   4C 8D7B     15526   	jmp fine1
                        15527   
     8D73   66 61       15528   findp	ror dptflg
     8D75   24 61       15529   	bit dptflg
     8D77   50 C3       15530   	bvc finc
     8D79               15531   fine
     8D79   A5 60       15532   	lda tenexp
     8D7B               15533   fine1
     8D7B   38          15534   	sec
     8D7C   E5 5F       15535   	sbc deccnt	;get number of palces to shift.
     8D7E   85 60       15536   	sta tenexp
     8D80   F0 12       15537   	beq finqng	;negate?
     8D82   10 09       15538   	bpl finmul	;positive, so multiply.
     8D84               15539   findiv
     8D84   20 8B38     15540   	jsr div10
     8D87   E6 60       15541   	inc tenexp	;done?
     8D89   D0 F9       15542   	bne findiv	;no.
     8D8B   F0 07       15543   	beq finqng	;yes.
                        15544   
                        15545   
     8D8D               15546   finmul
     8D8D   20 8B17     15547   	jsr mul10
     8D90   C6 60       15548   	dec tenexp	;done?
     8D92   D0 F9       15549   	bne finmul	;no.
     8D94               15550   finqng
     8D94   A5 69       15551   	lda sgnflg
     8D96   30 01       15552   	bmi negxqs	;if positive, return.
     8D98   60          15553   	rts
                        15554   
     8D99               15555   negxqs	
     8D99   4C 8FFA     15556   	jmp negop	;oterwise, negate and return.
                        15557   
                        15558   
     8D9C               15559   findig
     8D9C   48          15560   	pha
     8D9D   24 61       15561   	bit dptflg
     8D9F   10 02       15562   	bpl findg1
     8DA1   E6 5F       15563   	inc deccnt
     8DA3               15564   findg1
     8DA3   20 8B17     15565   	jsr mul10
     8DA6   68          15566   	pla		;get it back.
     8DA7   38          15567   	sec
     8DA8   E9 30       15568   	sbc #'0'
     8DAA   20 8DB0     15569   	jsr finlog	;add it in.
     8DAD   4C 8D3C     15570   	jmp finc
                        15571   
                        15572   
     8DB0               15573   finlog
     8DB0   48          15574   	pha
     8DB1   20 8C38     15575   	jsr movaf	;save it for later.
     8DB4   68          15576   	pla
     8DB5   20 8C68     15577   	jsr float	;float the value in acca.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 183-2
'code21'   CODE21.SRC

Error Addr  Code          Seq   Source statement

     8DB8   A5 6F       15578   	lda argsgn
     8DBA   45 68       15579   	eor facsgn
     8DBC   85 70       15580   	sta arisgn	;resultant sign.
     8DBE   A6 63       15581   	ldx facexp	;set signs on thing to add.
     8DC0   4C 8848     15582   	jmp faddt	;add together and return.
                        15583   
                        15584   			;
                        15585   			;here pack in the next digit of the exponent.
                        15586   			;multiply the old exp by 10 and add in the next
                        15587   			;digit. note: exp overflow is not checked for 
                        15588   			;
                        15589   
                        15590   
     8DC3               15591   finedg
     8DC3   A5 60       15592   	lda tenexp	;get exp so far.
     8DC5   C9 0A       15593   	cmp #@12	;will result be .ge. 100
     8DC7   90 09       15594   	bcc mlex10
     8DC9   A9 64       15595   	lda #@144
     8DCB   24 62       15596   	bit expsgn
     8DCD   30 21       15597   	bmi mlexmi	;if neg exp, no chk for overr.
     8DCF   4C 895D     15598   	jmp overr
                        15599   
     8DD2               15600   mlex10
     8DD2   0A          15601   	asl a		;max is 120.
     8DD3   0A          15602   	asl a		;mult by 2 twice.
     8DD4   18          15603   	clc		;possible shift out of high.
     8DD5   65 60       15604   	adc tenexp	;like multiplying by five.
     8DD7   0A          15605   	asl a		;and now by ten.
     8DD8   18          15606   	clc
     8DD9   A0 00       15607   	ldy #0
     8DDB   85 79       15608   	sta syntmp
                        15609   
     8DDD   AD 03DA     15610   	lda fin_bank	;bank 0 (text) or 1 (string)?
     8DE0   D0 06       15611   	bne 10$		;branch if string
     8DE2   20 03C9     15612   	jsr indtxt
     8DE5   4C 8DEB     15613   	jmp 20$
     8DE8   20 03B7     15614   10$	jsr indin1_ram1
                        15615   
     8DEB   65 79       15616   20$	adc syntmp
     8DED   38          15617   	sec
     8DEE   E9 30       15618   	sbc #'0'
     8DF0               15619   mlexmi
     8DF0   85 60       15620   	sta tenexp	;save result.
     8DF2   4C 8D62     15621   	jmp finec
                        15622   
                        15623   
                        15624   
                        15625   
                        15626   ;
                        15627   ; subby to get a character from bank 0 or 1, and set the flags in the manner
                        15628   ; performed by chrget in either case
                        15629   
     8DF5               15630   fin_chrget
     8DF5   AD 03DA     15631   	lda fin_bank	;which bank is byte to come from
     8DF8   D0 03       15632   	bne fin_chrget_1	;branch if string bank (1)

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 183-3
'code21'   CODE21.SRC

Error Addr  Code          Seq   Source statement

     8DFA   4C 0380     15633   	jmp chrget	;bank 0 (text) uses normal chrget mechanism
                        15634   
     8DFD               15635   fin_chrget_1
     8DFD   E6 24       15636   	inc index1
     8DFF   D0 02       15637   	bne fin_chrget_2
     8E01   E6 25       15638   	inc index1+1
     8E03               15639   fin_chrget_2
     8E03   A0 00       15640   	ldy #0
     8E05   20 03B7     15641   	jsr indin1_ram1
     8E08   C9 3A       15642   	cmp #':'
     8E0A   B0 0A       15643   	bcs 10$
     8E0C   C9 20       15644   	cmp #' '
     8E0E   F0 ED       15645   	beq fin_chrget_1	;skip over spaces
     8E10   38          15646   	sec
     8E11   E9 30       15647   	sbc #'0'	;set up .C as chrget would
     8E13   38          15648   	sec
     8E14   E9 D0       15649   	sbc #$d0
     8E16   60          15650   10$	rts
                        15651   
                        15652   ;.end
                        15653   	.include code22

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 184
'code22'   CODE22.SRC

Error Addr  Code          Seq   Source statement

                        15655   	.subttl 'code22'
     8E17   9B 3E BC    15656   n0999	.byte $9b,$3e,$bc,$1f,$fd
     8E1A   1F FD               
     8E1C   9E 6E 6B    15657   n9999	.byte $9e,$6e,$6b,$27,$fd
     8E1F   27 FD               
     8E21   9E 6E 6B    15658   nmil	.byte $9e,$6e,$6b,$28,$00
     8E24   28 00               
                        15659   
     8E26               15660   inprt
     8E26   20 9281     15661   	jsr k_primm
     8E29   20 49 4E    15662   	.byte ' IN ', 0
     8E2C   20 00               
     8E2E               15663   curprt
     8E2E   A5 3C       15664   	lda curlin+1
     8E30   A6 3B       15665   	ldx curlin
     8E32               15666   linprt
     8E32   85 64       15667   	sta facho
     8E34   86 65       15668   	stx facho+1
     8E36   A2 90       15669   	ldx #@220	;exponent of 16.
     8E38   38          15670   	sec		;number is positive.
     8E39   20 8C75     15671   	jsr floatc
     8E3C   20 8E44     15672   	jsr foutc
     8E3F   4C 55FF     15673   	jmp strout	;print and return.
                        15674   
     8E42               15675   fout
     8E42   A0 01       15676   	ldy #1
     8E44               15677   foutc
     8E44   A9 20       15678   	lda #' '	;if positive, print space
     8E46   24 68       15679   	bit facsgn
     8E48   10 02       15680   	bpl fout1
     8E4A   A9 2D       15681   	lda #'-'	;if neg
     8E4C               15682   fout1
     8E4C   99 00FF     15683   	sta fbuffr-1,y	;store the character.
     8E4F   85 68       15684   	sta facsgn	;make fac pos for qint.
     8E51   84 72       15685   	sty fbufpt	;save for later
     8E53   C8          15686   	iny
     8E54   A9 30       15687   	lda #'0'	;get zero to type if fac = 0
     8E56   A6 63       15688   	ldx facexp
     8E58   D0 03       15689   	bne *+5
     8E5A   4C 8F69     15690   	jmp fout19
                        15691   
     8E5D   A9 00       15692   	lda #0
     8E5F   E0 80       15693   	cpx #@200	;is number < 1?
     8E61   F0 02       15694   	beq fout37	;no
     8E63   B0 09       15695   	bcs fout7
     8E65               15696   fout37
     8E65   A9 21       15697   	lda #<nmil	;mult by 10~6
     8E67   A0 8E       15698   	ldy #>nmil
     8E69   20 8A08     15699   	jsr rommlt
     8E6C   A9 F7       15700   	lda #$f7
     8E6E               15701   fout7
     8E6E   85 5F       15702   	sta deccnt	;save count or zero it.
     8E70               15703   fout4
     8E70   A9 1C       15704   	lda #<n9999
     8E72   A0 8E       15705   	ldy #>n9999

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 184-1
'code22'   CODE22.SRC

Error Addr  Code          Seq   Source statement

     8E74   20 8C87     15706   	jsr fcomp	;is number .gt. 999999.499?
                        15707   			;or 999999999.5?
     8E77   F0 1E       15708   	beq bigges
     8E79   10 12       15709   	bpl fout9	;yes, make it smaller.
     8E7B               15710   fout3
     8E7B   A9 17       15711   	lda #<n0999
     8E7D   A0 8E       15712   	ldy #>n0999
     8E7F   20 8C87     15713   	jsr fcomp	;is number .gt.99999,9499?
                        15714   			;or 99999999.90625?
     8E82   F0 02       15715   	beq fout38
     8E84   10 0E       15716   	bpl fout5	;yes. done multiplying.
     8E86               15717   fout38
     8E86   20 8B17     15718   	jsr mul10	;make it bigger.
     8E89   C6 5F       15719   	dec deccnt
     8E8B   D0 EE       15720   	bne fout3	;see if taht does it.
     8E8D               15721   fout9			;this always goes.
     8E8D   20 8B38     15722   	jsr div10	;make it smaller.
     8E90   E6 5F       15723   	inc deccnt
     8E92   D0 DC       15724   	bne fout4	;see if that does it. 
     8E94               15725   fout5			;this always goes.
     8E94   20 8A0E     15726   	jsr faddh	;add a half to round up.
     8E97               15727   bigges
     8E97   20 8CC7     15728   	jsr qint
     8E9A   A2 01       15729   	ldx #1		;decimal point count.
     8E9C   A5 5F       15730   	lda deccnt
     8E9E   18          15731   	clc
     8E9F   69 0A       15732   	adc #$0a	;should number be printed in E notation? 
                        15733   			;(ie, is number .lt. .01?)
     8EA1   30 09       15734   	bmi foutpi	;yes.
     8EA3   C9 0B       15735   	cmp #$0b	;is it .gt. 999999 (9999999999)?
     8EA5   B0 06       15736   	bcs fout6	;yes, use E notation.
     8EA7   69 FF       15737   	adc #$ff	;number of palces before decimal point.
     8EA9   AA          15738   	tax		;put into accx.
     8EAA   A9 02       15739   	lda #2		;no E notation.
     8EAC               15740   foutpi
     8EAC   38          15741   	sec
     8EAD               15742   fout6
     8EAD   E9 02       15743   	sbc #2		;effectively add 5 to orig exp.
     8EAF   85 60       15744   	sta tenexp	;that is the exponent to print.
     8EB1   86 5F       15745   	stx deccnt	;number of decimal places.
     8EB3   8A          15746   	txa
     8EB4   F0 02       15747   	beq fout39
     8EB6   10 13       15748   	bpl fout8	;some places before dec pnt.
     8EB8               15749   fout39
     8EB8   A4 72       15750   	ldy fbufpt	;get pointer to output.
     8EBA   A9 2E       15751   	lda #'.'	;put in "."
     8EBC   C8          15752   	iny	
     8EBD   99 00FF     15753   	sta fbuffr-1,y
     8EC0   8A          15754   	txa
     8EC1   F0 06       15755   	beq fout16
     8EC3   A9 30       15756   	lda #'0'	;get the ensuing zero.
     8EC5   C8          15757   	iny
     8EC6   99 00FF     15758   	sta fbuffr-1,y
     8EC9               15759   fout16
     8EC9   84 72       15760   	sty fbufpt	;save it for later.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 184-2
'code22'   CODE22.SRC

Error Addr  Code          Seq   Source statement

     8ECB               15761   fout8
     8ECB   A0 00       15762   	ldy #0
     8ECD               15763   foutim
     8ECD   A2 80       15764   	ldx #@200	;first pass through ,accb has msb set.
     8ECF               15765   fout2
     8ECF   A5 67       15766   	lda faclo
     8ED1   18          15767   	clc
     8ED2   79 8F7E     15768   	adc foutbl+3,y
     8ED5   85 67       15769   	sta faclo
     8ED7   A5 66       15770   	lda facmo
     8ED9   79 8F7D     15771   	adc foutbl+2,y
     8EDC   85 66       15772   	sta facmo
     8EDE   A5 65       15773   	lda facmoh
     8EE0   79 8F7C     15774   	adc foutbl+1,y
     8EE3   85 65       15775   	sta facmoh
     8EE5   A5 64       15776   	lda facho
     8EE7   79 8F7B     15777   	adc foutbl,y
     8EEA   85 64       15778   	sta facho
     8EEC   E8          15779   	inx		;it was done yet another time.
     8EED   B0 04       15780   	bcs fout41
     8EEF   10 DE       15781   	bpl fout2
     8EF1   30 02       15782   	bmi fout40
                        15783   
     8EF3               15784   fout41
     8EF3   30 DA       15785   	bmi fout2
     8EF5               15786   fout40
     8EF5   8A          15787   	txa
     8EF6   90 04       15788   	bcc foutyp	;can use acca as is.
     8EF8   49 FF       15789   	eor #@377	;find 11.(a).
     8EFA   69 0A       15790   	adc #@12	;c is still on to complete negation.
                        15791   			;and will always be on after.
     8EFC               15792   foutyp
     8EFC   69 2F       15793   	adc #@57	;get a character to print.
     8EFE   C8          15794   	iny
     8EFF   C8          15795   	iny
     8F00   C8          15796   	iny
     8F01   C8          15797   	iny
     8F02   84 49       15798   	sty fdecpt
     8F04   A4 72       15799   	ldy fbufpt
     8F06   C8          15800   	iny		;point to place to store output.
     8F07   AA          15801   	tax
     8F08   29 7F       15802   	and #@177	;get rid of msb.
     8F0A   99 00FF     15803   	sta fbuffr-1,y
     8F0D   C6 5F       15804   	dec deccnt
     8F0F   D0 06       15805   	bne stxbuf	;not time for dp yet.
     8F11   A9 2E       15806   	lda #'.'
     8F13   C8          15807   	iny
     8F14   99 00FF     15808   	sta fbuffr-1,y	;store dp.
     8F17               15809   stxbuf
     8F17   84 72       15810   	sty fbufpt	;store pointer for later.
     8F19   A4 49       15811   	ldy fdecpt
     8F1B   8A          15812   	txa		;complement accb.
     8F1C   49 FF       15813   	eor #@377	;complement acca.
     8F1E   29 80       15814   	and #@200	;save only msb.
     8F20   AA          15815   	tax

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 184-3
'code22'   CODE22.SRC

Error Addr  Code          Seq   Source statement

     8F21   C0 24       15816   	cpy #fdcend-foutbl
     8F23   F0 04       15817   	beq fouldy
     8F25   C0 3C       15818   	cpy #timend-foutbl
     8F27   D0 A6       15819   	bne fout2	;continue with output.
     8F29               15820   fouldy		
     8F29   A4 72       15821   	ldy fbufpt      ;get back output pointer.
     8F2B               15822   fout11
     8F2B   B9 00FF     15823   	lda fbuffr-1,y	;remove trailing blanks.
     8F2E   88          15824   	dey
     8F2F   C9 30       15825   	cmp #'0'
     8F31   F0 F8       15826   	beq fout11
     8F33   C9 2E       15827   	cmp #'.'
     8F35   F0 01       15828   	beq fout12	;run into dp. stop.
     8F37   C8          15829   	iny		;something else, save it.
     8F38               15830   fout12
     8F38   A9 2B       15831   	lda #'+'
     8F3A   A6 60       15832   	ldx tenexp
     8F3C   F0 2E       15833   	beq fout17	;no exponent to output.
     8F3E   10 08       15834   	bpl fout14
     8F40   A9 00       15835   	lda #0
     8F42   38          15836   	sec
     8F43   E5 60       15837   	sbc tenexp
     8F45   AA          15838   	tax
                        15839   
                        15840   ;.end
                        15841   	.include code23

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 185
'code23'   CODE23.SRC

Error Addr  Code          Seq   Source statement

                        15843   	.subttl 'code23'
     8F46   A9 2D       15844   	lda #'-'	;exponent is negative.
     8F48               15845   fout14
     8F48   99 0101     15846   	sta fbuffr+1,y	;store sign of exponent.
     8F4B   A9 45       15847   	lda #'E'
     8F4D   99 0100     15848   	sta fbuffr,y	;store the "e" character.
     8F50   8A          15849   	txa
     8F51   A2 2F       15850   	ldx #@57
     8F53   38          15851   	sec
     8F54               15852   fout15
     8F54   E8          15853   	inx		;move closer to output value.
     8F55   E9 0A       15854   	sbc #@12	;subtract 10.
     8F57   B0 FB       15855   	bcs fout15	;not negative yet.
     8F59   69 3A       15856   	adc #@72	;get second output character.
     8F5B   99 0103     15857   	sta fbuffr+3,y	;store high digit.
     8F5E   8A          15858   	txa		
     8F5F   99 0102     15859   	sta fbuffr+2,y	;store low digit.
     8F62   A9 00       15860   	lda #0		;put in terminator.
     8F64   99 0104     15861   	sta fbuffr+4,y
     8F67   F0 08       15862   	beq fout20	;return, (always branches).
     8F69               15863   fout19
     8F69   99 00FF     15864   	sta fbuffr-1,y	;store the character.
     8F6C               15865   fout17
     8F6C   A9 00       15866   	lda #0		;a terminator.
     8F6E   99 0100     15867   	sta fbuffr,y
     8F71               15868   fout20
     8F71   A9 00       15869   	lda #<fbuffr
     8F73   A0 01       15870   	ldy #>fbuffr
     8F75   60          15871   	rts		;all done.
                        15872   
                        15873   
                        15874   
     8F76   80 00 00    15875   fhalf	.byte @200,0,0,0,0
     8F79   00 00               
                        15876   
     8F7B   FA 0A 1F    15877   foutbl	.byte @372,@12,@37,0,0
     8F7E   00 00               
     8F80   98 96 80    15878   	.byte @230,@226,@200,@377
     8F83   FF                  
     8F84   F0 BD C0    15879   	.byte @360,@275,@300,0
     8F87   00                  
     8F88   01 86 A0    15880   	.byte 1,@206,@240,@377
     8F8B   FF                  
     8F8C   FF D8 F0    15881   	.byte @377,@330,@360,0,0
     8F8F   00 00               
     8F91   03 E8 FF    15882   	.byte 3,@350,@377,@377
     8F94   FF                  
     8F95   FF 9C 00    15883   	.byte @377,@234,0,0,0,@12
     8F98   00 00 0A            
     8F9B   FF FF FF    15884   	.byte @377,@377,@377,@377
     8F9E   FF                  
                        15885   
     8F9F   FF DF 0A    15886   fdcend	.byte @377,@337,@12,@200
     8FA2   80                  
     8FA3   00 03 4B    15887   	.byte 0,3,@113,@300,@377

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 185-1
'code23'   CODE23.SRC

Error Addr  Code          Seq   Source statement

     8FA6   C0 FF               
     8FA8   FF 73 60    15888   	.byte @377,@163,@140,0,0
     8FAB   00 00               
     8FAD   0E 10 FF    15889   	.byte @16,@20,@377,@377
     8FB0   FF                  
     8FB1   FD A8 00    15890   	.byte @375,@250,0,0,0,@74
     8FB4   00 00 3C            
     8FB7               15891   timend
                        15892   			;
                        15893   			;exponentiation and square root function.
                        15894   			;	
                        15895   			;square root function---sqr(a).
                        15896   			;use sqr(x)=x~.5
     8FB7               15897   sqr
     8FB7   20 8C38     15898   	jsr movaf	;move fac into arg.
     8FBA   A9 76       15899   	lda #<fhalf
     8FBC   A0 8F       15900   	ldy #>fhalf
                        15901   
     8FBE   20 8BD4     15902   fpwr	jsr movfm	;put memory into fac.
                        15903   			;last thing fetched is facexp into accx.
                        15904   			;
                        15905   			;exponentiation --- x~y.
                        15906   			;n.b. 0~0=1
                        15907   			;first check if y=0. if so, the result is one.
                        15908   			;next check if x=0. if so the result is zero.
                        15909   			;then check if x>0. if not check that y is an integer.
                        15910   			;if so, negate x, so that lg doesn't give fcerr.
                        15911   			;if x is negative and y is odd, negate the result
                        15912   			;returned by exp.
                        15913   			;to compute the result use x~y=exp((y*log(x)).
                        15914   			;
                        15915   
     8FC1               15916   fpwrt
     8FC1   F0 70       15917   	beq exp		;if fac=0, just exponentiate taht.
     8FC3   A5 6A       15918   	lda argexp	;is x=0?
     8FC5   D0 03       15919   	bne fpwrt1	;
     8FC7   4C 88D8     15920   	jmp zerof1	;zero fac.
                        15921   
     8FCA               15922   fpwrt1
     8FCA   A2 50       15923   	ldx #<tempf3	;save it for later in a temp.
     8FCC   A0 00       15924   	ldy #>tempf3
     8FCE   20 8C00     15925   	jsr movmf
                        15926   			;y=0 already. good; incase no one calls int.
     8FD1   A5 6F       15927   	lda argsgn
     8FD3   10 0F       15928   	bpl fpwr1	;no problems if x>0.
     8FD5   20 8CFB     15929   	jsr int		;integerize the fac.
     8FD8   A9 50       15930   	lda #<tempf3	;get addr of comperand.
     8FDA   A0 00       15931   	ldy #>tempf3
     8FDC   20 8C87     15932   	jsr fcomp	;equal?
     8FDF   D0 03       15933   	bne fpwr1	;leave x neg. log will blow him out.
                        15934   			;a=-1 and y is irrelavant.
     8FE1   98          15935   	tya		;negative x. make positive.
     8FE2   A4 09       15936   	ldy integr	;get evenness.
     8FE4               15937   fpwr1
     8FE4   20 8C2A     15938   	jsr movfa1	;alternate entry point

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 185-2
'code23'   CODE23.SRC

Error Addr  Code          Seq   Source statement

     8FE7   98          15939   	tya
     8FE8   48          15940   	pha		;svae evenness for later. 
     8FE9   20 89CA     15941   	jsr log	        ;find log
     8FEC   A9 50       15942   	lda #<tempf3	;multiply fac times log(x).
     8FEE   A0 00       15943   	ldy #>tempf3
     8FF0   20 8A24     15944   	jsr fmult
     8FF3   20 9033     15945   	jsr exp		;exponentiate the fac.
     8FF6   68          15946   	pla
     8FF7   4A          15947   	lsr a		;is it even?
     8FF8   90 0A       15948   	bcc negrts	;yes. or x>0.
                        15949   			;negate the number in fac.
     8FFA               15950   negop
     8FFA   A5 63       15951   	lda facexp
     8FFC   F0 06       15952   	beq negrts
     8FFE   A5 68       15953   	lda facsgn
     9000   49 FF       15954   	eor #@377
     9002   85 68       15955   	sta facsgn
     9004               15956   negrts
     9004   60          15957   	rts
                        15958   
                        15959   ;.end
                        15960   	.include code24

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 186
'code24'   CODE24.SRC

Error Addr  Code          Seq   Source statement

                        15962   	.subttl 'code24'
                        15963   			;
                        15964   			;exponentation function
                        15965   			;
                        15966   			;first save the original aurgument and multiply the fac
                        15967   			;by log2(e). the result is used to determine if 
                        15968   			;overflow will occur since exp(x)=2~(x*log2(e)) where
                        15969   			;log2(e)=log(e) base 2. then save the integer part of 
                        15970   			;this to scale the answer at the end. since
                        15971   			;2~y=2~int(y)*2~(y-int(y)) and 2~int(y) is easy to
                        15972   			;compute. now compute 2~(x*log2(e))+1-x) where p is 
                        15973   			;an approximation polynomial. the result is then scaled
                        15974   			;by teh power of two previouly saved.
                        15975   			;
     9005   81 38 AA    15976   logeb2	.byte @201,@70,@252,@73,@51	;log(e) base 2.
     9008   3B 29               
                        15977   
     900A   07 71 34    15978   expcon	.byte 7,@161,@64,@130,@76
     900D   58 3E               
     900F   56 74 16    15979   	.byte @126,@164,@26,@176
     9012   7E                  
     9013   B3 1B 77    15980   	.byte @263,@33,@167,@57
     9016   2F                  
     9017   EE E3 85    15981   	.byte @356,@343,@205,@172
     901A   7A                  
     901B   1D 84 1C    15982   	.byte @35,@204,@34,@52
     901E   2A                  
     901F   7C 63 59    15983   	.byte @174,@143,@131,@130
     9022   58                  
     9023   0A 7E 75    15984   	.byte @12,@176,@165,@375
     9026   FD                  
     9027   E7 C6 80    15985   	.byte @347,@306,@200,@61
     902A   31                  
     902B   72 18 10    15986   	.byte @162,@30,@20,@201
     902E   81                  
     902F   00 00 00    15987   	.byte 0,0,0,0
     9032   00                  
                        15988   
                        15989   
                        15990   
     9033               15991   exp
     9033   A9 05       15992   	lda #<logeb2	;multiply by log(e) base 2.
     9035   A0 90       15993   	ldy #>logeb2
     9037   20 8A08     15994   	jsr rommlt
     903A   A5 71       15995   	lda facov
     903C   69 50       15996   	adc #@120
     903E   90 03       15997   	bcc stold
     9040   20 8C4F     15998   	jsr incrnd
                        15999   
                        16000   
                        16001   
     9043               16002   stold
     9043   85 58       16003   	sta oldov
     9045   20 8C3B     16004   	jsr movef	;to save in arg without round.
     9048   A5 63       16005   	lda facexp

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 186-1
'code24'   CODE24.SRC

Error Addr  Code          Seq   Source statement

     904A   C9 88       16006   	cmp #@210	;if abs(fac) .ge. 128, too big.
     904C   90 03       16007   	bcc exp1
     904E               16008   gomldv
     904E   20 8B09     16009   	jsr mldvex	;overflow or overflow.
     9051               16010   exp1
     9051   20 8CFB     16011   	jsr int
     9054   A5 09       16012   	lda integr	;get low part.
     9056   18          16013   	clc
     9057   69 81       16014   	adc #@201
     9059   F0 F3       16015   	beq gomldv	;overflow or overflow !!
     905B   38          16016   	sec
     905C   E9 01       16017   	sbc #1		;subtract it.
     905E   48          16018   	pha		;save a while.
     905F   A2 05       16019   	ldx #5		;prep to swap fac and arg.
     9061               16020   swaplp
     9061   B5 6A       16021   	lda argexp,x
     9063   B4 63       16022   	ldy facexp,x
     9065   95 63       16023   	sta facexp,x
     9067   94 6A       16024   	sty argexp,x
     9069   CA          16025   	dex
     906A   10 F5       16026   	bpl swaplp
     906C   A5 58       16027   	lda oldov
     906E   85 71       16028   	sta facov
     9070   20 8831     16029   	jsr fsubt
     9073   20 8FFA     16030   	jsr negop	;negate fac.
     9076   A9 0A       16031   	lda #<expcon
     9078   A0 90       16032   	ldy #>expcon
     907A   20 909C     16033   	jsr poly
     907D   A9 00       16034   	lda #0
     907F   85 70       16035   	sta arisgn 	;multiply by positive 1.0
     9081   68          16036   	pla		;get scale factor.
     9082   20 8AEE     16037   	jsr mldexp	;modify facexp and check for overflow.
     9085   60          16038   	rts		;has to do jsr due to pulas in muldiv.
                        16039   
                        16040   			;
                        16041   			;polynomial evaluator and the random number generator.
                        16042   			;
                        16043   			;evaluate p(x~2)*x
                        16044   			;pointer to degree is in xreg.
                        16045   			;the constants follow the degree.
                        16046   			;for x=fac, compute:
                        16047   			;c0*x+c1*x~3+c2*x~5+c3*x~7+... +c(n)*x~(2*n+1)
                        16048   			;
     9086               16049   polyx	
     9086   85 72       16050   	sta polypt	;retain polynomial pointer for later.
     9088   84 73       16051   	sty polypt+1
     908A   20 8BFC     16052   	jsr mov1f	;save fac in factmp.
     908D   A9 59       16053   	lda #tempf1
     908F   20 8A24     16054   	jsr fmult	;compute x~2.
     9092   20 90A0     16055   	jsr poly1	;compute p(x~2).
     9095   A9 59       16056   	lda #<tempf1
     9097   A0 00       16057   	ldy #>tempf1
     9099   4C 8A24     16058   	jmp fmult	;multiply by fac again.
                        16059   
                        16060   			;

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 186-2
'code24'   CODE24.SRC

Error Addr  Code          Seq   Source statement

                        16061   			;polynomial evaluator
                        16062   			;
                        16063   			;pointer to degree is in xreg.
                        16064   			;compute:
                        16065   		;c0+c1*x+c2*x~2+c3*x~3+c4*x~4...+c(n-1)*x~(n-1)+c(n)*x~n
                        16066   
     909C               16067   poly
     909C   85 72       16068   	sta polypt
     909E   84 73       16069   	sty polypt+1
     90A0               16070   poly1
     90A0   20 8BF9     16071   	jsr mov2f	;save fac.
     90A3   B1 72       16072   	lda (polypt),y
     90A5   85 69       16073   	sta degree
     90A7   A4 72       16074   	ldy polypt
     90A9   C8          16075   	iny
     90AA   98          16076   	tya
     90AB   D0 02       16077   	bne poly3
     90AD   E6 73       16078   	inc polypt+1
     90AF               16079   poly3
     90AF   85 72       16080   	sta polypt
     90B1   A4 73       16081   	ldy polypt+1
     90B3               16082   poly2
     90B3   20 8A08     16083   	jsr rommlt
     90B6   A5 72       16084   	lda polypt	;get current pointer.
     90B8   A4 73       16085   	ldy polypt+1
     90BA   18          16086   	clc
     90BB   69 05       16087   	adc #5
     90BD   90 01       16088   	bcc poly4
     90BF   C8          16089   	iny
     90C0               16090   poly4
     90C0   85 72       16091   	sta polypt
     90C2   84 73       16092   	sty polypt+1
     90C4   20 8A12     16093   	jsr romadd	;add in constant.
     90C7   A9 5E       16094   	lda #<tempf2	;multiply the origianl fac.
     90C9   A0 00       16095   	ldy #>tempf2
     90CB   C6 69       16096   	dec degree	;done?
     90CD   D0 E4       16097   	bne poly2
     90CF   60          16098   	rts		;yes.
                        16099   
                        16100   
                        16101   ;.end
                        16102   	.include code26

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 187
'code26'   CODE26.SRC

Error Addr  Code          Seq   Source statement

                        16104   	.subttl 'code26'
                        16105   
     90D0   AA          16106   erexit	tax			;set termination flags
     90D1   D0 02       16107   	bne erexiy
     90D3               16108   break_exit
     90D3   A2 1E       16109   	ldx #erbrk		;break error
     90D5   4C 4D59     16110   erexiy	jmp error		;normal error
                        16111   
                        16112   
     90D8   20 A855     16113   k_open	jsr put_io_in_map
     90DB   20 FFC0     16114   	jsr _open
     90DE   60          16115   	rts
                        16116   
                        16117   
     90DF   20 9269     16118   outch	jsr k_bsout
     90E2   B0 EC       16119   	bcs erexit
     90E4   60          16120   	rts
                        16121   
                        16122   
     90E5   20 9263     16123   inchr	jsr k_basin
     90E8   B0 E6       16124   	bcs erexit
     90EA   60          16125   	rts
                        16126   
                        16127   
     90EB   48          16128   coout	pha
     90EC   20 A855     16129   	jsr put_io_in_map
     90EF   20 FFC9     16130   	jsr _chkout
     90F2   20 9243     16131   	jsr dschk		;see if device # >=4, and clear ds if so
     90F5   AA          16132   	tax			;save error code
     90F6   68          16133   	pla
     90F7   90 03       16134   	bcc 1$			;no error
     90F9   8A          16135   	txa
     90FA   B0 D4       16136   	bcs erexit
     90FC   60          16137   1$	rts
                        16138   
                        16139   
     90FD   20 A855     16140   coin	jsr put_io_in_map
     9100   20 FFC6     16141   	jsr _chkin
     9103   20 9243     16142   	jsr dschk		;see if device # >=4, and clear ds if so
     9106   B0 C8       16143   	bcs erexit
     9108   60          16144   	rts
                        16145   
     9109   20 A855     16146   cgetl	jsr put_io_in_map
     910C   20 FFE4     16147   	jsr _getin
     910F   B0 C2       16148   	bcs break_exit		;'stop' key was pressed
     9111   60          16149   	rts
                        16150   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 188
'code26'   CODE26.SRC

Error Addr  Code          Seq   Source statement

                        16152   
     9112   20 91AE     16153   save	jsr plsv		;parse parms
                        16154   
     9115   AE 1210     16155   savenp	ldx text_top		;end save addr
     9118   AC 1211     16156   	ldy text_top+1
     911B   A9 2D       16157   	lda #<txttab		;indirect with start address
                        16158   
     911D   20 A855     16159   savenb	jsr put_io_in_map
     9120   20 FFD8     16160   	jsr _savesp		;save it
     9123   20 9243     16161   	jsr dschk		;see if device # >=4, and clear ds if so
     9126   B0 A8       16162   	bcs erexit
     9128   60          16163   	rts
                        16164   
                        16165   
                        16166   
     9129   A9 01       16167   verify	lda #1			;verify flag
     912B   2C          16168   	.byte $2c    		;skip two bytes
                        16169   
     912C   A9 00       16170   load	lda #0	   		;load flag
     912E   85 0C       16171   	sta verck
     9130   20 91AE     16172   	jsr plsv		;parse parameters
                        16173   
     9133               16174   cld10				;entry from dload
     9133   20 A855     16175   	jsr put_io_in_map
     9136   A5 0C       16176   	lda verck
     9138   A6 2D       16177   	ldx txttab		;.x and .y have alt...
     913A   A4 2E       16178   	ldy txttab+1		;...load address
     913C   20 FFD5     16179   	jsr _loadsp		;load it
     913F   08          16180   	php
     9140   20 9243     16181   	jsr dschk		;see if device # >=4, and clear ds if so
     9143   28          16182   	plp
     9144   B0 65       16183   	bcs jerxit		;problems
                        16184   
     9146   A5 0C       16185   	lda verck
     9148   F0 16       16186   	beq cld50		;was load
                        16187   
                        16188   ;  finish verify
                        16189   
     914A   A2 1C       16190   	ldx #ervfy		;assume error
     914C   20 9251     16191   	jsr k_readst		;read status
     914F   29 10       16192   	and #$10		;check error
     9151   D0 16       16193   	bne cld55		;replaces beq *+5/jmp error
                        16194   
                        16195   ;  print verify 'ok' if direct
                        16196   
     9153   24 7F       16197   	bit runmod		;direct mode?
     9155   30 08       16198   	bmi cld20		;no
     9157   20 9281     16199   	jsr k_primm
     915A   0D 4F 4B    16200   	.byte cr, 'OK', cr, 0
     915D   0D 00               
     915F   60          16201   cld20	rts
                        16202   
                        16203   
                        16204   
                        16205   ;  finish load

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 188-1
'code26'   CODE26.SRC

Error Addr  Code          Seq   Source statement

                        16206   
     9160   20 9251     16207   cld50	jsr k_readst		;read status
     9163   29 BF       16208   	and #$ff-$40		;clear e.o.i.
     9165   F0 05       16209   	beq cld60		;was o.k.
                        16210   
     9167               16211   load_error
     9167   A2 1D       16212   	ldx #erload
     9169   4C 4D59     16213   cld55	jmp error
                        16214   
     916C   8E 1210     16215   cld60	stx text_top
     916F   8C 1211     16216   	sty text_top+1		;end load address
                        16217   
     9172   24 7F       16218   	bit runmod		;direct?
     9174   30 0E       16219   	bmi cld70		;no...
     9176   70 E7       16220   	bvs cld20		;special "RUN file_name" flag...get out here.
                        16221   
     9178   20 4D47     16222   	jsr reddy		;print 'ready'
     917B   20 4F6C     16223   	jsr lnkprg
     917E   20 5210     16224   	jsr runc
     9181   4C 4DE0     16225   	jmp main
                        16226   
                        16227   ;  program load
                        16228   
     9184   20 5271     16229   cld70	jsr stxtpt
     9187   20 4F6C     16230   	jsr lnkprg
     918A   4C 5252     16231   	jmp fload
                        16232   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 189
'code26'   CODE26.SRC

Error Addr  Code          Seq   Source statement

                        16234   
     918D   20 91F6     16235   open	jsr paoc		;parse statement
     9190   18          16236   	clc			;do a real open
     9191   20 90D8     16237   	jsr k_open		;open it
     9194   20 9243     16238   	jsr dschk		;see if device # >=4, and clear ds if so
     9197   B0 12       16239   	bcs jerxit		;bad stuff
     9199   60          16240   	rts			;a.o.k.
                        16241   
                        16242   
                        16243   
     919A   20 91F6     16244   close	jsr paoc		;parse statement
     919D   20 A855     16245   	jsr put_io_in_map
     91A0   A5 4B       16246   	lda andmsk		;get la
     91A2   18          16247   	clc			;flag a real close
     91A3   20 9275     16248   	jsr k_close		;close it
     91A6   20 9243     16249   	jsr dschk		;see if device # >=4, and clear ds if so
     91A9   90 B4       16250   	bcc cld20		;it's okay
                        16251   
     91AB   4C 90D0     16252   jerxit	jmp erexit
                        16253   
                        16254   
                        16255   
                        16256   ;  parse load, save, & verify commands
                        16257   
     91AE               16258   plsv
                        16259   
                        16260   ;  default file name
                        16261   ;
     91AE   A9 00       16262   	lda #0			;length=0
     91B0   20 925D     16263   	jsr k_setnam
                        16264   
                        16265   ;  default device #
                        16266   ;
     91B3   A2 01       16267   	ldx #1			;device #1
     91B5   A0 00       16268   	ldy #0			;command 0
     91B7   20 9257     16269   	jsr k_setlfs
     91BA   20 9287     16270   	jsr k_setbank		;call with (.A=load bank=0) and (.X=name bank=1)
                        16271   
                        16272   
                        16273   
     91BD   20 91E3     16274   	jsr paoc20		;by-pass junk
     91C0   20 9239     16275   	jsr paoc15		;get/set file name
     91C3   20 91E3     16276   	jsr paoc20		;by-pass junk
     91C6   20 91DD     16277   	jsr plsv7		;get ',fa'
     91C9   A0 00       16278   	ldy #0			;command 0
     91CB   86 4B       16279   	stx andmsk
     91CD   20 9257     16280   	jsr k_setlfs
     91D0   20 91E3     16281   	jsr paoc20		;by-pass junk
     91D3   20 91DD     16282   	jsr plsv7 		;get ',sa'
     91D6   8A          16283   	txa			;new command
     91D7   A8          16284   	tay
     91D8   A6 4B       16285   	ldx andmsk		;device #
     91DA   4C 9257     16286   	jmp k_setlfs
                        16287   
                        16288   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 189-1
'code26'   CODE26.SRC

Error Addr  Code          Seq   Source statement

                        16289   
                        16290   ;  look for comma followed by byte
                        16291   
     91DD   20 91EB     16292   plsv7	jsr paoc30
     91E0   4C 87F4     16293   	jmp getbyt
                        16294   
                        16295   
                        16296   
                        16297   ;  skip return if next char is end
                        16298   ;
     91E3               16299   paoc20
     91E3   20 0386     16300   	jsr chrgot
     91E6   D0 02       16301   	bne paocx
     91E8   68          16302   	pla
     91E9   68          16303   	pla
     91EA   60          16304   paocx	rts
                        16305   
                        16306   
                        16307   
                        16308   ;  check for comma and good stuff
                        16309   ;
     91EB               16310   paoc30
     91EB   20 79F9     16311   	jsr chkcom		;check comma
     91EE               16312   paoc32
     91EE   20 0386     16313   	jsr chrgot		;get current
     91F1   D0 F7       16314   	bne paocx		;is o.k.
     91F3   4C 7A09     16315   	jmp snerr		;bad...end of line
                        16316   
                        16317   
                        16318   ;  parse open/close
                        16319   
     91F6   A9 00       16320   paoc	lda #0
     91F8   A2 01       16321   	ldx #1
     91FA   20 9287     16322   	jsr k_setbank
     91FD   20 925D     16323   	jsr k_setnam		;default file name
     9200   20 91EE     16324   	jsr paoc32		;must got something
     9203   20 87F4     16325   	jsr getbyt		;get la
     9206   86 4B       16326   	stx andmsk
     9208   8A          16327   	txa
     9209   A2 01       16328   	ldx #1    		;default device
     920B   A0 00       16329   	ldy #0    		;default command
     920D   20 9257     16330   	jsr k_setlfs		;store it
     9210   20 91E3     16331   	jsr paoc20		;skip junk
     9213   20 91DD     16332   	jsr plsv7
     9216   86 4C       16333   	stx eormsk
     9218   A0 00       16334   	ldy #0    		;default command
     921A   A5 4B       16335   	lda andmsk		;get la
     921C   E0 03       16336   	cpx #3
     921E   90 01       16337   	bcc paoc5
     9220   88          16338   	dey			;default ieee to $ff
     9221               16339   paoc5
     9221   20 9257     16340   	jsr k_setlfs		;store them
     9224   20 91E3     16341   	jsr paoc20		;skip junk
     9227   20 91DD     16342   	jsr plsv7 		;get sa
     922A   8A          16343   	txa

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 189-2
'code26'   CODE26.SRC

Error Addr  Code          Seq   Source statement

     922B   A8          16344   	tay
     922C   A6 4C       16345   	ldx eormsk
     922E   A5 4B       16346   	lda andmsk
     9230   20 9257     16347   	jsr k_setlfs		;set up real eveything
     9233   20 91E3     16348   	jsr paoc20
     9236   20 91EB     16349   	jsr paoc30
     9239               16350   paoc15
     9239   20 877B     16351   	jsr frmstr		;do frmevl, frestr. return with len in a, index =~string
     923C   A6 24       16352   	ldx index1
     923E   A4 25       16353   	ldy index1+1
     9240   4C 925D     16354   	jmp k_setnam		;bank always set at plsv
                        16355   
                        16356   
                        16357   
     9243   08          16358   dschk	php			;check if device >=4, and clear ds if so
     9244   48          16359   	pha
     9245   A5 BA       16360   	lda _fa
     9247   C9 04       16361   	cmp #4
     9249   90 03       16362   	bcc 1$
     924B   20 A81D     16363   	jsr oldclr
     924E   68          16364   1$	pla
     924F   28          16365   	plp
     9250   60          16366   	rts
                        16367   
                        16368   
                        16369   
                        16370   
     9251               16371   k_readst
     9251   20 A855     16372   	jsr put_io_in_map
     9254   4C FFB7     16373   	jmp _readst
                        16374   
                        16375   
                        16376   
     9257               16377   k_setlfs
     9257   20 A855     16378   	jsr put_io_in_map
     925A   4C FFBA     16379   	jmp _setlfs
                        16380   
                        16381   
                        16382   
     925D               16383   k_setnam
     925D   20 A855     16384   	jsr put_io_in_map
     9260   4C FFBD     16385   	jmp _setnam
                        16386   
                        16387   
                        16388   
     9263   20 A855     16389   k_basin	jsr put_io_in_map
     9266   4C FFCF     16390   	jmp _basin
                        16391   
                        16392   
     9269   20 A855     16393   k_bsout	jsr put_io_in_map
     926C   4C FFD2     16394   	jmp _bsout
                        16395   
                        16396   
     926F   20 A855     16397   k_clrch	jsr put_io_in_map
     9272   4C FFCC     16398   	jmp _clrch

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 189-3
'code26'   CODE26.SRC

Error Addr  Code          Seq   Source statement

                        16399   
                        16400   
                        16401   
     9275   20 A855     16402   k_close	jsr put_io_in_map
     9278   4C FFC3     16403   	jmp _close
                        16404   
                        16405   
                        16406   
     927B   20 A855     16407   k_clall	jsr put_io_in_map
     927E   4C FFE7     16408   	jmp _clall
                        16409   
                        16410   
                        16411   
     9281   20 A855     16412   k_primm	jsr put_io_in_map
     9284   4C FF7D     16413   	jmp _primm
                        16414   
                        16415   
     9287               16416   k_setbank
     9287   20 A855     16417   	jsr put_io_in_map
     928A   4C FF68     16418   	jmp _set_bank
                        16419   
                        16420   
     928D   8D FF03     16421   k_jplot	sta sw_rom_ram0
     9290   4C FFF0     16422   	jmp _jplot
                        16423   
                        16424   
     9293   20 A855     16425   k_stop	jsr put_io_in_map
     9296   4C FFE1     16426   	jmp _stop
                        16427   
                        16428   ;.end
                        16429   	.include grbcol

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 190
'grbcol'   GRBCOL.SRC

Error Addr  Code          Seq   Source statement

                        16431   	.subttl 'grbcol'
                        16432   ;  get space for a string.
                        16433   ;  note: may force garbage collection
                        16434   ;
                        16435   ;  entry:  ac = # of chars
                        16436   ;  exit:   ptr in y,x otherwise
                        16437   ;          blows off to 'out of string space' error
                        16438   ;          (also preserves .a and sets frespc= y,x = -> at space.)
                        16439   
     9299               16440   getspa
     9299   46 11       16441   	lsr garbfl	;signal no garbage collection yet.
     929B               16442   tryag2
     929B   AA          16443   	tax		;save in x also
     929C   F0 3B       16444   	beq getrts	;length of 0 no go...
     929E   48          16445   	pha		;save a (length) on stack
     929F   A5 35       16446   	lda fretop	;lo byte
     92A1   38          16447   	sec		;for subtract
     92A2   E9 02       16448   	sbc #2	   	;minus 2 (link bytes)
     92A4   A4 36       16449   	ldy fretop+1
     92A6   B0 01       16450   	bcs tryag3
     92A8   88          16451   	dey
     92A9               16452   tryag3
     92A9   85 24       16453   	sta index1	;save for later
     92AB   84 25       16454   	sty index1+1
     92AD   8A          16455   	txa
     92AE   49 FF       16456   	eor #$ff
     92B0   38          16457   	sec
     92B1   65 24       16458   	adc index1
     92B3   B0 01       16459   	bcs tryag4
     92B5   88          16460   	dey
     92B6               16461   tryag4
     92B6   C4 34       16462   	cpy strend+1
     92B8   90 20       16463   	bcc garbag
     92BA   D0 04       16464   	bne strfre
     92BC   C5 33       16465   	cmp strend
     92BE   90 1A       16466   	bcc garbag	;clean up
     92C0               16467   strfre
     92C0   85 37       16468   	sta frespc
     92C2   84 38       16469   	sty frespc+1
     92C4   A0 01       16470   	ldy #1		;flag string as garb.
     92C6   A9 FF       16471   	lda #$ff
     92C8   8D FF04     16472   	sta sw_rom_ram1	;set up string bank
     92CB   91 24       16473   	sta (index1),y	;flag
     92CD   88          16474   	dey
     92CE   68          16475   	pla		;length
     92CF   91 24       16476   	sta (index1),y
     92D1   A6 37       16477   	ldx frespc
     92D3   A4 38       16478   	ldy frespc+1
     92D5   86 35       16479   	stx fretop
     92D7   84 36       16480   	sty fretop+1	;save new (fretop).
     92D9               16481   getrts
     92D9   60          16482   	rts
                        16483   
     92DA               16484   garbag
     92DA   A5 11       16485   	lda garbfl

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 190-1
'grbcol'   GRBCOL.SRC

Error Addr  Code          Seq   Source statement

     92DC   30 09       16486   	bmi grbg99	;if out of memory
     92DE   20 92EA     16487   	jsr garba2
     92E1   38          16488   	sec
     92E2   66 11       16489   	ror garbfl
     92E4   68          16490   	pla		;get back string length.
     92E5   D0 B4       16491   	bne tryag2	;always branches.
                        16492   
     92E7               16493   grbg99
     92E7   4C 4D57     16494   	jmp omerr
                        16495   
                        16496   
                        16497   
                        16498   ;  routine looks for and squashes out any unused string
                        16499   ;  space it finds, thus returning the space for future
                        16500   ;  use by the string routines.
                        16501   ;  garba2 is called only when basic needs space of a fre
                        16502   ;  instruction is used.
                        16503   
     92EA               16504   garba2
     92EA   A6 18       16505   	ldx temppt	;ptr to temp. strings
     92EC               16506   garb1
     92EC   E0 1B       16507   	cpx #tempst    	;any out there?
     92EE   F0 13       16508   	beq garb2	;none
     92F0   20 93F0     16509   	jsr slr1	;setup ptr (tempf2) to temp. string's bkptr.
     92F3   F0 F7       16510   	beq garb1	; (skip if null string!)
     92F5   8A          16511   	txa		;.x = lsb of ptr to descriptor
     92F6   A0 00       16512   	ldy #0
     92F8   8D FF04     16513   	sta sw_rom_ram1	;set up string bank
     92FB   91 5E       16514   	sta (tempf2),y  ;place backpointer on string to temp. descr.
     92FD   98          16515   	tya		;.a = msb of ptr (0)
     92FE   C8          16516   	iny
     92FF   91 5E       16517   	sta (tempf2),y
     9301   D0 E9       16518   	bne garb1	;always
                        16519   
     9303               16520   garb2
     9303   A0 00       16521   	ldy #0	 	;set up flag
     9305   84 5A       16522   	sty highds
     9307   A6 39       16523   	ldx max_mem_1
     9309   A4 3A       16524   	ldy max_mem_1+1
     930B   86 61       16525   	stx grbtop	;set both pointers
     930D   86 50       16526   	stx grbpnt
     930F   86 37       16527   	stx frespc
     9311   84 62       16528   	sty grbtop+1
     9313   84 51       16529   	sty grbpnt+1
     9315   84 38       16530   	sty frespc+1
     9317   8A          16531   	txa
                        16532   ;
                        16533   ; do while (grbpnt <= fretop)
                        16534   ;
     9318               16535   gloop
     9318   20 9383     16536   	jsr chkgrb	;check garbage string
     931B   D0 0C       16537   	bne col01	;if not garbage
     931D               16538   col00a
     931D   88          16539   	dey		;back up to length
     931E   20 4318     16540   	jsr indgrb

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 190-2
'grbcol'   GRBCOL.SRC

Error Addr  Code          Seq   Source statement

     9321   20 93D2     16541   	jsr movpnt	;move grbpnt to next
     9324   38          16542   	sec
     9325   66 5A       16543   	ror highds	;indicate garbage string found
     9327   D0 EF       16544   	bne gloop	;always
                        16545   
     9329               16546   col01
     9329   24 5A       16547   	bit highds
     932B   10 42       16548   	bpl col03	;if garbage string not found
     932D   A2 00       16549   	ldx #0
     932F   86 5A       16550   	stx highds	;clear indicator
                        16551   
     9331   A9 02       16552   	lda #2	   	;skip pointers past
                        16553   ;
                        16554   ; move a string over garbage
                        16555   ;
     9333               16556   col02
     9333   A0 01       16557   	ldy #1	   	;move the link bytes
     9335   20 4318     16558   	jsr indgrb
     9338   91 61       16559   	sta (grbtop),y
     933A   88          16560   	dey
     933B   20 4318     16561   	jsr indgrb
     933E   91 61       16562   	sta (grbtop),y
                        16563   
     9340   20 03B7     16564   	jsr indin1_ram1
     9343   AA          16565   	tax
     9344   20 93E1     16566   	jsr movtop	;move top pointer
     9347   85 37       16567   	sta frespc	;save in frespc
     9349   84 38       16568   	sty frespc+1
     934B   8A          16569   	txa
     934C   20 93D2     16570   	jsr movpnt	;move grbpnt
     934F   8A          16571   	txa		;put length-1 in .y
     9350   A8          16572   	tay
                        16573   
     9351               16574   glop1
     9351   88          16575   	dey
     9352   20 4318     16576   	jsr indgrb
     9355   91 61       16577   	sta (grbtop),y
     9357   CA          16578   	dex
     9358   D0 F7       16579   	bne glop1
                        16580   
     935A   A0 02       16581   	ldy #2	   	;fix the descriptor
                        16582   
     935C   B9 0060     16583   col02b	lda grbtop-1,y
     935F   91 24       16584   	sta (index1),y
     9361   88          16585   	dey
     9362   D0 F8       16586   	bne col02b
     9364   A5 50       16587   	lda grbpnt	;check pointer
     9366   A4 51       16588   	ldy grbpnt+1
     9368   20 9383     16589   	jsr chkgrb	;check garbage string
     936B   F0 B0       16590   	beq col00a	;if garbage found
     936D   D0 C4       16591   	bne col02	;always
                        16592   
     936F   A0 00       16593   col03	ldy #0	   	;skip over good strings
     9371   20 03B7     16594   	jsr indin1_ram1
     9374   AA          16595   	tax

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 190-3
'grbcol'   GRBCOL.SRC

Error Addr  Code          Seq   Source statement

     9375   20 93E1     16596   	jsr movtop
     9378   85 37       16597   	sta frespc
     937A   84 38       16598   	sty frespc+1
     937C   8A          16599   	txa
     937D   20 93D2     16600   	jsr movpnt
     9380   4C 9318     16601   	jmp gloop
                        16602   
                        16603   
                        16604   
                        16605   ; subroutines used for garbage collection
                        16606   ;  compare for y,a = fretop.
                        16607   ;  entry  y,a = address of current string descriptor.
                        16608   ;  exit  exit to caller if y,a = fretop.
                        16609   ;  else  z flag set if garbage string.
                        16610   ;  z flag clear if not garbage string.
                        16611   ;  in either case pointers are setup for next loop
                        16612   ;  and string movement.
                        16613   ;  exit to cfre4.
                        16614   ;  carry clear y,a <= fretop.
                        16615   
     9383               16616   chkgrb
     9383   C4 36       16617   	cpy fretop+1	;end of strings ?
     9385   90 2A       16618   	bcc cfre4
     9387   D0 06       16619   	bne cfre1	;if not equal
     9389   C5 35       16620   	cmp fretop
     938B   F0 24       16621   	beq cfre4
     938D   90 22       16622   	bcc cfre4
                        16623   
     938F               16624   cfre1
     938F   24 5A       16625   	bit highds	;check flag
     9391   30 05       16626   	bmi cfre2	;if empty string found
     9393   A9 02       16627   	lda #2	   	;skip pointers past
     9395   20 93E1     16628   	jsr movtop	;move top pointer
     9398               16629   cfre2
     9398   A9 02       16630   	lda #2	   	;skip pointers past
     939A   20 93D2     16631   	jsr movpnt	;move pointers
     939D   A0 01       16632   	ldy #1
     939F   20 4318     16633   	jsr indgrb	;garbage?
     93A2   C9 FF       16634   	cmp #$ff
     93A4   D0 01       16635   	bne cfre3	;if not garbage string
     93A6   60          16636   	rts
                        16637   
     93A7               16638   cfre3
     93A7   20 4318     16639   	jsr indgrb	;to link bytes
     93AA   99 0024     16640   	sta index1,y
     93AD   88          16641   	dey
     93AE   10 F7       16642   	bpl cfre3	;if two bytes not moved
     93B0   60          16643   	rts
                        16644   
                        16645   
     93B1               16646   cfre4
     93B1   A6 18       16647   	ldx temppt	;ptr to temp. strings
     93B3               16648   cfre4a
     93B3   E0 1B       16649   	cpx #tempst	;any out there?
     93B5   F0 10       16650   	beq cfre4b	;no

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 190-4
'grbcol'   GRBCOL.SRC

Error Addr  Code          Seq   Source statement

     93B7   20 93F0     16651   	jsr slr1	;setup ptr (tempf2) to temp. string's bkptr.
     93BA   F0 F7       16652   	beq cfre4a	; (skip if null string!)
     93BC   A0 00       16653   	ldy #0	   	;.a = string length
     93BE   91 5E       16654   	sta (tempf2),y	;remove backpointer built at garba2
     93C0   C8          16655   	iny
     93C1   A9 FF       16656   	lda #$ff
     93C3   91 5E       16657   	sta (tempf2),y	;and mark as garbage
     93C5   D0 EC       16658   	bne cfre4a	;always
                        16659   
     93C7               16660   cfre4b
     93C7   68          16661   	pla		;throw away return address
     93C8   68          16662   	pla
     93C9   A5 37       16663   	lda frespc	;fix fretop and frespc
     93CB   A4 38       16664   	ldy frespc+1
     93CD   85 35       16665   	sta fretop
     93CF   84 36       16666   	sty fretop+1
     93D1   60          16667   	rts
                        16668   
                        16669   
     93D2               16670   movpnt
     93D2   49 FF       16671   	eor #$ff	;comp and add
     93D4   38          16672   	sec
     93D5   65 50       16673   	adc grbpnt
     93D7   A4 51       16674   	ldy grbpnt+1
     93D9   B0 01       16675   	bcs 1$
     93DB   88          16676   	dey
     93DC   85 50       16677   1$	sta grbpnt
     93DE   84 51       16678   	sty grbpnt+1
     93E0   60          16679   	rts
                        16680   
                        16681   
     93E1               16682   movtop
     93E1   49 FF       16683   	eor #$ff	;comp and add
     93E3   38          16684   	sec
     93E4   65 61       16685   	adc grbtop
     93E6   A4 62       16686   	ldy grbtop+1
     93E8   B0 01       16687   	bcs 1$
     93EA   88          16688   	dey
     93EB   85 61       16689   1$	sta grbtop
     93ED   84 62       16690   	sty grbtop+1
     93EF   60          16691   	rts
                        16692   
                        16693   
     93F0               16694   slr1
     93F0   CA          16695   	dex		;.x = ptr to temp. string descriptor
     93F1   B5 00       16696   	lda $00,x	;msb of ptr to string
     93F3   85 5F       16697   	sta tempf2+1
     93F5   CA          16698   	dex
     93F6   B5 00       16699   	lda $00,x	;lsb of ptr to string
     93F8   85 5E       16700   	sta tempf2
     93FA   CA          16701   	dex
     93FB   B5 00       16702   	lda $00,x	;string length
     93FD   48          16703   	pha		;save for later test
     93FE   18          16704   	clc
     93FF   65 5E       16705   	adc tempf2	;want ptr to string's backpointer

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 190-5
'grbcol'   GRBCOL.SRC

Error Addr  Code          Seq   Source statement

     9401   85 5E       16706   	sta tempf2
     9403   90 02       16707   	bcc slr2
     9405   E6 5F       16708   	inc tempf2+1
     9407               16709   slr2
     9407   68          16710   	pla		;.a=len & set z flag; .x=next desc. ptr
     9408   60          16711   	rts
                        16712   
                        16713   ;.end
                        16714   	.include trig

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 191
'trig'   TRIG.SRC

Error Addr  Code          Seq   Source statement

                        16716   	.subttl 'trig'
                        16717   
                        16718   			;
                        16719   			;sine, cosine, and tangent functions.
                        16720   			;
                        16721   			;cosine function
                        16722   			;use cos(x)=sin(x+pi/2)
     9409               16723   cos
     9409   A9 85       16724   	lda #<pi2	;pointer to pi/2
     940B   A0 94       16725   	ldy #>pi2
     940D   20 8A12     16726   	jsr romadd	;add it in. fall into sine.
                        16727   			;
                        16728   			;sine function.
                        16729   			;
                        16730   			;use identities to get fac in quadrants I or IV.
                        16731   			;the fac is divided by 2*pi and the integer part 
                        16732   			;is ignored because sin(x+2*pi)=sin(x). then the 
                        16733   			;argument can be compared with pi/2 by comparing 
                        16734   			;the result of the division with pi/2(2*pi)=1/4.
                        16735   			;identities are then used to get the result in 
                        16736   			;quadrants I or IV. an approximation polynomial
                        16737   			;is then used  to compute sin(x).
                        16738   			;
     9410               16739   sin
     9410   20 8C38     16740   	jsr movaf
     9413   A9 8A       16741   	lda #<twopi	;get pointer to divisor.
     9415   A0 94       16742   	ldy #>twopi
     9417   A6 6F       16743   	ldx argsgn	;geet sign of result.
     9419   20 8B41     16744   	jsr fdivf
     941C   20 8C38     16745   	jsr movaf	;get result into arg.
     941F   20 8CFB     16746   	jsr int		;integerize fac.
     9422   A9 00       16747   	lda #0
     9424   85 70       16748   	sta arisgn	;always have the same sign.
     9426   20 8831     16749   	jsr fsubt	;keep only the fractional part.
     9429   A9 8F       16750   	lda #<fr4	;get pointer to 1/4.
     942B   A0 94       16751   	ldy #>fr4
     942D   20 8A18     16752   	jsr romsub
     9430   A5 68       16753   	lda facsgn	;save sign for later.
     9432   48          16754   	pha
     9433   10 0D       16755   	bpl sin1	;first quadrant.
     9435   20 8A0E     16756   	jsr faddh	;add 1/2 to fac.
     9438   A5 68       16757   	lda facsgn	;sign is negative?
     943A   30 09       16758   	bmi sin2	
     943C   A5 14       16759   	lda tansgn	;quads II and III come here.
     943E   49 FF       16760   	eor #$ff
     9440   85 14       16761   	sta tansgn
     9442               16762   sin1
     9442   20 8FFA     16763   	jsr negop	;if positive, negate it.
     9445               16764   sin2
     9445   A9 8F       16765   	lda #<fr4	;pointer to 1/4.
     9447   A0 94       16766   	ldy #>fr4
     9449   20 8A12     16767   	jsr romadd	;add it in.
     944C   68          16768   	pla		;get original quadrant.
     944D   10 03       16769   	bpl sin3
     944F   20 8FFA     16770   	jsr negop	;if negative, negate result.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 191-1
'trig'   TRIG.SRC

Error Addr  Code          Seq   Source statement

     9452               16771   sin3
     9452   A9 94       16772   	lda #<sincon
     9454   A0 94       16773   	ldy #>sincon
     9456   4C 9086     16774   	jmp polyx	;do approximation polyomial
                        16775   
                        16776   
                        16777   			; tangent function.
     9459               16778   tan
     9459   20 8BFC     16779   	jsr mov1f	;move fac into temporary.
     945C   A9 00       16780   	lda #0
     945E   85 14       16781   	sta tansgn	;remember whether to negate.
     9460   20 9410     16782   	jsr sin		;compute the sin.
     9463   A2 50       16783   	ldx #<tempf3
     9465   A0 00       16784   	ldy #>tempf3
     9467   20 8C00     16785   	jsr movmf	;put sign into other temp.
     946A   A9 59       16786   	lda #<tempf1
     946C   A0 00       16787   	ldy #>tempf1
     946E   20 8BD4     16788   	jsr movfm	;put this memory location into fac.
     9471   A9 00       16789   	lda #0
     9473   85 68       16790   	sta facsgn	;start off positive.
     9475   A5 14       16791   	lda tansgn
     9477   20 9481     16792   	jsr cosc	;compute cosine.
     947A   A9 50       16793   	lda #<tempf3
     947C   A0 00       16794   	ldy #>tempf3	;address of sine value.
     947E   4C 8B49     16795   	jmp fdiv	;divide sine by cosine and return.
                        16796   
     9481               16797   cosc
     9481   48          16798   	pha
     9482   4C 9442     16799   	jmp sin1
                        16800   
                        16801   
     9485   81 49 0F    16802   pi2	.byte @201,@111,@17,@332,@242
     9488   DA A2               
                        16803   
     948A   83 49 0F    16804   twopi	.byte @203,@111,@17,@332,@242
     948D   DA A2               
                        16805   
     948F   7F 00 00    16806   fr4	.byte @177,0,0,0,0
     9492   00 00               
                        16807   
     9494   05 84 E6    16808   sincon	.byte 5,@204,@346,@32,@55	;degree-1.
     9497   1A 2D               
     9499   1B 86 28    16809   	.byte @33,@206,@50,@7,@373
     949C   07 FB               
     949E   F8 87 99    16810   	.byte @370,@207,@231,@150,@211
     94A1   68 89               
     94A3   01 87 23    16811   	.byte 1,@207,@43,@65,@337,@341
     94A6   35 DF E1            
     94A9   86 A5 5D    16812   	.byte @206,@245,@135,@347,@50,@203
     94AC   E7 28 83            
     94AF   49 0F DA    16813   	.byte @111,@17,@332,@242
     94B2   A2                  
                        16814   
                        16815   			;
                        16816   			;arctangent function

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 191-2
'trig'   TRIG.SRC

Error Addr  Code          Seq   Source statement

                        16817   			;
                        16818   			;use identities to get arg between 0 and 1 and then use
                        16819   			;an approximation polynomial to compute arctan(x).
                        16820   			;
     94B3               16821   atn
     94B3   A5 68       16822   	lda facsgn	;what is sign?
     94B5   48          16823   	pha		;save for later.
     94B6   10 03       16824   	bpl atn1
     94B8   20 8FFA     16825   	jsr negop	;if negative, negate fac.
     94BB               16826   atn1			;use arctan(x)=-arctan(-x).
     94BB   A5 63       16827   	lda facexp	
     94BD   48          16828   	pha		;save this too for later.
     94BE   C9 81       16829   	cmp #@201	;see if fac .ge. 1.0.
     94C0   90 07       16830   	bcc atn2	;it is less than 1
     94C2   A9 9C       16831   	lda #<fone	;get pntr to 1.0.
     94C4   A0 89       16832   	ldy #>fone
     94C6   20 8A1E     16833   	jsr romdiv	;compute reciprocal.
     94C9               16834   atn2			;use aectan(x)=pi/2-arctan(1/x).
     94C9   A9 E3       16835   	lda #<atncon	;pointer to arctan constants.
     94CB   A0 94       16836   	ldy #>atncon
     94CD   20 9086     16837   	jsr polyx
     94D0   68          16838   	pla
     94D1   C9 81       16839   	cmp #@201	;was original argument .lt.1?
     94D3   90 07       16840   	bcc atn3	;yes.
     94D5   A9 85       16841   	lda #<pi2
     94D7   A0 94       16842   	ldy #>pi2
     94D9   20 8A18     16843   	jsr romsub	;subtract arctan from pi/2.
     94DC               16844   atn3
     94DC   68          16845   	pla		;was original aurgument positive?
     94DD   10 03       16846   	bpl atn4	;yes.
     94DF   4C 8FFA     16847   	jmp negop	;if negative, negate result.
                        16848   	
     94E2   60          16849   atn4	rts		;all done.
                        16850   
                        16851   
     94E3   0B 76 B3    16852   atncon	.byte @13,@166,@263,@203	;degree-1.
     94E6   83                  
     94E7   BD D3 79    16853   	.byte @275,@323,@171,@36,@364
     94EA   1E F4               
     94EC   A6 F5 7B    16854   	.byte @246,@365,@173,@203,@374
     94EF   83 FC               
     94F1   B0 10       16855   	.byte @260,@20
     94F3   7C 0C 1F    16856   	.byte @174,@14,@37,@147,@312
     94F6   67 CA               
     94F8   7C DE 53    16857   	.byte @174,@336,@123,@313,@301
     94FB   CB C1               
     94FD   7D 14 64    16858   	.byte @175,@24,@144,@160,@114
     9500   70 4C               
     9502   7D B7 EA    16859   	.byte @175,@267,@352,@121,@172
     9505   51 7A               
     9507   7D 63 30    16860   	.byte @175,@143,@60,@210,@176
     950A   88 7E               
     950C   7E 92 44    16861   	.byte @176,@222,@104,@231,@72
     950F   99 3A               
     9511   7E 4C CC    16862   	.byte @176,@114,@314,@221,@307

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 191-3
'trig'   TRIG.SRC

Error Addr  Code          Seq   Source statement

     9514   91 C7               
     9516   7F AA AA    16863   	.byte @177,@252,@252,@252,@23
     9519   AA 13               
     951B   81 00 00    16864   	.byte @201,0,0,0,0
     951E   00 00               
                        16865   
                        16866   ;.end
                        16867   	.include using

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 192
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

                        16869   	.subttl USING - Formatted print routine
                        16870   ;       using
                        16871   ;
                        16872   ; entered by cmd, print, or print#
                        16873   ; sample syntax:  print using"****";a;b;c
                        16874   
     9520               16875   using
     9520   A2 FF       16876   	ldx #$ff
     9522   8E 0136     16877   	stx endfd
     9525   20 0380     16878   	jsr chrget
     9528   20 788C     16879   	jsr frmevl	;evaluate format string
     952B   20 787A     16880   	jsr chkstr	;must be string type...
                        16881   ;
                        16882   ;  save temp descriptor
                        16883   ;
     952E   A5 66       16884   	lda facmo
     9530   48          16885   	pha
     9531   A5 67       16886   	lda facmo+1
     9533   48          16887   	pha
                        16888   
     9534   A0 02       16889   	ldy #2		;move (facmo),1&2 to form,form+1
     9536               16890   ldform
     9536   20 4304     16891   	jsr indfmo
     9539   88          16892   	dey
     953A   99 003F     16893   	sta form,y
     953D   D0 F7       16894   	bne ldform
                        16895   
     953F   20 4304     16896   	jsr indfmo      ;get length
     9542   8D 0135     16897   	sta lfor
     9545   A8          16898   	tay
     9546   F0 0B       16899   	beq ser		;error if length is zero
     9548               16900   cncj
     9548   88          16901   	dey
     9549   20 42F0     16902   	jsr indfrm
     954C   C9 23       16903   	cmp #'#'       	;at least one # in format?
     954E   F0 06       16904   	beq cscol      	;yes...
     9550   98          16905   	tya		;no...end of format
     9551   D0 F5       16906   	bne cncj       	;no...
                        16907   
     9553   4C 7A09     16908   ser	jmp snerr      	;yes...syntax error
                        16909   
                        16910   
     9556               16911   cscol
     9556   A9 3B       16912   	lda #';'
     9558               16913   eex2
     9558   20 79FB     16914   	jsr synchr	;check character
     955B   84 77       16915   	sty z_p_temp_1  ;clear flag for anaf
     955D   8C 0123     16916   	sty bnr   	;set pointer to begin of no
     9560   20 788C     16917   	jsr frmevl	;evaluate expression
     9563   24 0F       16918   	bit valtyp	;numeric or string?
     9565   10 39       16919   	bpl conv 	;branch if numeric
     9567   20 979F     16920   	jsr ini  	;init counters and flags
     956A   20 98F2     16921   	jsr anaf 	;analyze format
     956D   AE 012B     16922   	ldx chsn 	;> or = in format field
     9570   F0 15       16923   	beq prcha	;branch if not

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 192-1
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

     9572   A2 00       16924   	ldx #0
     9574   38          16925   	sec
     9575   AD 0131     16926   	lda cform
     9578   E5 78       16927   	sbc hulp 	;.a=room left in field
     957A   90 0B       16928   	bcc prcha	;branch if no room left
     957C   A2 3D       16929   	ldx #'='
     957E   EC 012B     16930   	cpx chsn 	;= in field
     9581   D0 03       16931   	bne schs1	;branch if not
     9583   4A          16932   	lsr a   	;.a=.a/2
     9584   69 00       16933   	adc #0  	;add 1 if odd
     9586               16934   schs1
     9586   AA          16935   	tax     	;store no of blanks in x
     9587               16936   prcha
     9587   A0 00       16937   	ldy #0
     9589               16938   chx
     9589   8A          16939   	txa
     958A   F0 05       16940   	beq cpef	;branch if no blanks
     958C   CA          16941   	dex
     958D               16942   oblk
     958D   A9 20       16943   	lda #' '	;output a blank
     958F   D0 08       16944   	bne outc	;always
                        16945   
     9591               16946   cpef
     9591   C4 78       16947   	cpy hulp	;end of string reached?
     9593   B0 F8       16948   	bcs oblk	;output blank if yes
     9595   20 03B7     16949   	jsr indin1_ram1	;lda (index),y
     9598   C8          16950   	iny
     9599               16951   outc
     9599   20 98EB     16952   	jsr cdout	;output character
     959C   D0 EB       16953   	bne chx 	;branch if not ready
     959E   F0 27       16954   	beq reay
                        16955   
     95A0               16956   conv
     95A0   20 8E42     16957   	jsr fout	;convert mfp to decimal
                        16958   
                        16959   ;
                        16960   ;  build descriptor for fout string
                        16961   ;
     95A3   A0 FF       16962   	ldy #$ff
                        16963   
     95A5   C8          16964   10$	iny		;how big IS it?
     95A6   B9 0100     16965   	lda fbuffr,y
     95A9   D0 FA       16966   	bne 10$
     95AB   98          16967   	tya
     95AC   20 8690     16968   	jsr strspa	;jsr getspa,stx dsctmp+1,sty dsctmp+2,sta dsctmp,rts
     95AF   A0 00       16969   	ldy #0
     95B1   8D FF04     16970   	sta sw_rom_ram1	;set up string bank
                        16971   
     95B4   B9 0100     16972   20$	lda fbuffr,y
     95B7   F0 05       16973   	beq conv4
     95B9   91 64       16974   	sta (dsctmp+1),y
     95BB   C8          16975   	iny
     95BC   D0 F6       16976   	bne 20$
     95BE               16977   conv4
     95BE   20 86E3     16978   	jsr putnew

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 192-2
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

     95C1   20 979F     16979   	jsr ini  	;init counters and flags
     95C4   20 95E7     16980   	jsr fform	;output one formatted number
                        16981   
     95C7   20 0386     16982   reay	jsr chrgot	;get old character
     95CA   C9 2C       16983   	cmp #','	;comma?
     95CC   F0 8A       16984   	beq eex2 	;continue print use if yes
     95CE   38          16985   	sec
     95CF   66 77       16986   	ror z_p_temp_1 	;set flag for anaf
     95D1   20 98F2     16987   	jsr anaf 	;print rest of format
     95D4   68          16988   	pla		;restore descriptor
     95D5   A8          16989   	tay
     95D6   68          16990   	pla
     95D7   20 8785     16991   	jsr fretmp
     95DA   20 0386     16992   	jsr chrgot
     95DD   C9 3B       16993   	cmp #';'	;semi-colon?
     95DF   F0 03       16994   	beq nocr 	;branch if yes
     95E1   4C 55B5     16995   	jmp crdo 	;end of print using
                        16996   
     95E4   4C 0380     16997   nocr	jmp chrget	;rts to basic

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 193
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

                        16999   ;       fform
                        17000   ;
                        17001   ;  output a number to format
                        17002   ;
                        17003   ;  number is in fbuffr...format checked by anaf
                        17004   
     95E7               17005   fform
     95E7   8D FF03     17006   	sta sw_rom_ram0
     95EA   AD 1204     17007   	lda pufill
     95ED   8D 0133     17008   	sta blfd 	;set working fill char
     95F0   A9 FF       17009   	lda #$ff
     95F2               17010   ana
     95F2   8D 0132     17011   	sta sno  	;save blank or - in sno
     95F5   4C 95FA     17012   	jmp insy
                        17013   
     95F8               17014   stp
     95F8   86 80       17015   	stx point	;set point pointer
     95FA               17016   insy
     95FA   C4 78       17017   	cpy hulp 	;end of no reached?
     95FC   F0 33       17018   	beq eoa  	;branch if yes
     95FE   B9 0100     17019   	lda fbuffr,y    ;get character of no
     9601   C8          17020   	iny
     9602   C9 20       17021   	cmp #' ' 	;blank?
     9604   F0 F4       17022   	beq insy 	;yes...span
     9606   C9 2D       17023   	cmp #'-'  	;sign no negative
     9608   F0 E8       17024   	beq ana  	;yes...
     960A   C9 2E       17025   	cmp #'.'  	;decimal point?
     960C   F0 EA       17026   	beq stp  	;yes...
     960E   C9 45       17027   	cmp #'E'	;is char 'e'?
     9610   F0 11       17028   	beq lsg  	;yes...
     9612   9D 0100     17029   	sta fbuffr,x    ;move number
     9615   8E 0124     17030   	stx enr  	;update end-no pointer
     9618   E8          17031   	inx
     9619   24 80       17032   	bit point	;point pointer set?
     961B   10 DD       17033   	bpl insy 	;yes...
     961D   EE 012A     17034   	inc vn   	;count digits before point
     9620   4C 95FA     17035   	jmp insy
                        17036   
     9623               17037   lsg
     9623   B9 0100     17038   	lda fbuffr,y
     9626   C9 2D       17039   	cmp #'-'  	;sign of exponent negative
     9628   D0 03       17040   	bne nomn 	;no...
     962A   6E 0128     17041   	ror usgn 	;make sign negative
     962D               17042   nomn
     962D   C8          17043   	iny
     962E   8C 0129     17044   	sty uexp 	;set exponent pointer
     9631               17045   eoa
     9631   A5 80       17046   	lda point	;decimal found?
     9633   10 02       17047   	bpl rtts 	;yes...
     9635   86 80       17048   	stx point	;no...add point
     9637               17049   rtts
     9637   20 98F2     17050   	jsr anaf 	;analyze format
     963A   AD 012C     17051   	lda vf
     963D   C9 FF       17052   	cmp #$ff
     963F   F0 29       17053   	beq erst 	;field overflow

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 193-1
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

     9641   AD 012F     17054   	lda fesp 	;exponent in field
     9644   F0 3F       17055   	beq cff  	;convert to f format if not
     9646   AD 0129     17056   	lda uexp 	;exponent in number?
     9649   D0 12       17057   	bne ete  	;yes...
     964B   AE 0124     17058   	ldx enr
     964E   20 9774     17059   	jsr et2  	;add exponent to number
     9651   DE 0102     17060   	dec fbuffr+2,x
     9654   E8          17061   	inx
     9655   8E 0129     17062   	stx uexp
     9658   20 97FB     17063   	jsr alg  	;delete leading zeros
     965B   F0 25       17064   	beq hup  	;all zero
     965D               17065   ete
     965D   AC 012E     17066   	ldy posp 	;+ or - in format?
     9660   D0 17       17067   	bne sswe 	;yes...
     9662   AC 0132     17068   	ldy sno  	;+?
     9665   30 12       17069   	bmi sswe 	;yes...
     9667   AD 012C     17070   	lda vf
     966A               17071   erst
     966A   F0 6A       17072   	beq errf 	;no room for sign
     966C   CE 012C     17073   	dec vf   	;reserve room
     966F   D0 05       17074   	bne rspa
     9671   AD 012D     17075   	lda nf   	;one #?
     9674   F0 60       17076   	beq errf 	;yes...error
     9676               17077   rspa
     9676   EE 0127     17078   	inc swe
     9679               17079   sswe
     9679   20 96EE     17080   	jsr shpn 	;shift decimal point
     967C   20 97B9     17081   	jsr uround      ;round number
     967F   20 96EE     17082   	jsr shpn 	;shift again if necessary
                        17083   
     9682               17084   hup
     9682   4C 981C     17085   	jmp chout	;output number
                        17086   
                        17087   
     9685               17088   cff
     9685   AC 0129     17089   	ldy uexp 	;exponent in no?
     9688   F0 16       17090   	beq ftf  	;no...
     968A   85 78       17091   	sta hulp 	;delete exponent
     968C   38          17092   	sec		;adjust decimal point
     968D   6E 0130     17093   	ror etof 	;set e-to-f flag
     9690   A4 80       17094   	ldy point
     9692   AD 0128     17095   	lda usgn 	;exec nos3 or nos4
     9695   10 06       17096   	bpl no4  	;depends on sign of exp
     9697   20 9727     17097   	jsr nos3
     969A   4C 96A9     17098   	jmp rndd
                        17099   
     969D               17100   no4
     969D   20 9708     17101   	jsr nos4
     96A0               17102   ftf
     96A0   A4 80       17103   	ldy point	;at start of no?
     96A2   F0 05       17104   	beq rndd 	;yes...
     96A4   20 97FF     17105   	jsr cho  	;no = 0 ?
     96A7   F0 06       17106   	beq devn 	;yes...no round
     96A9               17107   rndd
     96A9   20 97B9     17108   	jsr uround

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 193-2
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

     96AC   4C 96B2     17109   	jmp devn2
                        17110   
     96AF               17111   devn
     96AF   CE 012A     17112   	dec vn         	;adjust...no was 0
     96B2               17113   devn2
     96B2   38          17114   	sec
     96B3   AD 012C     17115   	lda vf
     96B6   ED 012A     17116   	sbc vn
     96B9   90 1B       17117   	bcc errf 	;no fit...error
     96BB   8D 0127     17118   	sta swe  	;save difference
     96BE   AC 012E     17119   	ldy posp 	;+ or -?
     96C1   D0 1B       17120   	bne ahp  	;yes...
     96C3   AC 0132     17121   	ldy sno  	;get sign
     96C6   30 16       17122   	bmi ahp  	;positive...
     96C8   A8          17123   	tay
     96C9   F0 0B       17124   	beq errf 	;no room for sign
     96CB   88          17125   	dey
     96CC   D0 13       17126   	bne ldvn 	;swe<>1
     96CE   AD 012D     17127   	lda nf
     96D1   0D 012A     17128   	ora vn   	;both zero?
     96D4   D0 AC       17129   	bne hup  	;no...
                        17130   
     96D6               17131   errf
     96D6   A9 2A       17132   	lda #'*'	;format error
     96D8               17133   stout
     96D8   20 98EB     17134   	jsr cdout      	;fill field with stars
     96DB   D0 FB       17135   	bne stout
     96DD   60          17136   	rts
                        17137   
     96DE               17138   ahp
     96DE   A8          17139   	tay		;output no if swe=0
     96DF   F0 A1       17140   	beq hup
     96E1               17141   ldvn
     96E1   AD 012A     17142   	lda vn
     96E4   D0 9C       17143   	bne hup  	;vn<>0
     96E6   CE 0127     17144   	dec swe  	;add extra 0
     96E9   E6 77       17145   	inc z_p_temp_1 	;before decimal point
     96EB   4C 9682     17146   	jmp hup
                        17147   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 194
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

                        17149   ; shift decimal point
                        17150   ;
     96EE               17151   shpn
     96EE   38          17152   	sec
     96EF   AD 012C     17153   	lda vf
     96F2   ED 012A     17154   	sbc vn
     96F5   F0 39       17155   	beq rdy  	;format o.k
     96F7   A4 80       17156   	ldy point
     96F9   90 16       17157   	bcc pntl 	;vf<vn
     96FB   85 78       17158   	sta hulp
     96FD               17159   incy
     96FD   CC 0124     17160   	cpy enr		;end of no reached?
     9700   F0 02       17161   	beq ity
     9702   B0 01       17162   	bcs nos1 	;yes...
     9704               17163   ity
     9704   C8          17164   	iny
     9705               17165   nos1
     9705   EE 012A     17166   	inc vn
     9708               17167   nos4
     9708   20 973D     17168   	jsr eado	;adjust exponent
     970B   C6 78       17169   	dec hulp 	;ready?
     970D   D0 EE       17170   	bne incy 	;no...
     970F   F0 1D       17171   	beq poit
                        17172   
     9711               17173   pntl
     9711   49 FF       17174   	eor #$ff
     9713   69 01       17175   	adc #1
     9715   85 78       17176   	sta hulp 	;=vn-vf
     9717               17177   decy
     9717   CC 0123     17178   	cpy bnr		;begin of no?
     971A   F0 07       17179   	beq inz  	;yes...
     971C   88          17180   	dey
     971D   CE 012A     17181   	dec vn
     9720   4C 9725     17182   	jmp inz2
                        17183   
     9723               17184   inz
     9723   E6 77       17185   	inc z_p_temp_1	;add leading zeros
     9725               17186   inz2
     9725   A9 80       17187   	lda #$80
     9727               17188   nos3
     9727   20 973F     17189   	jsr eadj       	;adjust exponent
     972A   C6 78       17190   	dec hulp 	;ready?
     972C   D0 E9       17191   	bne decy 	;no...
     972E               17192   poit
     972E   84 80       17193   	sty point	;decimal point pointer
     9730   60          17194   rdy	rts
                        17195   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 195
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

                        17197   ; adjust exponent
                        17198   ;
     9731               17199   sexp
     9731   D0 39       17200   	bne retrn      	;no over/underflow
     9733   49 09       17201   	eor #$09   	;.a is 0 or 9
     9735   9D 0100     17202   	sta fbuffr,x	;digit back in exp
     9738   CA          17203   	dex		;= 0 or 9
     9739   EC 0129     17204   	cpx uexp
     973C   60          17205   	rts
                        17206   
     973D               17207   eado
     973D   A9 00       17208   	lda #0
     973F               17209   eadj
     973F   AE 0129     17210   	ldx uexp
     9742   E8          17211   	inx
     9743   2C 0130     17212   	bit etof 	;e-to-f flag on?
     9746   30 10       17213   	bmi tag2 	;yes...
     9748   4D 0128     17214   	eor usgn
     974B   F0 0B       17215   	beq tag2 	;++ or --
     974D               17216   tag1
     974D   20 9782     17217   	jsr tag3       	;inc exp, overflow?
     9750   20 9731     17218   	jsr sexp 	;digit 0 if yes
     9753   B0 F8       17219   	bcs tag1 	;try second digit
     9755   4C 895D     17220   	jmp overr	;exp>99
                        17221   
     9758               17222   tag2
     9758   BD 0100     17223   	lda fbuffr,x
     975B   DE 0100     17224   	dec fbuffr,x    ;decrement exp
     975E   C9 30       17225   	cmp #'0'	;underflow on digit?
     9760   20 9731     17226   	jsr sexp 	;set digit=9 if yes...
     9763   B0 F3       17227   	bcs tag2 	;try 2nd digit
     9765   2C 0130     17228   	bit etof 	;flag off?
     9768   10 05       17229   	bpl et3  	;yes...
     976A   84 80       17230   	sty point	;decimal point pointer
     976C               17231   retrn
     976C   68          17232   	pla
     976D   68          17233   	pla
     976E   60          17234   	rts		;return to fform/main
                        17235   
     976F               17236   et3
     976F   AD 0128     17237   	lda usgn
     9772   49 80       17238   	eor #$80 	;reverse sign exp
     9774               17239   et2
     9774   8D 0128     17240   	sta usgn
     9777   A9 30       17241   	lda #'0'
     9779   9D 0101     17242   	sta fbuffr+1,x  ;exp<0 here
     977C   A9 31       17243   	lda #'1'
     977E   9D 0102     17244   	sta fbuffr+2,x
     9781   60          17245   	rts
                        17246   
     9782               17247   tag3
     9782   BD 0100     17248   	lda fbuffr,x	;get digit of exp
     9785   FE 0100     17249   	inc fbuffr,x    ;increment digit
     9788   C9 39       17250   	cmp #'9'	;overflow
     978A   60          17251   	rts		;return .z set

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 196
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

                        17253   ; ansub : load format field char in .a
                        17254   ;
     978B               17255   ansub
     978B   18          17256   	clc
     978C   C8          17257   	iny       	;begin format?
     978D   F0 05       17258   	beq ans010	;yes...
     978F   CC 0135     17259   	cpy lfor  	;end?
     9792   90 04       17260   	bcc ans020	;no...
     9794               17261   ans010
     9794   A4 77       17262   	ldy z_p_temp_1 	;<>0?
     9796   D0 D4       17263   	bne retrn	;yes...
     9798               17264   ans020
     9798   20 42F0     17265   	jsr indfrm
     979B   EE 0131     17266   	inc cform	;pointer to field
     979E   60          17267   	rts
                        17268   
                        17269   ;
                        17270   ;  ini : init counters and flags
                        17271   ;
     979F               17272   ini
     979F   20 8781     17273   	jsr frefac	;free temp descriptor
     97A2   85 78       17274   	sta hulp 	;length string
     97A4   A2 0A       17275   	ldx #$0a 	;printed in hulp
     97A6   A9 00       17276   	lda #0
     97A8               17277   stz
     97A8   9D 0127     17278   	sta swe,x	;init working registers
     97AB   CA          17279   	dex
     97AC   10 FA       17280   	bpl stz
     97AE   8E 0126     17281   	stx flag 	;comma flag =ff
     97B1   86 80       17282   	stx point	;point pointer=ff
     97B3   8E 0125     17283   	stx dolr	;dollar flag=ff
     97B6   AA          17284   	tax		;x=y=0
     97B7   A8          17285   	tay
     97B8   60          17286   	rts
                        17287   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 197
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

                        17289   ; round number
                        17290   ;
     97B9               17291   uround
     97B9   18          17292   	clc
     97BA   A5 80       17293   	lda point
     97BC   6D 012D     17294   	adc nf   	;overflow?
     97BF   B0 39       17295   	bcs rrts 	;yes...
     97C1   38          17296   	sec
     97C2   E5 77       17297   	sbc z_p_temp_1 	;underflow?
     97C4   90 34       17298   	bcc rrts 	;yes...
     97C6   CD 0124     17299   	cmp enr  	;anything to round?
     97C9   F0 02       17300   	beq cbn  	;yes...
     97CB   B0 2D       17301   	bcs rrts 	;no...
                        17302   
     97CD               17303   cbn
     97CD   CD 0123     17304   	cmp bnr  	;again...
     97D0   90 28       17305   	bcc rrts 	;no...
     97D2   AA          17306   	tax
     97D3   BD 0100     17307   	lda fbuffr,x    ;get digit
     97D6   C9 35       17308   	cmp #'5'	;<5 ?
     97D8   90 20       17309   	bcc rrts 	;yes...no round
     97DA               17310   con1
     97DA   EC 0123     17311   	cpx bnr  	;begin of no reached?
     97DD   F0 0A       17312   	beq add1 	;yes..add 1
     97DF   CA          17313   	dex
     97E0   20 9782     17314   	jsr tag3 	;increment digit
     97E3   8E 0124     17315   	stx enr  	;new end of no pointer
     97E6   F0 F2       17316   	beq con1 	;branch on overflow
     97E8   60          17317   	rts
                        17318   
     97E9               17319   add1
     97E9   A9 31       17320   	lda #'1'
     97EB   9D 0100     17321   	sta fbuffr,x
     97EE   E8          17322   	inx
     97EF   86 80       17323   	stx point
     97F1   C6 77       17324   	dec z_p_temp_1 	;# of 0's before .
     97F3   10 05       17325   	bpl rrts 	;no underflow
     97F5   E6 77       17326   	inc z_p_temp_1 	;underflow...back to 0
     97F7   EE 012A     17327   	inc vn
     97FA   60          17328   rrts	rts
                        17329   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 198
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

                        17331   ; alg : delete leading zeros of no
                        17332   ;
     97FB               17333   alg
     97FB   A4 80       17334   	ldy point	;start with a .?
     97FD   F0 17       17335   	beq szer 	;yes...
     97FF               17336   cho
     97FF   AC 0123     17337   	ldy bnr
     9802               17338   cmo
     9802   B9 0100     17339   	lda fbuffr,y    ;start with a 0?
     9805   C9 30       17340   	cmp #'0'
     9807   60          17341   	rts
                        17342   
     9808               17343   nbr
     9808   E6 80       17344   	inc point	;adjust point
     980A   20 973D     17345   	jsr eado 	;and exponent
     980D   EE 0123     17346   	inc bnr  	;and pointer to begin of no
     9810   CC 0124     17347   	cpy enr  	;end of number?
     9813   F0 E5       17348   	beq rrts 	;yes...
     9815   C8          17349   	iny
     9816               17350   szer
     9816   20 9802     17351   	jsr cmo  	;zero in no?
     9819   F0 ED       17352   	beq nbr  	;yes...
     981B   60          17353   	rts		;no...
                        17354   
                        17355   
                        17356   ; chout : print number
                        17357   ;
     981C               17358   chout
     981C   AD 0125     17359   	lda dolr	;dollar flag set?
     981F   30 02       17360   	bmi chou	;no...
     9821   E6 77       17361   	inc z_p_temp_1	;make room for $
     9823               17362   chou
     9823   AE 0123     17363   	ldx bnr		;start of #
     9826   CA          17364   	dex
     9827   AC 0134     17365   	ldy begfd	;begin of field
     982A               17366   afrm
     982A   20 42F0     17367   	jsr indfrm
     982D   C8          17368   	iny
     982E   C9 2C       17369   	cmp #','	;comma?
     9830   D0 14       17370   	bne punt	;no...
     9832   2C 0126     17371   	bit flag	;comma flag on?
     9835   30 09       17372   	bmi bout	;yes, do a fill char
     9837   8D FF03     17373   	sta sw_rom_ram0
     983A   AD 1205     17374   	lda pucoma
     983D   4C 98AB     17375   	jmp out		;no,...output a comma char
                        17376   
     9840               17377   bout
     9840   AD 0133     17378   	lda blfd
     9843   4C 98AB     17379   	jmp out
                        17380   
     9846               17381   punt
     9846   C9 2E       17382   	cmp #'.'	;decimal point?
     9848   D0 09       17383   	bne afplus
     984A   8D FF03     17384   	sta sw_rom_ram0
     984D   AD 1206     17385   	lda pudot	;yes...

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 198-1
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

     9850   4C 98AB     17386   	jmp out
                        17387   
     9853               17388   afplus
     9853   C9 2B       17389   	cmp #'+'	;plus?
     9855   F0 3B       17390   	beq ispl 	;yes...
     9857   C9 2D       17391   	cmp #'-'	;minus?
     9859   F0 32       17392   	beq ispl1	;yes...
     985B   C9 5E       17393   	cmp #'^' 	;up arrow?
     985D   D0 69       17394   	bne pndd 	;no...
     985F   A9 45       17395   	lda #'E'
     9861   20 98EB     17396   	jsr cdout
     9864   AC 0129     17397   	ldy uexp
     9867   20 9802     17398   	jsr cmo  	;first dig of exp zero?
     986A   D0 06       17399   	bne mint 	;no...
     986C   C8          17400   	iny
     986D   20 9802     17401   	jsr cmo  	;second digit?
     9870   F0 07       17402   	beq post 	;yes
     9872               17403   mint
     9872   A9 2D       17404   	lda #'-'
     9874   2C 0128     17405   	bit usgn
     9877   30 02       17406   	bmi mout
     9879               17407   post
     9879   A9 2B       17408   	lda #'+'
     987B               17409   mout
     987B   20 98EB     17410   	jsr cdout	;output sign exp
     987E   AE 0129     17411   	ldx uexp
     9881   BD 0100     17412   	lda fbuffr,x
     9884   20 98EB     17413   	jsr cdout	;output first dig exp
     9887   AC 0136     17414   	ldy endfd
     988A   4C 98A1     17415   	jmp telx
                        17416   
     988D               17417   ispl1
     988D   AD 0132     17418   	lda sno 	;positive?
     9890   30 AE       17419   	bmi bout	;yes...out blank or *
     9892               17420   ispl
     9892   AD 0132     17421   	lda sno 	;output sgn
     9895   4C 98AB     17422   	jmp out
                        17423   
     9898               17424   zerot
     9898   A5 77       17425   	lda z_p_temp_1	;# of zeros
     989A   D0 18       17426   	bne zerot1
     989C   EC 0124     17427   	cpx enr		;end of # reached?
     989F   F0 05       17428   	beq zout	;yes...output zero
     98A1               17429   telx
     98A1   E8          17430   	inx
     98A2   BD 0100     17431   	lda fbuffr,x	;get digit
     98A5   2C          17432   	.byte $2c	;branch always
                        17433   
     98A6               17434   zout
     98A6   A9 30       17435   	lda #'0'	;output zero
     98A8               17436   outs
     98A8   4E 0126     17437   	lsr flag	;clear comma flag
     98AB               17438   out
     98AB   20 98EB     17439   	jsr cdout   	;output character
     98AE   F0 03       17440   	beq 10$

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 198-2
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

     98B0   4C 982A     17441   	jmp afrm	;not ready...
     98B3   60          17442   10$	rts
                        17443   
                        17444   
     98B4   C6 77       17445   zerot1	dec z_p_temp_1	;count leading zeros
     98B6   AD 0125     17446   	lda dolr	;$ flag set?
     98B9   30 EB       17447   	bmi zout	;no...output zero
                        17448   
     98BB   20 ABC7     17449   	jsr using_patch	; (318019-03 fix; FAB:  $,999.99 delemma)
     98BE   EA          17450   	nop		;
                        17451   			; was:	sec
                        17452   			;	ror dolr	;clear dollar flag
                        17453   
     98BF   8D FF03     17454   	sta sw_rom_ram0
     98C2   AD 1207     17455   	lda pumony
     98C5   4C 98A8     17456   	jmp outs	;output money symbol
                        17457   
     98C8               17458   pndd
     98C8   AD 0127     17459   	lda swe 	;# of blanks
     98CB   F0 CB       17460   	beq zerot
     98CD   CE 0127     17461   	dec swe 	;count !
     98D0               17462   pndx
     98D0   F0 03       17463   	beq *+5
     98D2   4C 9840     17464   	jmp bout	;out blank or *
                        17465   
     98D5   AD 012E     17466   	lda posp	;+ or - in field?
     98D8   30 F6       17467   	bmi pndx	;yes...out blank or *
     98DA               17468   tat
     98DA   20 42F0     17469   	jsr indfrm
     98DD   C9 2C       17470   	cmp #','	;comma?
     98DF   D0 AC       17471   	bne ispl1	;no...out sign
     98E1   AD 0133     17472   	lda blfd	;yes...
     98E4   20 98EB     17473   	jsr cdout	;out blank or *
     98E7   C8          17474   	iny
     98E8   4C 98DA     17475   	jmp tat
                        17476   
     98EB               17477   cdout
     98EB   20 5629     17478   	jsr outdo	;char out
     98EE   CE 0131     17479   	dec cform	;count it
     98F1   60          17480   	rts
                        17481   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 199
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

                        17483   ; anaf :analyze format
                        17484   ;
     98F2               17485   anaf
     98F2   AC 0136     17486   	ldy endfd	;format pointer
     98F5               17487   gfor
     98F5   20 978B     17488   	jsr ansub
     98F8   20 99A7     17489   	jsr comp 	;check special chars
     98FB   D0 14       17490   	bne pchar	;no match...
     98FD   8C 0134     17491   	sty begfd	;save beginning of field
     9900   90 1A       17492   	bcc ffoun	;# was found
     9902   AA          17493   	tax		;save char
     9903               17494   sfur
     9903   20 978B     17495   	jsr ansub	;get next format char
     9906   B0 05       17496   	bcs nono 	;stop on wrap-around
     9908   20 99AF     17497   	jsr com1 	;compare specials
     990B   F0 0A       17498   	beq foun1	;found some...
     990D               17499   nono
     990D   AC 0134     17500   	ldy begfd
     9910   8A          17501   	txa
     9911               17502   pchar
     9911   20 5629     17503   	jsr outdo	;out character
     9914   4C 98F5     17504   	jmp gfor
                        17505   
     9917               17506   foun1
     9917   B0 EA       17507   	bcs sfur 	;no #...keep looking
     9919   AC 0134     17508   	ldy begfd
     991C               17509   ffoun
     991C   A6 77       17510   	ldx z_p_temp_1
     991E   D0 7A       17511   	bne trts
     9920   8E 0131     17512   	stx cform
     9923   88          17513   	dey
                        17514   
     9924               17515   hyo2
     9924   CE 0131     17516   	dec cform	;correct counter
     9927               17517   hyo
     9927   20 978B     17518   	jsr ansub	;get next format char
     992A   B0 74       17519   	bcs efo		;end of format
     992C   C9 2C       17520   	cmp #','	;comma?
     992E   F0 F7       17521   	beq hyo  	;yes...ignore it
     9930   20 997E     17522   	jsr isp  	;+ or - in format?
     9933   90 EF       17523   	bcc hyo2 	;yes...
     9935   C9 2E       17524   	cmp #'.'	;decimal point?
     9937   D0 08       17525   	bne avf1 	;no...
     9939   E8          17526   	inx
     993A   E0 02       17527   	cpx #2   	;more than 1 decimal?
     993C   90 E9       17528   	bcc hyo  	;no...
     993E   4C 7A09     17529   ero	jmp snerr	;yes...syntax error
                        17530   
     9941               17531   avf1
     9941   20 99B3     17532   	jsr com2 	;=, >, or # in field
     9944   D0 0B       17533   	bne llar 	;no...
     9946   90 03       17534   	bcc hyo1 	;was #
     9948   8D 012B     17535   	sta chsn 	;was > or =
     994B               17536   hyo1
     994B   FE 012C     17537   	inc vf,x

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 199-1
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

     994E   4C 9927     17538   	jmp hyo
                        17539   
     9951               17540   llar
     9951   C9 24       17541   	cmp #'$'	;dollar?
     9953   D0 0F       17542   	bne expo  	;no...
     9955   2C 0125     17543   	bit dolr  	;test flag
     9958   10 F1       17544   	bpl hyo1  	;no...
     995A   18          17545   	clc
     995B   6E 0125     17546   	ror dolr  	;set flag
     995E   CE 012C     17547   	dec vf
     9961   4C 994B     17548   	jmp hyo1
                        17549   
     9964               17550   expo
     9964   C9 5E       17551   	cmp #'^'  	;up arrow?
     9966   D0 16       17552   	bne isp  	;no...
     9968   A2 02       17553   	ldx #$02
     996A               17554   chkk
     996A   20 978B     17555   	jsr ansub	;must be 4 up arrows
     996D   B0 CF       17556   	bcs ero
     996F   C9 5E       17557   	cmp #'^' 	;up arrow?
     9971   D0 CB       17558   	bne ero
     9973   CA          17559   	dex
     9974   10 F4       17560   	bpl chkk
     9976   EE 012F     17561   	inc fesp 	;set exp flag
     9979   20 978B     17562   	jsr ansub	;next format char
     997C   B0 22       17563   	bcs efo  	;end of format
     997E               17564   isp
     997E   C9 2B       17565   	cmp #'+'	;plus?
     9980   D0 19       17566   	bne chom 	;no...
     9982   AD 0132     17567   	lda sno  	;sign neg?
     9985   10 05       17568   	bpl spos 	;yes...
     9987   A9 2B       17569   	lda #'+'
     9989   8D 0132     17570   	sta sno
     998C               17571   spos
     998C   AD 012E     17572   	lda posp 	;+ or - already?
     998F   D0 AD       17573   	bne ero
     9991   6E 012E     17574   	ror posp 	;make posp neg/clc
     9994   8C 0136     17575   	sty endfd	;end field pointer
     9997   EE 0131     17576   	inc cform	;correct counter
     999A   60          17577   trts	rts
                        17578   
     999B               17579   chom
     999B   C9 2D       17580   	cmp #'-'	;minus?
     999D   F0 ED       17581   	beq spos 	;yes...
     999F   38          17582   	sec
     99A0               17583   efo
     99A0   8C 0136     17584   	sty endfd	;end field pointer
     99A3   CE 0136     17585   	dec endfd
     99A6   60          17586   	rts
                        17587   
                        17588   
                        17589   ; comp :compare .a with symbols
                        17590   ;
     99A7               17591   comp
     99A7   C9 2B       17592   	cmp #'+'

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 199-2
USING - Formatted print routine   USING.SRC

Error Addr  Code          Seq   Source statement

     99A9   F0 15       17593   	beq rt
     99AB   C9 2D       17594   	cmp #'-'
     99AD   F0 11       17595   	beq rt
     99AF               17596   com1
     99AF   C9 2E       17597   	cmp #'.'
     99B1   F0 0D       17598   	beq rt
     99B3               17599   com2
     99B3   C9 3D       17600   	cmp #'='
     99B5   F0 09       17601   	beq rt
     99B7   C9 3E       17602   	cmp #'>'
     99B9   F0 05       17603   	beq rt
     99BB   C9 23       17604   	cmp #'#'
     99BD   D0 01       17605   	bne rt
     99BF   18          17606   	clc
     99C0   60          17607   rt	rts
                        17608   
                        17609   ;.end
                        17610   	.include instring

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 200
INSTRing Function   INSTRING.SRC

Error Addr  Code          Seq   Source statement

                        17612   	.subttl INSTRing Function
                        17613   
                        17614   ;
                        17615   ;  instring : position of str1 in str2 at or after position n
                        17616   ;     usage : instr(a$, b$ {,n})
                        17617   
     99C1   A5 66       17618   instr	lda facmo	;save pointer to temporary descriptors
     99C3   8D 03D6     17619   	sta tmpdes
     99C6   A5 67       17620   	lda facmo+1
     99C8   8D 03D7     17621   	sta tmpdes+1
                        17622   
     99CB   20 788C     17623   	jsr frmevl	;get next arg.
     99CE   20 787A     17624   	jsr chkstr	;must be string
     99D1   A5 66       17625   	lda facmo
     99D3   8D 03D8     17626   	sta tmpdes+2
     99D6   A5 67       17627   	lda facmo+1
     99D8   8D 03D9     17628   	sta tmpdes+3
                        17629   
     99DB   A2 01       17630   	ldx #1	   	;default starting position
     99DD   86 67       17631   	stx faclo
     99DF   20 0386     17632   	jsr chrgot
     99E2   C9 29       17633   	cmp #')'	;any length argument?
     99E4   F0 03       17634   	beq 1$		;branch if not
     99E6   20 8809     17635   	jsr combyt	;else go get a one byte argument
                        17636   
     99E9   20 79F3     17637   1$	jsr chkcls	;look for )
     99EC   A6 67       17638   	ldx faclo
     99EE   D0 03       17639   	bne 2$
     99F0   4C 7DC5     17640   	jmp fcerr	;starting position can't be 0
                        17641   
     99F3   CA          17642   2$	dex
     99F4   86 63       17643   	stx positn
                        17644   
     99F6   A2 03       17645   	ldx #3	   	;copy 'pointers to temp descriptors' to zero page
     99F8   BD 03D6     17646   3$	lda tmpdes,x
     99FB   95 59       17647   	sta ptarg1,x
     99FD   CA          17648   	dex
     99FE   10 F8       17649   	bpl 3$
                        17650   
     9A00   A0 02       17651   	ldy #2	   	;now get the descriptors
     9A02   A9 59       17652   4$	lda #ptarg1
     9A04   20 03AB     17653   	jsr indsub_ram1
     9A07   99 005D     17654   	sta str1,y
     9A0A   A9 5B       17655   	lda #ptarg2
     9A0C   20 03AB     17656   	jsr indsub_ram1
     9A0F   99 0060     17657   	sta str2,y
     9A12   88          17658   	dey
     9A13   10 ED       17659   	bpl 4$
                        17660   
     9A15   A5 60       17661   	lda str2	;check if string 2 is null
     9A17   F0 3B       17662   	beq instnf	;if so, return 0
                        17663   
     9A19               17664   inst5
     9A19   A9 00       17665   	lda #0
     9A1B   85 64       17666   	sta match

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 200-1
INSTRing Function   INSTRING.SRC

Error Addr  Code          Seq   Source statement

     9A1D   18          17667   	clc
     9A1E   A5 60       17668   	lda str2	;length of string 2
     9A20   65 63       17669   	adc positn
     9A22   B0 30       17670   	bcs instnf	;too long, not found
     9A24   C5 5D       17671   	cmp str1	;see if > length of string 1
     9A26   90 02       17672   	bcc inst6	;< len string 1
     9A28   D0 2A       17673   	bne instnf	;must be >, not found
     9A2A               17674   inst6
     9A2A   A4 64       17675   	ldy match
     9A2C   C4 60       17676   	cpy str2	;if match len = str len, then found
     9A2E   F0 1F       17677   	beq instfd
     9A30   98          17678   	tya
     9A31   18          17679   	clc
     9A32   65 63       17680   	adc positn	;compare str1(s+p+m) with str2(m)
     9A34   A8          17681   	tay
     9A35   A9 5E       17682   	lda #str1+1
     9A37   20 03AB     17683   	jsr indsub_ram1
     9A3A   85 79       17684   	sta syntmp
     9A3C   A4 64       17685   	ldy match
     9A3E   A9 61       17686   	lda #str2+1
     9A40   20 03AB     17687   	jsr indsub_ram1
     9A43   C5 79       17688   	cmp syntmp
     9A45   F0 04       17689   	beq inst7
     9A47   E6 63       17690   	inc positn	;not the same, start over from next positn
     9A49   D0 CE       17691   	bne inst5	;always
                        17692   
     9A4B   E6 64       17693   inst7	inc match	;count characters that match
     9A4D   D0 DB       17694   	bne inst6	;always
                        17695   
     9A4F   E6 63       17696   instfd	inc positn
     9A51   A5 63       17697   	lda positn
     9A53   2C          17698   	.byte $2c
                        17699   
     9A54   A9 00       17700   instnf	lda #0
     9A56   8D FF03     17701   	sta sw_rom_ram0
     9A59   48          17702   	pha
     9A5A   AD 03D8     17703   	lda tmpdes+2	;free temp descriptors
     9A5D   AC 03D9     17704   	ldy tmpdes+3
     9A60   20 8785     17705   	jsr fretmp
     9A63   8D FF03     17706   	sta sw_rom_ram0
     9A66   AD 03D6     17707   	lda tmpdes
     9A69   AC 03D7     17708   	ldy tmpdes+1
     9A6C   20 8785     17709   	jsr fretmp
     9A6F   68          17710   	pla
     9A70   A8          17711   	tay
     9A71   4C 84D4     17712   	jmp sngflt
                        17713   
                        17714   ;end
                        17715   	.include graphic3

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 201
'graphics3'   GRAPHIC3.SRC

Error Addr  Code          Seq   Source statement

                        17717   	.subttl 'graphics3'
                        17718   ;****************************************************************
                        17719   ;
                        17720   ;  getang  -  set cosine & sine values
                        17721   ;             results in sinval & cosval based as a fraction
                        17722   ;             - over 65536
                        17723   ;             angsgn = angle phase (0-3)
                        17724   ;    on input vwork+y = 2 byte angle
                        17725   ;
                        17726   ;***************************************************************
                        17727   ;
     9A74               17728   getang
     9A74   20 9D98     17729   	jsr settwo      ;move angle value into y/a
     9A77               17730   gtang1
     9A77   A2 00       17731   	ldx #0		;init count of phase
     9A79               17732   getan1
     9A79   E8          17733   	inx
     9A7A   38          17734   	sec
     9A7B   E9 5A       17735   	sbc #90		;subtract 90 until less than 0
     9A7D   B0 FA       17736   	bcs getan1
     9A7F   88          17737   	dey
     9A80   10 F7       17738   	bpl getan1
     9A82   8E 1149     17739   	stx angsgn	;save phase (here it is 1-4)
     9A85   48          17740   	pha
     9A86   69 5A       17741   	adc #90		;make positive
     9A88   20 9A94     17742   	jsr getan2	;do division by 10
     9A8B   68          17743   	pla		;get 2's comp of angle
     9A8C   18          17744   	clc
     9A8D   49 FF       17745   	eor #$ff
     9A8F   69 01       17746   	adc #1		;make positive
     9A91   CE 1149     17747   	dec angsgn	;correct phase
     9A94               17748   getan2
     9A94   A2 FF       17749   	ldx #$ff
     9A96               17750   getan3
     9A96   E8          17751   	inx		;do division by 10
     9A97   38          17752   	sec
     9A98   E9 0A       17753   	sbc #10
     9A9A   B0 FA       17754   	bcs getan3
     9A9C   69 0A       17755   	adc #10		;make positive
     9A9E   85 8E       17756   	sta vtemp1	;save remainder
     9AA0   8A          17757   	txa
     9AA1   0A          17758   	asl a		;get quotient*2 as index
     9AA2   AA          17759   	tax
     9AA3   BD 9F33     17760   	lda angval+1,x	;get low byte base
     9AA6   BC 9F32     17761   	ldy angval,x	;get high byte value
     9AA9               17762   getan4
     9AA9   18          17763   	clc
     9AAA   C6 8E       17764   	dec vtemp1
     9AAC   30 0C       17765   	bmi getan5	;done - remainder = 0
     9AAE   7D 9F47     17766   	adc incval+1,x	;add low byte increment
     9AB1   48          17767   	pha
     9AB2   98          17768   	tya
     9AB3   7D 9F46     17769   	adc incval,x	;add high byte increment
     9AB6   A8          17770   	tay
     9AB7   68          17771   	pla

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 201-1
'graphics3'   GRAPHIC3.SRC

Error Addr  Code          Seq   Source statement

     9AB8   90 EF       17772   	bcc getan4	;...always
     9ABA               17773   getan5
     9ABA   48          17774   	pha		;save low byte of result
     9ABB   A2 00       17775   	ldx #0		;point to sinval
     9ABD   AD 1149     17776   	lda angsgn
     9AC0   4A          17777   	lsr a
     9AC1   B0 02       17778   	bcs getan6	;skip if sine value
     9AC3   A2 02       17779   	ldx #2		;point to cosval
     9AC5               17780   getan6
     9AC5   68          17781   	pla
     9AC6   9D 114A     17782   	sta sinval,x	;save low byte result
     9AC9   98          17783   	tya
     9ACA   9D 114B     17784   	sta sinval+1,x	;save high byte result
     9ACD   60          17785   	rts
                        17786   
                        17787   
                        17788   
                        17789   ;*************************************************************
                        17790   ;
                        17791   ;  angmlt  -  multiple 2-byte integer times angle
                        17792   ;	      carry set/reset = cosine/sine
                        17793   ;
                        17794   ;	      vwork+x = 2-byte integer
                        17795   ;	      result left in y/a
                        17796   ;
                        17797   ;*************************************************************
                        17798   
     9ACE               17799   angmlt
     9ACE   A0 19       17800   	ldy #sinval-vwork	;get offset to angle value
     9AD0   90 02       17801   	bcc angm10      	;get cosine/sine offset
     9AD2   A0 1B       17802   	ldy #cosval-vwork
     9AD4               17803   angm10
     9AD4   AD 1149     17804   	lda angsgn
     9AD7   69 02       17805   	adc #2		;correct phase for cosine to look as sine
     9AD9   4A          17806   	lsr a
     9ADA   4A          17807   	lsr a
     9ADB   08          17808   	php		;save if carry - means negative angle value
     9ADC   20 9D98     17809   	jsr settwo      ;get angle fraction in y/a
     9ADF   C0 FF       17810   	cpy #$ff	;test if value should be 1
     9AE1   90 07       17811   	bcc angm20      ;skip if not
     9AE3   8A          17812   	txa
     9AE4   A8          17813   	tay		;get offset to integer
     9AE5   20 9D98     17814   	jsr settwo	;just get integer - multiplied by 1
     9AE8   B0 03       17815   	bcs angm30
     9AEA               17816   angm20
     9AEA   20 9DB7     17817   	jsr twobyt	;multiply integer times angle value
     9AED               17818   angm30
     9AED   28          17819   	plp		;get sign of angle
     9AEE   B0 1B       17820   	bcs angd20
     9AF0   4C 9DA7     17821   	jmp invert	;invert result if negative,do rts
                        17822   
                        17823   
                        17824   
                        17825   ;*************************************************************
                        17826   ;

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 201-2
'graphics3'   GRAPHIC3.SRC

Error Addr  Code          Seq   Source statement

                        17827   ;  angdst  -  set up values for distance * angles
                        17828   ;	      vwork+x = x & y distances
                        17829   ;	      a = angles : ang1,ang2,ang3,ang4,0,0,0,0
                        17830   ;	      get xdist1 = xdist1 * angle-1
                        17831   ;		   ydist1 = ydist1 * angle-2
                        17832   ;		   xdist2 = xdist2 * angle-3
                        17833   ;		   ydist2 = ydist2 * angle-4
                        17834   ;
                        17835   ;*************************************************************
                        17836   
     9AF3               17837   angdst
     9AF3   8D 114E     17838   	sta angcnt      ;save angles
     9AF6   A2 23       17839   	ldx #xdist1-vwork
     9AF8               17840   angd10
     9AF8   0E 114E     17841   	asl angcnt
     9AFB   20 9ACE     17842   	jsr angmlt      ;multiply angle * distance
     9AFE   9D 1131     17843   	sta vwork,x
     9B01   98          17844   	tya		;save results
     9B02   9D 1132     17845   	sta vwork+1,x
     9B05   E8          17846   	inx		;point to next distance
     9B06   E8          17847   	inx
     9B07   E0 2B       17848   	cpx #disend-vwork
     9B09   90 ED       17849   	bcc angd10	;loop 4 times
     9B0B   60          17850   angd20	rts
                        17851   
                        17852   
                        17853   ;.end
                        17854   	.include rdot

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 202
RDOT Function   RDOT.SRC

Error Addr  Code          Seq   Source statement

                        17856   	.subttl  RDOT Function
                        17857   
                        17858   ;**************************************************************
                        17859   ;
                        17860   ;  rdot(n)  --  read characteristics of current xpos/ypos
                        17861   ;		 n = 0 : x-position
                        17862   ;		     1 : y-position
                        17863   ;		     2 : color selection (0-3)
                        17864   ;
                        17865   ;**************************************************************
                        17866   
     9B0C   20 87F7     17867   rdot	jsr conint      ;get 1 byte arg. in x
     9B0F   E0 02       17868   	cpx #2
     9B11   90 10       17869   	bcc 30$		;0 or 1
     9B13   F0 03       17870   	beq 10$
     9B15   4C 7DC5     17871   	jmp fcerr	;>2, error
                        17872   
     9B18   20 9C4C     17873   10$	jsr readpt      ;get color
     9B1B   A8          17874   	tay
     9B1C   90 02       17875   	bcc 20$	;branch if in bounds
     9B1E   A0 00       17876   	ldy #0		;else return 0
     9B20   4C 84D4     17877   20$	jmp sngflt      ;float 1 byte value in y
                        17878   
     9B23   8A          17879   30$	txa		;convert (0 or 1) to (0 or 2)
     9B24   0A          17880   	asl a
     9B25   AA          17881   	tax
     9B26   BD 1131     17882   	lda xpos,x      ;get xpos or ypos ls byte
     9B29   A8          17883   	tay
     9B2A   BD 1132     17884   	lda xpos+1,x    ;get ms byte
     9B2D   4C 79D9     17885   	jmp givayf      ;float 2 byte value in (y,a)
                        17886   
                        17887   ;.end
                        17888   	.include graphic7

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 203
'graphics7'   GRAPHIC7.SRC

Error Addr  Code          Seq   Source statement

                        17890   	.subttl 'graphics7'
                        17891   ;******************************************************************
                        17892   ;
                        17893   ;  drawln - draw a line from x/y-pos to x/y-dest. draw the line
                        17894   ;           by plotting x/y-pos and increasing or decreasing it
                        17895   ;           until it equals x/y-dest.
                        17896   ;
                        17897   ;           absx    = abs(destx-posx) : absy = abs(desty-posy)
                        17898   ;           sgnx    = sgn(destx-posx) : sgny = sgn(desty-posy)
                        17899   ;                     ( sgn=(1,0,-1) if (+,0,-) )
                        17900   ;           greatr  = index to the greatr of absx,absy
                        17901   ;           lesser  = index to the smaller of absx,absy
                        17902   ;
                        17903   ;           fct1    = 2*min(absx,absy)
                        17904   ;           fct2    = fct1 - 2*max(absx,absy)
                        17905   ;           error   = fct1 - max(absx,absy)
                        17906   ;
                        17907   ;           for i:= 1 to max(absx,absy) do begin
                        17908   ;                 plot(posx,posy)
                        17909   ;                 if error > 0 then begin
                        17910   ;                      pos(lesser):= pos(lesser) + sgn(lesser)
                        17911   ;                      error:= error + fct2
                        17912   ;                      end
                        17913   ;                      else error:= error + fct1
                        17914   ;                 pos(greatr):= pos(greatr) + sgn(greatr)
                        17915   ;           end;
                        17916   ;                                                08nov82   f.a.b.
                        17917   ;******************************************************************
                        17918   
     9B30               17919   drawln
     9B30   A2 02       17920   	ldx #ypos-vwork
     9B32   A0 06       17921   	ldy #ydest-vwork
     9B34               17922   drw01
     9B34   A9 00       17923   	lda #0
     9B36   9D 113D     17924   	sta xysgn,x     ;init direction pointers
     9B39   9D 113E     17925   	sta xysgn+1,x
     9B3C   20 9DA2     17926   	jsr abstwo	;get absolute value of coordinate differences
     9B3F   10 08       17927   	bpl drw02
     9B41   DE 113D     17928   	dec xysgn,x	;negative direction
     9B44   DE 113E     17929   	dec xysgn+1,x
     9B47   D0 0B       17930   	bne drw04	;always
     9B49   C9 00       17931   drw02	cmp #0
     9B4B   D0 04       17932   	bne drw03
     9B4D   C0 00       17933   	cpy #0
     9B4F   F0 03       17934   	beq drw04	;zero direction
     9B51   FE 113D     17935   drw03	inc xysgn,x	;positive direction
     9B54   9D 1139     17936   drw04	sta xyabs,x
     9B57   0A          17937   	asl a
     9B58   9D 1141     17938   	sta fct,x	;fct(x,y) = 2*abs(x,y)
     9B5B   98          17939   	tya
     9B5C   9D 113A     17940   	sta xyabs+1,x
     9B5F   2A          17941   	rol a
     9B60   9D 1142     17942   	sta fct+1,x
     9B63   CA          17943   	dex
     9B64   CA          17944   	dex

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 203-1
'graphics7'   GRAPHIC7.SRC

Error Addr  Code          Seq   Source statement

     9B65   A0 04       17945   	ldy #xdest-vwork ;loop to do in x-direction
     9B67   E0 00       17946   	cpx #xpos-vwork
     9B69   F0 C9       17947   	beq drw01
                        17948   
     9B6B   A2 0A       17949   	ldx #yabs-vwork ;determine max(xabs,yabs)
     9B6D   A0 08       17950   	ldy #xabs-vwork
     9B6F   20 9D85     17951   	jsr subtwo
     9B72   A9 00       17952   	lda #0
     9B74   2A          17953   	rol a
     9B75   2A          17954   	rol a		;a = c * 2
     9B76   8D 1147     17955   	sta lesser      ;index to smaller delta
     9B79   49 02       17956   	eor #2
     9B7B   8D 1148     17957   	sta greatr      ;index to greatr delta
                        17958   
     9B7E   18          17959   	clc
     9B7F   A9 10       17960   	lda #fct-vwork
     9B81   6D 1147     17961   	adc lesser
     9B84   A8          17962   	tay
     9B85   48          17963   	pha
     9B86   49 02       17964   	eor #2
     9B88   AA          17965   	tax
     9B89   20 9D85     17966   	jsr subtwo      ;fct(greatr) = fct(lesser)-fct(greatr)
     9B8C   9D 1131     17967   	sta vwork,x
     9B8F   98          17968   	tya
     9B90   9D 1132     17969   	sta vwork+1,x
                        17970   
     9B93   68          17971   	pla
     9B94   A8          17972   	tay		;fct(lesser)
     9B95   18          17973   	clc
     9B96   A9 08       17974   	lda #xyabs-vwork
     9B98   6D 1148     17975   	adc greatr
     9B9B   AA          17976   	tax
     9B9C   20 9D85     17977   	jsr subtwo      ;error = fct(lesser) - abs(greatr)
     9B9F   8D 1145     17978   	sta errval
     9BA2   8C 1146     17979   	sty errval+1
                        17980   
     9BA5               17981   dloop
     9BA5   20 9BFB     17982   	jsr gplot	;plot (xpos,ypos)
     9BA8   AC 1148     17983   	ldy greatr
     9BAB   38          17984   	sec
     9BAC   B9 1139     17985   	lda xyabs,y     ;for i = 1 to abs(greatr)
     9BAF   E9 01       17986   	sbc #1
     9BB1   99 1139     17987   	sta xyabs,y
     9BB4   B0 0B       17988   	bcs drw05
     9BB6   B9 113A     17989   	lda xyabs+1,y
     9BB9   E9 00       17990   	sbc #0
     9BBB   99 113A     17991   	sta xyabs+1,y
     9BBE   B0 01       17992   	bcs drw05
     9BC0   60          17993   	rts		;done!
                        17994   
     9BC1               17995   drw05
     9BC1   AE 1147     17996   	ldx lesser
     9BC4   AD 1146     17997   	lda errval+1
     9BC7   30 06       17998   	bmi drw06	;branch if error negative
     9BC9   20 9BEA     17999   	jsr drwinc	;pos(lesser) = pos(lesser) + sgn(lesser)

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 203-2
'graphics7'   GRAPHIC7.SRC

Error Addr  Code          Seq   Source statement

     9BCC   AE 1148     18000   	ldx greatr
                        18001   
     9BCF   18          18002   drw06	clc		;error = error + fct(.x)
     9BD0   AD 1145     18003   	lda errval
     9BD3   7D 1141     18004   	adc fct,x
     9BD6   8D 1145     18005   	sta errval
     9BD9   AD 1146     18006   	lda errval+1
     9BDC   7D 1142     18007   	adc fct+1,x
     9BDF   8D 1146     18008   	sta errval+1
                        18009   
     9BE2   AE 1148     18010   	ldx greatr
     9BE5   20 9BEA     18011   	jsr drwinc	;pos(greatr) = pos(greatr) + sgn(greatr)
     9BE8   F0 BB       18012   	beq dloop	;always
                        18013   
                        18014   
                        18015   
     9BEA   A0 02       18016   drwinc	ldy #2
     9BEC   18          18017   	clc
     9BED   BD 1131     18018   drwin1	lda xypos,x	;calculate new position
     9BF0   7D 113D     18019   	adc xysgn,x
     9BF3   9D 1131     18020   	sta xypos,x	;  (.x points to lesser/greatr)
     9BF6   E8          18021   	inx
     9BF7   88          18022   	dey
     9BF8   D0 F3       18023   	bne drwin1
     9BFA   60          18024   	rts
                        18025   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 204
'graphics7'   GRAPHIC7.SRC

Error Addr  Code          Seq   Source statement

                        18027   ;******************************************************************
                        18028   ;
                        18029   ;     plot - plot a point within the graphic bit map table
                        18030   ;    x/y-pos holds the coordinates - colsel contains color
                        18031   ;
                        18032   ;******************************************************************
                        18033   
     9BFB               18034   gplot
     9BFB   AD 116C     18035   	lda filflg      ;flag =1 to plot double width
     9BFE   0D 116B     18036   	ora width
     9C01   F0 16       18037   	beq plot01
     9C03   EE 1131     18038   	inc xpos
     9C06   D0 03       18039   	bne 10$
     9C08   EE 1132     18040   	inc xpos+1
     9C0B   20 9C19     18041   10$	jsr plot01
     9C0E   AE 1131     18042   	ldx xpos
     9C11   D0 03       18043   	bne 20$
     9C13   CE 1132     18044   	dec xpos+1
     9C16   CE 1131     18045   20$	dec xpos
                        18046   
     9C19               18047   plot01			;entry here ignores wide-line mode
     9C19   6C 03E4     18048   	jmp (plot_point)
     9C1C               18049   plot_vic
     9C1C   20 9D2D     18050   	jsr divpos	;convert xpos/ypos to column&row
     9C1F   B0 24       18051   	bcs plotgo	;exit if out of bounds
     9C21   20 9C76     18052   	jsr docolr	;set colors
     9C24   20 9CF1     18053   	jsr getps1	;get bit map address
     9C27   8D 116D     18054   	sta bitmsk
     9C2A   B1 8C       18055   	lda (grapnt),y	;get bit map byte
     9C2C   0D 116D     18056   	ora bitmsk	;set bits
     9C2F   24 D8       18057   	bit _graphm	;check graphic mode
     9C31   10 13       18058   	bpl plot30	;go if a hires mode
     9C33   48          18059   	pha		;save new byte
     9C34   A6 83       18060   	ldx colsel	;get color selction
     9C36   AD 116D     18061   	lda bitmsk	;get mask
     9C39   3D 9F2E     18062   	and colval,x	;get inverted bits
     9C3C   8D 116D     18063   	sta bitmsk
     9C3F   68          18064   	pla
     9C40               18065   plot10
     9C40   4D 116D     18066   	eor bitmsk	;set correct bits
     9C43               18067   plot20
     9C43   91 8C       18068   	sta (grapnt),y	;save byte
     9C45               18069   plotgo
     9C45   60          18070   	rts
     9C46               18071   plot30
     9C46   A6 83       18072   	ldx colsel	;get color selection
     9C48   D0 F9       18073   	bne plot20	;done if to be set
     9C4A   F0 F4       18074   	beq plot10
                        18075   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 205
'graphics7'   GRAPHIC7.SRC

Error Addr  Code          Seq   Source statement

                        18077   ;*****************************************************************
                        18078   ;
                        18079   ;  readpt  -  read the point located at xpos,ypos
                        18080   ;	      return the color value in a-reg - right justified
                        18081   ;	      carry set = coordinates out of bounds
                        18082   ;	      zero flag =  ((stopnb = 0  &  color = colsel)
                        18083   ;			   or (stopnb = $80 & color <> background))
                        18084   ;
                        18085   ;******************************************************************
                        18086   
     9C4C               18087   readpt
     9C4C   6C 03E8     18088   	jmp (read_point)
                        18089   
     9C4F               18090   read_vic
     9C4F   20 9CEC     18091   	jsr getpos	;get address in graphic bit map
     9C52   B0 21       18092   	bcs readgo	;error exit if out of bounds error
     9C54   8D 116D     18093   	sta bitmsk	;save mask
     9C57   B1 8C       18094   	lda (grapnt),y	;get bit map byte
     9C59   2D 116D     18095   	and bitmsk	;mask out bits
     9C5C               18096   readlp
     9C5C   2A          18097   	rol a		;shift bits to be right-justified
     9C5D   CA          18098   	dex
     9C5E   10 FC       18099   	bpl readlp
     9C60   2A          18100   	rol a
     9C61   24 8B       18101   	bit stopnb	;is stop-on-any flag set?
     9C63   30 06       18102   	bmi readl1	;branch if so
     9C65   29 03       18103   	and #3
     9C67   C5 83       18104   	cmp colsel	;else compare against specific color
     9C69   18          18105   	clc
     9C6A   60          18106   	rts
     9C6B               18107   readl1
     9C6B   18          18108   	clc
     9C6C   29 03       18109   	and #3
     9C6E   F0 03       18110   	beq readl3	;invert zero flag
     9C70   A2 00       18111   	ldx #0
     9C72   60          18112   	rts
     9C73   A2 FF       18113   readl3	ldx #$ff
     9C75               18114   readgo
     9C75   60          18115   	rts
                        18116   
                        18117   ;.end
                        18118   	.include graphic8

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 206
'graphic8'   GRAPHIC8.SRC

Error Addr  Code          Seq   Source statement

                        18120   	.subttl 'graphic8'
                        18121   ;****************************************************************
                        18122   ;
                        18123   ;  docolr  --  set up color for 8x8 charcater cell
                        18124   ;		 x = row number  --  y = column number
                        18125   ;
                        18126   ;****************************************************************
                        18127   
     9C76   6C 03E6     18128   docolr	jmp (plot_color)
                        18129   
     9C79               18130   color_vic
     9C79   BD C033     18131   	lda _ldtb2,x     	;put address of video ram into grapnt
     9C7C   85 8C       18132   	sta grapnt
     9C7E   BD 9CD3     18133   	lda graphic_ldtb1,x	;point to bit mapped color area
     9C81   85 8D       18134   	sta grapnt+1
                        18135   
     9C83   A5 83       18136   	lda colsel		;get current color source selected
                        18137   
     9C85   D0 08       18138   	bne 10$			;branch if NOT background
     9C87   AD 03E2     18139   	lda fg_bg
     9C8A   24 D8       18140   	bit _graphm		;test if mode = hires
     9C8C   10 08       18141   	bpl 25$			;if so, go set up byte
     9C8E   60          18142   	rts			;else exit
                        18143   
     9C8F   C9 02       18144   10$	cmp #2
     9C91   D0 10       18145   	bne 30$			;branch if NOT multi-color 1
                        18146   
     9C93   AD 03E3     18147   20$	lda fg_mc1		;get correct packed colors for multicolor mode.
     9C96   29 0F       18148   25$	and #$0f
     9C98   85 77       18149   	sta z_p_temp_1
     9C9A   B1 8C       18150   	lda (grapnt),y
     9C9C   29 F0       18151   	and #$f0
     9C9E   05 77       18152   	ora z_p_temp_1
     9CA0   91 8C       18153   	sta (grapnt),y
     9CA2   60          18154   	rts
                        18155   
     9CA3   B0 10       18156   30$	bcs 40$			;branch if multicolor 2
                        18157   
     9CA5   AD 03E2     18158   	lda fg_bg		;here for foreground. get packed colors.
     9CA8   29 F0       18159   	and #$f0
     9CAA   85 77       18160   	sta z_p_temp_1
     9CAC   B1 8C       18161   	lda (grapnt),y		;do foreground
     9CAE   29 0F       18162   	and #$0f
     9CB0   05 77       18163   	ora z_p_temp_1
     9CB2   91 8C       18164   	sta (grapnt),y
     9CB4   60          18165   	rts
                        18166   
     9CB5   A5 8D       18167   40$	lda grapnt+1		;do multicolor 2
     9CB7   29 03       18168   	and #3
     9CB9   09 D8       18169   	ora #>color_ram_hi	;set up to point to high color area
     9CBB   85 8D       18170   	sta grapnt+1
                        18171   
     9CBD   A9 00       18172   	lda #0			;put i/o in map
     9CBF   8D FF00     18173   	sta mmu_config_reg
                        18174   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 206-1
'graphic8'   GRAPHIC8.SRC

Error Addr  Code          Seq   Source statement

     9CC2   78          18175   	sei
     9CC3   A5 01       18176   	lda _6510_data_reg
     9CC5   48          18177   	pha
     9CC6   29 FE       18178   	and #%11111110		;point cpu at correct nybble bank
     9CC8   85 01       18179   	sta _6510_data_reg
     9CCA   A5 85       18180   	lda multicolor_2
     9CCC   91 8C       18181   	sta (grapnt),y
     9CCE   68          18182   	pla
     9CCF   85 01       18183   	sta _6510_data_reg
     9CD1   58          18184   	cli
     9CD2   60          18185   	rts
                        18186   
                        18187   
                        18188   
     9CD3               18189   graphic_ldtb1			;_ldtb1 adjusted for an org at color_ram_lo
            =1C00       18190   99$=color_ram_lo
            =1C28       18191   1$=color_ram_lo+40*1
            =1C50       18192   2$=color_ram_lo+40*2
            =1C78       18193   3$=color_ram_lo+40*3
            =1CA0       18194   4$=color_ram_lo+40*4
            =1CC8       18195   5$=color_ram_lo+40*5
            =1CF0       18196   6$=color_ram_lo+40*6
            =1D18       18197   7$=color_ram_lo+40*7
            =1D40       18198   8$=color_ram_lo+40*8
            =1D68       18199   9$=color_ram_lo+40*9
            =1D90       18200   10$=color_ram_lo+40*10
            =1DB8       18201   11$=color_ram_lo+40*11
            =1DE0       18202   12$=color_ram_lo+40*12
            =1E08       18203   13$=color_ram_lo+40*13
            =1E30       18204   14$=color_ram_lo+40*14
            =1E58       18205   15$=color_ram_lo+40*15
            =1E80       18206   16$=color_ram_lo+40*16
            =1EA8       18207   17$=color_ram_lo+40*17
            =1ED0       18208   18$=color_ram_lo+40*18
            =1EF8       18209   19$=color_ram_lo+40*19
            =1F20       18210   20$=color_ram_lo+40*20
            =1F48       18211   21$=color_ram_lo+40*21
            =1F70       18212   22$=color_ram_lo+40*22
            =1F98       18213   23$=color_ram_lo+40*23
            =1FC0       18214   24$=color_ram_lo+40*24
                        18215   
     9CD3   1C 1C 1C    18216   	.byte >99$,>1$,>2$,>3$,>4$,>5$,>6$,>7$,>8$,>9$,>10$
     9CD6   1C 1C 1C            
     9CD9   1C 1D 1D            
     9CDC   1D 1D               
     9CDE   1D 1D 1E    18217   	.byte >11$,>12$,>13$,>14$,>15$,>16$,>17$,>18$,>19$
     9CE1   1E 1E 1E            
     9CE4   1E 1E 1E            
     9CE7   1F 1F 1F    18218   	.byte >20$,>21$,>22$,>23$,>24$
     9CEA   1F 1F               

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 207
'graphic8'   GRAPHIC8.SRC

Error Addr  Code          Seq   Source statement

                        18220   
                        18221   ;******************************************************************
                        18222   ;
                        18223   ;  getpos - get address in graphic bit map into grapnt
                        18224   ;	     x = bit offset into byte specified (0-7)
                        18225   ;	     y = offset to byte within 8x8 character cell
                        18226   ;	     a = bit mask to the bit (or bits if multicolor mode)
                        18227   ;
                        18228   ;******************************************************************
                        18229   
     9CEC   20 9D2D     18230   getpos	jsr divpos      ;get xpos/ypos to column/row position
     9CEF   B0 33       18231   	bcs grprts      ;abort if position too large
                        18232   
     9CF1   98          18233   getps1	tya		;get addr for row (X) and col (Y) in grapnt
     9CF2   18          18234   	clc
     9CF3   7D C033     18235   	adc _ldtb2,x	;add column position to low byte offset
     9CF6   85 8C       18236   	sta grapnt
     9CF8   BD C04C     18237   	lda _ldtb1,x	;get high byte screen address
     9CFB   69 00       18238   	adc #0		;add any carry
     9CFD   06 8C       18239   	asl grapnt
     9CFF   2A          18240   	rol a
     9D00   06 8C       18241   	asl grapnt	;mult by 8 to get offset into 8k area
     9D02   2A          18242   	rol a
     9D03   06 8C       18243   	asl grapnt
     9D05   2A          18244   	rol a
     9D06   85 8D       18245   	sta grapnt+1
                        18246   
     9D08   AD 1133     18247   	lda ypos
     9D0B   29 07       18248   	and #07
     9D0D   A8          18249   	tay		;get byte offset into 8x8 char cell
     9D0E   AD 1131     18250   	lda xpos
     9D11   24 D8       18251   	bit _graphm
     9D13   08          18252   	php
     9D14   10 01       18253   	bpl grpos3	;skip if not multicolor mode
     9D16   0A          18254   	asl a		;shift x-pos for multicolor mode
                        18255   
     9D17   29 07       18256   grpos3	and #07
     9D19   AA          18257   	tax
     9D1A   BD 9D25     18258   	lda rbits,x	;get bit mask
     9D1D   28          18259   	plp
     9D1E   10 04       18260   	bpl grprts	;done if not multicolor mode
     9D20   E8          18261   	inx
     9D21   1D 9D25     18262   	ora rbits,x	;mask for 2 bits if multicolor mode
     9D24   60          18263   grprts	rts
                        18264   
     9D25   80 40 20    18265   rbits	.byte   $80,$40,$20,$10,$08,$04,$02,$01
     9D28   10 08 04            
     9D2B   02 01               

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 208
'graphic8'   GRAPHIC8.SRC

Error Addr  Code          Seq   Source statement

                        18267   
                        18268   ;**************************************************************
                        18269   ;
                        18270   ;  divpos  --  convert xpos to column number
                        18271   ;		convert ypos to row number
                        18272   ;		return carry set if either above limits
                        18273   ;
                        18274   ;**************************************************************
                        18275   
     9D2D   AD 1132     18276   divpos	lda xpos+1
     9D30   4A          18277   	lsr a
     9D31   D0 1E       18278   	bne 20$      	;out of bounds if greater than 1
     9D33   AD 1131     18279   	lda xpos
     9D36   6A          18280   	ror a
     9D37   4A          18281   	lsr a		;get column position = xpos/8
     9D38   24 D8       18282   	bit _graphm
     9D3A   30 01       18283   	bmi 10$		;skip if multicolor mode
     9D3C   4A          18284   	lsr a		;divide by 8 if a hires or text mode
     9D3D   A8          18285   10$	tay
     9D3E   C0 28       18286   	cpy #llen
     9D40   B0 0F       18287   	bcs 20$		;error exit if out of bounds
     9D42   AD 1134     18288   	lda ypos+1
     9D45   D0 0A       18289   	bne 20$		;out of bounds error if not = 0
     9D47   AD 1133     18290   	lda ypos
     9D4A   4A          18291   	lsr a
     9D4B   4A          18292   	lsr a		;get row number = ypos/8
     9D4C   4A          18293   	lsr a
     9D4D   AA          18294   	tax
     9D4E   C9 19       18295   	cmp #nlines	;compare to max number of rows
     9D50   60          18296   	rts		;carry clr if okay
     9D51   38          18297   20$	sec
     9D52   60          18298   	rts

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 209
'graphic8'   GRAPHIC8.SRC

Error Addr  Code          Seq   Source statement

                        18300   
                        18301   ;***************************************************************
                        18302   ;
                        18303   ;   scalxy  -  scale the x & y coordinates found in vwork+x
                        18304   ;
                        18305   ;***************************************************************
                        18306   
     9D53   AD 116A     18307   scalxy	lda scalem
     9D56   F0 17       18308   	beq sclrts      ;do nothing if scaling off
                        18309   
     9D58   A5 87       18310   	lda scale_x
     9D5A   A4 88       18311   	ldy scale_x+1
     9D5C   20 9D63     18312   	jsr doscal      ;scale in the x-direction
                        18313   
     9D5F   A5 89       18314   	lda scale_y
     9D61   A4 8A       18315   	ldy scale_y+1	;scale in the y direction
                        18316   
     9D63   20 9DB7     18317   doscal	jsr twobyt	;multiply * coordinate
     9D66   9D 1131     18318   	sta vwork,x
     9D69   98          18319   	tya
     9D6A   E8          18320   	inx		;store back into original position
     9D6B   9D 1131     18321   	sta vwork,x
     9D6E   E8          18322   	inx
     9D6F               18323   sclrts
     9D6F   60          18324   	rts
                        18325   
                        18326   ;.end
                        18327   	.include graphic9

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 210
'graphics9'   GRAPHIC9.SRC

Error Addr  Code          Seq   Source statement

                        18329   	.subttl  'graphics9'
                        18330   ;***************************************************************
                        18331   ;
                        18332   ;   dotwo  -  add two 2-byte values if carry clear
                        18333   ;	      subtract two 2-byte values if carry set	
                        18334   ;
                        18335   ;***************************************************************
                        18336   
     9D70               18337   dotwo2
     9D70   90 07       18338   	bcc addtw2      ;go do addition
     9D72   B0 14       18339   	bcs subtw2      ;go do subtraction
     9D74               18340   dotwo
     9D74   B0 0F       18341   	bcs subtwo      ;go do subtraction
                        18342   
                        18343   ;***************************************************************
                        18344   ;
                        18345   ;  addtwo  -  add vwork+y and vwork+x  -  result in y/a
                        18346   ;
                        18347   ;***************************************************************
                        18348   
     9D76               18349   addtwo
     9D76   20 9D98     18350   	jsr settwo      ;put vwrok+y into y/a
                        18351   
     9D79               18352   addtw2			;enter here to add y/a to vwork+x
     9D79   18          18353   	clc
     9D7A   7D 1131     18354   	adc vwork,x
     9D7D   48          18355   	pha
     9D7E   98          18356   	tya
     9D7F   7D 1132     18357   	adc vwork+1,x
     9D82   A8          18358   	tay
     9D83   68          18359   	pla
     9D84   60          18360   	rts
                        18361   
                        18362   ;****************************************************************
                        18363   ;
                        18364   ;  subtwo  -  subtract vwork+y - vwork+x  - result in y/a
                        18365   ;
                        18366   ;****************************************************************
                        18367   
     9D85               18368   subtwo
     9D85   20 9D98     18369   	jsr settwo      ;move vwork+y into y/a
                        18370   
     9D88               18371   subtw2			;enter here with 1st value in y/a
     9D88   38          18372   	sec
     9D89   FD 1131     18373   	sbc vwork,x
     9D8C   85 59       18374   	sta tempf1
     9D8E   98          18375   	tya
     9D8F   FD 1132     18376   	sbc vwork+1,x
     9D92   A8          18377   	tay
     9D93   08          18378   	php
     9D94   A5 59       18379   	lda tempf1
     9D96   28          18380   	plp
     9D97   60          18381   	rts
                        18382   
                        18383   ;************************************************************

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 210-1
'graphics9'   GRAPHIC9.SRC

Error Addr  Code          Seq   Source statement

                        18384   ;
                        18385   ;  settwo  -  move value in vwork+y into y/a
                        18386   ;
                        18387   ;************************************************************
                        18388   
     9D98               18389   settwo
     9D98   B9 1131     18390   	lda vwork,y
     9D9B   48          18391   	pha
     9D9C   B9 1132     18392   	lda vwork+1,y
     9D9F   A8          18393   	tay
     9DA0   68          18394   	pla
     9DA1   60          18395   	rts
                        18396   
                        18397   ;******************************************************************
                        18398   ;
                        18399   ;  abstwo  -  get absolute value of vwork+y - vwork+x
                        18400   ;	      result in y/a  -  carry === vwork+y >= vwork+x
                        18401   ;
                        18402   ;******************************************************************
                        18403   
     9DA2               18404   abstwo
     9DA2   20 9D85     18405   	jsr subtwo      ;subtract vwork+y - vwork+x
     9DA5               18406   abstw2			;entrance with vwork+y in y/a
     9DA5   10 0F       18407   	bpl absrts      ;done if result is positive
     9DA7   08          18408   invert	php
     9DA8   18          18409   	clc
     9DA9   49 FF       18410   	eor #$ff	;invert low byte result and add 1
     9DAB   69 01       18411   	adc #1
     9DAD   48          18412   	pha
     9DAE   98          18413   	tya
     9DAF   49 FF       18414   	eor #$ff	;invert high byte result
     9DB1   69 00       18415   	adc #0		;add back any carry
     9DB3   A8          18416   	tay
     9DB4   68          18417   	pla
     9DB5   28          18418   	plp
     9DB6   60          18419   absrts	rts
                        18420   
                        18421   
                        18422   
                        18423   ;****************************************************************
                        18424   ;
                        18425   ;  twobyt  -  multiply 2 byte fraction in y/a times 2 bytes
                        18426   ;	      integer found in vwork+x-reg.  result = y/a
                        18427   ;
                        18428   ;****************************************************************
                        18429   
     9DB7               18430   twobyt
     9DB7   84 8E       18431   	sty vtemp1      ;save fraction
     9DB9   85 8F       18432   	sta vtemp2
     9DBB   BD 1131     18433   	lda vwork,x
     9DBE   BC 1132     18434   	ldy vwork+1,x
     9DC1   08          18435   	php		;save sign of integer
     9DC2   20 9DA5     18436   	jsr abstw2      ;absolute value
     9DC5   9D 1131     18437   	sta vwork,x
     9DC8   98          18438   	tya

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 210-2
'graphics9'   GRAPHIC9.SRC

Error Addr  Code          Seq   Source statement

     9DC9   9D 1132     18439   	sta vwork+1,x
     9DCC   A9 00       18440   	lda #0
     9DCE   8D 1177     18441   	sta vtemp3      ;initialize result to zero
     9DD1   A0 10       18442   	ldy #16		;initialize count
     9DD3               18443   twoby1
     9DD3   46 8E       18444   	lsr vtemp1
     9DD5   66 8F       18445   	ror vtemp2
     9DD7   90 0F       18446   	bcc twoby2      ;skip if no bit set
     9DD9   18          18447   	clc
     9DDA   7D 1131     18448   	adc vwork,x     ;add integer low byte
     9DDD   48          18449   	pha
     9DDE   AD 1177     18450   	lda vtemp3
     9DE1   7D 1132     18451   	adc vwork+1,x   ;add integer high byte to total
     9DE4   8D 1177     18452   	sta vtemp3
     9DE7   68          18453   	pla
     9DE8               18454   twoby2
     9DE8   4E 1177     18455   	lsr vtemp3      ;divide by 2
     9DEB   6A          18456   	ror a
     9DEC   88          18457   	dey
     9DED   D0 E4       18458   	bne twoby1	;loop 16 times - test all bits in 2 bytes
     9DEF   69 00       18459   	adc #0		;add back round factor
     9DF1   AC 1177     18460   	ldy vtemp3
     9DF4   90 01       18461   	bcc tworts
     9DF6   C8          18462   	iny
     9DF7   28          18463   tworts	plp		;pop sign
     9DF8   4C 9DA5     18464   	jmp abstw2      ;return with signed product in y/a
                        18465   
                        18466   
                        18467   
                        18468   ;******************************************************************
                        18469   ;  dstpos  -  move xdest/ydest to xpos/ypos
                        18470   ;
                        18471   ;******************************************************************
                        18472   
     9DFB               18473   dstpos
     9DFB   A0 00       18474   	ldy #0
     9DFD   20 9E02     18475   	jsr dstmov
     9E00   A0 02       18476   	ldy #2
     9E02               18477   dstmov
     9E02   B9 1135     18478   	lda xdest,y
     9E05   99 1131     18479   	sta xpos,y
     9E08   B9 1136     18480   	lda xdest+1,y
     9E0B   99 1132     18481   	sta xpos+1,y
     9E0E   60          18482   	rts
                        18483   
                        18484   
                        18485   
                        18486   ;*****************************************************************
                        18487   ;
                        18488   ;  optwrd - get an optional 2 byte value in y,a.
                        18489   ;      case 1 : pointer at end of line:
                        18490   ;		 return a=y=0, clear c to flag 'default'
                        18491   ;      case 2 : pointer is at comma, next non-blank is also a comma:
                        18492   ;		 return a=y=0, clear c to flag 'default'
                        18493   ;      case 3 : pointer is at comma, next non-blank is not a comma:

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 210-3
'graphics9'   GRAPHIC9.SRC

Error Addr  Code          Seq   Source statement

                        18494   ;		 get word in y,a, set c to flag 'non-default'
                        18495   ;
                        18496   ;*****************************************************************
                        18497   
     9E0F               18498   optwrd
     9E0F   20 0386     18499   	jsr chrgot
     9E12   F0 0C       18500   	beq 10$
     9E14   20 79F9     18501   	jsr chkcom
     9E17   C9 2C       18502   	cmp #','
     9E19   F0 05       18503   	beq 10$
     9E1B   20 8812     18504   	jsr getwrd
     9E1E   38          18505   	sec
     9E1F   60          18506   	rts
                        18507   
     9E20   A9 00       18508   10$	lda #0
     9E22   A8          18509   	tay
                        18510   
     9E23   18          18511   optw99	clc
     9E24   60          18512   	rts
                        18513   
                        18514   
                        18515   
                        18516   ;*****************************************************************
                        18517   ;
                        18518   ;  optbyt - get an optional 1 byte value in x.
                        18519   ;  enter with default value in x.
                        18520   ;      case 1 : pointer at end of line:
                        18521   ;		 return default x.
                        18522   ;      case 2 : pointer is at comma, next non-blank is also a comma:
                        18523   ;		 return default x.
                        18524   ;      case 3 : pointer is at comma, next non-blank is not a comma:
                        18525   ;		 get byte in x.
                        18526   ;
                        18527   ;*****************************************************************
                        18528   
     9E25               18529   optzer			;optional byte, with default=0
     9E25   A2 00       18530   	ldx #0
                        18531   
     9E27               18532   optbyt
     9E27   20 0386     18533   	jsr chrgot
     9E2A   F0 F7       18534   	beq optw99
     9E2C   20 79F9     18535   	jsr chkcom
     9E2F   C9 2C       18536   	cmp #','
     9E31   F0 F0       18537   	beq optw99
     9E33   20 87F4     18538   	jsr getbyt
     9E36   38          18539   	sec
     9E37   60          18540   	rts
                        18541   
                        18542   ;.end
                        18543   	.include graphic10

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 211
'graphics10'   GRAPHIC10.SRC

Error Addr  Code          Seq   Source statement

                        18545   	.subttl 'graphics10'
     9E38               18546   grpcol
     9E38   20 A07D     18547   	jsr isgrap      ;make sure graphics area allocated
                        18548   
                        18549   
                        18550   
                        18551   ;************************************************************
                        18552   ;
                        18553   ;   incolr  --  get color selection parameter into colsel
                        18554   ;
                        18555   ;************************************************************
                        18556   
     9E3B               18557   incolr
     9E3B   A2 01       18558   	ldx #1			;get an optional 1 byte val, def=fg(1)
     9E3D   20 0386     18559   	jsr chrgot
     9E40               18560   incol1
     9E40   F0 13       18561   	beq incol2      	;eol, use default
     9E42   C9 2C       18562   	cmp #','
     9E44   F0 0F       18563   	beq incol2      	;just ',', use default
     9E46   20 87F4     18564   	jsr getbyt
     9E49   E0 04       18565   	cpx #4			;must be 0-3
     9E4B   B0 0B       18566   	bcs illval      	;..else illegal value
     9E4D   E0 02       18567   	cpx #2
     9E4F   24 D8       18568   	bit _graphm      	;if hires, must be 0 or 1
     9E51   30 02       18569   	bmi incol2
     9E53   B0 03       18570   	bcs illval
     9E55               18571   incol2
     9E55   86 83       18572   	stx colsel
     9E57   60          18573   	rts
                        18574   
     9E58               18575   illval
     9E58   4C 7DC5     18576   	jmp fcerr		;illegal value
                        18577   
                        18578   
                        18579   
                        18580   ;******************************************************************
                        18581   ;
                        18582   ;  incord  ---  get x/y coordinates from input stream into vwork+x
                        18583   ;
                        18584   ;  coordinate may have form :
                        18585   ;      x,y = absolute xpos & absolute ypos
                        18586   ;      +/-x,y = relative xpos & absolute ypos
                        18587   ;      x,+/-y = absolute xpos & relative ypos
                        18588   ;    +/-x,+/-y = relative xpos & relative ypos
                        18589   ;	   x;y = x-distance at an angle y
                        18590   ;  relative distances and angle distances are relative to
                        18591   ;    current xpos and/or ypos
                        18592   ;  values are scaled to current mode parameters if required
                        18593   ;
                        18594   ;***************************************************************
                        18595   
                        18596   
     9E5B               18597   incor2				;enter here for optional argument
     9E5B   20 0386     18598   	jsr chrgot		;end of line?
     9E5E   F0 07       18599   	beq incr2a		;yes, use defaults

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 211-1
'graphics10'   GRAPHIC10.SRC

Error Addr  Code          Seq   Source statement

     9E60   20 79F9     18600   	jsr chkcom
     9E63   C9 2C       18601   	cmp #','		;is there really an arg?
     9E65   D0 12       18602   	bne incord		;yes, let'er rip
                        18603   
     9E67               18604   incr2a				;set default pos = current pos
     9E67   A0 00       18605   	ldy #0
     9E69               18606   incr2c
     9E69   B9 1131     18607   	lda xpos,y
     9E6C   9D 1131     18608   	sta vwork,x
     9E6F   E8          18609   	inx
     9E70   C8          18610   	iny
     9E71   C0 04       18611   	cpy #4
     9E73   D0 F4       18612   	bne incr2c
     9E75   60          18613   	rts
                        18614   
                        18615   
     9E76               18616   incor3				;enter here for non-optional arg preceded by a comma
     9E76   20 79F9     18617   	jsr chkcom
                        18618   
                        18619   
     9E79               18620   incord
     9E79   8E 1178     18621   	stx vtemp4		;save offset to destination
     9E7C   20 9F11     18622   	jsr cordsb		;get 2-byte x-parameter
     9E7F   20 0386     18623   	jsr chrgot
     9E82   C9 2C       18624   	cmp #','
     9E84   F0 56       18625   	beq docord		;skip ahead if have comma
     9E86   C9 3B       18626   	cmp #';'		;check for semi-colon
     9E88   F0 03       18627   	beq docrd1		;skip if have angle
     9E8A   4C 7A09     18628   	jmp snerr		;show syntax message
                        18629   
                        18630   
     9E8D               18631   docrd1
     9E8D   20 0380     18632   	jsr chrget      	;skip over '	;'
     9E90   20 8812     18633   	jsr getwrd      	;get 2-byte angle in a,y
     9E93   85 77       18634   	sta z_p_temp_1		;swap a,y
     9E95   98          18635   	tya
     9E96   A4 77       18636   	ldy z_p_temp_1
     9E98   20 9A77     18637   	jsr gtang1      	;get sine & cosine values for the angle
     9E9B   AE 1178     18638   	ldx vtemp4
     9E9E   BD 1131     18639   	lda vwork,x
     9EA1   9D 1133     18640   	sta vwork+2,x   	;move length to y-parameter
     9EA4   BD 1132     18641   	lda vwork+1,x
     9EA7   9D 1134     18642   	sta vwork+3,x
     9EAA   20 9D53     18643   	jsr scalxy      	;scale the values
     9EAD   A9 0E       18644   	lda #$0e
     9EAF   8D 1179     18645   	sta vtemp5
     9EB2   18          18646   	clc
     9EB3   AE 1178     18647   	ldx vtemp4
     9EB6               18648   doang1
     9EB6   20 9ACE     18649   	jsr angmlt      	;multiply length * angle
     9EB9   9D 1131     18650   	sta vwork,x     	;save angle result
     9EBC   98          18651   	tya
     9EBD   9D 1132     18652   	sta vwork+1,x
     9EC0   A0 00       18653   	ldy #xpos-vwork
     9EC2   4E 1179     18654   	lsr vtemp5

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 211-2
'graphics10'   GRAPHIC10.SRC

Error Addr  Code          Seq   Source statement

     9EC5   90 02       18655   	bcc doang2
     9EC7   A0 02       18656   	ldy #ypos-vwork
     9EC9               18657   doang2
     9EC9   20 9D74     18658   	jsr dotwo		;add/subtract value to current position
     9ECC   9D 1131     18659   	sta vwork,x
     9ECF   98          18660   	tya			;save result in destination
     9ED0   9D 1132     18661   	sta vwork+1,x
     9ED3   E8          18662   	inx
     9ED4   E8          18663   	inx
     9ED5   4E 1179     18664   	lsr vtemp5
     9ED8   D0 DC       18665   	bne doang1      	;do y-coordinate
     9EDA   18          18666   	clc
     9EDB   60          18667   	rts
                        18668   
                        18669   
     9EDC               18670   docord
     9EDC   20 0380     18671   	jsr chrget      	;skip over comma
     9EDF   EE 1178     18672   	inc vtemp4      	;point to y-destination
     9EE2   EE 1178     18673   	inc vtemp4
     9EE5   20 9F11     18674   	jsr cordsb      	;get y-paramter
     9EE8   AE 1178     18675   	ldx vtemp4
     9EEB   CA          18676   	dex
     9EEC   CA          18677   	dex
     9EED   20 9D53     18678   	jsr scalxy      	;scale the values
     9EF0   A0 02       18679   	ldy #ypos-vwork
     9EF2   AE 1178     18680   	ldx vtemp4
     9EF5   E8          18681   	inx
     9EF6   E8          18682   	inx
     9EF7               18683   docor1
     9EF7   CA          18684   	dex
     9EF8   CA          18685   	dex
     9EF9   4E 1179     18686   	lsr vtemp5
     9EFC   90 0A       18687   	bcc docor2      	;skip if not relative
     9EFE   20 9D76     18688   	jsr addtwo      	;add to current position
     9F01   9D 1131     18689   	sta vwork,x
     9F04   98          18690   	tya
     9F05   9D 1132     18691   	sta vwork+1,x
     9F08               18692   docor2
     9F08   A0 00       18693   	ldy #xpos-vwork
     9F0A   EC 1178     18694   	cpx vtemp4
     9F0D   F0 E8       18695   	beq docor1      	;loop to do x-coordinate
     9F0F   18          18696   	clc
     9F10   60          18697   	rts
                        18698   
                        18699   
                        18700   ;
                        18701   ; cordsb -- get the next 2-byte parameter
                        18702   ;
     9F11               18703   cordsb
     9F11   20 0386     18704   	jsr chrgot      	;read character
     9F14   C9 AA       18705   	cmp #plustk     	;check if relative - plus sign
     9F16   F0 05       18706   	beq crdsb1      	;skip if yes
     9F18   C9 AB       18707   	cmp #minutk
     9F1A   F0 01       18708   	beq crdsb1      	;skip if relative - minus sign
     9F1C   18          18709   	clc			;.c=1 if relative coord, .c=0 if absolute

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 211-3
'graphics10'   GRAPHIC10.SRC

Error Addr  Code          Seq   Source statement

     9F1D               18710   crdsb1
     9F1D   2E 1179     18711   	rol vtemp5		;save coord type for later
     9F20   20 6E5D     18712   	jsr cordsb_patch	; (318018-03 mod; fab: get SIGNED value in (y,a))
     9F23   AE 1178     18713   	ldx vtemp4
     9F26   9D 1132     18714   	sta vwork+1,x   	;save 2-byte parameter
     9F29   98          18715   	tya
     9F2A   9D 1131     18716   	sta vwork,x
     9F2D   60          18717   	rts
                        18718   
                        18719   ;.end
                        18720   	.include graphic11

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 212
'graphics11'   GRAPHIC11.SRC

Error Addr  Code          Seq   Source statement

                        18722   	.subttl 'graphics11'
                        18723   
                        18724   ;   multicolor color values
                        18725   
     9F2E               18726   colval
     9F2E   FF AA 55    18727   	.byte $ff,$aa,$55,$00
     9F31   00                  
                        18728   
                        18729   ;  angval  --  table of angle values on 10 degree boundaries
                        18730   ;		values based as fraction of 65536
                        18731   
     9F32               18732   angval
     9F32   00 00       18733   	.byte $00,$00   	;sine 00 degrees -  .0000
     9F34   2C 71       18734   	.byte $2c,$71   	;sine 10 degrees -  .1736
     9F36   57 8D       18735   	.byte $57,$8d   	;sine 20 degrees -  .3420
     9F38   80 00       18736   	.byte $80,$00   	;sine 30 degrees -  .5000
     9F3A   A4 8F       18737   	.byte $a4,$8f   	;sine 40 degrees -  .6428
     9F3C   C4 19       18738   	.byte $c4,$19   	;sine 50 degrees -  .7660
     9F3E   DD B2       18739   	.byte $dd,$b2   	;sine 60 degrees -  .8660
     9F40   F0 90       18740   	.byte $f0,$90   	;sine 70 degrees -  .9397
     9F42   FC 1C       18741   	.byte $fc,$1c   	;sine 80 degrees -  .9848
     9F44   FF FF       18742   	.byte $ff,$ff   	;sine 90 degrees - 1.0000
                        18743   
                        18744   ;  incval  --  table of incremental values between 10 degrees
                        18745   ;		values based on fraction of 65536
                        18746   
     9F46               18747   incval
     9F46   04 72       18748   	.byte $04,$72   	; 01 - 09 degrees -  .01739
     9F48   04 50       18749   	.byte $04,$50   	; 11 - 19 degrees -  .01692
     9F4A   04 0B       18750   	.byte $04,$0b   	; 21 - 29 degrees -  .01592
     9F4C   03 A8       18751   	.byte $03,$a8   	; 31 - 39 degrees -  .01443
     9F4E   03 28       18752   	.byte $03,$28   	; 41 - 49 degrees -  .01252
     9F50   02 90       18753   	.byte $02,$90   	; 51 - 59 degrees -  .01023
     9F52   01 E3       18754   	.byte $01,$e3   	; 61 - 69 degrees -  .00762
     9F54   01 28       18755   	.byte $01,$28   	; 71 - 79 degrees -  .00477
     9F56   00 63       18756   	.byte $00,$63   	; 81 - 89 degrees -  .00179
                        18757   
                        18758   ;.end
                        18759   	.include sethires

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 213
Set Hires Mode   SETHIRES.SRC

Error Addr  Code          Seq   Source statement

                        18761   	.subttl Set Hires Mode 
                        18762   
                        18763   
                        18764   ; test if 10k graphics screen already allocated. if so, return
                        18765   ; immediately.
                        18766   
     9F58   A5 76       18767   sethir	lda mvdflg      ;done already if <>0
     9F5A   F0 01       18768   	beq 1$
     9F5C   60          18769   	rts
                        18770   
     9F5D   AD 1211     18771   1$	lda text_top+1	;first see if it will all fit
     9F60   18          18772   	clc
     9F61   69 24       18773   	adc #$24	;we're moving from $1c00 on up, to $4000 on up.
     9F63   B0 0E       18774   	bcs 2$		;wrapped!
     9F65   85 62       18775   	sta grbtop+1	;..save a copy while we're at it, for the transfer operation
     9F67   CD 1213     18776   	cmp max_mem_0+1	;this is the top of usable bank 0
     9F6A   90 0A       18777   	bcc 3$		;less than the top, ok.
     9F6C   D0 05       18778   	bne 2$		;greater than the top, won't fit.
     9F6E   CC 1212     18779   	cpy max_mem_0	;equal to the top, check ls byte
     9F71   90 03       18780   	bcc 3$		;ok
     9F73   4C 4D57     18781   2$	jmp omerr	;no fit, out of memory error
                        18782   
     9F76   C6 76       18783   3$	dec mvdflg      ;it will fit. flag 'moved'
     9F78   AD 1210     18784   	lda text_top	;now set up to move text
     9F7B   85 24       18785   	sta index1      ; first the destination,
     9F7D   A5 62       18786   	lda grbtop+1
     9F7F   85 25       18787   	sta index1+1
     9F81   AE 1210     18788   	ldx text_top	;...then the source. x,y will also be used to pass length
     9F84   86 26       18789   	stx index2
     9F86   AD 1211     18790   	lda text_top+1
     9F89   85 27       18791   	sta index2+1
     9F8B   38          18792   	sec
     9F8C   E9 1C       18793   	sbc #$1c	;calculate the length (top - $1c00)
     9F8E   A8          18794   	tay
     9F8F   8A          18795   	txa	      	;make counter 1's complement
     9F90   49 FF       18796   	eor #$ff
     9F92   85 50       18797   	sta grbpnt
     9F94   98          18798   	tya
     9F95   49 FF       18799   	eor #$ff
     9F97   85 51       18800   	sta grbpnt+1
     9F99   A0 00       18801   	ldy #0
                        18802   
                        18803   			;main loop
     9F9B   E6 50       18804   10$	inc grbpnt      ;decrement 2 byte counter
     9F9D   D0 04       18805   	bne 20$
     9F9F   E6 51       18806   	inc grbpnt+1
     9FA1   F0 18       18807   	beq 50$		;done
                        18808   
     9FA3   A5 24       18809   20$	lda index1      ;decrement dest. pointer
     9FA5   D0 02       18810   	bne 30$
     9FA7   C6 25       18811   	dec index1+1
     9FA9   C6 24       18812   30$	dec index1
                        18813   
     9FAB   A5 26       18814   	lda index2      ;decrement source pointer
     9FAD   D0 02       18815   	bne 40$

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 213-1
Set Hires Mode   SETHIRES.SRC

Error Addr  Code          Seq   Source statement

     9FAF   C6 27       18816   	dec index2+1
     9FB1   C6 26       18817   40$	dec index2
                        18818   
     9FB3   20 03C0     18819   	jsr indin2      ;load from source,
     9FB6   91 24       18820   	sta (index1),y	;...and put into dest.
     9FB8   4C 9F9B     18821   	jmp 10$
                        18822   
     9FBB   18          18823   50$	clc
     9FBC   AD 1211     18824   	lda text_top+1
     9FBF   69 24       18825   	adc #$24
     9FC1   8D 1211     18826   	sta text_top+1
                        18827   
     9FC4   A5 2E       18828   	lda txttab+1	;(assume .c=0)
     9FC6   69 24       18829   	adc #$24
     9FC8   85 2E       18830   	sta txttab+1
                        18831   
     9FCA   A5 44       18832   	lda datptr+1
     9FCC   69 24       18833   	adc #$24
     9FCE   85 44       18834   	sta datptr+1
                        18835   
                        18836   
     9FD0   20 4F6C     18837   seth30	jsr lnkprg
     9FD3   20 4F9F     18838   	jsr fixlnk      ;re-link basic text & fix vartab
                        18839   ;
                        18840   ; fix run-time stack if not in direct mode
                        18841   ;
     9FD6   24 7F       18842   	bit runmod      ;done if direct mode
     9FD8   10 2D       18843   	bpl seth45      ;done
                        18844   
     9FDA   A2 24       18845   	ldx #$24	;adjust text pointers
     9FDC   24 76       18846   	bit mvdflg      ;alloc. or dealloc?
     9FDE   30 02       18847   	bmi 1$		;branch if alloc (add $2400)
     9FE0   A2 DC       18848   	ldx #$dc	;else sub. $2400
                        18849   
     9FE2   8A          18850   1$	txa
     9FE3   18          18851   	clc
     9FE4   65 3E       18852   	adc txtptr+1
     9FE6   85 3E       18853   	sta txtptr+1
     9FE8   8A          18854   	txa
     9FE9   18          18855   	clc
     9FEA   6D 1203     18856   	adc oldtxt+1
     9FED   8D 1203     18857   	sta oldtxt+1
     9FF0   8A          18858   	txa
     9FF1   18          18859   	clc
     9FF2   6D 120F     18860   	adc errtxt+1
     9FF5   8D 120F     18861   	sta errtxt+1
                        18862   
     9FF8   20 5064     18863   	jsr movtos      ;copy top-of-stack pointer to fndpnt
     9FFB               18864   seth40
     9FFB   A5 3F       18865   	lda fndpnt      ;test if fndpnt points to stack bottom
     9FFD   C9 FF       18866   	cmp #<stkbot
     9FFF   D0 07       18867   	bne seth50      ;no
     A001   A5 40       18868   	lda fndpnt+1
     A003   C9 09       18869   	cmp #>stkbot
     A005   D0 01       18870   	bne seth50      ;no

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 213-2
Set Hires Mode   SETHIRES.SRC

Error Addr  Code          Seq   Source statement

     A007               18871   seth45
     A007   60          18872   	rts		;all moved!
                        18873   
     A008   A0 00       18874   seth50	ldy #0		;adjust any pointers in this stack entry
     A00A   B1 3F       18875   	lda (fndpnt),y	;what kind of entry is this?
     A00C   C9 81       18876   	cmp #fortk
     A00E   D0 09       18877   	bne seth60
                        18878   
     A010   A0 10       18879   	ldy #16
     A012   20 A06B     18880   	jsr addoff      ;A "FOR" entry needs the pointer to the 'for' line in text fixed.
     A015   A9 12       18881   	lda #18		;set up to adjust temp. stack pointer
     A017   D0 07       18882   	bne seth70      ;always
                        18883   
     A019   A0 04       18884   seth60	ldy #4		;'do' & 'gosub' only need 1 adjustment,
     A01B   20 A06B     18885   	jsr addoff      ;..to the text pointer.
     A01E   A9 05       18886   	lda #5
                        18887   
     A020   18          18888   seth70	clc
     A021   65 3F       18889   	adc fndpnt
     A023   85 3F       18890   	sta fndpnt
     A025   90 D4       18891   	bcc seth40
     A027   E6 40       18892   	inc fndpnt+1
     A029   D0 D0       18893   	bne seth40      ;always
                        18894   
                        18895   ;.end
                        18896   	.include clrhires

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 214
Clear Hires Mode Routines   CLRHIRES.SRC

Error Addr  Code          Seq   Source statement

                        18898   	.subttl Clear Hires Mode Routines
                        18899   
                        18900   ; clear (de-allocate) 10k graphics area, if installed
                        18901   
     A02B   A5 76       18902   clrhir	lda mvdflg      ;see if already cleared
     A02D   D0 01       18903   	bne 1$		;branch if not,
     A02F   60          18904   	rts		;else done
                        18905   
     A030   A0 00       18906   1$	ldy #0
     A032   84 76       18907   	sty mvdflg      ;flag 'moved'
     A034   84 24       18908   	sty index1      ;set up pointers for memory transfer
     A036   84 26       18909   	sty index2
     A038   A9 1C       18910   	lda #$1c
     A03A   85 25       18911   	sta index1+1    ;destination
     A03C   A9 40       18912   	lda #$40
     A03E   85 27       18913   	sta index2+1    ;origin
                        18914   
     A040   20 03C0     18915   2$	jsr indin2      ;lda (index2),y
     A043   91 24       18916   	sta (index1),y
     A045   C8          18917   	iny
     A046   D0 F8       18918   	bne 2$		;do 1 full page
     A048   E6 25       18919   	inc index1+1
     A04A   E6 27       18920   	inc index2+1
     A04C   AD 1211     18921   	lda text_top+1	;test if page containing last bytes was moved
     A04F   C5 27       18922   	cmp index2+1
     A051   B0 ED       18923   	bcs 2$		;keep going until msb of index2 > msb of strend
                        18924   
     A053   38          18925   	sec
     A054   A5 2E       18926   	lda txttab+1
     A056   E9 24       18927   	sbc #$24
     A058   85 2E       18928   	sta txttab+1
                        18929   
     A05A   AD 1211     18930   	lda text_top+1
     A05D   E9 24       18931   	sbc #$24
     A05F   8D 1211     18932   	sta text_top+1
                        18933   
     A062   A5 44       18934   	lda datptr+1
     A064   E9 24       18935   	sbc #$24
     A066   85 44       18936   	sta datptr+1
                        18937   
     A068   4C 9FD0     18938   	jmp seth30
                        18939   
                        18940   
                        18941   
     A06B   B1 3F       18942   addoff	lda (fndpnt),y
     A06D   24 76       18943   	bit mvdflg
     A06F   D0 06       18944   	bne 10$			;if z then subtract.else add $30
     A071   38          18945   	sec
     A072   E9 24       18946   	sbc #$24
     A074   91 3F       18947   	sta (fndpnt),y
     A076   60          18948   	rts
                        18949   
     A077   18          18950   10$	clc
     A078   69 24       18951   	adc #$24
     A07A   91 3F       18952   	sta (fndpnt),y

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 214-1
Clear Hires Mode Routines   CLRHIRES.SRC

Error Addr  Code          Seq   Source statement

     A07C   60          18953   	rts
                        18954   
                        18955   
                        18956   
     A07D   A5 76       18957   isgrap	lda mvdflg		;test if graphics mode allocated, error if not
     A07F   F0 01       18958   	beq isgrer      	;oh-oh, bad news
     A081   60          18959   isgrts	rts			;ok!
                        18960   
     A082   AD 03E5     18961   isgrer	lda plot_point+1	;test if graphic80 mode
     A085   C9 9C       18962   	cmp #>plot_vic
     A087   D0 F8       18963   	bne isgrts		;...yes!
     A089   A2 23       18964   	ldx #errng      	;'no graphics area' error
     A08B   4C 4D59     18965   	jmp error
                        18966   
                        18967   
                        18968   ;.end
                        18969   	.include dos1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 215
DOS 1   DOS1.SRC

Error Addr  Code          Seq   Source statement

                        18971   	.subttl DOS 1
                        18972   
            =0000       18973   	doslfn = 0
                        18974   
                        18975   ;    this set of routines takes tokens and values after the
                        18976   ;    following basic keywords
                        18977   ;
                        18978   ;    dopen, dclose, record, format, collect, backup, copy, bload
                        18979   ;    concat, dsave, dload, catlog, rename, append, scrtch, bsave
                        18980   ;
                        18981   ;    it then parses the following line and finds syntax errors, checks for
                        18982   ;	out of range values, and sets variables in the zero-page to be passed
                        18983   ;	to the disk message generator (dmg).
                        18984   
     A08E               18985   catalog		;catalog a device (==directory)
     A08E   20 A3CF     18986   	jsr dospar 		;parse the line
     A091   A5 80       18987   	lda parsts 		;check options
     A093   29 E6       18988   	and #$e6
     A095   F0 03       18989   	beq 10$
     A097   4C 7A09     18990   	jmp snerr
     A09A   A0 01       18991   10$	ldy #fcat 		;table offset
     A09C   A2 01       18992   	ldx #1			;just $
     A09E   A5 80       18993   	lda parsts 		;chk for default
     A0A0   29 11       18994   	and #$11 		;no drive?
     A0A2   F0 06       18995   	beq dcat2
     A0A4   4A          18996   	lsr a
     A0A5   90 02       18997   	bcc dcat1 		;just drive
     A0A7   E8          18998   	inx			;drive and filename
     A0A8   E8          18999   	inx
     A0A9   E8          19000   dcat1	inx
     A0AA   8A          19001   dcat2	txa			;a now has length
     A0AB   20 A677     19002   	jsr sendp 		;build
                        19003   
     A0AE   A9 00       19004   	lda #0
     A0B0   AA          19005   	tax
     A0B1   20 9287     19006   	jsr k_setbank
                        19007   
     A0B4   A0 60       19008   	ldy #$60 		;sa, load floppy
     A0B6   AE 011C     19009   	ldx dosfa
     A0B9   A9 00       19010   	lda #doslfn 		;lfn
     A0BB   20 9257     19011   	jsr k_setlfs 		;set file parameters
     A0BE   38          19012   	sec
     A0BF   20 90D8     19013   	jsr k_open 		;open it...
     A0C2   90 09       19014   	bcc 10$			;ok
     A0C4   48          19015   	pha
     A0C5   20 A124     19016   	jsr dcat10
     A0C8   68          19017   	pla
     A0C9   AA          19018   	tax
     A0CA   4C 4D59     19019   	jmp error
                        19020   
                        19021   ;    get length in blocks
                        19022   
     A0CD   A2 00       19023   10$	ldx #doslfn
     A0CF   20 A855     19024   	jsr put_io_in_map
     A0D2   20 FFC6     19025   	jsr _chkin

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 215-1
DOS 1   DOS1.SRC

Error Addr  Code          Seq   Source statement

                        19026   
     A0D5   A0 03       19027   	ldy #3 			;loop counter
     A0D7   8C 1174     19028   dcat3	sty t3			;save counter
                        19029   
     A0DA   20 9263     19030   10$	jsr k_basin 		;get char
     A0DD   8D 1175     19031   	sta t4
     A0E0   20 9251     19032   	jsr k_readst
     A0E3   D0 3F       19033   	bne dcat10 		;if bad status
     A0E5   20 9263     19034   	jsr k_basin 		;get char
     A0E8   8D 1176     19035   	sta t4+1
     A0EB   20 9251     19036   	jsr k_readst
     A0EE   D0 34       19037   	bne dcat10 		;if bad status
     A0F0   CE 1174     19038   	dec t3
     A0F3   D0 E5       19039   	bne 10$			;if not done
                        19040   
                        19041   ;    output blocks number
                        19042   
     A0F5   AE 1175     19043   	ldx t4
     A0F8   AD 1176     19044   	lda t4+1
     A0FB   20 8E32     19045   	jsr linprt 		;output number
     A0FE   A9 20       19046   	lda #' '
     A100   20 9269     19047   	jsr k_bsout		;output a space
                        19048   
                        19049   ;    loop reading name and output
                        19050   
     A103   20 9263     19051   dcat4	jsr k_basin 		;get char
     A106   48          19052   	pha 			;save char
     A107   20 9251     19053   	jsr k_readst 		;get status
     A10A   D0 17       19054   	bne dcat9 		;if bad status
     A10C   68          19055   	pla 			;get back char
     A10D   F0 06       19056   	beq dcat5 		;if eol
     A10F   20 9269     19057   	jsr k_bsout		;echo char
     A112   4C A103     19058   	jmp dcat4 		;continue to process name
                        19059   
                        19060   ;    here on end of name
                        19061   
     A115   A9 0D       19062   dcat5	lda #cr
     A117   20 9269     19063   	jsr k_bsout		;output new line
                        19064   
                        19065   ;    check for halt
                        19066   
     A11A   20 9293     19067   	jsr k_stop 		;get status of stop key
     A11D   F0 05       19068   	beq dcat10 		;if stop request
                        19069   
                        19070   ;    process next
                        19071   
     A11F   A0 02       19072   	ldy #2			;perform 2 times
     A121   D0 B4       19073   	bne dcat3 		;jmp
                        19074   
     A123   68          19075   dcat9	pla			;clean up stack
                        19076   
     A124   20 926F     19077   dcat10	jsr k_clrch
     A127   A9 00       19078   	lda #doslfn
     A129   18          19079   	clc			;a real close
     A12A   4C 9275     19080   	jmp k_close 		;close special channel

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 215-2
DOS 1   DOS1.SRC

Error Addr  Code          Seq   Source statement

                        19081   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 216
DOS 1   DOS1.SRC

Error Addr  Code          Seq   Source statement

                        19083   
                        19084   ;    dopen code dfn(,t(,r))
                        19085   
     A12D   A9 22       19086   dopen	lda #$22 		;set error flag
     A12F   20 A3D1     19087   	jsr dosprs 		;parse the line
     A132   20 A77F     19088   	jsr chk6 		;chk req'd parms
     A135   20 A167     19089   	jsr fndsca		;find secondary address
     A138   A0 05       19090   	ldy #fopn 		;fcb format pointer
     A13A   A2 04       19091   	ldx #4			;normal length
     A13C   24 80       19092   	bit parsts 		;relative record
     A13E   50 13       19093   	bvc dop2 		;if not random access
     A140   A2 08       19094   	ldx #8 			;random access length
     A142   D0 0F       19095   	bne dop2 		;alway jump
                        19096   
                        19097   
                        19098   
                        19099   ;    append code
                        19100   
     A144   A9 E2       19101   append	lda #$e2 		;set error flags
     A146   20 A3D1     19102   	jsr dosprs 		;parse the line
     A149   20 A77F     19103   	jsr chk6 		;chk req'd parms
     A14C   20 A167     19104   	jsr fndsca		;find secondary address
     A14F   A0 16       19105   	ldy #fapn 		;tabld index
     A151   A2 05       19106   	ldx #5			;length
                        19107   
     A153   8A          19108   dop2	txa			;set length into a
     A154   20 A677     19109   	jsr sendp
     A157   20 926F     19110   	jsr k_clrch
     A15A   A9 00       19111   	lda #0
     A15C   AA          19112   	tax
     A15D   20 9287     19113   	jsr k_setbank
     A160   20 90D8     19114   	jsr k_open
     A163   EA          19115   	nop			;placeholder
     A164   4C A3C2     19116   	jmp dopen_patch		;318019-03 fix; FAB
                        19117   
                        19118   
                        19119   
                        19120   
                        19121   ; find an available secondary address
                        19122   
     A167   A0 61       19123   fndsca	ldy #$61
                        19124   
     A169   C8          19125   fsca10	iny
     A16A   C0 6F       19126   	cpy #$6f
     A16C   F0 0C       19127   	beq fsca20 		;if none available
     A16E   20 A855     19128   	jsr put_io_in_map
     A171   20 FF5C     19129   	jsr _lkupsa 		;get physical unit from secondary
     A174   90 F3       19130   	bcc fsca10 		;if secondary address used
     A176   8C 011D     19131   	sty dossa 		;save secondary address
     A179   60          19132   	rts	 		;return .y = sa
                        19133   
     A17A   A2 01       19134   fsca20	ldx #errtmf		;too many files open
     A17C   4C 4D59     19135   	jmp error
                        19136   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 217
DOS 1   DOS1.SRC

Error Addr  Code          Seq   Source statement

                        19138   
                        19139   ;    close disk file
                        19140   
     A17F               19141   dclose	
     A17F   A9 F3       19142   	lda #$f3 		;set error flags
     A181   20 A3D1     19143   	jsr dosprs 		;parse the line
     A184   20 A81D     19144   	jsr oldclr
     A187   A5 80       19145   	lda parsts 		;any la given?
     A189   29 04       19146   	and #$04
     A18B   F0 06       19147   	beq dclall 		;no....
     A18D   AD 011B     19148   	lda dosla
     A190   4C 9275     19149   	jmp k_close 		;close file
                        19150   
     A193   AD 011C     19151   dclall	lda dosfa 		;get disk #
     A196   20 A855     19152   	jsr put_io_in_map
     A199   4C FF4A     19153   	jmp _close_all		;close all channels
                        19154   
                        19155   
                        19156   
                        19157   ;    dsave dfn
                        19158   
     A19C   A9 66       19159   dsave	lda #$66 		;set error flags
     A19E   20 A3D1     19160   	jsr dosprs 		;parse the line
     A1A1   20 A760     19161   	jsr chk2		;check required parms
     A1A4   A0 05       19162   	ldy #fopn		;table offset
     A1A6   A9 04       19163   	lda #4			;..length,
     A1A8   20 A677     19164   	jsr sendp
                        19165   
     A1AB   A9 00       19166   	lda #0			;set up banks
     A1AD   AA          19167   	tax
     A1AE   20 9287     19168   	jsr k_setbank
                        19169   
     A1B1   4C 9115     19170   	jmp savenp
                        19171   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 218
DOS 1   DOS1.SRC

Error Addr  Code          Seq   Source statement

                        19173   
                        19174   
                        19175   ; 	dverify 
                        19176   
     A1B4   A9 01       19177   dverify	lda #1			;flag 'verify'
     A1B6   2C          19178   	.byt $2c
                        19179   
                        19180   
                        19181   ;	dload dfn
                        19182   
     A1B7   A9 00       19183   dload	lda #0			;flag 'load'
     A1B9   85 0C       19184   	sta verck		;eventually the 'load' routine will look here
                        19185   
     A1BB   A9 E6       19186   	lda #$e6 		;set error flags
     A1BD   20 A3D1     19187   	jsr dosprs 		;parse the line
     A1C0   20 A760     19188   	jsr chk2		;check required parms
                        19189   
     A1C3   A9 00       19190   	lda #0
     A1C5   8D 011D     19191   	sta dossa		;tell 'em to relocate, s'il vous plait.
                        19192   
     A1C8   A0 05       19193   	ldy #fopn		;table offset
     A1CA   A9 04       19194   	lda #4			;..length,
     A1CC   20 A677     19195   	jsr sendp
                        19196   
     A1CF   A9 00       19197   	lda #0			;set up banks
     A1D1   AA          19198   	tax
     A1D2   20 9287     19199   	jsr k_setbank
                        19200   
     A1D5   4C 9133     19201   	jmp cld10		;finish load, using 'LOAD' code.
                        19202   	
                        19203   
                        19204   
                        19205   ;    bsave dfn
                        19206   
     A1D8   A9 66       19207   bsave	lda #$66 		;std error flag
     A1DA   A2 F8       19208   	ldx #$f8		;auxiliary error flag
     A1DC   20 A3D3     19209   	jsr dosprx		;parse options
     A1DF   20 A760     19210   	jsr chk2		;check required parms
                        19211   
     A1E2   A5 81       19212   	lda parstx		;check for styarting & ending addresses
     A1E4   29 06       19213   	and #6
     A1E6   C9 06       19214   	cmp #6
     A1E8   F0 03       19215   	beq 10$
     A1EA   4C 7A09     19216   	jmp snerr		;..if not present, syntax error
                        19217   
     A1ED   AD 011A     19218   10$	lda dosofh+1		;check that ea>sa
     A1F0   CD 0118     19219   	cmp dosofl+1
     A1F3   90 30       19220   	bcc 30$			;...error
     A1F5   D0 0A       19221   	bne 20$
     A1F7   AD 0119     19222   	lda dosofh
     A1FA   CD 0117     19223   	cmp dosofl
     A1FD   90 26       19224   	bcc 30$			;...error
     A1FF   F0 24       19225   	beq 30$
                        19226   
     A201   A0 05       19227   20$	ldy #fopn		;table offset

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 218-1
DOS 1   DOS1.SRC

Error Addr  Code          Seq   Source statement

     A203   A9 04       19228   	lda #4			;..length,
     A205   20 A677     19229   	jsr sendp
                        19230   
     A208   AD 011F     19231   	lda dosbnk		;get requested bank
     A20B   A2 00       19232   	ldx #0			;..and name will be in system bank
     A20D   20 9287     19233   	jsr k_setbank		;..and go set up bank
                        19234   
     A210   AE 0117     19235   	ldx dosofl 		;start addr
     A213   AC 0118     19236   	ldy dosofl+1
     A216   A9 5A       19237   	lda #highds		;..and a pointer to start address
     A218   86 5A       19238   	stx highds
     A21A   84 5B       19239   	sty highds+1
     A21C   AE 0119     19240   	ldx dosofh 		;end addr
     A21F   AC 011A     19241   	ldy dosofh+1
     A222   4C 911D     19242   	jmp savenb
                        19243   
     A225   4C 7DC5     19244   30$	jmp fcerr		;bad quantity
                        19245   
                        19246   
                        19247   
                        19248   ;    bload dfn
                        19249   
     A228   A9 E6       19250   bload	lda #$e6 		;std error flag
     A22A   A2 FC       19251   	ldx #$fc 		;aux error flag
     A22C   20 A3D3     19252   	jsr dosprx 		;parse options (entry for BOOT filename)
     A22F   20 A760     19253   bload_1	jsr chk2		;check required parms
                        19254   
     A232   AE 0117     19255   	ldx dosofl		;get starting address high
     A235   AC 0118     19256   	ldy dosofl+1		;..and lo
     A238   A9 00       19257   	lda #0			;assume x & y not both=ff (means real add., not def)
     A23A   E0 FF       19258   	cpx #$ff
     A23C   D0 06       19259   	bne 10$
     A23E   C0 FF       19260   	cpy #$ff
     A240   D0 02       19261   	bne 10$
     A242   A9 FF       19262   	lda #$ff		;use defaults
     A244   8D 011D     19263   10$	sta dossa
                        19264   
     A247   A0 05       19265   	ldy #fopn		;table offset
     A249   A9 04       19266   	lda #4			;..length,
     A24B   20 A677     19267   	jsr sendp		;...and go send parms
                        19268   
     A24E   AD 011F     19269   	lda dosbnk
     A251   A2 00       19270   	ldx #0
     A253   20 9287     19271   	jsr k_setbank
                        19272   
     A256   A9 00       19273   	lda #0			;flag "LOAD",
     A258   AE 0117     19274   	ldx dosofl		;get starting address high
     A25B   AC 0118     19275   	ldy dosofl+1		;..and lo (in case this isn't a 'default' load)
     A25E   20 FFD5     19276   	jsr _loadsp		;..and go do it!
                        19277   
     A261   08          19278   	php			;save carry
     A262   20 9243     19279   	jsr dschk		;clear old status
     A265   28          19280   	plp
     A266   90 03       19281   	bcc 15$			;branch if ok,
     A268   4C 90D0     19282   	jmp erexit		;..else error

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 218-2
DOS 1   DOS1.SRC

Error Addr  Code          Seq   Source statement

                        19283   
     A26B   20 9251     19284   15$	jsr k_readst
     A26E   29 BF       19285   	and #$ff-$40		;ignore e-o-i
     A270   F0 03       19286   	beq 20$
     A272   4C 9167     19287   	jmp load_error
                        19288   
     A275   18          19289   20$	clc			;flag 'good return'
     A276   60          19290   	rts
                        19291   
                        19292   
                        19293   
                        19294   
                        19295   ;	header   nddn (,id)
                        19296   
     A277   20 A3CF     19297   header	jsr dospar 		;parse the line
     A27A   20 A759     19298   	jsr chk1 		;check parameter errors
     A27D   29 01       19299   	and #$01
     A27F   C9 01       19300   	cmp #$01
     A281   D0 61       19301   	bne rec5 		;if required parameters not present
                        19302   
     A283   20 927B     19303   	jsr k_clall 		;close all files
     A286   20 A7F1     19304   	jsr are_you_sure
     A289   D0 25       19305   	bne 30$			;if no and direct mode
     A28B   A0 1B       19306   	ldy #fhed 		;tabld index
     A28D   A9 04       19307   	lda #4			;length
     A28F   AE 0120     19308   	ldx dosdid 		;check for diskid
     A292   F0 02       19309   	beq 10$
     A294   A9 06       19310   	lda #6			;length with id
                        19311   
     A296   20 A3A7     19312   10$	jsr trans 		;build and send
     A299   20 A788     19313   	jsr errchl 		;get error status
     A29C   24 7F       19314   	bit runmod		;test if direct mode
     A29E   30 10       19315   	bmi 30$			;it is direct mode
                        19316   
     A2A0   A0 00       19317   	ldy #0
     A2A2   A9 7B       19318   	lda #dsdesc+1
     A2A4   20 03AB     19319   	jsr indsub_ram1
     A2A7   C9 32       19320   	cmp #'2'
     A2A9   90 05       19321   	bcc 30$			;if error occured
                        19322   
     A2AB   A2 24       19323   20$	ldx #errbdk		;bad disk
     A2AD   4C 4D59     19324   	jmp error
                        19325   
     A2B0   60          19326   30$	rts
                        19327   
                        19328   
                        19329   
                        19330   ;    scratch sdfn
                        19331   
     A2B1   20 A3CF     19332   scratc	jsr dospar 		;parse the line
     A2B4   20 A759     19333   	jsr chk1
     A2B7   20 A7F1     19334   	jsr are_you_sure
     A2BA   D0 27       19335   	bne 30$ 		;if no and direct mode
     A2BC   A0 37       19336   	ldy #fscr 		;offset
     A2BE   A9 04       19337   	lda #4			;length

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 218-3
DOS 1   DOS1.SRC

Error Addr  Code          Seq   Source statement

     A2C0   20 A3A7     19338   	jsr trans
     A2C3   20 A788     19339   	jsr errchl 		;read error channel
     A2C6   24 7F       19340   	bit runmod
     A2C8   30 19       19341   	bmi 30$ 		;if not direct mode
     A2CA   A9 0D       19342   	lda #cr
     A2CC   20 9269     19343   	jsr k_bsout 		;output cr
                        19344   
     A2CF   A0 00       19345   	ldy #0			;clr to read errchl
     A2D1   A9 7B       19346   10$	lda #dsdesc+1
     A2D3   20 03AB     19347   	jsr indsub_ram1
     A2D6   F0 06       19348   	beq 20$			;if end of error message
     A2D8   20 9269     19349   	jsr k_bsout
     A2DB   C8          19350   	iny
     A2DC   D0 F3       19351   	bne 10$			;always
                        19352   
     A2DE   A9 0D       19353   20$	lda #cr
     A2E0   20 90DF     19354   	jsr outch
     A2E3   60          19355   30$	rts
                        19356   
     A2E4   4C 7A09     19357   rec5	jmp snerr 		;syntax error
                        19358   
                        19359   
                        19360   	;    record - random record access.
                        19361   
     A2E7   A9 23       19362   record	lda #'#'
     A2E9   20 79FB     19363   	jsr synchr		;syntax error if not 'record#'
                        19364   	
     A2EC   20 87F4     19365   	jsr getbyt		;get lfn in x
     A2EF   E0 00       19366   	cpx #0
     A2F1   F0 37       19367   	beq rec4 		;cannot be zero
     A2F3   8E 011B     19368   	stx dosla 		;save logical address
                        19369   
     A2F6   20 880F     19370   	jsr comwrd		;check for comma, get record number in 'poker'
                        19371   
     A2F9   A2 01       19372   	ldx #1			;set up to get starting byte # - default is 1
     A2FB   20 9E27     19373   	jsr optbyt
                        19374   
     A2FE   E0 00       19375   	cpx #0
     A300   F0 28       19376   	beq rec4 		;if out of range
     A302   E0 FF       19377   	cpx #$ff
     A304   F0 24       19378   	beq rec4 		;if out of range
     A306   8E 011E     19379   	stx dosrcl 		;save byte position (pos)
                        19380   
     A309   AD 011B     19381   	lda dosla 		;get logical address
     A30C   20 A855     19382   	jsr put_io_in_map
     A30F   20 FF59     19383   	jsr _lkupla 		;logical to physical map
     A312   B0 19       19384   	bcs rec6 		;if file not found
     A314   8C 11ED     19385   	sty dossa_temp		;save secondary address
                        19386   
     A317   8E 011C     19387   	stx dosfa		;set up device number for trans routine
     A31A   A9 00       19388   	lda #0
     A31C   8D 011B     19389   	sta dosla		;set up logical address for trans routine
     A31F   A9 6F       19390   	lda #$6f
     A321   8D 011D     19391   	sta dossa		;and secondary address, too!
                        19392   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 218-4
DOS 1   DOS1.SRC

Error Addr  Code          Seq   Source statement

     A324   A0 3B       19393   	ldy #frec 		;set pointer
     A326   A9 04       19394   	lda #4			;process five bytes
     A328   D0 7D       19395   	bne trans 		;transfer on channel 15
                        19396   
     A32A   4C 7DC5     19397   rec4	jmp fcerr		;illegal value error
     A32D   A2 04       19398   rec6	ldx #errfnf		;file not found err
     A32F   4C 4D59     19399   	jmp error
                        19400   
                        19401   
                        19402   
     A332   20 A3CF     19403   dclear	jsr dospar 		;parse the line
     A335   A0 FF       19404   	ldy #fclr 		;set code
     A337   A9 02       19405   	lda #2
     A339   20 A3A7     19406   	jsr trans
     A33C   4C A193     19407   	jmp dclall
                        19408   
                        19409   
                        19410   
                        19411   ;    collect v<drive#>
                        19412   
     A33F   20 A3CF     19413   collect	jsr dospar		;parse the line
     A342   20 A76B     19414   	jsr chk3 		;chk opt parms
     A345   20 927B     19415   	jsr k_clall 		;close all files
     A348   A0 21       19416   	ldy #fcoll 		;tabld offset
     A34A   A2 01       19417   	ldx #1			;length
     A34C   A5 80       19418   	lda parsts
     A34E   29 10       19419   	and #$10
     A350   F0 01       19420   	beq 10$
     A352   E8          19421   	inx 			;include drive
     A353   8A          19422   10$	txa 			;place in a
     A354   D0 51       19423   	bne trans 		;always (x <> 0)
                        19424   
                        19425   
                        19426   
                        19427   
                        19428   ;    copy routines cdddfn=sdsfn
                        19429   
     A356   20 A3CF     19430   dcopy	jsr dospar 		;parse the line
     A359   29 30       19431   	and #$30
     A35B   C9 30       19432   	cmp #$30 		;chk req'd parms
     A35D   D0 06       19433   	bne 10$
     A35F   A5 80       19434   	lda parsts
     A361   29 C7       19435   	and #$c7
     A363   F0 07       19436   	beq 20$
     A365   A5 80       19437   10$	lda parsts
     A367   20 A770     19438   	jsr chk4
     A36A   A5 80       19439   	lda parsts
     A36C   A0 27       19440   20$	ldy #fcopy 		;tabld offset
     A36E   A9 08       19441   	lda #8			;length
     A370   D0 35       19442   	bne trans 		;go do it
                        19443   
                        19444   
                        19445   
                        19446   ;    concat routines
                        19447   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 218-5
DOS 1   DOS1.SRC

Error Addr  Code          Seq   Source statement

     A372   20 A3CF     19448   concat	jsr dospar 		;parse the line
     A375   20 A770     19449   	jsr chk4
     A378   A0 0D       19450   	ldy #fconc 		;offset
     A37A   A9 0C       19451   	lda #12 		;length
     A37C   D0 29       19452   	bne trans 		;go do it
                        19453   
                        19454   
                        19455   
                        19456   
                        19457   ;    rename rdddfn=sdsfn
                        19458   
     A37E   A9 E4       19459   rename	lda #$e4 		;set error flags
     A380   20 A3D1     19460   	jsr dosprs 		;parse the line
     A383   20 A776     19461   	jsr chk5
     A386   A0 2F       19462   	ldy #fren 		;offset
     A388   A9 08       19463   	lda #8			;length
     A38A   D0 1B       19464   	bne trans 		;go do it
                        19465   
                        19466   
                        19467   
                        19468   
                        19469   ;    backup d<dd>=<sd>
                        19470   
     A38C   A9 C7       19471   backup	lda #$c7 		;set error flags
     A38E   20 A3D1     19472   	jsr dosprs 		;parse the line
     A391   29 30       19473   	and #$30 		;req'd parms
     A393   C9 30       19474   	cmp #$30
     A395   F0 03       19475   	beq 5$
     A397   4C 7A09     19476   	jmp snerr
                        19477   
     A39A   20 A7F1     19478   5$	jsr are_you_sure
     A39D   F0 01       19479   	beq 10$			;if run mode or not 'yes'
     A39F   60          19480   	rts
                        19481   
     A3A0   20 A193     19482   10$	jsr dclall 		;close disk
     A3A3   A0 23       19483   	ldy #fbak
     A3A5   A9 04       19484   	lda #4			;length
                        19485   				;fall thru to trans
                        19486   
                        19487   
                        19488   
                        19489   ;    trans subroutine
                        19490   
     A3A7   20 A677     19491   trans	jsr sendp 		;build string to output
     A3AA   20 926F     19492   	jsr k_clrch
     A3AD   A9 00       19493   	lda #0			;name is in bank 0
     A3AF   AA          19494   	tax
     A3B0   20 9287     19495   	jsr k_setbank
     A3B3   38          19496   	sec
     A3B4   20 90D8     19497   	jsr k_open		;send it...
     A3B7   08          19498   	php			;save error status (.c)
     A3B8   48          19499   	pha			;save error code (if any)
     A3B9   AD 011B     19500   	lda dosla
     A3BC   38          19501   	sec
     A3BD   20 9275     19502   	jsr k_close		;special close...

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 218-6
DOS 1   DOS1.SRC

Error Addr  Code          Seq   Source statement

     A3C0   68          19503   	pla			;pop error 
     A3C1   28          19504   	plp			;pop error status
                        19505   
     A3C2               19506   dopen_patch
     A3C2   B0 01       19507   	bcs 10$			;...branch if there was an error opening
     A3C4   60          19508   	rts
                        19509   
     A3C5   4C 90D0     19510   10$	jmp erexit
                        19511   
                        19512   ;end
                        19513   	.include dos2

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 219
DOS 2   DOS2.SRC

Error Addr  Code          Seq   Source statement

                        19515   	.subttl DOS 2
                        19516   
                        19517   ;       -mgm 7/23/79-
                        19518   ;
                        19519   ;    this is the dos parser routine which looks at lines
                        19520   ;    passed to it and varifies that the syntax is proper.
                        19521   ;
                        19522   ;    entry  (dosprs)
                        19523   ;        a = parsts bit which must be zero.
                        19524   ;
                        19525   ;    exit  a = parsts as follows
                        19526   ;
                        19527   ;    i-i-i-i-i-i-i-i-i
                        19528   ;    i7+6+5+4+3+2+1+0i
                        19529   ;    i-i-i-i-i-i-i-i-i
                        19530   ;    ~ ~ ~ ~ ~ ~ ~ ~ ====> fn1 this bit is set when the
                        19531   ;    | | | | | | | |       first filename is parsed
                        19532   ;    | | | | | | | ======> fn2 set for second filename
                        19533   ;    | | | | | |=========> la set when #lfn parsed
                        19534   ;    | | | | |===========> fa set for device number
                        19535   ;    | | | | ============> d1 set for first disk unit
                        19536   ;    | | | ==============> d2 set for second disk unit
                        19537   ;    | | ================> dosrcl set for record size
                        19538   ;    | ==================> @ set when @ encountered.
                        19539   ;
                        19540   ;    the following are the vaild bit patterns for parsts
                        19541   ;    after parsing for the various keywords
                        19542   ;
                        19543   ;	     7 6 5 4  3 2 1 0
                        19544   ;    (format)
                        19545   ;    header  0 0 0 *  * 0 0 1
                        19546   ;    colect  0 0 0 *  * 0 0 0
                        19547   ;    dclear  0 0 0 *  * 0 0 0
                        19548   ;    backup  0 0 1 1  * 0 0 0
                        19549   ;    copy    0 0 1 1  * 0 0 0
                        19550   ;     or..   0 0 * *  * 0 1 1
                        19551   ;    concat  0 0 * *  * 0 1 1
                        19552   ;    bsave   * 0 0 *  * 0 0 1
                        19553   ;    dsave   * 0 0 *  * 0 0 1
                        19554   ;    bload   0 0 0 *  * 0 0 1
                        19555   ;    dload   0 0 0 *  * 0 0 1
                        19556   ;    dverify 0 0 0 *  * 0 0 1
                        19557   ;    catlog  0 0 0 *  * 0 0 *
                        19558   ;    rename  0 0 0 *  * 0 1 1
                        19559   ;    append  0 0 0 *  * 1 0 1
                        19560   ;    scrtch  0 0 0 *  * 0 0 1
                        19561   ;    dopen   * * 0 *  * 1 0 1
                        19562   ;    dclose  0 0 0 0  * * 0 0
                        19563   ;            ~ ~ ~ ~  ~ ~ ~ ~
                        19564   ;            @ l d d  f l f f
                        19565   ;            r r 2 1  a a n n
                        19566   ;            p e          2 1
                        19567   ;            l l
                        19568   ;
                        19569   ;     "0" bits are required to be clear.

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 219-1
DOS 2   DOS2.SRC

Error Addr  Code          Seq   Source statement

                        19570   ;     "1" bits are required to be set.
                        19571   ;     "*" bits are optional parameters.
                        19572   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 220
DOS 2   DOS2.SRC

Error Addr  Code          Seq   Source statement

                        19574   
                        19575   ;    entry (dosprs)
                        19576   ;        parstx shall be set to prevent any
                        19577   ;        auxiliary options to be specified.
                        19578   ;
                        19579   ;    entry (dosprx)
                        19580   ;        x = parstx bits whic must be zero.
                        19581   ;    exit  x = parstx as follows
                        19582   ;
                        19583   ;    i-i-i-i-i-i-i-i-i
                        19584   ;    i7+6+5+4+3+2+1+0i
                        19585   ;    i-i-i-i-i-i-i-i-i
                        19586   ;    ~ ~ ~ ~ ~ ~ ~ ~ ====> bnk is set for bank option
                        19587   ;    < < < < < < < ======> offl set for 1st address
                        19588   ;    < < < < < <=========> offh set for 2nd address
                        19589   ;    < < < < <===========> unused
                        19590   ;    < < < < ============> unused
                        19591   ;    < < < = ============> unused
                        19592   ;    < < = = ============> unused
                        19593   ;    < = = = ============> unused
                        19594   ;
                        19595   ;    the following are the vaild bit patterns for parstx
                        19596   ;    after parsing for the various keywords
                        19597   ;    only two stmts are allowed bits set in parstx.
                        19598   ;
                        19599   ;		7 6 5 4  3 2 1 0
                        19600   ;    (format)
                        19601   ;	 bsave  0 0 0 0  0 1 1 *
                        19602   ;	 bload  0 0 0 0  0 0 * *
                        19603   ;		~ ~ ~ ~  ~ ~ ~ ~
                        19604   ;		? ? ? ?  ? o o b
                        19605   ;			   f f n
                        19606   ;			   h l k
                        19607   
                        19608   ;     "0" bits are required to be clear.
                        19609   ;     "1" bits are required to be set.
                        19610   ;     "*" bits are optional parameters.
                        19611   
                        19612   
     A3C8   FF FF FF    19613   dostbl  .byte $ff,$ff,$ff,$ff,doslfn,8,$6f
     A3CB   FF 00 08            
     A3CE   6F                  
                        19614   
                        19615   
     A3CF   A9 00       19616   dospar	lda #0
                        19617   
     A3D1               19618   dosprs  			;special error flag entry
     A3D1   A2 FF       19619   	ldx #$ff 		;no aux options!
     A3D3               19620   dosprx  			;spec aux error flag entry
     A3D3   48          19621   	pha 			;save error flags
     A3D4   8A          19622   	txa
     A3D5   48          19623   	pha
     A3D6   A9 00       19624   	lda #0
     A3D8   85 80       19625   	sta parsts
     A3DA   85 81       19626   	sta parstx

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 220-1
DOS 2   DOS2.SRC

Error Addr  Code          Seq   Source statement

                        19627   
     A3DC   A2 22       19628   	ldx #dosspc-1 		;clear dos scratch area
     A3DE   9D 0100     19629   dos01	sta fbuffr,x
     A3E1   CA          19630   	dex
     A3E2   D0 FA       19631   	bne dos01
     A3E4   A2 06       19632   	ldx #dossa-dosofl 	;set some defaults from table
     A3E6   BD A3C8     19633   dos02	lda dostbl,x
     A3E9   9D 0117     19634   	sta dosofl,x
     A3EC   CA          19635   	dex
     A3ED   10 F7       19636   	bpl dos02
     A3EF   AE 03D5     19637   	ldx current_bank	;get current bank
     A3F2   8E 011F     19638   	stx dosbnk
                        19639   
     A3F5   20 0386     19640   	jsr chrgot 	;get current chr
     A3F8   D0 0E       19641   	bne parse1 	;if not end of statement
                        19642   
     A3FA   68          19643   done	pla 		;get aux error flag
     A3FB   25 81       19644   	and parstx 	; repeated,illegal params?
     A3FD   D0 6B       19645   	bne dn20
     A3FF   68          19646   	pla 		;get error flags
     A400   20 A62D     19647   	jsr prmrpt
     A403   A5 80       19648   	lda parsts
     A405   A6 81       19649   	ldx parstx
     A407   60          19650   	rts
                        19651   
     A408   C9 23       19652   parse1	cmp #'#'
     A40A   F0 4B       19653   	beq logadr 	;if logical file number
     A40C   C9 57       19654   	cmp #'W'
     A40E   F0 5D       19655   	beq reclen 	;if record length
     A410   C9 4C       19656   	cmp #'L'
     A412   F0 59       19657   	beq reclen 	;if record length
     A414   C9 52       19658   	cmp #'R'
     A416   F0 29       19659   	beq go_delim1
     A418   C9 44       19660   	cmp #'D'
     A41A   F0 73       19661   	beq drv1
     A41C   C9 91       19662   	cmp #ontk	;"on" token
     A41E   F0 27       19663   	beq on1
     A420   C9 42       19664   	cmp #'B'
     A422   F0 2E       19665   	beq dbank1
     A424   C9 55       19666   	cmp #'U'
     A426   F0 25       19667   	beq unit1
     A428   C9 50       19668   	cmp #'P'
     A42A   D0 03       19669   	bne 10$
     A42C   4C A4C4     19670   	jmp doffl
     A42F   C9 49       19671   10$	cmp #'I'
     A431   F0 75       19672   	beq ident
     A433   C9 22       19673   	cmp #'"'
     A435   F0 07       19674   	beq 20$
     A437   C9 28       19675   	cmp #'('
     A439   F0 03       19676   	beq 20$
     A43B   4C 7A09     19677   	jmp snerr
     A43E   4C A4EC     19678   20$	jmp name1
                        19679   
     A441               19680   go_delim1
     A441   20 0380     19681   	jsr chrget 	;move on

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 220-2
DOS 2   DOS2.SRC

Error Addr  Code          Seq   Source statement

     A444   4C A50B     19682   	jmp delim1
                        19683   
                        19684   
     A447   20 A592     19685   on1	jsr on
     A44A   4C A507     19686   sav60	jmp del1
                        19687   
                        19688   
     A44D   20 A59D     19689   unit1	jsr unit 	;do unit# parsing
     A450   D0 F8       19690   	bne sav60 	;always
                        19691   
                        19692   
     A452   20 A5AE     19693   dbank1	jsr dbank
     A455   F0 F3       19694   	beq sav60 	;always
                        19695   
                        19696   
                        19697   
                        19698   
                        19699   
     A457   A9 04       19700   logadr	lda #4
     A459   20 A62D     19701   	jsr prmrpt 	;check for repeated parameter
     A45C   20 A602     19702   	jsr getval
     A45F   E0 00       19703   	cpx #0
     A461   F0 42       19704   	beq qtyer2 	;if illegal value
     A463   8E 011B     19705   	stx dosla
     A466   A9 04       19706   	lda #4 		;set logical address flag
     A468   D0 E0       19707   	bne sav60 	;get next parameter
     A46A   4C 7A09     19708   dn20	jmp snerr
                        19709   
                        19710   
                        19711   
                        19712   
     A46D   AA          19713   reclen	tax 		;save char
     A46E   A9 40       19714   	lda #$40
     A470   20 A62D     19715   	jsr prmrpt 	;check for repeated parameter
     A473   E0 57       19716   	cpx #'W'
     A475   D0 06       19717   	bne 10$
     A477   20 0380     19718   	jsr chrget
     A47A   4C A48B     19719   	jmp recon 	;set parsts
     A47D   20 A602     19720   10$	jsr getval
     A480   E0 00       19721   	cpx #0
     A482   F0 21       19722   	beq qtyer2 	;zero illegal dosrcl
     A484   E0 FF       19723   	cpx #255
     A486   F0 1D       19724   	beq qtyer2 	;illegal dosrcl
     A488   8E 011E     19725   	stx dosrcl 	;store parcel
                        19726   
                        19727   
                        19728   
     A48B   A9 40       19729   recon	lda #$40 	;set dosrcl flag &
     A48D   D0 14       19730   	bne tacky1
                        19731   
                        19732   
                        19733   
                        19734   
     A48F   A9 10       19735   drv1	lda #$10
     A491   20 A62D     19736   	jsr prmrpt 	;check for repeated parameter

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 220-3
DOS 2   DOS2.SRC

Error Addr  Code          Seq   Source statement

     A494   20 A602     19737   	jsr getval
     A497   E0 02       19738   	cpx #2
     A499   B0 0A       19739   	bcs qtyer2 	;illegal drv# if >1
     A49B   8E 0112     19740   	stx dosds1
     A49E   8E 0114     19741   	stx dosds2
     A4A1   A9 10       19742   	lda #$10
     A4A3   D0 62       19743   tacky1	bne del1
                        19744   
                        19745   
     A4A5   4C 7DC5     19746   qtyer2	jmp fcerr
                        19747   
                        19748   
                        19749   
     A4A8   AD 0122     19750   ident	lda didchk
     A4AB   D0 BD       19751   	bne dn20
     A4AD   20 0380     19752   	jsr chrget 	;get next character
     A4B0   8D 0120     19753   	sta dosdid 	;m(txtptr => dosdid
     A4B3   20 0380     19754   	jsr chrget
     A4B6   8D 0121     19755   	sta dosdid+1
     A4B9   A9 FF       19756   	lda #$ff
     A4BB   8D 0122     19757   	sta didchk 	;set dosdid flag &
     A4BE   20 0380     19758   	jsr chrget 	;continue
     A4C1   4C A50B     19759   	jmp delim1
                        19760   
                        19761   
                        19762   
     A4C4   A9 02       19763   doffl	lda #$02 	;chk aux status
     A4C6   20 A632     19764   	jsr prxrpt
     A4C9   20 A615     19765   	jsr getoff 	;get offset value
     A4CC   8C 0117     19766   	sty dosofl
     A4CF   8D 0118     19767   	sta dosofl+1
     A4D2   A9 02       19768   	lda #$02
     A4D4   05 81       19769   dlimx1	ora parstx 	;set aux status bits
     A4D6   85 81       19770   	sta parstx
     A4D8   D0 31       19771   	bne delim1 	;try for nxt param
                        19772   
                        19773   
     A4DA   A9 04       19774   doffh	lda #$04
     A4DC   20 A632     19775   	jsr prxrpt
     A4DF   20 A615     19776   	jsr getoff
     A4E2   8C 0119     19777   	sty dosofh
     A4E5   8D 011A     19778   	sta dosofh+1
     A4E8   A9 04       19779   	lda #$04
     A4EA   D0 E8       19780   	bne dlimx1 	;set aux status
                        19781   
                        19782   
                        19783   
     A4EC   A9 01       19784   name1	lda #1		;name1 allwd only once
     A4EE   20 A5C9     19785   	jsr newnam 	;do name parsing
     A4F1   8D 0111     19786   	sta dosf1l
                        19787   
     A4F4   A0 00       19788   	ldy #0
     A4F6   20 03B7     19789   10$	jsr indin1_ram1
     A4F9   8D FF03     19790   	sta sw_rom_ram0
     A4FC   99 12B7     19791   	sta savram,y 	; set char in buffer

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 220-4
DOS 2   DOS2.SRC

Error Addr  Code          Seq   Source statement

     A4FF   C8          19792   	iny
     A500   CC 0111     19793   	cpy dosf1l
     A503   90 F1       19794   	bcc 10$		;if not full name
     A505   A9 01       19795   	lda #1 		;set name1 flag
                        19796   
                        19797   
     A507   05 80       19798   del1	ora parsts
     A509   85 80       19799   	sta parsts
                        19800   
     A50B   20 0386     19801   delim1	jsr chrgot
     A50E   D0 19       19802   	bne nxxx
     A510   4C A3FA     19803   done1	jmp done 	;<cr>/<> => done
                        19804   
     A513   C9 91       19805   next6	cmp #ontk
     A515   D0 03       19806   	bne next6a
     A517   4C A447     19807   	jmp on1
     A51A   C9 A4       19808   next6a	cmp #totk	;"to" token
     A51C   F0 02       19809   	beq next6b
     A51E   D0 6D       19810   	bne sav61 	;sntax error
                        19811   
                        19812   
                        19813   
                        19814   ;  if "to" is not followed by an offset param,then do file2 params. otherwise,
                        19815   ;  do high offset and continue with file0 options.
                        19816   
     A520   20 0380     19817   next6b	jsr chrget
     A523   C9 50       19818   	cmp #'P'
     A525   D0 0F       19819   	bne pars22
     A527   F0 B1       19820   	beq doffh
                        19821   
     A529   C9 2C       19822   nxxx	cmp #','
     A52B   D0 E6       19823   	bne next6
     A52D   20 0380     19824   	jsr chrget
     A530   4C A408     19825   	jmp parse1
                        19826   
     A533   20 0380     19827   parse2	jsr chrget
     A536   C9 44       19828   pars22	cmp #'D'
     A538   F0 10       19829   	beq drv2
     A53A   C9 91       19830   	cmp #ontk	;"on" token
     A53C   F0 1F       19831   	beq on2
     A53E   C9 55       19832   	cmp #'U'
     A540   F0 21       19833   	beq unit2
     A542   C9 22       19834   	cmp #'"'
     A544   F0 22       19835   	beq name2
     A546   C9 28       19836   	cmp #'('
     A548   F0 1E       19837   	beq name2
                        19838   
     A54A   A9 20       19839   drv2	lda #$20
     A54C   20 A62D     19840   	jsr prmrpt 	;check for repeated parameter
     A54F   20 A602     19841   	jsr getval
     A552   E0 02       19842   	cpx #2
     A554   B0 39       19843   	bcs qtyerr 	;illegal drive #
     A556   8E 0114     19844   	stx dosds2
     A559   A9 20       19845   	lda #$20
     A55B   D0 1B       19846   	bne del2

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 220-5
DOS 2   DOS2.SRC

Error Addr  Code          Seq   Source statement

                        19847   
     A55D   20 A592     19848   on2	jsr on
     A560   4C A578     19849   	jmp del2
                        19850   
     A563   20 A59D     19851   unit2	jsr unit 	;do unit# parsing
     A566   D0 10       19852   	bne del2 	;always
                        19853   
     A568   A9 02       19854   name2	lda #2		;name2 allowed only once
     A56A   20 A5C9     19855   	jsr newnam
     A56D   8D 0113     19856   	sta dosf2l
     A570   8E 0115     19857   	stx dosf2a
     A573   8C 0116     19858   	sty dosf2a+1
                        19859   
     A576   A9 02       19860   	lda #2		;set filename2 flag &
     A578   05 80       19861   del2	ora parsts 	;set flag in status
     A57A   85 80       19862   	sta parsts
     A57C   20 0386     19863   	jsr chrgot
     A57F   F0 8F       19864   	beq done1 	;done on <cr>/<>
     A581   C9 2C       19865   	cmp #','
     A583   F0 AE       19866   	beq parse2
     A585   C9 91       19867   	cmp #ontk	;"on" token
     A587   F0 D4       19868   	beq on2
     A589   C9 55       19869   	cmp #'U'
     A58B   F0 D6       19870   	beq unit2
     A58D   D0 37       19871   sav61	bne sner
                        19872   
                        19873   
                        19874   
                        19875   
     A58F   4C 7DC5     19876   qtyerr	jmp fcerr 	;"illegal quantity"
                        19877   
                        19878   
                        19879   
     A592   20 0380     19880   on	jsr chrget
     A595   C9 42       19881   	cmp #'B'
     A597   F0 15       19882   	beq dbank
     A599   C9 55       19883   	cmp #'U'
     A59B   D0 29       19884   	bne sner
                        19885   
     A59D   20 A602     19886   unit	jsr getval
     A5A0   E0 1F       19887   	cpx #31
     A5A2   B0 56       19888   	bcs err_ild	;error if >30
     A5A4   E0 04       19889   	cpx #4
     A5A6   90 52       19890   	bcc err_ild	;error if <4
     A5A8   8E 011C     19891   	stx dosfa
     A5AB   A9 08       19892   	lda #8
     A5AD   60          19893   	rts
                        19894   
                        19895   
                        19896   
     A5AE   A9 01       19897   dbank	lda #$01 	;repeated param?
     A5B0   20 A632     19898   	jsr prxrpt
     A5B3   20 A602     19899   	jsr getval
     A5B6   E0 10       19900   	cpx #16		;bank too large?
     A5B8   B0 D5       19901   	bcs qtyerr

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 220-6
DOS 2   DOS2.SRC

Error Addr  Code          Seq   Source statement

     A5BA   8E 011F     19902   	stx dosbnk
     A5BD   A9 01       19903   	lda #$01
     A5BF   05 81       19904   	ora parstx 	;set bnk bit in aux status
     A5C1   85 81       19905   	sta parstx
     A5C3   A9 00       19906   	lda #0		; .a=std status wrd, no bits to set
     A5C5   60          19907   	rts
                        19908   
     A5C6   4C 7A09     19909   sner	jmp snerr 	;jump syntax error
                        19910   
                        19911   
     A5C9   20 A62D     19912   newnam	jsr prmrpt 	;check for repeated parameter
     A5CC   20 877B     19913   	jsr frmstr
     A5CF   AA          19914   	tax		;save length of string
     A5D0   F0 25       19915   	beq err_mfn	;if length = 0
     A5D2   A0 00       19916   	ldy #0
     A5D4   20 03B7     19917   	jsr indin1_ram1
     A5D7   C9 40       19918   	cmp #'@'
     A5D9   D0 12       19919   	bne lenchk
     A5DB   A9 80       19920   	lda #$80
     A5DD   20 A62D     19921   	jsr prmrpt
     A5E0   A5 80       19922   	lda parsts
     A5E2   09 80       19923   	ora #$80 	;set "@" flag
     A5E4   85 80       19924   	sta parsts
     A5E6   CA          19925   	dex		;decrement length
     A5E7   E6 24       19926   	inc index1 	;increment past "@"
     A5E9   D0 02       19927   	bne lenchk 	;if no carry
     A5EB   E6 25       19928   	inc index1+1
     A5ED   8A          19929   lenchk	txa
     A5EE   C9 11       19930   	cmp #17
     A5F0   B0 0B       19931   	bcs errlen 	;if length < 17
     A5F2   A6 24       19932   	ldx index1
     A5F4   A4 25       19933   	ldy index1+1
     A5F6   60          19934   	rts
                        19935   
                        19936   
     A5F7   A2 08       19937   err_mfn	ldx #err_missing_fname
     A5F9   2C          19938   	.byte $2c
                        19939   
     A5FA   A2 09       19940   err_ild	ldx #err_illegal_device
     A5FC   2C          19941   	.byte $2c
                        19942   
     A5FD   A2 17       19943   errlen	ldx #errls 	;filename too long
     A5FF   4C 4D59     19944   	jmp error
                        19945   
                        19946   
                        19947   
                        19948   ; get nextvalue routine
                        19949   
     A602   20 0380     19950   getval	jsr chrget 	;get nxt chr
     A605   F0 BF       19951   gtvl2	beq sner 	;if end of statement
     A607   90 09       19952   	bcc 10$		;can be numeric
     A609   20 79F6     19953   	jsr chkopn 	;or a "("
     A60C   20 87F4     19954   	jsr getbyt 	;anything else is an error
     A60F   4C 79F3     19955   	jmp chkcls 	;need closing ")"
                        19956   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 220-7
DOS 2   DOS2.SRC

Error Addr  Code          Seq   Source statement

     A612   4C 87F4     19957   10$	jmp getbyt 	;evaluate it
                        19958   
                        19959   
                        19960   
                        19961   ;  get next 2byte expr routine
                        19962   ;  exit: .a,.y (high,low) value
                        19963   
     A615   20 0380     19964   getoff	jsr chrget 	;get nxt chr
     A618   F0 AC       19965   	beq sner 	;if end of statement
     A61A   90 0E       19966   	bcc 10$		;can be num. const
     A61C   20 79F6     19967   	jsr chkopn 	;or a "("
     A61F   20 8812     19968   	jsr getwrd	;expr
     A622   20 79F3     19969   	jsr chkcls 	;need closing ")"
     A625   A4 16       19970   	ldy poker
     A627   A5 17       19971   	lda poker+1
     A629   60          19972   	rts
     A62A   4C 8812     19973   10$	jmp getwrd	;evaluate it
                        19974   
                        19975   
                        19976   
                        19977   
                        19978   ;    prmrpt checks for a repeated parameter.
                        19979   ;
                        19980   ;    entry: .A contains parsts flag to check.
                        19981   
     A62D   25 80       19982   prmrpt	and parsts 	;and with parsts
     A62F   D0 95       19983   	bne sner 	;if bit previously set
     A631   60          19984   	rts
                        19985   
                        19986   
                        19987   
                        19988   ;    prxrpt checks for a repeated parameter.
                        19989   ;
                        19990   ;    entry: .A contains parstx flag to check.
                        19991   
     A632   25 81       19992   prxrpt	and parstx 	;and with parstx
     A634   D0 90       19993   	bne sner 	;if bit previously set
     A636   60          19994   	rts
                        19995   
                        19996   ;end
                        19997   	.include dos3

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 221
DOS 3   DOS3.SRC

Error Addr  Code          Seq   Source statement

                        19999   	.subttl DOS 3
                        20000   
                        20001   ; cbm 2001 disk verb processors
                        20002   ; author rsr 7-24-79
                        20003   ;
                        20004   ;- token table definitions -
                        20005   ;
            =00C2       20006   xsca  =$c2 	;send dossca
            =00D0       20007   xid  =$d0 	;sends disk id
            =00D1       20008   xd1  =$d1 	;sends dosds1
            =00D2       20009   xd2  =$d2 	;sends dosds2
            =00E0       20010   xrec  =$e0 	;sends s for seq or dosrcl
            =00E1       20011   xwrt  =$e1 	;sends w or l
            =00E2       20012   xrcl  =$e2 	;send low ((poker))
            =00F0       20013   xfat  =$f0 	;sends "@" if specified
            =00F1       20014   xfn1  =$f1 	;sends filename1
            =00F2       20015   xfn2  =$f2 	;sends filename2
                        20016   ;
                        20017   ; tabld - used to build disk command strings
                        20018   ;
     A637               20019   tabld 	;
            =00FF       20020   fclr  =$ff
     A637   49 D1       20021   	.byte 'I',xd1
                        20022   
            =0001       20023   fcat  =*-tabld-1
     A639   24 D1 3A    20024   	.byte '$',xd1,':',xfn1
     A63C   F1                  
                        20025   
            =0005       20026   fopn  =*-tabld-1
     A63D   F0 D1 3A    20027   	.byte xfat,xd1,':',xfn1,',',xwrt,',',xrec
     A640   F1 2C E1            
     A643   2C E0               
                        20028   
            =000D       20029   fconc =*-tabld-1
     A645   43 D2 3A    20030   	.byte 'C',xd2,':',xfn2,'=',xd2,':',xfn2,','
     A648   F2 3D D2            
     A64B   3A F2 2C            
                        20031   
            =0016       20032   fapn  =*-tabld-1
     A64E   D1 3A F1    20033   	.byte xd1,':',xfn1,',','A'
     A651   2C 41               
                        20034   
            =001B       20035   fhed  =*-tabld-1
     A653   4E D1 3A    20036   	.byte 'N',xd1,':',xfn1,',',xid
     A656   F1 2C D0            
                        20037   
            =0021       20038   fcoll =*-tabld-1
     A659   56 D1       20039   	.byte 'V',xd1
                        20040   
            =0023       20041   fbak  =*-tabld-1
     A65B   44 D2 3D    20042   	.byte 'D',xd2,'=',xd1
     A65E   D1                  
                        20043   
            =0027       20044   fcopy =*-tabld-1
     A65F   43 D2 3A    20045   	.byte 'C',xd2,':',xfn2,'=',xd1,':',xfn1

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 221-1
DOS 3   DOS3.SRC

Error Addr  Code          Seq   Source statement

     A662   F2 3D D1            
     A665   3A F1               
                        20046   
            =002F       20047   fren  =*-tabld-1
     A667   52 D1 3A    20048   	.byte 'R',xd1,':',xfn2,'=',xd1,':',xfn1
     A66A   F2 3D D1            
     A66D   3A F1               
                        20049   
            =0037       20050   fscr  =*-tabld-1
     A66F   53 D1 3A    20051   	.byte 'S',xd1,':',xfn1
     A672   F1                  
                        20052   
            =003B       20053   frec  =*-tabld-1
     A673   50 C2 E2    20054   	.byte 'P',xsca,xrcl,xrec
     A676   E0                  
                        20055   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 222
DOS 3   DOS3.SRC

Error Addr  Code          Seq   Source statement

                        20057   ; send parameters to device
                        20058   ;
                        20059   ; entry a number of bytes in format.
                        20060   ; y --> tabld entry.
                        20061   
     A677   8D 0110     20062   sendp	sta xcnt 	;save number of string bytes
     A67A   98          20063   	tya
     A67B   48          20064   	pha
     A67C   20 A81D     20065   	jsr oldclr 	;clear old status
                        20066   
     A67F   A2 00       20067   	ldx #0
     A681   68          20068   sdp1	pla
     A682   CE 0110     20069   	dec xcnt
     A685   30 48       20070   	bmi tranr
     A687   A8          20071   	tay
     A688   C8          20072   	iny		;move down table
     A689   98          20073   	tya
     A68A   48          20074   	pha
     A68B   B9 A637     20075   	lda tabld,y 	;get next entry
     A68E   10 37       20076   	bpl sdp5 	;if not escape code
     A690   C9 C2       20077   	cmp #xsca 	;if not secondary address
     A692   F0 52       20078   	beq rsca
     A694   C9 D0       20079   	cmp #xid
     A696   F0 5D       20080   	beq rid 	;if disk id
     A698   C9 E2       20081   	cmp #xrcl
     A69A   F0 77       20082   	beq rdcn 	;if record number
     A69C   C9 E1       20083   	cmp #xwrt
     A69E   F0 61       20084   	beq rwrt 	;if w or l
     A6A0   C9 F0       20085   	cmp #xfat
     A6A2   F0 47       20086   	beq rfat 	;if "@" symbol request
     A6A4   C9 F1       20087   	cmp #xfn1
     A6A6   F0 75       20088   	beq rsfn 	;if filename 1
     A6A8   C9 F2       20089   	cmp #xfn2
     A6AA   F0 21       20090   	beq gordfn 	;if filename 2
     A6AC   C9 E0       20091   	cmp #xrec
     A6AE   D0 05       20092   	bne sdp2 	;if not record type
     A6B0   AD 011E     20093   	lda dosrcl 	;get rec #
     A6B3   D0 12       20094   	bne sdp5 	;always branch
     A6B5   C9 D1       20095   sdp2	cmp #xd1
     A6B7   D0 05       20096   	bne sdp3 	;if not drive 1
     A6B9   AD 0112     20097   	lda dosds1
     A6BC   10 07       20098   	bpl sdp4 	;always branch
     A6BE   C9 D2       20099   sdp3	cmp #xd2
     A6C0   D0 BF       20100   	bne sdp1 	;if not drive 2, continue
     A6C2   AD 0114     20101   	lda dosds2
     A6C5   09 30       20102   sdp4	ora #'0 	;change # to ascii
                        20103   
     A6C7   9D 1100     20104   sdp5	sta dosstr,x 	;else into buffer
     A6CA   E8          20105   	inx
     A6CB   D0 B4       20106   	bne sdp1 	;always
                        20107   
     A6CD   F0 64       20108   gordfn	beq rdfn
                        20109   
                        20110   
     A6CF   8A          20111   tranr	txa		;length to a

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 222-1
DOS 3   DOS3.SRC

Error Addr  Code          Seq   Source statement

     A6D0   48          20112   	pha
     A6D1   A2 00       20113   	ldx #<dosstr 	;set filename
     A6D3   A0 11       20114   	ldy #>dosstr
     A6D5   20 925D     20115   	jsr k_setnam
                        20116   
     A6D8   AD 011B     20117   	lda dosla
     A6DB   AE 011C     20118   	ldx dosfa
     A6DE   AC 011D     20119   	ldy dossa
     A6E1   20 9257     20120   	jsr k_setlfs
                        20121   
     A6E4   68          20122   	pla
     A6E5   60          20123   	rts
                        20124   
                        20125   
                        20126   
                        20127   
     A6E6   AD 11ED     20128   rsca	lda dossa_temp 	;secondary address (record)
     A6E9   D0 DC       20129   	bne sdp5 	;always
                        20130   
     A6EB   24 80       20131   rfat	bit parsts
     A6ED   30 02       20132   	bmi rfata
     A6EF   10 90       20133   	bpl sdp1 	;if @ not encountered
     A6F1   A9 40       20134   rfata	lda #'@
     A6F3   D0 D2       20135   	bne sdp5 	;always
                        20136   
                        20137   
                        20138   
                        20139   ; id subroutine
                        20140   
     A6F5   AD 0120     20141   rid	lda dosdid 	;include id
     A6F8   9D 1100     20142   	sta dosstr,x
     A6FB   E8          20143   	inx
     A6FC   AD 0121     20144   	lda dosdid+1
     A6FF   D0 C6       20145   	bne sdp5 	;always
                        20146   
                        20147   
     A701   AD 011E     20148   rwrt	lda dosrcl 	;chk for l or w
     A704   F0 04       20149   	beq 10$	;zero then write
     A706   A9 4C       20150   	lda #'L'
     A708   D0 BD       20151   	bne sdp5 	;always
     A70A   A9 53       20152   10$	lda #'S' 	;send w,s
     A70C   8D 011E     20153   	sta dosrcl
     A70F   A9 57       20154   	lda #'W'
     A711   D0 B4       20155   	bne sdp5 	;always
                        20156   
                        20157   
                        20158   
                        20159   ; move record number
                        20160   
     A713   A5 16       20161   rdcn	lda poker
     A715   9D 1100     20162   	sta dosstr,x
     A718   A5 17       20163   	lda poker+1
     A71A   E8          20164   	inx
     A71B   D0 AA       20165   	bne sdp5 	;always
                        20166   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 222-2
DOS 3   DOS3.SRC

Error Addr  Code          Seq   Source statement

                        20167   
                        20168   ; move file names.
                        20169   
     A71D   AC 0111     20170   rsfn	ldy dosf1l	;file name 1: get length
     A720   F0 33       20171   	beq rdrt0 	;if null string
                        20172   
     A722   A0 00       20173   	ldy #0 		;move name to dosstr
     A724   B9 12B7     20174   10$	lda savram,y
     A727   9D 1100     20175   	sta dosstr,x
     A72A   E8          20176   	inx
     A72B   C8          20177   	iny
     A72C   CC 0111     20178   	cpy dosf1l
     A72F   D0 F3       20179   	bne 10$		;if move not complete
     A731   F0 23       20180   	beq rdrt1	;always
                        20181   
     A733   AD 0115     20182   rdfn	lda dosf2a
     A736   85 24       20183   	sta index1
     A738   AD 0116     20184   	lda dosf2a+1
     A73B   85 25       20185   	sta index1+1
     A73D   AC 0113     20186   	ldy dosf2l
     A740   F0 13       20187   	beq rdrt0 	;if null string
                        20188   
     A742   A0 00       20189   	ldy #0 		;move name to dosstr
     A744   20 03B7     20190   10$	jsr indin1_ram1
     A747   8D FF03     20191   	sta sw_rom_ram0
     A74A   9D 1100     20192   	sta dosstr,x
     A74D   E8          20193   	inx
     A74E   C8          20194   	iny
     A74F   CC 0113     20195   	cpy dosf2l
     A752   D0 F0       20196   	bne 10$		;if move not complete
                        20197   
     A754   24          20198   	.byte $24 	;hop
     A755   CA          20199   rdrt0	dex 		;case cdd=sd
     A756   4C A681     20200   rdrt1	jmp sdp1 	;get next symbol
                        20201   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 223
DOS 3   DOS3.SRC

Error Addr  Code          Seq   Source statement

                        20203   
                        20204   ; syntax checker
                        20205   ; routines for dos.write
                        20206   
     A759   29 E6       20207   chk1	and #$e6 	;for header,dload,scrtch
     A75B   F0 03       20208   	beq chk2 	;chk opt parms
     A75D   4C 7A09     20209   chker1	jmp snerr
                        20210   
                        20211   
     A760   A5 80       20212   chk2	lda parsts 	;for dsave
     A762   29 01       20213   	and #1
     A764   C9 01       20214   	cmp #1 	;chk req'd parms
     A766   D0 F5       20215   	bne chker1 	;error if 1 missing
     A768   A5 80       20216   	lda parsts 	;reload for return
     A76A   60          20217   	rts
                        20218   
                        20219   
     A76B   29 E7       20220   chk3	and #$e7 	;for colect
     A76D   D0 EE       20221   	bne chker1 	;chk opt parms
     A76F   60          20222   	rts
                        20223   
                        20224   
     A770   29 C4       20225   chk4	and #$c4 	;for copy,concat
     A772   D0 E9       20226   	bne chker1 	;chk opt parms
     A774   A5 80       20227   	lda parsts
     A776   29 03       20228   chk5	and #3 	;for rename
     A778   C9 03       20229   	cmp #3 	;chk req'd parms
     A77A   D0 E1       20230   	bne chker1
     A77C   A5 80       20231   	lda parsts 	;reload for return
     A77E   60          20232   	rts
                        20233   
                        20234   
     A77F   29 05       20235   chk6	and #5 	;for append,dk_open
     A781   C9 05       20236   	cmp #5 	;chk req'd parms
     A783   D0 D8       20237   	bne chker1
     A785   A5 80       20238   	lda parsts 	;reload for rts
     A787   60          20239   	rts
                        20240   
                        20241   
                        20242   ;end
                        20243   	.include dos4

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 224
DOS 4   DOS4.SRC

Error Addr  Code          Seq   Source statement

                        20245   	.subttl DOS 4
                        20246   
                        20247   ;   error on channel - read status
                        20248   
     A788   A5 7A       20249   errchl	lda dsdesc      	;entry for user
     A78A   D0 19       20250   	bne echks       	;chk old status
     A78C   A9 28       20251   	lda #40         	;get 40 char str
     A78E   85 7A       20252   	sta dsdesc      	;we have 40 chrs
     A790   20 9299     20253   	jsr getspa
     A793   86 7B       20254   	stx dsdesc+1		;return low
     A795   84 7C       20255   	sty dsdesc+2		;return high
     A797   A0 28       20256   	ldy #40
     A799   8D FF04     20257   	sta sw_rom_ram1		;set up string bank
     A79C   A9 7A       20258   	lda #<dsdesc
     A79E   91 7B       20259   	sta (dsdesc+1),y
     A7A0   C8          20260   	iny
     A7A1   A9 00       20261   	lda #>dsdesc
     A7A3   91 7B       20262   	sta (dsdesc+1),y
                        20263   
                        20264   
     A7A5   AE 011C     20265   echks	ldx dosfa       	;chk bus <=ds read
     A7A8   D0 05       20266   	bne eread       	;if =0 default
     A7AA   A2 08       20267   	ldx #8
     A7AC   8E 011C     20268   	stx dosfa
     A7AF               20269   eread
     A7AF   A9 00       20270   	lda #doslfn
     A7B1   A0 6F       20271   	ldy #$6f
     A7B3   20 9257     20272   	jsr k_setlfs
                        20273   
     A7B6   A9 00       20274   	lda #0
     A7B8   20 925D     20275   	jsr k_setnam
                        20276   
     A7BB   20 90D8     20277   	jsr k_open
     A7BE   A2 00       20278   	ldx #doslfn
     A7C0   20 FFC6     20279   	jsr _chkin
     A7C3   B0 20       20280   	bcs errbad      	;a problem??
                        20281   
     A7C5   A0 FF       20282   	ldy #$ff
     A7C7               20283   loop1
     A7C7   C8          20284   	iny
     A7C8   20 9263     20285   	jsr k_basin
     A7CB   8D FF04     20286   	sta sw_rom_ram1	;set up string bank
     A7CE   C9 0D       20287   	cmp #cr         	;check for end
     A7D0   F0 06       20288   	beq errend
     A7D2   91 7B       20289   	sta (dsdesc+1),y
     A7D4   C0 28       20290   	cpy #40
     A7D6   90 EF       20291   	bcc loop1       	;branch unless too long.
     A7D8               20292   errend
     A7D8   A9 00       20293   	lda #0
     A7DA   91 7B       20294   	sta (dsdesc+1),y
     A7DC   20 926F     20295   	jsr k_clrch
     A7DF   A9 00       20296   	lda #doslfn
     A7E1   38          20297   	sec             	;not a real close
     A7E2   4C 9275     20298   	jmp k_close
                        20299   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 224-1
DOS 4   DOS4.SRC

Error Addr  Code          Seq   Source statement

     A7E5               20300   errbad
     A7E5   48          20301   	pha
     A7E6   20 A7D8     20302   	jsr errend
     A7E9   20 A81D     20303   	jsr oldclr      	;flag 'no ds available'
     A7EC   68          20304   	pla             	;get error
     A7ED   AA          20305   	tax
     A7EE   4C 4D59     20306   	jmp error
                        20307   
                        20308   
                        20309   ;  r-u-sure subroutine
                        20310   
     A7F1               20311   are_you_sure
     A7F1   24 7F       20312   	bit runmod      	;direct mode?
     A7F3   30 25       20313   	bmi ans3        	;no
     A7F5   20 9281     20314   	jsr k_primm		;prompt user
     A7F8   41 52 45    20315   	.byte 'ARE YOU SURE?', 0
     A7FB   20 59 4F            
     A7FE   55 20 53            
     A801   55 52 45            
     A804   3F 00               
     A806   20 926F     20316   	jsr k_clrch       	;clear channel for basin
     A809   20 9263     20317   	jsr k_basin       	;next char
     A80C   48          20318   	pha             	;save first char of reply
     A80D               20319   ans1   			;eat chars until end of line
     A80D   C9 0D       20320   	cmp #cr
     A80F   F0 05       20321   	beq ans2        	;if cr received, exit
     A811   20 9263     20322   	jsr k_basin
     A814   D0 F7       20323   	bne ans1        	;continue to ignore
                        20324   
     A816               20325   ans2
     A816   68          20326   	pla
     A817   C9 59       20327   	cmp #'Y'		;z set means ans=y.....
     A819   60          20328   	rts
     A81A               20329   ans3
     A81A   A9 00       20330   	lda #0          	;...or not in direct mode.
     A81C   60          20331   	rts
                        20332   
                        20333   
                        20334   
                        20335   ;  oldclr subroutine
                        20336   ;  clears disk status
                        20337   
     A81D   98          20338   oldclr	tya             	;save y
     A81E   48          20339   	pha
     A81F   A5 7A       20340   	lda dsdesc      	;chk for allocation
     A821   F0 0D       20341   	beq 10$			;bra if not
     A823   A0 28       20342   	ldy #40
     A825   98          20343   	tya
     A826   8D FF04     20344   	sta sw_rom_ram1		;set up string bank
     A829   91 7B       20345   	sta (dsdesc+1),y	;length of garbage
     A82B   C8          20346   	iny
     A82C   A9 FF       20347   	lda #$ff
     A82E   91 7B       20348   	sta (dsdesc+1),y	;garbage flaged
                        20349   
     A830   A9 00       20350   10$	lda #0

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 224-2
DOS 4   DOS4.SRC

Error Addr  Code          Seq   Source statement

     A832   8D FF03     20351   	sta sw_rom_ram0
     A835   85 7A       20352   	sta dsdesc      	;kill ds$
     A837   68          20353   	pla             	;restore y
     A838   A8          20354   	tay
     A839   60          20355   	rts
                        20356   
                        20357   ;.end
                        20358   	.include overflow

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 225
'basic overflow & patches'   OVERFLOW.SRC

Error Addr  Code          Seq   Source statement

                        20360   	.subttl 'basic overflow & patches'
                        20361   ;  overflow area for basic routines to bulge into in an attempt to
                        20362   ;  keep sundry entry points constant for pre-release applications.
                        20363   
     A83A               20364   preamb
     A83A   2C 30 20    20365          .byte ',0 YEK'	;fct key preamble
     A83D   59 45 4B            
                        20366   
     A840               20367   prtdec
     A840   AA          20368          tax             	;prints decimal value of chr in .a
     A841   98          20369          tya             	;saves .y but destroys .x
     A842   48          20370          pha
     A843   A9 00       20371          lda #0
     A845   20 8E32     20372          jsr linprt
     A848   68          20373          pla
     A849   A8          20374          tay
     A84A   60          20375          rts
                        20376   
                        20377   
     A84B               20378   retpat
     A84B   85 3C       20379          sta curlin+1    	;01/18/84 patch: fixes a problem when return-ing to a
     A84D   88          20380          dey             	;         'gosub' in direct mode. 'curlin+1' must not be restored
     A84E   AA          20381          tax             	;         to $ff without also resetting 'runmod'.
     A84F   E8          20382          inx
     A850   D0 02       20383          bne retpa1      	;branch if 'gosub' was from a program
     A852   86 7F       20384          stx runmod      	;(.x=0) else force return to direct mode
     A854               20385   retpa1
     A854   60          20386          rts
                        20387   
                        20388   
     A855               20389   put_io_in_map
     A855   48          20390   	pha
     A856   A9 00       20391   	lda #%0000000	;ram0, system rom in, i/o in
     A858   8D FF00     20392   	sta mmu_config_reg
     A85B   68          20393   	pla
     A85C   60          20394   	rts
                        20395   
                        20396   ;.end
                        20397   	.include irq

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 226
Basic's Interrupt Code   IRQ.SRC

Error Addr  Code          Seq   Source statement

                        20399   	.subttl Basic's Interrupt Code
                        20400   
     A85D               20401   basic_irq
     A85D   AD 12FD     20402   	lda irq_wrap_flag	;filter out wrapped irq calls (but allow interruptable code)
     A860   F0 01       20403   	beq 1$			;...it's ok
     A862   60          20404   	rts			;she's wrapped- bar new irq's until old ones done
                        20405   
     A863   EE 12FD     20406   1$	inc irq_wrap_flag	;shut the door
                        20407   
                        20408   
                        20409   ; copy saved VIC info into registers
                        20410   
     A866   A2 10       20411   	ldx #16
     A868   BD 11D6     20412   5$	lda vic_save,x
     A86B   9D D000     20413   	sta vic,x
     A86E   CA          20414   	dex
     A86F   10 F7       20415   	bpl 5$
                        20416   
                        20417   ; update any moving sprites
                        20418   
     A871   A0 07       20419   	ldy #7
     A873   AD D015     20420   10$	lda vic+21		;see if this sprite is enabled
     A876   39 6D50     20421   	and sbits,y		;'sbits' is a bit mask
     A879   F0 38       20422   	beq 40$			;not set, see if done
                        20423   
     A87B   BE 6E76     20424   	ldx sproff,y		;get offset to sprite info from a table
     A87E   BD 117E     20425   	lda sprite_data,x		;test if sprite move active
     A881   F0 30       20426   	beq 40$			;not active, see if done
                        20427   
     A883   9D 117F     20428   	sta sprite_data+1,x	;set counter
     A886   98          20429   20$	tya
     A887   0A          20430   	asl a			;double index to point to position registers
     A888   A8          20431   	tay
     A889   BD 1180     20432   	lda sprite_data+2,x	;get angle sign
     A88C   38          20433   	sec
     A88D   E9 01       20434   	sbc #1			;subtract 1 for cosine
     A88F   E8          20435   	inx
     A890   E8          20436   	inx
     A891   C8          20437   	iny
     A892   20 AA04     20438   	jsr sprsub		;update y position
     A895   CA          20439   	dex
     A896   CA          20440   	dex
     A897   88          20441   	dey
     A898   BD 1180     20442   	lda sprite_data+2,x
     A89B   20 AA04     20443   	jsr sprsub		;update x position
     A89E   08          20444   	php
     A89F   98          20445   	tya
     A8A0   4A          20446   	lsr a			;restore index (.Y)
     A8A1   A8          20447   	tay
     A8A2   28          20448   	plp
     A8A3   90 09       20449   	bcc 30$			;skip if no overflow
     A8A5   AD 11E6     20450   	lda vic_save+16		;get x position msb bits
     A8A8   59 6D50     20451   	eor sbits,y		;invert bit
     A8AB   8D 11E6     20452   	sta vic_save+16
     A8AE   DE 117F     20453   30$	dec sprite_data+1,x

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 226-1
Basic's Interrupt Code   IRQ.SRC

Error Addr  Code          Seq   Source statement

     A8B1   D0 D3       20454   	bne 20$			;loop 'till counter done
                        20455   
     A8B3   88          20456   40$	dey
     A8B4   10 BD       20457   	bpl 10$
                        20458   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 227
Basic's Interrupt Code   IRQ.SRC

Error Addr  Code          Seq   Source statement

                        20460   
                        20461   ; test if there was a vic collision/light pen interrupt
                        20462   
     A8B6               20463   collision_irq
     A8B6   AD D019     20464   	lda vic+25
     A8B9   8D D019     20465   	sta vic+25
     A8BC   29 0E       20466   	and #$0e
     A8BE   F0 44       20467   	beq music_irq		;not a collision type interrupt
     A8C0   4A          20468   	lsr a			;shift out raster interrupt bit (not used)
                        20469   
                        20470   ; test for 3 types of collision interrupts : sprite/sprite, sprite/bkgrnd, & light pen
                        20471   
     A8C1   A0 01       20472   	ldy #1			;s/s & s/b are very similar, so save code
     A8C3   4A          20473   10$	lsr a
     A8C4   90 20       20474   	bcc 30$			;bit not set ==> not source of interrupt
     A8C6   48          20475   	pha
     A8C7   B9 D01E     20476   	lda vic+30,y		;get collision data
     A8CA   19 11E7     20477   	ora vic_save+17,y
     A8CD   99 11E7     20478   	sta vic_save+17,y
     A8D0   A9 00       20479   	lda #0
     A8D2   99 D01E     20480   	sta vic+30,y		;clear collision data
                        20481   
     A8D5   AD 127F     20482   	lda intval		;record of allowable interrupts
     A8D8   C0 00       20483   	cpy #0			;examine selected bit
     A8DA   F0 01       20484   	beq 20$
     A8DC   4A          20485   	lsr a
     A8DD   4A          20486   20$	lsr a
     A8DE   90 05       20487   	bcc 25$			;BASIC doesn't want this interrupt
     A8E0   A9 FF       20488   	lda #$ff
     A8E2   99 1276     20489   	sta int_trip_flag,y	;turn on trip flag
                        20490   
     A8E5   68          20491   25$	pla
     A8E6   88          20492   30$	dey
     A8E7   10 DA       20493   	bpl 10$
                        20494   
                        20495   ; check light pen
                        20496   
     A8E9   4A          20497   	lsr a
     A8EA   90 18       20498   	bcc music_irq
                        20499   
     A8EC   AD D013     20500   	lda vic+19		;save x pos'n,
     A8EF   8D 11E9     20501   	sta vic_save+19
     A8F2   AD D014     20502   	lda vic+20		;..and y, too!
     A8F5   8D 11EA     20503   	sta vic_save+20
                        20504   
     A8F8   AD 127F     20505   	lda intval		;is BASIC interested in our little find?
     A8FB   29 04       20506   	and #4
     A8FD   F0 05       20507   	beq music_irq		;hey, no big deal.
                        20508   
     A8FF   A9 FF       20509   	lda #$ff
     A901   8D 1278     20510   	sta int_trip_flag+2	;let BASIC know we caught one.
                        20511   	

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 228
Basic's Interrupt Code   IRQ.SRC

Error Addr  Code          Seq   Source statement

                        20513   ; play music, if in progress
                        20514   
     A904               20515   music_irq
                        20516   
     A904   A2 00       20517   	ldx #0
     A906   BD 1224     20518   100$	lda voices+1,x
     A909   30 27       20519   	bmi 110$		;skip if not active
                        20520   
     A90B   BD 1223     20521   	lda voices,x
     A90E   38          20522   	sec
     A90F   ED 1222     20523   	sbc tempo_rate		;decrement current value by current tempo
     A912   9D 1223     20524   	sta voices,x
     A915   B0 1B       20525   	bcs 110$
     A917   BD 1224     20526   	lda voices+1,x
     A91A   E9 00       20527   	sbc #0
     A91C   9D 1224     20528   	sta voices+1,x
     A91F   B0 11       20529   	bcs 110$		;ok, no underflow
                        20530   
     A921   8A          20531   	txa
     A922   4A          20532   	lsr a			;get offset to waveform
     A923   A8          20533   	tay
     A924   B9 1230     20534   	lda wave0,y		;get waveform
     A927   29 FE       20535   	and #$fe		;mask out gate bit
     A929   48          20536   	pha
     A92A   B9 70D6     20537   	lda offtab,y		;get offset to correct oscillator
     A92D   A8          20538   	tay
     A92E   68          20539   	pla
     A92F   99 D404     20540   	sta sid+4,y		;turn off sound
                        20541   
     A932   E8          20542   110$	inx
     A933   E8          20543   	inx
     A934   E0 06       20544   	cpx #6
     A936   D0 CE       20545   	bne 100$		;loop for 3 voices
                        20546   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 229
Basic's Interrupt Code   IRQ.SRC

Error Addr  Code          Seq   Source statement

                        20548   
                        20549   ; test if SOUND command wants anything
                        20550   
     A938               20551   sound_irq
                        20552   
     A938   A0 02       20553   	ldy #2			;test three voices
     A93A   B9 1285     20554   10$	lda sound_time_hi,y	;active if msb clear
     A93D   10 06       20555   	bpl 12$
     A93F   88          20556   11$	dey
     A940   10 F8       20557   	bpl 10$
     A942   4C AA00     20558   	jmp basic_irq_end
                        20559   
     A945   18          20560   12$	clc			;add step to frequency
                        20561   
     A946   B9 129D     20562   	lda sound_freq_lo,y
     A949   79 1297     20563   	adc sound_step_lo,y
     A94C   99 129D     20564   	sta sound_freq_lo,y
                        20565   
     A94F   B9 12A0     20566   	lda sound_freq_hi,y
     A952   79 129A     20567   	adc sound_step_hi,y
     A955   99 12A0     20568   	sta sound_freq_hi,y
                        20569   
     A958   B9 1294     20570   	lda sound_direction,y	;test if this is up or down
     A95B   AA          20571   	tax
     A95C   29 01       20572   	and #1
     A95E   F0 2E       20573   	beq 20$			;branch if up
                        20574   
                        20575   ; if step direction is down, .C==0 OR freq < min  ==> reset value
                        20576   
     A960   90 0F       20577   	bcc 13$			;underflow, reset
                        20578   
     A962   38          20579   	sec
     A963   B9 129D     20580   	lda sound_freq_lo,y
     A966   F9 128E     20581   	sbc sound_min_lo,y
     A969   B9 12A0     20582   	lda sound_freq_hi,y
     A96C   F9 1291     20583   	sbc sound_min_hi,y
     A96F   B0 4D       20584   	bcs 40$			;no borrow, don't reset
                        20585   
     A971   E0 02       20586   13$	cpx #2			;is 'cycle' bit set?
     A973   90 0A       20587   	bcc 15$			;no, keep direction 'down'
                        20588   
     A975   20 A9EA     20589   	jsr negate_step		;make step 2's comp
     A978   A9 02       20590   	lda #%10		;change direction to 'up'
     A97A   99 1294     20591   	sta sound_direction,y
     A97D   D0 33       20592   	bne 35$			;go reset for 'up'
                        20593   
     A97F   B9 1288     20594   15$	lda sound_max_lo,y	;reset to max
     A982   99 129D     20595   	sta sound_freq_lo,y
     A985   B9 128B     20596   	lda sound_max_hi,y
     A988   99 12A0     20597   	sta sound_freq_hi,y
                        20598   
     A98B   4C A9BE     20599   	jmp 40$			;go update SID frequency
                        20600   
                        20601   ; if step direction is up, overflow (.C==1) OR freq > max ==> reset frequency
                        20602   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 229-1
Basic's Interrupt Code   IRQ.SRC

Error Addr  Code          Seq   Source statement

     A98E   B0 14       20603   20$	bcs 30$			;overflow, must reset
                        20604   
     A990   B9 12A0     20605   	lda sound_freq_hi,y	;16 bit compare (yech!)
     A993   D9 128B     20606   	cmp sound_max_hi,y
     A996   90 26       20607   	bcc 40$			; freq < max, no reset
     A998   D0 0A       20608   	bne 30$			; freq > max, reset
     A99A   B9 129D     20609   	lda sound_freq_lo,y	; msb's the same, test lsb's
     A99D   D9 1288     20610   	cmp sound_max_lo,y
     A9A0   90 1C       20611   	bcc 40$			; freq < max, no reset
     A9A2   F0 1A       20612   	beq 40$			; freq = max, no reset
                        20613   
     A9A4   E0 02       20614   30$	cpx #2			;is this 'cycle'?
     A9A6   90 0A       20615   	bcc 35$			;no, go reset for next 'up'
                        20616   
     A9A8   20 A9EA     20617   	jsr negate_step		;make step 2's comp
     A9AB   A9 03       20618   	lda #%11		;change direction to 'down'
     A9AD   99 1294     20619   	sta sound_direction,y
     A9B0   D0 CD       20620   	bne 15$			;go reset for next 'down'
                        20621   
     A9B2   B9 128E     20622   35$	lda sound_min_lo,y	;set freq to minimum value
     A9B5   99 129D     20623   	sta sound_freq_lo,y
     A9B8   B9 1291     20624   	lda sound_min_hi,y
     A9BB   99 12A0     20625   	sta sound_freq_hi,y
                        20626   
                        20627   ; update SID's frequency registers
                        20628   
     A9BE   BE 70D6     20629   40$	ldx offtab,y		;get index to sid voices
     A9C1   B9 129D     20630   	lda sound_freq_lo,y
     A9C4   9D D400     20631   	sta sid,x
     A9C7   B9 12A0     20632   	lda sound_freq_hi,y
     A9CA   9D D401     20633   	sta sid+1,x
                        20634   
                        20635   ; decrement total time - see if it's time to bring down the curtain
                        20636   
     A9CD   98          20637   	tya
     A9CE   AA          20638   	tax
     A9CF   BD 1282     20639   	lda sound_time_lo,x	;16 bit decrement - not very pretty
     A9D2   D0 03       20640   	bne 50$
                        20641   
     A9D4   DE 1285     20642   	dec sound_time_hi,x
     A9D7   DE 1282     20643   50$	dec sound_time_lo,x
                        20644   
     A9DA   BD 1285     20645   	lda sound_time_hi,x	;underflow?
     A9DD   10 08       20646   	bpl 60$			;nope
                        20647   
                        20648   ; time to turn off this voice
                        20649   
     A9DF   A9 08       20650   	lda #$08
     A9E1   BE 70D6     20651   	ldx offtab,y
     A9E4   9D D404     20652   	sta sid+4,x
     A9E7   4C A93F     20653   60$	jmp 11$
                        20654   
     A9EA               20655   negate_step
     A9EA   B9 1297     20656   	lda sound_step_lo,y
     A9ED   49 FF       20657   	eor #$ff

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 229-2
Basic's Interrupt Code   IRQ.SRC

Error Addr  Code          Seq   Source statement

     A9EF   18          20658   	clc
     A9F0   69 01       20659   	adc #1
     A9F2   99 1297     20660   	sta sound_step_lo,y
                        20661   
     A9F5   B9 129A     20662   	lda sound_step_hi,y
     A9F8   49 FF       20663   	eor #$ff
     A9FA   69 00       20664   	adc #0
     A9FC   99 129A     20665   	sta sound_step_hi,y
     A9FF   60          20666   	rts
                        20667   
                        20668   
                        20669   
                        20670   
     AA00               20671   basic_irq_end
     AA00   CE 12FD     20672   	dec irq_wrap_flag	;open the door to new irq's
     AA03   60          20673   	rts

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 230
Basic's Interrupt Code   IRQ.SRC

Error Addr  Code          Seq   Source statement

                        20675   
                        20676   ; update sprite position subroutine
                        20677   
     AA04   48          20678   sprsub	pha			;save angle phase
     AA05   18          20679   	clc
     AA06   BD 1181     20680   	lda sprite_data+3,x
     AA09   7D 1185     20681   	adc sprite_data+7,x
     AA0C   9D 1185     20682   	sta sprite_data+7,x
     AA0F   BD 1182     20683   	lda sprite_data+4,x	;add high bytes
     AA12   7D 1186     20684   	adc sprite_data+8,x
     AA15   9D 1186     20685   	sta sprite_data+8,x
     AA18   68          20686   	pla			;get angle sign
     AA19   90 13       20687   	bcc 30$			;skip if no carry - do not update position
     AA1B   4A          20688   	lsr a
     AA1C   4A          20689   	lsr a			;test if positive or negative
     AA1D   B9 11D6     20690   	lda vic_save,y
     AA20   B0 05       20691   	bcs 10$			;skip if negative
     AA22   69 01       20692   	adc #1			;increment position
     AA24   4C AA2B     20693   	jmp 20$
                        20694   
     AA27   E9 01       20695   10$	sbc #1			;decrement position
     AA29   C9 FF       20696   	cmp #$ff		;set carry if underflow
     AA2B   99 11D6     20697   20$	sta vic_save,y		;decrement position
     AA2E   60          20698   30$	rts
                        20699   
                        20700   ;end
                        20701   	.include stash

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 231
STASH Command   STASH.SRC

Error Addr  Code          Seq   Source statement

                        20703   	.subttl STASH Command
                        20704   
                        20705   ;	STASH Command - set up for call to kernal dma routine
                        20706   
     AA2F   A9 84       20707   stash	lda #$84
     AA31   4C AA3B     20708   	jmp swap_01		;pass the buck
                        20709   
                        20710   ;end
                        20711   	.include fetch

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 232
FETCH Command   FETCH.SRC

Error Addr  Code          Seq   Source statement

                        20713   	.subttl FETCH Command
                        20714   
                        20715   ; Fetch - set up for call to kernal routine
                        20716   
     AA34   A9 85       20717   fetch	lda #$85
     AA36   4C AA3B     20718   	jmp swap_01
                        20719   
                        20720   ;end
                        20721   	.include swap

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 233
SWAP Command   SWAP.SRC

Error Addr  Code          Seq   Source statement

                        20723   	.subttl SWAP Command
                        20724   
                        20725   ; set up for call to kernal routine
                        20726   ;
                        20727   ;	syntax SWAP length,c128_address,ramdisk_address,ramdisk_bank
                        20728   ;
                        20729   ;	c128_bank is that assigned by the BANK command
                        20730   
     AA39   A9 86       20731   swap	lda #$86
                        20732   
     AA3B               20733   swap_01
     AA3B   48          20734   	pha			;save command
     AA3C   20 8812     20735   	jsr getwrd		;get length
     AA3F   20 A855     20736   	jsr put_io_in_map
     AA42   8C DF07     20737   	sty _dma+7
     AA45   8D DF08     20738   	sta _dma+8
                        20739   
     AA48   20 880F     20740   	jsr comwrd		;eat comma, get c128 address
     AA4B   20 A855     20741   	jsr put_io_in_map
     AA4E   8C DF02     20742   	sty _dma+2
     AA51   8D DF03     20743   	sta _dma+3
                        20744   
     AA54   20 880F     20745   	jsr comwrd		;eat comma, get ramdisk address
     AA57   20 A855     20746   	jsr put_io_in_map
     AA5A   8C DF04     20747   	sty _dma+4
     AA5D   8D DF05     20748   	sta _dma+5
                        20749   
     AA60   20 8809     20750   	jsr combyt		;eat comma, get bank number
     AA63   E0 10       20751   	cpx #16
     AA65   B0 0E       20752   	bcs 20$
     AA67   20 A855     20753   	jsr put_io_in_map
     AA6A   8E DF06     20754   	stx _dma+6
                        20755   
     AA6D   68          20756   	pla			;restore command
     AA6E   A8          20757   	tay
     AA6F   AE 03D5     20758   	ldx current_bank
     AA72   4C FF50     20759   	jmp _do_dma
                        20760   
     AA75   4C 7DC5     20761   20$	jmp fcerr		;illegal value error
                        20762   ;end
                        20763   	.include graphic80		;c256

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 234
GRAPHIC80 for c256   GRAPHIC80.SRC

Error Addr  Code          Seq   Source statement

                        20765   	.subttl GRAPHIC80 for c256
                        20766   
                        20767   ;*************************************************************
                        20768   ;
                        20769   ;  Collection of perverse wedges for c256 demo
                        20770   ;
                        20771   ;*****************************************************************
                        20772   
            =CDCA       20773   vdcput	= $cdca			;editor routine: update 8563 reg #31 with .A
            =CDCC       20774   vdcout	= $cdcc			;editor routine: update 8563 reg .X  with .A
            =CDD8       20775   vdcget	= $cdd8			;editor routine: read   8563 reg #31 into .A
            =CDDA       20776   vdcin	= $cdda			;editor routine: read   8563 reg .X  into .A
                        20777   
                        20778   
     AA78               20779   plot_80				;plot a point on 8563 bit map
     AA78   20 AB3E     20780   	jsr calc_grapnt		;calc grapnt, read byte, bit offset in .Y
     AA7B   90 01       20781   	bcc 1$
     AA7D   60          20782   	rts
                        20783   
     AA7E   19 9D25     20784   1$	ora rbits,y		;set bit
     AA81   A6 83       20785   	ldx colsel
     AA83   D0 03       20786   	bne 10$			;...branch if bit to be set
     AA85   59 9D25     20787   	eor rbits,y		;...else bit to be cleared
                        20788   
     AA88   20 AB71     20789   10$	jsr put_grapnt		;update bit map at grapnt
                        20790   				;fall into color_80 to color the square & rts
                        20791   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 235
GRAPHIC80 for c256   GRAPHIC80.SRC

Error Addr  Code          Seq   Source statement

     AA8B               20793   color_80
     AA8B   AD 1133     20794   	lda ypos		;convert (xpos,ypos) to absolute color address
     AA8E   A0 00       20795   	ldy #0
     AA90   20 ABA5     20796   	jsr div80		; Y = ypos/8 * 80
     AA93   20 AB89     20797   	jsr mul80
     AA96   85 59       20798   	sta tempf1
     AA98   84 5E       20799   	sty tempf2
     AA9A   AD 1131     20800   	lda xpos
     AA9D   AC 1132     20801   	ldy xpos+1
     AAA0   20 ABA5     20802   	jsr div80		; X = xpos/8
     AAA3   18          20803   	clc
     AAA4   65 59       20804   	adc tempf1
     AAA6   85 8C       20805   	sta grapnt		; ADR = Y + X + offset to color map
     AAA8   A5 5E       20806   	lda tempf2
     AAAA   69 C0       20807   	adc #>$c000		;offset
     AAAC   85 8D       20808   	sta grapnt+1
                        20809   
     AAAE   AD 03E2     20810   	lda fg_bg		;get color spec: must swap nybbles for 8563!
     AAB1   A6 83       20811   	ldx colsel		;want fg or bg?
     AAB3   F0 0A       20812   	beq 10$			;...bg
     AAB5   4A          20813   	lsr a			;...fg
     AAB6   4A          20814   	lsr a
     AAB7   4A          20815   	lsr a
     AAB8   4A          20816   	lsr a
     AAB9   AA          20817   	tax			;convert to 8563 colors
     AABA   BD CE5C     20818   	lda $ce5c,x
     AABD   10 0A       20819   	bpl 20$			;bra
                        20820   
     AABF   29 0F       20821   10$	and #$0f
     AAC1   AA          20822   	tax
     AAC2   BD CE5C     20823   	lda $ce5c,x
     AAC5   0A          20824   	asl a
     AAC6   0A          20825   	asl a
     AAC7   0A          20826   	asl a
     AAC8   0A          20827   	asl a
     AAC9   85 77       20828   20$	sta z_p_temp_1
                        20829   
     AACB   20 AB6B     20830   	jsr get_grapnt		;get the current bg/fg colors at (grapnt) in .A
     AACE   A6 83       20831   	ldx colsel		;want fg or bg??
     AAD0   F0 03       20832   	beq 30$			;...bg
     AAD2   29 F0       20833   	and #$f0		;want fg, preserve bg
     AAD4   2C          20834   	.byte $2c
     AAD5   29 0F       20835   30$	and #$0f
     AAD7   05 77       20836   	ora z_p_temp_1		;merge
                        20837   
     AAD9   4C AB71     20838   	jmp put_grapnt		;update 8563 color at (grapnt) per .A & rts
                        20839   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 236
GRAPHIC80 for c256   GRAPHIC80.SRC

Error Addr  Code          Seq   Source statement

     AADC               20841   read_80
     AADC   20 AB3E     20842   	jsr calc_grapnt		;calc grapnt, read byte, bit offset in .Y
     AADF   B0 5C       20843   	bcs rts_80		;...off screen
     AAE1   39 9D25     20844   	and rbits,y		;get the bit
     AAE4   48          20845   	pha
     AAE5   98          20846   	tya			;tyx
     AAE6   AA          20847   	tax
     AAE7   68          20848   	pla
     AAE8   4C 9C5C     20849   	jmp readlp		;continue normal 'readpt'
                        20850   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 237
GRAPHIC80 for c256   GRAPHIC80.SRC

Error Addr  Code          Seq   Source statement

     AAEB               20852   scnclr_80
     AAEB   20 A855     20853   	jsr put_io_in_map	;put IO into map
     AAEE   A2 13       20854   	ldx #19
     AAF0   A9 00       20855   	lda #<$8000		;point to start of bit map
     AAF2   20 CDCC     20856   	jsr vdcout
     AAF5   CA          20857   	dex
     AAF6   A9 80       20858   	lda #>$8000
     AAF8   20 CDCC     20859   	jsr vdcout
     AAFB   A9 00       20860   	lda #0			;clear the 8563 bit map
     AAFD   20 CDCA     20861   	jsr vdcput
     AB00   A0 3F       20862   	ldy #$3f		;# pages:  16k bit map
     AB02   20 AB33     20863   	jsr wipe_80
                        20864   
                        20865   
     AB05   AD 03E2     20866   	lda fg_bg		;current color spec: must swap nybbles for 8563!
     AB08   29 0F       20867   	and #$0f
     AB0A   AA          20868   	tax			;convert to 8563 colors
     AB0B   BD CE5C     20869   	lda $ce5c,x
     AB0E   0A          20870   	asl a
     AB0F   0A          20871   	asl a
     AB10   0A          20872   	asl a
     AB11   0A          20873   	asl a
     AB12   85 77       20874   	sta z_p_temp_1
     AB14   AD 03E2     20875   	lda fg_bg
     AB17   4A          20876   	lsr a
     AB18   4A          20877   	lsr a
     AB19   4A          20878   	lsr a
     AB1A   4A          20879   	lsr a
     AB1B   AA          20880   	tax			;convert to 8563 colors
     AB1C   BD CE5C     20881   	lda $ce5c,x
     AB1F   05 77       20882   	ora z_p_temp_1
     AB21   20 CDCA     20883   	jsr vdcput		;clear the 8563 attributes
     AB24   A2 13       20884   	ldx #19
     AB26   A9 00       20885   	lda #<$c000		;point to start of bit map
     AB28   20 CDCC     20886   	jsr vdcout
     AB2B   CA          20887   	dex
     AB2C   A9 C0       20888   	lda #>$c000
     AB2E   20 CDCC     20889   	jsr vdcout
     AB31   A0 08       20890   	ldy #$08		;# of pages: 2k attributes,  fall into wipe_80
                        20891   	
                        20892   
     AB33               20893   wipe_80				;init .Y pages of 8563 ram
     AB33   A2 1E       20894   	ldx #30
     AB35   A9 00       20895   	lda #0			;a page at a time
     AB37   20 CDCC     20896   10$	jsr vdcout
     AB3A   88          20897   	dey
     AB3B   D0 FA       20898   	bne 10$			;...loop until done
     AB3D   60          20899   rts_80	rts
                        20900   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 238
GRAPHIC80 for c256   GRAPHIC80.SRC

Error Addr  Code          Seq   Source statement

     AB3E               20902   calc_grapnt
     AB3E   38          20903   	sec			;convert (xpos,ypos) to absolute bit map address
     AB3F   AD 1134     20904   	lda ypos+1
     AB42   D0 F9       20905   	bne rts_80		;...off screen!
     AB44   AD 1133     20906   	lda ypos
     AB47   C9 C8       20907   	cmp #200
     AB49   B0 F2       20908   	bcs rts_80		;...off screen!
     AB4B   20 AB89     20909   	jsr mul80		; Y = ypos*80
     AB4E   85 59       20910   	sta tempf1
     AB50   84 5E       20911   	sty tempf2
     AB52   AD 1131     20912   	lda xpos
     AB55   AC 1132     20913   	ldy xpos+1
     AB58   20 ABA5     20914   	jsr div80		; X = xpos/8	(.Y = remainder = offset into byte)
     AB5B   C9 50       20915   	cmp #80
     AB5D   B0 DE       20916   	bcs rts_80		;off screen!
     AB5F   18          20917   	clc
     AB60   65 59       20918   	adc tempf1
     AB62   85 8C       20919   	sta grapnt		; ADR = Y + X + offset to bit map
     AB64   A5 5E       20920   	lda tempf2
     AB66   69 80       20921   	adc #>$8000		;offset
     AB68   85 8D       20922   	sta grapnt+1
     AB6A   18          20923   	clc			;...grapnt = byte in bit map,  .Y=bit offset in byte
                        20924   				;...fall into get_grapnt to read the byte
                        20925   
                        20926   
                        20927   
     AB6B               20928   get_grapnt
     AB6B   20 AB79     20929   	jsr set_grapnt		;setup address
     AB6E   4C CDD8     20930   	jmp vdcget		;read the byte into .A & rts
                        20931   
                        20932   
                        20933   
     AB71               20934   put_grapnt
     AB71   48          20935   	pha
     AB72   20 AB79     20936   	jsr set_grapnt		;setup address
     AB75   68          20937   	pla
     AB76   4C CDCA     20938   	jmp vdcput		;store the byte & rts
                        20939   
                        20940   
                        20941   
     AB79               20942   set_grapnt
     AB79   20 A855     20943   	jsr put_io_in_map
     AB7C   A2 12       20944   	ldx #18			;point 8563 update address at (grapnt)
     AB7E   A5 8D       20945   	lda grapnt+1
     AB80   20 CDCC     20946   	jsr vdcout
     AB83   E8          20947   	inx
     AB84   A5 8C       20948   	lda grapnt
     AB86   4C CDCC     20949   	jmp vdcout		;rts
                        20950   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 239
GRAPHIC80 for c256   GRAPHIC80.SRC

Error Addr  Code          Seq   Source statement

                        20952   ;	MULTIPLY by 80	(.A * 80 --> 16-bit product)
                        20953   ;
                        20954   ;	result in (.a/.y) = (lo/hi), .x preserved
                        20955   
     AB89   85 8E       20956   mul80	sta vtemp1	;multiplier
     AB8B   A9 00       20957   	lda #0		;product lsb
     AB8D   85 8F       20958   	sta vtemp2	;product msb
     AB8F   A0 08       20959   	ldy #8		;# bits in multiplier
                        20960   
     AB91   0A          20961   10$	asl a		;shift product left 1 bit
     AB92   26 8F       20962   	rol vtemp2
     AB94   06 8E       20963   	asl vtemp1	;shift multiplier left
     AB96   90 07       20964   	bcc 20$
     AB98   18          20965   	clc
     AB99   69 50       20966   	adc #80		;add multiplicand to product
     AB9B   90 02       20967   	bcc 20$
     AB9D   E6 8F       20968   	inc vtemp2
                        20969   
     AB9F   88          20970   20$	dey
     ABA0   D0 EF       20971   	bne 10$		;...loop until done
     ABA2   A4 8F       20972   	ldy vtemp2	;...return .A=lsb .Y=msb
     ABA4   60          20973   	rts
                        20974   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 240
GRAPHIC80 for c256   GRAPHIC80.SRC

Error Addr  Code          Seq   Source statement

                        20976   ;	DIVIDE	by 8	(.A/.Y) / 8 --> 8-bit quotient in .A, remainder in .Y
                        20977   ;
                        20978   ;	result in .a, .x preserved
                        20979   ;
                        20980   ;div80	sta vtemp1	;dividend lsb
                        20981   ;	tya		;dividend msb
                        20982   ;	ldy #8		;# bits in divisor
                        20983   ;
                        20984   ;10$	asl vtemp1	;shift dividend and quotient left 1 bit
                        20985   ;	rol a
                        20986   ;	cmp #8
                        20987   ;	bcc 20$
                        20988   ;	sbc #8		;subtract divisor
                        20989   ;	inc vtemp1	;increment quotient
                        20990   ;
                        20991   ;20$	dey
                        20992   ;	bne 10$		;...loop until done
                        20993   ;	tay		;...return .Y=remainder
                        20994   ;	lda vtemp1	;...return .A=quotient
                        20995   ;	rts
                        20996   
     ABA5   85 8E       20997   div80	sta vtemp1	;divide (a,y) by 8, result in a, remainder in y
     ABA7   84 8F       20998   	sty vtemp2
     ABA9   46 8F       20999   	lsr vtemp2
     ABAB   66 8E       21000   	ror vtemp1
     ABAD   6A          21001   	ror a
     ABAE   46 8F       21002   	lsr vtemp2
     ABB0   66 8E       21003   	ror vtemp1
     ABB2   6A          21004   	ror a
     ABB3   46 8F       21005   	lsr vtemp2
     ABB5   66 8E       21006   	ror vtemp1
     ABB7   6A          21007   	ror a
     ABB8   4A          21008   	lsr a
     ABB9   4A          21009   	lsr a
     ABBA   4A          21010   	lsr a
     ABBB   4A          21011   	lsr a
     ABBC   4A          21012   	lsr a
     ABBD   A8          21013   	tay
     ABBE   A5 8E       21014   	lda vtemp1
     ABC0   60          21015   	rts
                        21016   
                        21017   ;	.end
                        21018   	.include patcheshi

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 241
PATCHES to BASIC ($8000-$AFFF)   PATCHESHI.SRC

Error Addr  Code          Seq   Source statement

                        21020   	.subttl  PATCHES to BASIC ($8000-$AFFF)
                        21021   
                        21022   ;  ROUND_QINT	fixes the infamous   INT(.9+.1) -> 0   Microsoft bug
                        21023   ;
                        21024   
     ABC1               21025   round_qint
     ABC1   20 8C47     21026   	jsr round	;must 'round' fac per 'facov'
     ABC4   4C 8CC7     21027   	jmp qint	;now int(fac)
                        21028   
                        21029   
                        21030   ;  USING_PATCH	fixes the infamous  $,999.99  print-using bug
                        21031   ;
                        21032   
     ABC7               21033   using_patch
     ABC7   20 42F0     21034   	jsr indfrm	;take a peek at the next character in the format string
     ABCA   C9 2C       21035   	cmp #','	;if it's a comma, we got problems
     ABCC   D0 07       21036   	bne 10$		;...branch if no comma & resume normal processing
                        21037   
     ABCE   AD 0133     21038   	lda blfd	;here's the bug fix:
     ABD1   20 98EB     21039   	jsr cdout	;print a 'fill' character instead of the '$'
     ABD4   C8          21040   	iny		;and increment format string pointer past comma
                        21041   
     ABD5   38          21042   10$	sec		;resume normal processing
     ABD6   6E 0125     21043   	ror dolr	;clear the dollar flag & go on to print '$'
     ABD9   60          21044   	rts
                        21045   	
                        21046   ;.end
                        21047   
            =FCDA       21048   	.ifge *-$af00			;make sure JUMPTABLE starts at $af00
                        21049   	.messg "*** ADDRESS CHECK ***"
                        21050   	.endif
            =AF00       21051   	*=$af00
                        21052   
                        21053   	.include jumptable

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 242
jump table   JUMPTABLE.SRC

Error Addr  Code          Seq   Source statement

                        21055   	.subttl jump table
                        21056   
                        21057   ; Format Conversions
                        21058   
     AF00   4C 84B4     21059   	jmp ayint	;convert f.p. to integer
     AF03   4C 79D9     21060   	jmp givayf	;convert integer to f.p.
     AF06   4C 8E42     21061   	jmp fout	;convert f.p. to ascii string
     AF09   4C 8052     21062   	jmp val_1	;convert ascii string to f.p.
     AF0C   4C 8815     21063   	jmp getadr	;convert f.p. to an address
     AF0F   4C 8C75     21064   	jmp floatc	;convert address to f.p.
                        21065   
                        21066   ; Math Functions
                        21067   
     AF12   4C 882E     21068   	jmp fsub	;MEM - FACC
     AF15   4C 8831     21069   	jmp fsubt	;ARG - FACC
     AF18   4C 8845     21070   	jmp fadd	;MEM + FACC
     AF1B   4C 8848     21071   	jmp faddt	;ARG - FACC
     AF1E   4C 8A24     21072   	jmp fmult	;MEM * FACC
     AF21   4C 8A27     21073   	jmp fmultt	;ARG * FACC
     AF24   4C 8B49     21074   	jmp fdiv	;MEM / FACC
     AF27   4C 8B4C     21075   	jmp fdivt	;ARG / FACC
     AF2A   4C 89CA     21076   	jmp log		;compute natural log of FACC
     AF2D   4C 8CFB     21077   	jmp int		;perform basic INT on FACC
     AF30   4C 8FB7     21078   	jmp sqr		;compute square root of FACC
     AF33   4C 8FFA     21079   	jmp negop	;negate FACC
     AF36   4C 8FBE     21080   	jmp fpwr	;raise ARG to the MEM power
     AF39   4C 8FC1     21081   	jmp fpwrt	;raise ARG to the FACC power
     AF3C   4C 9033     21082   	jmp exp		;compute EXP of FACC
     AF3F   4C 9409     21083   	jmp cos		;compute COS of FACC
     AF42   4C 9410     21084   	jmp sin		;compute SIN of FACC
     AF45   4C 9459     21085   	jmp tan		;compute TAN of FACC
     AF48   4C 94B3     21086   	jmp atn		;compute ATN of FACC
     AF4B   4C 8C47     21087   	jmp round	;round FACC
     AF4E   4C 8C84     21088   	jmp abs		;absolute value of FACC
     AF51   4C 8C57     21089   	jmp sign	;test sign of FACC
     AF54   4C 8C87     21090   	jmp fcomp	;compare FACC with MEM
     AF57   4C 8437     21091   	jmp rnd_0	;generate random f.p. number
                        21092   
                        21093   ; Movement
                        21094   
     AF5A   4C 8AB4     21095   	jmp conupk	;move RAM MEM to ARG
     AF5D   4C 8A89     21096   	jmp romupk	;move ROM MEM to ARG
     AF60   4C 7B22     21097   	jmp movfrm	;move RAM MEM to FACC
     AF63   4C 8BD4     21098   	jmp movfm	;move ROM MEM to FACC
     AF66   4C 8C00     21099   	jmp movmf	;move FACC to MEM
     AF69   4C 8C28     21100   	jmp movfa	;move ARG to FACC
     AF6C   4C 8C38     21101   	jmp movaf	;move FACC to ARG
                        21102   
                        21103   
     AF6F   4C 4845     21104   	jmp optab
     AF72   4C 9B30     21105   	jmp drawln
     AF75   4C 9BFB     21106   	jmp gplot
     AF78   4C 676D     21107   	jmp cirsub
     AF7B   4C 5AB8     21108   	jmp run
     AF7E   4C 5210     21109   	jmp runc

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page 242-1
jump table   JUMPTABLE.SRC

Error Addr  Code          Seq   Source statement

     AF81   4C 5215     21110   	jmp clear
     AF84   4C 51F3     21111   	jmp new
     AF87   4C 4F6C     21112   	jmp lnkprg
     AF8A   4C 4327     21113   	jmp crunch
     AF8D   4C 5081     21114   	jmp fndlin
     AF90   4C 4B13     21115   	jmp newstt
     AF93   4C 7974     21116   	jmp eval
     AF96   4C 788C     21117   	jmp frmevl
     AF99   4C 5AC3     21118   	jmp run_a_program
     AF9C   4C 5A9E     21119   	jmp setexc
     AF9F   4C 50BD     21120   	jmp linget
     AFA2   4C 92EA     21121   	jmp garba2
     AFA5   4C 4DEA     21122   	jmp execute_a_line
                        21123   ;end
                        21124   
            =FFA8       21125   	.ifge *-$b000			;make sure end of code doesn't overflow ROM
                        21126   	.messg "*** ADDRESS CHECK ***"
                        21127   	.endif
                        21128   
                        21129   
                        21130   	.subttl *************** cross reference *****************
                        21131   	.end

     No errors detected

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-1
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

ABS                 8C84           3226    15346#  21088   
ABSRTS              9DB6           18407   18419#  
ABSTW2              9DA5           18406#  18436   18464   
ABSTWO              9DA2           8114    8223    17926   18404#  
ADD1                97E9           17312   17319#  
ADDEND              002A           1584#   12801$  12823$  12827$  12845   12848   
ADDIND              7EAF           12779   12786#  
ADDOFF              A06B           18880   18885   18942#  
ADDON               52AF           4933#   4944    5628    5830    
ADDTW2              9D79           8572    18338   18352#  
ADDTWO              9D76           8064    8124    18349#  18688   
ADD_XAY_TO_SLEEP    6CB3           9604    9612    9630#   
ADRAY1              117A           1950#   2250$   2251$   
ADRAY2              117C           1951#   2255$   2256$   
AFFRTS              50B0           4502    4512#   
AFPLUS              9853           17383   17388#  
AFRM                982A           17366#  17441   
AHP                 96DE           17120   17122   17138#  
ALG                 97FB           17063   17333#  
ALINE1              4F56           4207#   4212    
ALINE2              4F61           4209    4215#   
ANA                 95F2           17010#  17024   
ANAF                98F2           16921   16987   17050   17485#  
ANDMSK              004B           1606#   9653$   9666    16246   16279$  16285   16326$  16335   16346   
ANDOP               4CA6           3278    3768#   
ANGBEG              115C           1871#   8553$   8554$   8567    8611    8612$   8614$   8616    8638    
ANGCNT              114E           1856#   7991    8142    8147$   8149$   8662$   8666$   8667$   8671$   8672$   17838$  17841$  
ANGD10              9AF8           17840#  17849   
ANGD20              9B0B           17820   17850#  
ANGDST              9AF3           8134    8584    8649    17837#  
ANGEND              115E           1872#   8557$   8558$   8566    8615    8623    
ANGLPT              6784           8170    8662#   
ANGM10              9AD4           17801   17803#  
ANGM20              9AEA           17811   17816#  
ANGM30              9AED           17815   17818#  
ANGMLT              9ACE           9842    17799#  17842   18649   
ANGSGN              1149           1853#   8013    8055    8075$   8079$   8135    8137$   8144    9815    17739$  17747$  17776   
                                   17804   
ANGVAL              9F32           17760   17761   18732#  
ANS010              9794           17258   17261#  
ANS020              9798           17260   17264#  
ANS1                A80D           20319#  20323   
ANS2                A816           20321   20325#  
ANS3                A81A           20313   20329#  
ANSUB               978B           17255#  17488   17495   17518   17555   17562   
APPEND              A144           3196    19101#  
ARE_YOU_SURE        A7F1           6324    19304   19334   19478   20311#  
ARGEXP              006A           1661#   3803    3804    11828$  14644   14645   14679   14681   15009$  15043$  15054   15276   
                                   15288$  15918   16021   16024$  
ARGHO               006B           1662#   3801    3802$   11830$  14741   14971   15006$  15040$  15140   15167$  15184   15186$  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-2
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

ARGLO               006E           1665#   11836$  14732   14962   14992$  15026$  15149   15164$  15175   15177$  
ARGMO               006D           1664#   3819    3820    3822$   3823$   3845    6857$   6875$   7023$   7040    7062    11834$  
                                   14735   14965   14995$  15029$  15146   15165$  15178   15180$  
ARGMOH              006C           1663#   11832$  14738   14968   14998$  15032$  15143   15166$  15181   15183$  
ARGSGN              006F           1666#   3799    11838$  14630   14655   15001$  15004   15035$  15038   15271   15578   15927   
                                   16743   
ARISGN              0070           1668#   11840$  12959$  12966   14631$  14676   15003$  15037$  15071   15097$  15118$  15580$  
                                   16035$  16748$  
ARYDON              7CDD           12363   12442#  
ARYGET              7C9B           12393   12396#  12437   12439   
ARYPNT              005A           1630#   12353$  12354$  12356   12357   12376   12377$  12380   12381$  12398   12400   12695   
                                   12697$  12700   12715$  12718$  12721$  12805   12808   12864$  12865$  
ARYTAB              0031           1590#   4829$   4830$   12240   12242   12325   12326   12344$  12345$  12573   12574   
ARYVA2              7C57           12355#  12383   12385   
ARYVA3              7C5B           12358#  12401   
ARYVGO              7C65           12360   12362   12365#  
ASC                 8677           3242    14248#  
ASPAC               55EC           5489    5503#   
ATKMUS              70AE           2388    10307#  
ATKTAB              123F           2018#   2389$   10105   10441   10505$  
ATN                 94B3           3237    16821#  21086   
ATN1                94BB           16824   16826#  
ATN2                94C9           16830   16834#  
ATN3                94DC           16840   16844#  
ATN4                94E2           16846   16849#  
ATNCON              94E3           16835   16836   16852#  
AUTINC              0074           1678#   2273$   2274$   4187    4188    4193    4196    6169$   6171$   6362$   6363$   
AUTO                5992           3153    6165#   
AVF1                9941           17525   17531#  
AYINT               84B4           3770    3778    5179    11899   13897   13909#  21059   
BACKUP              A38C           3179    19471#  
BAD_BAD_VALUE       69F2           9061    9075    9092    9095    9098#   
BAD_COMMAND         4863           3212    3218    3288#   7662    
BANK                6C66           3184    9567#   
BANK_0_TOP         =FF00           1514#   2319    2320    
BANK_1_TOP         =FF00           1515#   2324    2325    
BASBGN             =1C00           1513#   2271$   2308    
BASIC_IRQ           A85D           2194    20401#  
BASIC_IRQ_END       AA00           20558   20671#  
BASWRK             =1C01           2308#   2309    2310    
BEATS              =0480           1506#   2365    2366    10147   10149   
BEGFD               0134           1763#   17365   17491$  17500   17508   
BEGINTK            =0018           3065#   5002    5024    5083    5112    
BENDTK             =0019           3067#   5080    
BIGGES              8E97           15708   15727#  
BITCNT              1169           1933#   8428$   8440$   8445$   8505    
BITIDX              1161           1926#   8270$   8290    8305    
BITMSK              116D           1937#   11032$  11042   11045   18054$  18056   18061   18063$  18066   18093$  18095   
BITS                03DF           1813#   2267$   4863$   14821   15417$  15426$  15437$  
BLFD                0133           1762#   17008$  17378   17472   21038   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-3
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

BLOAD               A228           3199    19250#  
BLOAD_1             A22F           10923   19253#  
BLTLP               7D33           12496#  12500   
BLTU                7D03           12340   12468#  
BNKVEC              02FE           1775#   
BNR                 0123           1746#   16916$  17178   17304   17311   17337   17346$  17363   
BOOT                73D2           3209    10915#  
BOUT                9840           17372   17377#  17419   17464   
BOX                 62D4           3158    7966#   
BOX10               6301           7987#   7992    
BOX15               6304           7985    7989#   
BOX20               630C           7993#   8050    
BOX30               630E           7995#   7999    
BOXANG              1154           1901#   7972$   7973$   8107    
BOXF05              6325           8015    8017#   
BOXF10              6335           8024#   8027    
BOXF20              633B           8031#   8095    
BOXF25              633D           8033#   8037    
BOXF28              6349           8040#   8045    
BOXF30              6352           8046#   8084    
BOXF40              635C           8048    8051#   
BOXF45              636B           8057    8059#   
BOXF50              636D           8061#   8081    
BOXF60              637E           8069    8071#   
BOXF65              6389           8076    8078#   
BOXF70              6395           8085#   8094    
BOXF80              639F           8086    8088    8090#   
BOXFIL              631B           7984    8011#   
BOXP10              642D           8172#   8185    
BOXP20              6441           8177    8179    8181#   
BOXPNT              6428           7988    8140    8143    8169#   
BOXS10              63AF           8111#   8132    
BOXSUB              63A6           7982    8106#   
BOXTAB              640A           8139    8145    8148    8152#   
BREAK_EXIT          90D3           16108#  16148   
BSAVE               A1D8           3198    19207#  
BSERR               7DC2           12601#  12618   12770   
BSERR7              7E97           12763   12770#  
BUF                 0200           1769#   2292$   2293$   4281$   5458$   5460    5574    5575    5580$   5610$   5623    5686$   
                                   5688    
BUFFUL              56AA           5615    5618    5622#   
BUFLEN             =00A1           1496#   1769    4283    
BUMP                837C           3256    13651#  
BXLENG              115A           1904#   8019$   8021$   8047    8049$   8052$   
CALC_GRAPNT         AB3E           20780   20842   20902#  
CAT                 870D           11735   14377#  
CATALOG             A08E           3171    3194    18985#  
CBINV               0316           1787#   
CBN                 97CD           17300   17303#  
CDOUT               98EB           16952   17134   17396   17410   17413   17439   17473   17477#  21039   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-4
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

CFF                 9685           17055   17088#  
CFORM               0131           1760#   16926   17266$  17479$  17512$  17516$  17576$  
CFRE1               938F           16619   16624#  
CFRE2               9398           16626   16629#  
CFRE3               93A7           16635   16638#  16642   
CFRE4               93B1           16618   16621   16622   16646#  
CFRE4A              93B3           16648#  16652   16658   
CFRE4B              93C7           16650   16660#  
CGETL               9109           5680    5685    16146#  
CHANNL              0015           1573#   2209$   2268$   3920$   5417$   5464    5470    5540    5571$   5583    5590$   5593    
                                   5596$   5614    5625    5630    5697    5749    5755    5796    
CHAR                67F4           3157    8755#   
CHAR10              6820           8775    8779#   
CHAR20              6880           8806    8838#   
CHAR25              68A2           8849    8859#   
CHAR27              68AD           8851    8853    8855    8857    8861    8865#   
CHAR30              68B7           8870#   8893    8898    
CHAR50              68F4           8875    8900#   
CHARAC              0009           1559#   4543$   4562    4951$   4956    4957$   5714$   5716$   5720$   14294$  14306   
CHARACTER_ROM       1168           1932#   8841$   8885$   8944    10961$  
CHARER              681D           8770    8777#   
CHARGT              5DB9           6595    6675    6692    6696    6721    6723    6726    6730    6845    6902    6906    6929    
                                   6967    6993    6994#   
CHARGT_X2           5DB6           6673    6717    6893    6992#   
CHAR_PATCH          7F1F           8813    12881#  
CHEAD               4F75           4231#   4255    
CHGKEY              60FE           7622#   7656    
CHK1                A759           19298   19333   20207#  
CHK2                A760           19161   19188   19210   19253   20208   20212#  
CHK3                A76B           19414   20220#  
CHK4                A770           19438   19449   20225#  
CHK5                A776           19461   20228#  
CHK6                A77F           19088   19103   20235#  
CHKCLS              79F3           6105    11920#  12566   13399   13468   13525   13568   13618   13651   13696   13764   13798   
                                   13992   14207   17637   19955   19969   
CHKCOM              79F9           3689    5781    5972    7629    8786    9089    11522   11926#  13566   13694   14180   14548   
                                   14551   16311   18501   18535   18600   18617   
CHKCOM_1            6E63           9901    9933#   
CHKDS               7A80           12009   12038#  12105   
CHKER1              A75D           20209#  20215   20221   20226   20230   20237   
CHKERR              7884           6072    8210    11663   11667#  
CHKGRB              9383           16536   16589   16616#  
CHKK                996A           17554#  17560   
CHKNUM              7877           3727    3756    7164    11656#  11746   11820   13090   13173   13223   13757   13905   13991   
                                   14017   14026   14095   
CHKOK               7881           11664#  11666   
CHKOPN              79F6           3687    3739    6088    11918   11923#  13517   13987   19953   19967   
CHKSTR              787A           3690    6092    6110    11659#  14382   14451   16880   17624   
CHKVAL              787B           3797    5172    11657   11661#  
CHK_ESCAPE          5C5D           6747    6756#   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-5
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

CHK_QUOTE           5C30           6727#   6775    6798    
CHO                 97FF           17105   17336#  
CHOM                999B           17566   17579#  
CHOU                9823           17360   17362#  
CHOUT               981C           17085   17358#  
CHRD                85BF           3243    14109#  
CHRD1               85D1           13153   13191   14119#  
CHRDSP              68F8           8889    8915#   10973   10978   10992   11009   11058   11270   
CHRGET              0380           1793#   2263$   2667    2694    2734    2738    2778    3444    3464    3566    3576    3582    
                                   3666    3733    3738    3964    4566    5010    5013    5026    5027    5036    5079    5103    
                                   5142    5509    5564    5567    5706    5868    6067    6311    6314    6748    6759    6763    
                                   6774    6783    6807    6825    6871    7187    7312    7415    7512    7607    7658    8727    
                                   9425    9942    11725   11851   11865   11945   12195   12201   12224   13516   13902   14532   
                                   15633   16878   16997   18632   18671   19681   19718   19752   19754   19758   19817   19824   
                                   19827   19880   19950   19964   
CHRGET_PATTERN      4296           2261    2262    2512#   2523    
CHRGOT              0386           1794#   2663    3970    4987    4997    5015    5029    5425    5671    5741    5779    5831    
                                   5865    5975    6039    6065    6237    6419    6528    6881    7184    7227    7308    7350    
                                   7385    7459    7472    7504    8710    8715    8719    8780    9038    9655    9910    9934    
                                   11711   12182   12185   12561   12901   14068   14177   14540   16300   16313   16982   16992   
                                   17632   18499   18533   18559   18598   18623   18704   19640   19801   19863   
CHSN                012B           1754#   16922   16930   17535$  
CHX                 9589           16938#  16953   
CINV                0314           1786#   
CIRC10              6716           8569    8576#   
CIRC20              6718           8578#   8582    
CIRC30              6728           8590#   8594    
CIRC45              6746           8610#   8621    
CIRC50              6754           8613    8615#   
CIRCLE              66AB           3159    8529#   
CIRCLE_SEGMENT      1220           1995#   8607$   8610    
CIREND              6765           8618    8622#   
CIRS10              676F           8624    8640#   
CIRSUB              676D           8595    8619    8638#   21107   
CLD10               9133           16174#  19201   
CLD20               915F           16198   16201#  16220   16250   
CLD50               9160           16186   16207#  
CLD55               9169           16193   16213#  
CLD60               916C           16209   16215#  
CLD70               9184           16219   16229#  
CLEAR               5215           3139    4807#   21110   
CLEARC              5217           4808#   6418    
CLEAR_40            6B19           9260    9266    9314#   
CLEAR_80            6B05           9237    9239    9254    9300#   
CLEAR_FLAG          6F94           10078   10086   10093   10113   10128#  10137   
CLEAR_GRAPHICS      6B57           9289    9362#   10965   11018   
CLEAR_HIGH_COLOR    6B3E           9288    9344#   
CLEAR_PLAY_FLAGS    706B           9978    10258   10271#  
CLOSE               919A           3143    16244#  
CLRFAC              8D18           15410   15460#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-6
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

CLRHIR              A02B           9424    18902#  
CLRTK              =009C           2895#   2902    9421    
CMD                 555D           3140    5408    5411#   
CMDEND              772E           11100   11428#  
CMDSTR              771C           11100   11101   11424#  
CMO                 9802           17338#  17351   17398   17401   
CNCJ                9548           16900#  16906   
COIN                90FD           5572    5591    16140#  
COL00A              931D           16538#  16590   
COL01               9329           16537   16546#  
COL02               9333           16556#  16591   
COL02B              935C           16583#  16586   
COL03               936F           16548   16593#  
COLBYT              76AD           11120   11347   11368#  
COLBYT_1            76D1           11375   11377   11380   11387#  11461   
COLCNT              115E           1891#   8765$   8769    8771$   8811    8888    8890$   8895$   11079$  11122   11127   11185   
                                   11187$  11223   11227$  11234$  11256$  11408   
COLEND              7762           11087   11447#  
COLLECT             A33F           3176    19413#  
COLLISION           7201           3205    10533#  
COLLISION_IRQ       A8B6           20463#  
COLLISION_TK       =0017           3063#   6761    
COLNUM              7752           11087   11089   11443#  
COLOR               69FF           3164    9130#   
COLOR_80            AA8B           9546    20793#  
COLOR_RAM_HI       =D800           1522#   9352    18169   
COLOR_RAM_LO       =1C00           1521#   9373    9382$   11454   18190   18191   18192   18193   18194   18195   18196   18197   
                                   18198   18199   18200   18201   18202   18203   18204   18205   18206   18207   18208   18209   
                                   18210   18211   18212   18213   18214   
COLOR_VIC           9C79           2505    18130#  
COLSEL              0083           1703#   7776    8465$   8708$   8846    8961    18060   18072   18104   18136   18572$  20785   
                                   20811   20831   
COLTYP              1280           2032#   10539$  10542   
COLUMN_WIDTH       =000A           1498#   5485    
COLVAL              9F2E           11151   18062   18726#  
COM1                99AF           17497   17596#  
COM2                99B3           17532   17599#  
COMBYT              8809           6094    6100    8768    8773    9135    9657    10853   10858   10868   14547#  17635   20750   
COMMON_TOP         =0400           1516#   2314    2315    
COMP                99A7           17489   17591#  
COMPARE             5E0B           7043    7064    7073#   
COMPRT              55C6           5444    5481#   
COMWRD              880F           10689   10697   13763   14551#  19370   20740   20745   
CON1                97DA           17310#  17316   
CONCAT              A372           3201    19448#  
CONINT              87F7           11567   12943   13118   13261   13340   13400   13469   13559   13619   13652   13687   13799   
                                   14109   14535#  17867   
CONT                5A7D           3137    6341#   
CONT_RTS            5AB7           6341    6344    6374#   
CONUPK              8AB4           14625   14638   14926   15017#  15125   21095   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-7
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

CONV                95A0           16919   16956#  
CONV4               95BE           16973   16977#  
COOUT               90EB           5418    16128#  
COPFLT              5417           5177    5190#   
COPSTR              5421           5174    5196#   
COPY                54B1           5257    5260    5283#   8352    
COPYC               54CF           5264    5299#   
COPY_LINE           7700           11268   11419#  
CORDSB              9F11           18622   18674   18703#  
CORDSB_PATCH        6E5D           9918#   18712   
COS                 9409           3234    16723#  21083   
COSC                9481           16792   16797#  
COSVAL              114C           1855#   8054    8077    17802   
COUNT               000D           1563#   2726    2761    2815$   2832$   2846    2847$   3769$   3772    3775    3780    3782    
                                   3785    3787    3978$   3999    4073    4174    6037$   6049    6061$   6062    7022$   7037    
                                   7060    12560$  12562   12616   12667   12693$  12748$  12789$  12857   
CPEF                9591           16940   16946#  
CR                 =000D           1502#   2469    2469    2470    2471    2472    3638    3875    3875    4278    5468    5535    
                                   5761    5799    7740    11427   16200   16200   19062   19342   19353   20287   20320   
CRDO                55B5           3925    4585    4607    5427    5467#   6189    6194    6408    16995   
CRDSB1              9F1D           18706   18708   18710#  
CRFIN               55C3           5471    5474#   5537    
CRTSKP              5624           5541    5545#   
CRUN05              4330           2662#   2689    2736    
CRUN10              4336           2666#   2669    2677    2686    2698    2722    2733    2779    
CRUN20              4339           2664    2668#   
CRUN30              4353           2679    2682#   
CRUN40              4362           2684    2690#   
CRUN50              4366           2693#   2699    
CRUN75              43A3           2681    2728#   
CRUN80              43B8           2731    2738#   
CRUN90              43BE           2675    2696    2744#   
CRUN94              43CD           2709    2717    2761#   
CRUN95              43CF           2672    2762#   
CRUNCH              4327           2655#   3969    3977    21113   
CRUN_ESC            4373           2692    2702#   
CSCOL               9556           16904   16911#  
CURLIN              003B           1595#   3489$   3492$   3629    3630    3892    3941    3959$   4923$   5053$   5056$   5948$   
                                   5951$   6249    6251    6295    6298    6356$   6357$   6897$   6899$   7150    7153    7405$   
                                   7408$   7425$   7454    7537$   7540$   7576$   7577$   7603$   15664   15665   20379$  
CURPRT              8E2E           3526    15663#  
CURRENT_BANK        03D5           1809#   2296$   5991    9570$   9662    10925   13092   13110   19637   20758   
CURTOL              0072           1675#   12651$  12666$  12690$  12691$  12709$  12711   12719$  12750$  12752$  12776   12777   
                                   12788$  12791$  12840$  12841$  
D1PRA              =DC00           1537#   13352   13355$  13357   13358   13363$  13418   13420$  13440$  13442   13446$  13846   
                                   13848   13850   13852   
D1_6526            =DC00           1536#   1537    
D2PRA              =DD00           1541#   
D2_6526            =DD00           1540#   1541    
DATA                52AC           2735    3114    3207    4924    4931#   5006    5620    7416    7549    14004   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-8
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

DATAN               52BF           4932    4947#   5627    5814    7134    
DATATK             =0083           2732    2862#   2869    5833    
DATBK               571B           5692    5702#   
DATBK1              571F           5672    5705#   5835    
DATLIN              0041           1599#   5824$   5828$   
DATLOP              57E7           5695    5814#   5834    
DATPTR              0043           1600#   5637    5638    5788$   5789$   6457$   6458$   18832   18834$  18934   18936$  
DBANK               A5AE           19693   19882   19897#  
DBANK1              A452           19665   19693#  
DCAT1               A0A9           18997   19000#  
DCAT10              A124           19016   19033   19037   19068   19077#  
DCAT2               A0AA           18995   19001#  
DCAT3               A0D7           19028#  19073   
DCAT4               A103           19051#  19058   
DCAT5               A115           19056   19062#  
DCAT9               A123           19054   19075#  
DCLALL              A193           19147   19151#  19407   19482   
DCLEAR              A332           3203    19403#  
DCLOSE              A17F           3197    19141#  
DCML                8076           3252    13029#  
DCOPY               A356           3177    19430#  
DEC010              8083           13035#  13041   13070   
DEC030              80A9           13050   13057#  
DEC040              80B1           13064#  13069   
DEC050              80BB           13037   13072#  
DECBAD              80C2           13045   13048   13052   13054   13077#  
DECBLT              7D40           12481   12504#  
DECCNT              005F           1637#   1642    11998$  12829$  12852$  15482$  15535   15563$  15702$  15719$  15723$  15730   
                                   15745$  15804$  
DECCUR              7E52           12712   12717#  
DECY                9717           17177#  17191   
DEF                 84FA           3133    13985#  
DEF040              7534           11118#  11431   11431   11431   11431   
DEF044              757D           11142   11155#  
DEF046              7587           11153   11157   11160#  
DEF050              7591           11168#  11432   
DEF060              759B           11175#  11432   
DEF070              75A3           11181#  11433   
DEF080              75B9           11191#  11433   
DEF090              75BC           11194#  11433   
DEF100              75CD           11203#  11436   
DEF102              75D1           11206#  11208   
DEF110              75DC           11162   11215#  11434   
DEF120              75DF           11218#  11434   
DEF130              7604           11240#  11257   11435   
DEF140              7601           11238#  11435   
DEF150              7613           11250#  11437   
DEF155              761B           11228   11244   11246   11253#  
DEF160              761E           11226   11255#  11437   
DEFBEG              7461           11004#  11177   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-9
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

DEFFIN              85A0           14005   14076#  
DEFJMP              772E           11111   11113   11430#  
DEFMOD              12FA           2077#   11037$  11141   11161   11181   11183$  11219   11231   11250   11252$  11341   11372   
                                   11400   11409   
DEFPNT              0050           1614#   2576    14015$  14016$  14021   14023   14028$  14030$  14065$  14067$  14079$  
DEFSTF              8561           14041#  14045   
DEF_CLEAR           7771           11002   11210   11459#  
DEF_COPY            7625           11262#  11438   
DEGREE              0069           1657#   16073$  16096$  
DEJAVU              1221           1997#   
DEL1                A507           19686   19743   19798#  
DEL2                A578           19846   19849   19852   19861#  
DEL300              5ED1           7235    7242    7247#   
DEL500              5EEF           7265#   7271    
DELETE              5EA4           3180    7226#   
DELETE_PATCH        7F31           7270    12908#  
DELIM1              A50B           19682   19759   19771   19801#  
DESC_FREE           7836           11516   11566   11583#  
DEVN                96AF           17106   17111#  
DEVN2               96B2           17109   17113#  
DFLOOP              74F7           11081#  11096   11105   11163   11199   11253   11314   
DIDCHK              0122           1740#   19750   19757$  
DIM                 5898           3117    5973#   
DIM3                5895           5972#   5976    
DIMFLG              000E           1564#   12183$  12530   12572$  12610   12675   12731   
DIMRTS              7EDA           12732   12812#  
DIRIS               4BFE           3627    3633#   
DISEND              115C           1889#   17848   
DIV10               8B38           15112#  15540   15722   
DIV80               ABA5           20796   20802   20914   20997#  
DIVIDE              8B63           15139#  15170   
DIVNRM              8BB8           15158   15194#  
DIVPOS              9D2D           18050   18230   18276#  
DIVSUB              8B97           15162   15173#  
DLIMX1              A4D4           19769#  19780   
DLOAD               A1B7           3173    6401    19183#  
DLOOP               9BA5           17981#  18012   
DLOOP1              7506           11089#  11098   
DN20                A46A           19645   19708#  19751   
DNOTE               1233           2010#   10141$  10243   10274$  
DNTCPY              5493           5247    5252    5256    5261#   
DO                  5FFD           3168    7450#   7604    
DO10                6028           7462    7477#   
DOAGIN              5781           5756    5760#   
DOANG1              9EB6           18648#  18665   
DOANG2              9EC9           18655   18657#  
DOCHR0              6969           8957    8968    8971    8976    8982    8987#   
DOCMP               4D3B           3840    3842    3855    3860#   
DOCOLR              9C76           8916    18052   18128#  
DOCOR1              9EF7           18683#  18695   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-10
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

DOCOR2              9F08           18687   18692#  
DOCORD              9EDC           18625   18670#  
DOCRD1              9E8D           18627   18631#  
DOCSTR              7882           11662   11666#  
DOFFH               A4DA           19774#  19820   
DOFFL               A4C4           19670   19763#  
DOHEX               8174           13198   13201#  
DOHOME              74EF           11077#  11211   11436   
DOLR                0125           1748#   17283$  17359   17446   17543   17546$  21043$  
DOMASK              0014           1571#   3864    11826$  
DOMIN               7A0E           11873   11953#  
DONE                A3FA           19643#  19803   
DONE1               A510           19803#  19864   
DONO                6022           7472#   7479    7522    
DOP2                A153           19093   19095   19108#  
DOPEN               A12D           3195    19086#  
DOPEN_PATCH         A3C2           19116   19506#  
DOPRE1              790E           11750   11774#  
DOPREC              78E7           11747#  11773   
DOREL               4CD3           3286    3796#   
DORES               0011           1568#   4625$   4635    4637$   4655    
DOS01               A3DE           19629#  19631   
DOS02               A3E6           19633#  19636   
DOSBNK              011F           1737#   10929   19231   19269   19638$  19902$  
DOSCAL              9D63           18312   18317#  
DOSDID              0120           1739#   19308   19753$  19755$  20141   20144   
DOSDS1              0112           1724#   10937   19740$  20097   
DOSDS2              0114           1727#   19741$  19844$  20101   
DOSF1L              0111           1723#   19786$  19793   20170   20178   
DOSF2A              0115           1728#   19857$  19858$  20182   20184   
DOSF2L              0113           1726#   19856$  20186   20195   
DOSFA               011C           1733#   2279$   10939   19009   19151   19387$  19891$  20118   20265   20268$  
DOSLA               011B           1732#   19148   19368$  19381   19389$  19500   19705$  20117   
DOSLFN             =0000           18973#  19010   19023   19078   19613   20270   20278   20296   
DOSOFH              0119           1731#   19218   19222   19240   19241   19777$  19778$  
DOSOFL              0117           1730#   19219   19223   19235   19236   19255   19256   19274   19275   19632   19634$  19766$  
                                   19767$  
DOSPAR              A3CF           18986   19297   19332   19403   19413   19430   19448   19616#  
DOSPRS              A3D1           19087   19102   19143   19160   19187   19460   19472   19618#  
DOSPRX              A3D3           10917   19209   19252   19620#  
DOSRCL              011E           1736#   19379$  19725$  20093   20148   20153$  
DOSSA               011D           1734#   19131$  19191$  19263$  19391$  19632   20119   
DOSSA_TEMP          11ED           1960#   19385$  20128   
DOSSPC             =0023           1742#   19628   
DOSSTR              1100           1827#   20104$  20113   20114   20142$  20162$  20175$  20192$  
DOSTBL              A3C8           19613#  19633   
DOTK               =00EB           3002#   3004    7497    7519    7565    
DOTWO               9D74           8668    18340#  18658   
DOTWO2              9D70           8673    18337#  
DOVERR              8B33           15107#  15127   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-11
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

DOYES               602F           7460    7470    7481#   
DO_ESC_FN           4C71           3657    3732#   
DO_RTS              4C13           3625    3642#   
DPTFLG              0061           1639#   15528$  15529   15561   
DRAW                67B4           3162    8705#   
DRAWLN              9B30           7990    8038    8620    8625    8732    17919#  21105   
DRV1                A48F           19661   19735#  
DRV2                A54A           19829   19839#  
DRW01               9B34           17922#  17947   
DRW02               9B49           17927   17931#  
DRW03               9B51           17932   17935#  
DRW04               9B54           17930   17934   17936#  
DRW05               9BC1           17988   17992   17995#  
DRW06               9BCF           17998   18002#  
DRWIN1              9BED           18018#  18023   
DRWINC              9BEA           17999   18011   18016#  
DSAVE               A19C           3172    19159#  
DSCHK               9243           16131   16142   16161   16181   16238   16249   16358#  19279   
DSCPNT              0052           1615#   2582    5287    5288    5300$   5301$   5336    14143   14144   14217$  14219$  14270$  
                                   14271$  14400   14401   
DSCTMP              0063           1647#   3816$   3817$   3818$   3826    3830    3848    5297    5298    8303$   8332$   8340    
                                   8342    13148$  13206$  14117$  14274$  14275$  14276$  14299$  14300$  14316$  14352   14354   
                                   14356   16974$  
DSDESC              007A           1689#   4810$   5271    5277    5279    5374    5376    12013   12024   12038   12107   12117   
                                   19318   19346   20249   20252$  20254$  20255$  20258   20259$  20261   20262$  20289$  20294$  
                                   20340   20345$  20348$  20352$  
DSKX1               5475           5242#   5278    5280    
DSKX2               5477           5245#   5272    
DSTMOV              9E02           8228    18475   18477#  
DSTPOS              9DFB           7765    7902    8141    8353    8420    8596    8735    9013    18473#  
DVARTS              7CD0           12405   12433#  
DVERIFY             A1B4           3202    19177#  
EADJ                973F           17189   17209#  
EADO                973D           17168   17207#  17345   
EATEM               7B71           12201#  12202   12204   
ECHKS               A7A5           20250   20265#  
EEX2                9558           16913#  16984   
EFO                 99A0           17519   17563   17583#  
ELSE                53AE           3146    5108#   
ELSETK             =00D5           2977#   2979    3551    3553    3591    5011    6512    
END                 4BEA           3111    3624#   
ENDCHR              000A           1560#   4536$   4541$   4953$   4955    4958$   4961    5723$   6244    6535    7316    14295$  
                                   14308   
ENDFD               0136           1765#   16877$  17414   17486   17575$  17584$  17585$  
ENDMOV              42EB           2261    2569#   
ENDREL              78C5           11715   11717   11727#  
ENDTK              =0080           2856#   2858    3556    3591    
ENR                 0124           1747#   17030$  17058   17160   17299   17315$  17347   17427   
ENVELOPE            715E           3192    10433#  
EOA                 9631           17018   17045#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-12
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

EORMSK             =004C           1608#   9658$   9665    16333$  16345   
EQULTK             =00B2           2929#   2931    5163    6106    13993   
ERBRK              =001E           3350#   3617    16109   
EREAD               A7AF           20266   20269#  
EREXIT              90D0           10945   16106#  16119   16124   16136   16143   16162   16252   19282   19510   
EREXIY              90D5           16107   16110#  
ERLOAD             =001D           3348#   16212   
ERO                 993E           17529#  17556   17558   17573   
ERR01               4868           3295#   3384    3386    
ERRBAD              A7E5           20280   20300#  
ERRBD              =0018           3338#   5757    
ERRBDK             =0024           3362#   19323   
ERRBS              =0012           3326#   12601   
ERRCHL              A788           12040   19313   19339   20249#  
ERRCN              =001A           3342#   6346    
ERRCR              =001F           3352#   7442    
ERRD                80F6           3254    13118#  
ERRDD              =0013           3328#   12609   
ERRDIR              84D9           5558    5608    7349    7381    13941#  13986   
ERRDVO             =0014           3330#   15108   
ERREND              A7D8           20288   20292#  20302   
ERRERR              8136           13122   13155#  
ERRF                96D6           17072   17076   17117   17124   17131#  
ERRFC              =000E           3318#   12604   
ERRFIN              4DCC           3639    3941#   
ERRFNF             =0004           3301#   19398   
ERRGO3              7DC7           12605#  12611   
ERRGUF              84E0           13945#  14037   
ERRID              =0015           3332#   13943   
ERRIND              84F0           6166    6515    7226    13960#  
ERRISD              4D99           3889    3901    3914#   
ERRLEN              A5FD           4285    8300    14394   19931   19943#  
ERRLIN              1209           1981#   3893$   4813$   4814$   6182    6183    7382    7424    7433$   7434$   12131   12132   
ERRLNF             =0020           3354#   7578    
ERRLS              =0017           3336#   19943   
ERRLST             =0029           3372#   13121   
ERRLWD             =0021           3356#   7581    
ERRNF              =000A           3310#   5877    
ERRNG              =0023           3360#   18964   
ERRNUM              1208           1980#   3887$   4815$   6179    7432$   12136   
ERROD              =000D           3316#   5818    
ERROID             =0022           3358#   13964   
ERROM              =0010           3322#   3881    
ERROR               4D59           3290    3618    3883#   4907    5092    5758    5879    6278    6349    6623    6900    7443    
                                   7582    11670   11949   12605   13946   13965   14350   14806   15109   16110   16213   18965   
                                   19019   19135   19324   19399   19944   20306   
ERROV              =000F           3320#   14805   
ERRRG              =000C           3314#   4906    
ERRSN              =000B           3312#   11948   
ERRST              =0019           3340#   11669   14349   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-13
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

ERRTM              =0016           3334#   5752    11667   
ERRTMF             =0001           3297#   19134   
ERRTXT              120E           1984#   3895$   6203    6205    7426    18860   18861$  
ERRUF              =001B           3344#   13945   
ERRUS              =0011           3324#   6277    
ERRVAL              1145           1847#   17978$  17979$  17997   18003   18005$  18006   18008$  
ERR_BAD_COMMAND    =0028           3289    3370#   3372    
ERR_ILD             A5FA           19888   19890   19940#  
ERR_ILLEGAL_DEVICE =0009           3308#   19940   
ERR_MFN             A5F7           19915   19937#  
ERR_MISSING_FNAME  =0008           3306#   19937   
ERR_NO_BEND        =0025           3364#   5091    
ERR_REF            =0027           3368#   6895    
ERR_TOO_LARGE      =0026           3366#   6622    
ERST                966A           17053   17071#  
ERSTUP              4A9F           3382#   3917    13123   
ERVFY              =001C           3346#   16190   
ESC_CMD_LST         4626           2703    2704    3038#   4717    4718    
ESC_CMD_TK         =00FE           2768    3027#   3532    4662    4756    4998    5020    5076    5108    6757    7655    
ESC_FN_LST          46E6           2711    2712    3088#   4736    4737    
ESC_FN_TK          =00CE           2771    2967#   2974    3656    4664    
ESC_FN_VEC          02FC           1774#   2485$   2487$   3759    
ET2                 9774           17059   17239#  
ET3                 976F           17229   17236#  
ETE                 965D           17057   17065#  
ETOF                0130           1759#   17093$  17212   17228   
EVAL                7974           11707   11845#  14381   21116   
EVAL0               797B           11850#  11875   
EVAL1               7980           11853#  11871   
EVAL2               7985           11852   11856#  
EVAL3               79C5           11877   11892#  
EVAL4               79DF           11894   11908#  
EXCHQT              52CA           4955#   4966    
EXECUTE_A_LINE      4DEA           3961#   21122   
EXIT                6056           3170    7503#   
EXP                 9033           3233    15917   15945   15991#  21082   
EXP1                9051           16007   16010#  
EXPCON              900A           15978#  16031   16032   
EXPO                9964           17542   17550#  
EXPSGN              0062           1641#   15516$  15521   15596   
FAC                 0063           1646#   14661   15421   
FACEXP              0063           1649#   4993    5205$   7173    7198    7469    7478    7562    9093    11808   11842   12148$  
                                   13878   13881$  13909   14559   14632   14651   14654$  14678   14724$  14755   14759$  14763$  
                                   14877   14881$  15010   15048   15058   15067$  15099$  15132   15133$  15135$  15236$  15266   
                                   15277$  15287   15296   15309   15340$  15368   15409   15445   15455$  15581   15688   15951   
                                   16005   16022   16023$  16827   
FACHO               0064           1651#   4194$   4200$   6687    6690    6919$   6921$   6944$   6946$   6977    6980$   6981    
                                   6983$   7168    7169$   11806   12085$  12155$  13847$  13868   13870$  13952$  13953$  14698$  
                                   14707   14709   14710$  14740   14742$  14751$  14765$  14777   14779$  14801$  14945   15141   
                                   15185   15207$  15233$  15263   15325$  15327$  15332   15373   15433$  15434   15435$  15461$  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-14
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

                                   15667$  15668$  15776   15778$  
FACLO               0067           1655#   3774    3779    5137$   5185    5228    5254    11800   11900   12083$  12167$  13853$  
                                   13867   13869$  13899   14176$  14197   14199   14377   14539   14689$  14716$  14731   14733$  
                                   14748$  14768$  14786   14788$  14795$  14939   15150   15176   15213$  15222$  15252   15337$  
                                   15387   15456   15464$  15766   15769$  17631$  17638   
FACMO               0066           1654#   2592    3696    3698    3771    3784    5181    5226    5258    5262    5263    8345$   
                                   8347$   11558$  11560$  11585   11586   11802   11903   11967$  11968$  11986   11989   12061   
                                   12064   12081$  12139   12140   12163$  13849$  13872   13874$  13898   14268   14269   14359$  
                                   14360$  14379   14452   14453   14537   14563   14564   14692$  14713   14714$  14734   14736$  
                                   14749$  14767$  14783   14785$  14797$  14941   15147   15179   15211$  15225$  15255   15338$  
                                   15381   15463$  15770   15772$  16884   16886   17618   17620   17625   17627   
FACMOH              0065           1652#   5227    11804   12082$  12159$  13851$  13871   13873$  14695$  14711   14712$  14737   
                                   14739$  14750$  14766$  14780   14782$  14799$  14943   15144   15182   15209$  15228$  15258   
                                   15377   15462$  15773   15775$  
FACOV               0071           1672#   11974$  12149$  12963$  12964   12969$  13879$  14361$  14642   14665$  14672   14686$  
                                   14715   14717$  14730$  14747$  14769$  14789   14791$  14792$  14814$  14829   14937   14978$  
                                   15201$  15237$  15268$  15280$  15291$  15298$  15341$  15385   15449$  15995   16028$  
FACSGN              0068           1656#   3832$   3838    5206$   5898$   7166    9091    11787   11839   12153$  13877$  13906   
                                   14555   14627   14629$  14656$  14725$  14773   14775$  15002   15036   15072$  15076   15231$  
                                   15261   15273$  15312   15342$  15347$  15366   15391   15413   15431   15450   15451$  15579   
                                   15679   15684$  15953   15955$  16753   16757   16790$  16822   
FADD                8845           5912    14638#  21070   
FADD1               8876           14662   14666#  
FADD2               88DD           14677   14729#  
FADD4               8882           14636   14652   14676#  
FADD5               8840           14635#  14670   
FADDA               8872           14653   14664#  
FADDC               8855           14647#  15098   
FADDH               8A0E           14906#  15726   16756   
FADDT               8848           3268    14633   14639#  14912   15582   21071   
FADFLT              88B1           14699#  15343   15458   
FAPN               =0016           19105   20032#  
FAST                7850           3219    11612#  
FBAK               =0023           19483   20041#  
FBUFFR              0100           1720#   1742    6805    6820    6841    15683$  15753$  15758$  15803$  15808$  15823   15846$  
                                   15848$  15857$  15859$  15861$  15864$  15867$  15869   15870   16965   16972   17019   17029$  
                                   17038   17060$  17202$  17223   17224$  17242$  17244$  17248   17249$  17307   17321$  17339   
                                   17412   17431   19629$  
FBUFPT              0072           1676#   5208$   5211$   5212    5220    11996$  15685$  15750   15760$  15799   15810$  15821   
FCAT               =0001           18991   20023#  
FCERR               7DC5           2243    2244    5235    6153    6554    7336    7626    7769    7977    8402    8605    8777    
                                   9035    9099    9190    9256    9505    9573    9728    10138   10283   10379   10413   10438   
                                   10555   10592   10617   10655   10683   10898   11581   12604#  12947   13078   13156   13278   
                                   13378   13453   13595   13632   13666   13737   13825   13917   14257   14570   14875   17640   
                                   17871   18576   19244   19397   19746   19876   20761   
FCERR2              546D           5203    5234#   
FCLR               =00FF           19404   20020#  
FCOLL              =0021           19416   20038#  
FCOMP               8C87           3805    5932    13914   15357#  15706   15713   15932   21090   
FCOMPC              8CBE           15369   15374   15378   15382   15390#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-15
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

FCOMPD              8CC4           15392   15394#  
FCOMPS              8C5D           15313#  15394   
FCONC              =000D           19450   20029#  
FCOPY              =0027           19440   20044#  
FCSIGN              8C5B           15311#  15367   
FCT                 1141           1846#   17938$  17942$  17960   18004   18007   
FDCEND              8F9F           11999   15816   15886#  
FDECPT              0049           1603#   15798$  15811   
FDIV                8B49           15124#  16795   21074   
FDIVF               8B41           15117#  16744   
FDIVT               8B4C           3274    9056    9070    14920   15120   15126#  21075   
FESP                012F           1758#   17054   17561$  
FETCH               AA34           3215    20717#  
FFORM               95E7           16980   17005#  
FFOUN               991C           17492   17509#  
FG_BG               03E2           1816#   9207$   9368    18139   18158   20810   20866   20875   
FG_MC1              03E3           1817#   9210$   9371    18147   
FHALF               8F76           14907   14908   15875#  15899   15900   
FHED               =001B           19306   20035#  
FILFLG              116C           1936#   2277$   7979$   8000$   18035   
FILTER              70E3           3185    10346#  
FILTERS             1271           2023#   2383$   2384$   10065   10068$  10069   10070$  10073   10118   10121$  10122   10348   
                                   10408$  10641   10644$  10646   10649$  
FIN                 8D22           5737    11855   13014   15478#  
FIN1                8D41           15493   15499#  
FINC                8D3C           15490   15495#  15530   15570   
FINDG1              8DA3           15562   15564#  
FINDGQ              8D3F           15486   15497#  
FINDIG              8D9C           15497   15559#  
FINDIV              8D84           15539#  15542   
FINDP               8D73           15500   15528#  
FIND_BEND           533D           5004    5034#   5042    5061    5063    5069    5077    5084    5086    5087    5114    
FIND_IT             5D39           6892#   6933    
FINE                8D79           15502   15522   15531#  
FINE1               8D7B           15526   15533#  
FINEC               8D62           15511   15513   15518#  15621   
FINEC1              8D60           15507   15509   15516#  
FINEC2              8D67           15514   15521#  
FINEDG              8DC3           15520   15591#  
FINGO               4C5C           3708    3716#   3748    
FININL              55A8           4280    5456#   
FINLOG              8DB0           5238    14898   15569   15573#  
FINML6              8B22           5219    15095#  
FINMUL              8D8D           15538   15546#  15549   
FINPTR              7CF4           12252   12455#  
FINQNG              8D94           15537   15543   15550#  
FINRE2              78FF           11762   11764#  
FINREL              78F5           11729   11757#  
FIN_BANK            03DA           1811#   15478$  15610   15631   
FIN_CHRGET          8DF5           15495   15504   15518   15630#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-16
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

FIN_CHRGET_1        8DFD           15632   15635#  15645   
FIN_CHRGET_2        8E03           13012   15637   15639#  
FIXLNK              4F9F           4259#   18838   
FLAG                0126           1749#   10043$  10046$  10049$  10052$  10130$  10200$  17281$  17371   17437$  
FLINRT              50BB           4492    4519#   
FLNRTS              50BC           4499    4509    4510    4520#   
FLOAD               5252           4840#   16231   
FLOAT               8C68           3868    12093   12121   12137   15324#  15577   
FLOATB              8C7B           12078   15339#  
FLOATC              8C75           4203    6925    13927   15335#  15671   21064   
FLOATS              8C70           11907   15331#  
FLPINT              849F           2248    2249    13897#  
FLTFLG              1238           2012#   10372$  10382   10384   10387$  
FLTSAV              1234           2011#   10349$  10359$  10363$  10365$  10367$  10369$  10381   10385$  10401   10404$  10407   
FMAPTR              7F0E           12612   12648   12857#  
FMULT               8A24           14925#  15944   16054   16058   21072   
FMULTT              8A27           3272    14904   14927#  21073   
FND010              6064           7473    7505    7513#   
FND40               6078           7518    7525#   
FND50               607D           7514    7528#   
FND60               60A4           7516    7549#   
FNDEND              6061           7511#   7520    7521    7526    7529    7545    7547    
FNDERR              60C7           7531    7534    7573#   
FNDLIN              5081           3979    4485#   6186    6442    6567    6576    7234    7307    21114   
FNDLNC              5085           4488#   4517    6265    
FNDOER              853B           11911   14020#  
FNDPNT              003F           1598#   4320    4323    4339    4345    4349    4355    4369    4370$   4372$   4443$   4445$   
                                   4452    4454    4914    4917    4920    4922    5885    5888    5897    5903    5907    5922    
                                   5925    5935    5941    5944    5947    5950    6649$   6650$   6810$   6812$   6814    6816    
                                   6827    6829$   6830$   7594    7597    7600    7602    18865   18868   18875   18889   18890$  
                                   18892$  18942   18947$  18952$  
FNDSCA              A167           19089   19104   19123#  
FNEDG1              8D65           15505   15520#  
FNTK               =00A5           2908#   2910    11909   14010   
FONE                899C           7181    7182    14861#  14888   14889   16831   16832   
FOPN               =0005           19090   19162   19193   19227   19265   20026#  
FOR                 5E16           3112    7116#   
FOR010              5E2C           7122    7133#   
FOR020              5E62           7173#   7177    
FOR030              5E7E           7186    7190#   
FOR040              5E8A           7197#   7201    
FOREGROUND          0086           1706#   2299$   8843    8859    8865$   8901$   9150$   9197    13284   
FOREIGN_ESC_FN      4C91           3743    3745    3751#   
FORM                003F           1597#   2579    16893$  
FORM_LINE           5D36           6777    6890#   
FORPNT              004B           1607#   1608    4342    4348    5161$   5162$   5183$   5186$   5190    5191    5198    5313    
                                   5317    5320    5322    5338$   5660$   5661$   5871$   5873$   6044$   6045$   6090$   6091$   
                                   6113    6722$   6724$   6896    6898    7205    7207    8349$   8351$   11064$  11068$  11072   
                                   11140   11160$  11171$  11206$  11299$  11336   11493$  11494$  11497   11534$  11536$  11540   
                                   11555$  11556$  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-17
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

FORTK              =0081           2858#   2860    4330    4363    5874    7120    7210    18876   
FOULDY              8F29           15817   15820#  
FOUN1               9917           17498   17506#  
FOUT                8E42           4204    5450    6926    15675#  16957   21061   
FOUT1               8E4C           15680   15682#  
FOUT11              8F2B           15822#  15826   
FOUT12              8F38           15828   15830#  
FOUT14              8F48           15834   15845#  
FOUT15              8F54           15852#  15855   
FOUT16              8EC9           15755   15759#  
FOUT17              8F6C           15833   15865#  
FOUT19              8F69           15690   15863#  
FOUT2               8ECF           15765#  15781   15785   15819   
FOUT20              8F71           15862   15868#  
FOUT3               8E7B           15710#  15720   
FOUT37              8E65           15694   15696#  
FOUT38              8E86           15715   15717#  
FOUT39              8EB8           15747   15749#  
FOUT4               8E70           15703#  15724   
FOUT40              8EF5           15782   15786#  
FOUT41              8EF3           15780   15784#  
FOUT5               8E94           15716   15725#  
FOUT6               8EAD           15736   15742#  
FOUT7               8E6E           15695   15701#  
FOUT8               8ECB           15748   15761#  
FOUT9               8E8D           15709   15721#  
FOUTBL              8F7B           11999   15768   15771   15774   15777   15816   15818   15877#  
FOUTC               8E44           14097   15672   15677#  
FOUTIM              8ECD           12000   15763#  
FOUTPI              8EAC           15734   15740#  
FOUTYP              8EFC           15788   15792#  
FPWR                8FBE           15902#  21080   
FPWR1               8FE4           15928   15933   15937#  
FPWRT               8FC1           3276    15916#  21081   
FPWRT1              8FCA           15919   15922#  
FR4                 948F           16750   16751   16765   16766   16806#  
FRE                 8000           3228    12943#  
FRE02               87CA           14457   14459   14501#  
FREC               =003B           19393   20053#  
FREFAC              8781           3815    5201    5526    6151    14452#  17273   
FREN               =002F           19462   20047#  
FREPLA              87C8           14496   14498#  
FRERTS              87F0           14481   14483   14518   14520   14525#  
FRESPC              0037           1593#   12026$  14334$  14430$  14435   14436$  14438$  16468$  16469$  16477   16478   16527$  
                                   16530$  16567$  16568$  16597$  16598$  16663   16664   
FRESTR              877E           14235   14451#  
FRETMP              8785           3821    14145   14402   14406   14454#  16991   17705   17709   
FRETMS              87E0           5295    5304    11587   14456   14517#  
FRETOP              0035           1592#   4402    4405    4426    4429    4819$   4820$   5246    5251    5368    5371    7808    
                                   7811    12956   12976   12979   14480   14482   14491   14492$  14494$  14495$  14497$  16446   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-18
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

                                   16449   16479$  16480$  16617   16620   16665$  16666$  
FRMEVL              788C           3688    3740    4986    5169    5447    6109    7608    11564   11654   11694#  11919   13903   
                                   14449   16879   16917   17623   21117   
FRMJMP              60F8           7468    7477    7561    7589    7606#   
FRMNUM              7874           7165    7188    9090    9919    11654#  14063   14534   14544   14553   
FRMSTR              877B           7331    7630    8390    8788    9975    14449#  16351   19913   
FSCA10              A169           19125#  19130   
FSCA20              A17A           19127   19134#  
FSCR               =0037           19336   20050#  
FSUB                882E           14625#  21068   
FSUBT               8831           3270    14627#  14916   16029   16749   21069   
FTF                 96A0           17090   17102#  
FUNDSP              47F5           3223#   3721    3723    
GARB1               92EC           16506#  16510   16518   
GARB2               9303           16508   16520#  
GARBA2              92EA           4416    7795    12974   16487   16504#  21121   
GARBAG              92DA           16463   16466   16484#  
GARBFL              0011           1567#   12111$  12114   12115$  12120   16441$  16485   16489$  
GET                 562F           3144    5558#   
GETADR              8815           9057    9071    13091   13178   13758   14545   14555#  21063   
GETAGN              5696           5612#   5626    
GETAN1              9A79           17732#  17736   17738   
GETAN2              9A94           17742   17748#  
GETAN3              9A96           17750#  17754   
GETAN4              9AA9           17762#  17772   
GETAN5              9ABA           17765   17773#  
GETAN6              9AC5           17778   17780#  
GETANG              9A74           8108    8640    9800    17728#  
GETBYT              87F4           3702    5129    5411    5568    5587    6317    7622    9032    9130    9246    9447    9567    
                                   9758    10278   10434   10534   10574   10610   10632   10679   10845   13567   13695   14181   
                                   14533#  14549   16293   16325   18538   18564   19365   19954   19957   
GETCMP              4D23           3837    3845#   
GETDEF              7E6F           12619   12747#  
GETERR              4DB3           3929#   3935    
GETFNM              8528           13985   14010#  14020   
GETN                5642           5561    5567#   
GETNTH              5718           5698    5700#   
GETNUM              8803           9652    13105   14543#  
GETOFF              A615           19765   19776   19964#  
GETPOS              9CEC           8256    8285    18091   18230#  
GETPS1              9CF1           18053   18233#  
GETRTS              92D9           16444   16481#  
GETSAD              8819           9920    14558#  
GETSPA              9299           14273   16440#  20253   
GETSPT              549A           5200    5268#   
GETSTK              501B           4384#   6287    7130    7482    
GETTIM              7AB7           11993   12075   12080#  
GETTTY              5652           5563    5565    5577#   
GETTYP              1154           1917#   8404$   8447    
GETVAL              A602           19702   19720   19737   19841   19886   19899   19950#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-19
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

GETVM               7762           11124   11331   11407   11450#  11465   
GETWRD              8812           5985    6439    7352    7418    9591    10356   14553#  18504   18633   19968   19973   20735   
GET_GRAPNT          AB6B           20830   20928#  
GET_LT_32768        69E1           9052    9066    9088#   
GET_SPRITE_NUMBER   6D58           9689    9757#   9782    
GFOR                98F5           17487#  17504   
GINLIN              56C3           5631    5634#   
GIVAYF              79D9           2253    2254    3788    6057    11905#  12054   13935   17885   21060   
GLOOP               9318           16535#  16544   16601   
GLOP1               9351           16574#  16579   
GOBADV              7C16           12293   12296   12299   12303   12306   12309#  
GOFLOT              4D44           3865    3867#   
GOFUC               8685           14184   14257#  
GOGO                7CA5           12399   12402#  
GOMAIN              4F69           4189    4197    4199    4220#   
GOMERR              5061           4393    4396    4428    4430    4433#   
GOMLDV              904E           16008#  16015   
GOMOVF              7B1E           12063   12066   12074   12091   12101   12124   12128   12139#  
GONPRC              7A10           11896   11955#  
GOOVER              8B14           15060   15078   15085#  15094   15100   15136   
GORDFN              A6CD           20090   20108#  
GORDY2              513D           4582    4596    4607#   4640    
GOSUB               59EC           3124    6236#   
GOSUB_SUB           5A3A           3445    6236    6285#   
GOSUTK             =008D           2876#   2879    4903    5131    6301    6512    
GOTARY              7DCA           12590   12609#  
GOTK               =00CB           2960#   2964    3535    6746    
GOTNUM              5470           5233    5236#   
GOTO                59F8           3120    5018    6238    6243#   6315    6420    
GOTOTK             =0089           2869#   2871    4988    5133    6512    
GOTO_1              59FF           3446    6247#   
GO_DELIM1           A441           19659   19680#  
GO_FCERR            882B           14538   14556   14561   14569#  
GO_FOREIGN_ESC_FN   4C9A           3753    3758#   
GO_READY            401F           2211#   2235    
GO_WITHOUT_TO       5A5A           3537    6310#   
GPLOT               9BFB           8717    8736    17982   18034#  21106   
GRAPER              6C14           9454    9469    9476    9505#   
GRAPH80             6C1C           9449    9511#   
GRAPH80_CLR         6B8F           9428#   9496    
GRAPHIC             6B81           3155    9421#   
GRAPHIC01           6BB5           9422    9446#   
GRAPHIC_BASE       =2000           1519#   9364    
GRAPHIC_LDTB1       9CD3           18133   18189#  
GRAPNT              008C           1710#   8257    8288    8921$   8924$   8926$   8928$   8930$   8988$   9333$   9335$   9336$   
                                   9339$   11399$  11403$  11413   11415$  11451$  11455$  11469$  11531$  11532$  11543$  18055   
                                   18068$  18094   18132$  18134$  18150   18153$  18161   18164$  18167   18170$  18181$  18236$  
                                   18239$  18241$  18243$  18245$  20805$  20808$  20919$  20922$  20945   20948   
GRBG99              92E7           16486   16493#  
GRBPNT              0050           1612#   2605    16526$  16529$  16587   16588   16673   16674   16677$  16678$  18797$  18800$  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-20
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

                                   18804$  18806$  
GRBTOP              0061           1638#   16525$  16528$  16559$  16562$  16577$  16583   16685   16686   16689$  16690$  18775$  
                                   18786   
GREASE              7E3E           12701   12704#  
GREATK             =00B1           2927#   2929    11714   11716   11731   
GREATR              1148           1849#   17957$  17975   17983   18000   18010   
GRPCOL              9E38           7762    7966    8529    18546#  
GRPOS3              9D17           18253   18256#  
GRPRTS              9D24           18231   18260   18263#  
GSA                 65F7           8427#   8509    
GSB                 660D           8436#   8507    
GSHAPE              65AA           3160    8389#   
GTANG1              9A77           8564    9836    17730#  18637   
GTBYTC              87F1           5495    14531#  
GTVL2               A605           19951#  
HARD_RESET          4026           2192    2218#   
HAVSTR              645E           8209    8212#   
HEADER              A277           3174    19297#  
HELP                59A3           3167    6179#   
HELPER              0055           1617#   4641    6188$   6193$   6208$   
HELPSB              59C9           4643    6197#   
HEXD                8142           3253    13173#  
HEXIT               816B           13184   13186   13193#  
HIGHDS              005A           1631#   4080$   4081$   4124    4126$   4128$   4132$   4137$   4140$   4413    4420$   6570$   
                                   6571$   6579    6581    6903$   6907$   6930$   6957    6960    12338$  12339$  12341   12342   
                                   12489   12491$  12493$  12497$  12502$  12505$  16522$  16543$  16547   16550$  16625   19237   
                                   19238$  19239$  
HIGHEST_ESC_CMD_TK =0026           3083#   3586    4713    
HIGHEST_ESC_FN_TK  =000A           3101#   3744    4732    
HIGHEST_OLD_FN_TK  =00D4           2975#   3747    
HIGHTR              005C           1632#   2585    2589    4070$   4071$   4106    4110    4116    4119$   4121$   4139$   6525$   
                                   6526$   6563$   6565$   6604    6607    6680    6684    6911    6915    6959    6961    12331$  
                                   12332$  12411$  12415$  12425$  12429$  12472   12476   12482   12485$  12487$  12504$  
HOP_1               5C52           6748#   6760    6764    
HULP                0078           1685#   6096$   6125    6137    6143    9979$   9981    9987$   16927   16947   17017   17091$  
                                   17158$  17169$  17176$  17190$  17274$  
HUP                 9682           17064   17084#  17129   17140   17143   17146   
HYO                 9927           17517#  17521   17528   17538   
HYO1                994B           17534   17536#  17544   17548   
HYO2                9924           17515#  17523   
ICRNCH              0304           1778#   2656    
IDENT               A4A8           19672   19750#  
IERROR              0300           1776#   2480$   3883    
IESCEX              0310           1784#   3595    
IESCLK              030C           1782#   2670    
IESCPR              030E           1783#   4762    
IEVAL               030A           1781#   11846   
IF                  52E2           3122    4986#   
IF_FALSE            52F5           4996#   
IF_TRUE             531B           4994    5015#   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-21
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

IGONE               0308           1780#   3413    
ILINE_10            5C73           6742    6751    6769#   6797    
ILINE_15            5C9B           6785    6787#   
ILINE_20            5CA6           6795#   6872    6883    
ILLVAL              9E58           18566   18570   18575#  
IMAIN               0302           1777#   3957    
IMBED_LINES         5C18           6651    6663    6714#   
INCFAC              894E           14794#  15301   
INCFRT              895C           14793   14796   14798   14800   14802#  
INCHR               90E5           4277    16123#  
INCOL1              9E40           18560#  
INCOL2              9E55           18561   18563   18569   18571#  
INCOLR              9E3B           8714    8755    18557#  
INCOR2              9E5B           7764    7970    8216    8397    8531    18597#  
INCOR3              9E76           7968    8213    18616#  
INCORD              9E79           8729    9012    18602   18620#  
INCR2A              9E67           18599   18604#  
INCR2C              9E69           18606#  18612   
INCRND              8C4F           15300#  15998   
INCVAL              9F46           17766   17769   18747#  
INCY                96FD           17159#  17170   
INDDEF              42EB           2576#   14032   14036   14054   14057   
INDDPT              42F5           2582#   14129   14136   14162   14190   
INDEX               0024           1579#   4108$   4118    4125    4228$   4229$   4245    4248$   4250    4252$   4253$   4254$   
                                   4260    4261    4545$   4551$   4553$   4556    5302$   5303$   5315$   5318$   5321$   5323$   
                                   5329$   5332$   5379$   5380$   5384    5385$   5387$   7633$   7634    8802$   8804$   12474$  
                                   12484   12490   12692   12821$  14150   14151$  14153$  14421$  14422$  14454$  14455$  14463$  
                                   14466$  14471   14472   14476$  14477$  14510$  14511$  15253$  15256$  15259$  15264$  15267$  
INDEX1              0024           1580#   2548    2612    2790$   2793$   2797    2812$   2813$   2820    2827    2835    2836$   
                                   2838$   2841    4018$   4020$   4046    4048$   4055$   4672$   4673$   4680    4682$   4684$   
                                   4693    7014$   7016$   7033$   7035$   7042$   7074    7077    7278    7279    7803$   7805$   
                                   7882    7885    7889    7891$   7892$   7922    7926    7938$   7940$   7942$   11738$  11740   
                                   11793$  11796$  11810   12141$  12142$  12366$  12367$  12391   12392$  12394$  12397   12435   
                                   12436$  12438$  12785   13000   13002   14988$  14989$  14991   14994   14997   15000   15008   
                                   15018$  15019$  15218$  15219$  15221   15224   15227   15230   15235   15249$  15250$  15636$  
                                   15638$  16352   16353   16453$  16454$  16458   16473$  16476$  16584$  16640$  18785$  18787$  
                                   18809   18811$  18812$  18820$  18908$  18911$  18916$  18919$  19926$  19928$  19932   19933   
                                   20183$  20185$  
INDEX2              0026           1581#   2554    3385$   3387$   3392    3394$   3396$   3929    4022$   4031$   4043$   4052$   
                                   4056$   7018$   7020$   7054    7056$   7058$   7063$   7075    7078    7232$   7233$   7248    
                                   7252    7266$   8393$   8394$   8412    8431    8942$   8945$   8952    12909$  12911$  12914   
                                   12916   13030$  13032$  13036   13042$  13043   13129   13142   15358$  15359$  15361   15365   
                                   15371   15376   15380   15386   18789$  18791$  18814   18816$  18817$  18909$  18913$  18920$  
                                   18922   
INDFMO              4304           2592#   5250    5270    5276    5285    6116    11590   11593   11596   12048   12051   14390   
                                   16891   16896   
INDFRM              42F0           2579#   16902   17265   17367   17469   21034   
INDGRB              4318           2605#   16540   16558   16561   16576   16633   16639   
INDHTR              42FA           2585#   4131    4136    
INDHTR_RAM1         42FF           2588#   12423   12427   12496   12501   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-22
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

INDICE              0066           1653#   12555   12557   12756$  12760$  12782   12787   
INDIN1              4322           2612#   4051    4233    4236    4241    7039    
INDIN1_RAM1         03B7           1803#   5231    5353    5357    5360    5367    5532    7337    7893    8823    8872    9984    
                                   12147   12152   12158   12162   12166   12369   12372   12375   12379   12387   12404   12408   
                                   12413   13038   14251   14429   14502   14505   14508   15025   15028   15031   15034   15042   
                                   15614   15641   16564   16594   16949   19789   19917   20190   
INDIN2              03C0           1804#   7061    18819   18915   
INDLOP              7D52           12537#  12564   
INDLOW              4309           2595#   3994    4017    4024    4491    4495    4505    4513    4516    4578    4581    4587    
                                   4590    4599    4602    4645    4708    4727    7237    7241    7244    7265    
INDLOW_RAM1         431D           2608#   12245   12249   12584   12588   12593   12598   12614   12747   12757   12765   12822   
                                   12825   
INDST1              430E           2598#   14304   14332   
INDST1_RAM1         4313           2601#   14388   14411   14414   14417   
INDSUB_RAM0         039F           1801#   2533$   2586    2596    2599    2613    5794    
INDSUB_RAM1         03AB           1802#   2540$   2577    2580    2583    2590    2593    2603    2606    2610    3846    3849    
                                   5337    6114    6145    8413    8432    11541   12014   12025   12108   12118   13008   14042   
                                   17653   17656   17683   17687   19319   19347   
INDTXT              03C9           1805#   3478    3485    3488    3491    4959    5001    5008    5023    5048    5052    5055    
                                   5099    5111    5820    5823    5826    6597    6602    6606    6627    6630    6678    7000    
                                   7300    7393    7396    7399    7404    7407    7533    7536    7539    11942   15612   
INI                 979F           16920   16979   17272#  
INIT_AS_0          =006C           1955#   2344    
INIT_MMU            417D           2203    2219    2417#   
INIT_PLOT_VEC       4269           2204    2489#   9429    
INIT_STORAGE        4048           2221    2238#   
INIT_VECTORS        4254           2220    2477#   
INIT_VOICES         4115           2206    2349    2360#   
INLIN               4FB0           3960    4276#   5635    
INLOOP              56D5           5659#   5782    
INLOP1              5700           5678    5685#   
INLOP2              5703           5683    5686#   
INLPN1              7E9E           12768   12776#  
INLPN2              7E9D           12762   12774#  
INLPNM              7E78           12751#  12790   
INPCO1              56CF           5582    5644#   
INPCOM              5422           5198#   5733    11561   
INPCON              56CD           5624    5642#   
INPFLG              0013           1570#   5644$   5673    5709    5746    5786    
INPPTR              0045           1601#   5656$   5657$   5666    5773$   5784    5785    5793    
INPRT               8E26           3944    15660#  
INPRTS              57E6           5795    5797    5800#   
INPUT               567F           3116    5601#   
INPUTN              5665           3115    5587#   
INST5               9A19           17664#  17691   
INST6               9A2A           17672   17674#  17694   
INST7               9A4B           17689   17693#  
INSTFD              9A4F           17677   17696#  
INSTGO              4C9D           3694    3761#   
INSTNF              9A54           17662   17670   17673   17700#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-23
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

INSTR               99C1           3761    17618#  
INSTTK             =00D4           2974#   2975    2977    3658    3667    3693    
INSY                95FA           17012   17016#  17022   17033   17035   
INT                 8CFB           3225    15444#  15929   16011   16746   21077   
INTEGR              0009           1558#   3773$   3776$   3781    3786    15457$  15936   16012   
INTERR              7B5D           12188#  12215   
INTFLG              0010           1566#   5165    5739    6058    12045   12194$  12217$  12531   12570$  
INTIDX              84A7           12543   13902#  
INTRTS              8D21           15447   15466#  
INTVAL              127F           2031#   2284$   3420    3440    3442$   3449    3451$   6364$   10547   10552$  20482   20505   
INT_ADR_HI          127C           2029#   3431    10543$  
INT_ADR_LO          1279           2028#   3429    10545$  
INT_TRIP_FLAG       1276           2027#   2281$   2282$   2283$   3424    3428$   6368$   20489$  20510$  
INVERT              9DA7           17821   18408#  
INZ                 9723           17179   17184#  
INZ2                9725           17182   17186#  
IODONE              5675           5409    5593#   5619    
IORELE              5677           5584    5594#   
IQPLOP              0306           1779#   4647    
IRQ_WRAP_FLAG       12FD           2083#   2380$   20402   20406$  20672$  
ISFUN               4C14           3656#   11915   
ISGRAP              A07D           8203    8389    8705    8838    9010    9261    18547   18957#  
ISGRER              A082           18958   18961#  
ISGRTS              A081           18959#  18963   
ISLETC              7BD9           11857   12186   12197   12203   12268#  13518   
ISP                 997E           17522   17552   17564#  
ISPL                9892           17390   17420#  
ISPL1               988D           17392   17417#  17471   
ISSEC               7B70           12196   12199#  
ISVDS               7A51           11976   12005#  
ISVRET              7A18           11967#  12280   
IS_ARRAY            7D48           12231   12529#  
IS_FLOATING         7A9A           12046   12060#  
IS_NUMERIC          7A87           11972   12044#  
IS_STOP_KEY_DOWN    4BD2           3467    3606#   4584    7899    9615    
IS_VARIABLE         7A15           11859   11964#  
ITIME               0312           1785#   
ITY                 9704           17161   17163#  
IV10                427E           2478    2479    2502#   
IV20                4290           2478    2490    2491    2504#   
IV30                4296           2490    2506#   
JERXIT              91AB           16183   16239   16252#  
JMPER               0056           1618#   2240$   3722$   3724$   3725    14211$  14220   
JOY                 8203           3250    13340#  
JOYTAB              8242           13368   13380#  
KEY                 6127           3182    7651#   
KEYCHR              61C1           7690    7740#   
KEYDAT              61BA           7725    7738#   
KEYLEN              1151           1914#   
KEYNXT              1152           1915#   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-24
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

KEYSIZ              0078           1686#   7670$   7708$   
KEYTK              =00F9           3018#   3020    5562    5677    
KLOOP               43E9           2688    2725    2764    2787#   
K_BASIN             9263           16123   16389#  19030   19034   19051   20285   20317   20322   
K_BSOUT             9269           2457    2461    7678    7700    7702    7704    7713    7715    7726    7733    9306    9320    
                                   10896   16118   16393#  19047   19057   19063   19343   19349   
K_CLALL             927B           4808    16407#  19303   19415   
K_CLOSE             9275           16248   16402#  19080   19149   19502   20298   
K_CLRCH             926F           3918    5594    16397#  19077   19110   19492   20295   20316   
K_JPLOT             928D           5482    5493    9281    13932   16421#  
K_OPEN              90D8           16113#  16237   19013   19114   19497   20277   
K_PRIMM             9281           3637    3874    3938    5760    5798    15661   16199   16412#  20314   
K_PRINT             7F25           8819    8832    12890#  
K_READST            9251           5616    12092   16191   16207   16371#  19032   19036   19053   19284   
K_SETBANK           9287           16270   16322   16416#  19006   19113   19168   19199   19233   19271   19495   
K_SETLFS            9257           16269   16280   16286   16330   16340   16347   16377#  19011   20120   20272   
K_SETNAM            925D           16263   16323   16354   16383#  20115   20275   
K_STOP              9293           3607    3615    16425#  19067   
LASNUM             =00C7           2953#   2955    
LASTPT              0019           1577#   2269$   14364$  14517   14519   14523$  
LD100               8BB4           15157   15191#  
LDFORM              9536           16890#  16894   
LDVN                96E1           17126   17141#  
LDZR                7BEF           12279   12284#  12290   
LEFTD               85D6           3244    14127#  
LEFTTK             =00C8           2955#   2958    3671    
LEFT_FLAG           0063           1648#   7827$   7850    7852$   
LEN                 8668           3239    14232#  
LEN1                866E           12993   13029   14232   14235#  14248   
LENCHK              A5ED           19919   19927   19929#  
LENFOR             =0012           1494#   4352    4362    5863    7129    7136    7171    7194    
LENGOS             =0005           1495#   4910    6286    6288    
LESSER              1147           1848#   17955$  17961   17996   
LESSTK             =00B3           2931#   2933    11716   
LET                 53E3           3119    3558    5160#   7119    
LF                 =000A           1503#   5472    
LFOR                0135           1764#   16897$  17259   
LINCNT              12FB           2078#   11330$  11355   
LINE_ADD            5D92           6932    6956#   
LINE_INC            5D9D           6693    6963#   
LINGET              50BD           3976    4535#   5143    6167    6243    6534    6776    7306    7313    21120   
LINNUM              0016           1575#   3430$   3432$   3903$   3906$   4156    4158    4191    4195    4497    4507    4537$   
                                   4538$   4544    4549    4554    4555$   4557    4558$   4559$   4560$   4561    4563$   4565$   
                                   4592    4594    5987    5989    6168    6170    6184$   6185$   6190    6191    6250    6252    
                                   6440$   6441$   6537    6538    6564$   6566$   6574$   6575$   6676$   6683    6904    6908    
                                   6914    6918    6920    7319$   7320$   7419$   
LINPRT              8E32           4626    15666#  19045   20372   
LIST                50FF           3138    4575#   
LIST_SPECIAL        61A0           7691    7723#   
LLAR                9951           17533   17540#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-25
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

LLEN               =0028           1504#   8757    8892    9041    9041    18286   
LNKPRG              4F6C           4061    4182    4225#   6407    7277    16223   16230   18837   21112   
LNKRTS              4FAF           4237    4267#   
LOAD                912C           3130    16170#  
LOAD_ERROR          9167           16211#  19287   
LOCATE              6972           3163    9009#   
LOFBUF              00FF           1716#   14101   14102   
LOG                 89CA           3232    14872#  15941   21076   
LOG1                89D4           14874   14877#  
LOG2                89C5           14870#  14899   14900   
LOGADR              A457           19653   19700#  
LOGCN2              89A1           14862#  14891   14892   
LOGEB2              9005           15976#  15992   15993   
LOGERR              89D1           14873   14875#  
LOOP                60A7           3169    7553#   
LOOP1               A7C7           20283#  20291   
LOOP10              60D9           7555    7588#   
LOOPTK             =00EC           3004#   3018    7515    
LOPFDA              7D95           12575#  12600   
LOPFDV              7DA1           12579   12582#  
LOPFN               7BBC           12241   12245#  
LOPFND              7BB2           12239#  12258   
LOPPTA              7E0B           12672#  12694   
LOPREL              78A9           11712#  11726   
LOWEST_ESC_CMD_TK  =0002           2707    3040#   3584    3591    4711    4715    
LOWEST_ESC_FN_TK   =0002           2715    3090#   3742    3747    4730    4734    
LOWTR               0061           1640#   2595    2609    3996    4021    4026    4035    4038    4107    4111    4149$   4151$   
                                   4157$   4160$   4165    4167$   4169$   4178$   4489$   4490$   4603$   4604$   6197    6200    
                                   6267    6270    6445    6446    6568    6569    6578    6580    7230    7231    7245$   7246$   
                                   7250    7253    7267$   7269$   12238$  12239$  12256   12327$  12328$  12445$  12448$  12451$  
                                   12455   12458   12473   12477   12576$  12577$  12595   12599   12655$  12661$  12671$  12685$  
                                   12688$  12724   12726$  12729   12730$  12860   12861   
LPOPER              7897           11700#  11781   
LSG                 9623           17028   17037#  
LSLOOP              615E           7684#   7709    
LSTEST              619B           7669    7718#   
LSTKY1              6142           7667#   7719    
LSTND               6187           7708#   7735    
LSTPNT              004B           1605#   4624$   4629    4668$   4710$   4729$   
LUK4IT              5A18           3912    6253    6262#   7421    
LUKALL              5A1C           6258    6260    6265#   
MAIN                4DE0           3957#   3967    4221    16225   
MAIN00              4DF2           3967#   4065    
MAIN1               4DFF           3968    3975#   
MAKCR1              76F8           11410   11411   11413#  
MATCH              =0064           1629#   17666$  17675   17685   17693$  
MAXCHR             =0050           1501#   
MAX_MEM_0           1212           1987#   2321$   2322$   4008    4011    4086    4089    6815    6817    12950   12953   18776   
                                   18779   
MAX_MEM_1           0039           1594#   2326$   2327$   4817    4818    5361    5364    16523   16524   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-26
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

MIDD                861C           3246    14175#  
MIDD2               591E           6084#   6086    
MIDDTK             =00CA           2958#   2960    3539    3660    3662    3669    
MIDWRK             =591D           3571    3573    6086#   
MINT                9872           17399   17403#  
MINUTK             =00AB           2920#   2927    7297    7310    9913    11872   15506   18707   
MLDEXP              8AEE           15055#  16037   
MLDVEX              8B09           15075#  16009   
MLEX10              8DD2           15594   15600#  
MLEXMI              8DF0           15597   15619#  
MLTPL1              8A5B           14946   14954#  
MLTPL2              8A5E           14957#  14981   
MLTPL3              8A7A           14959   14973#  
MLTPLY              8A55           14938   14940   14942   14944   14949#  
MMU                =D500           1530#   1531    
MMU_CONFIG_REG     =FF00           1545#   1546    1547    1548    1549    15021   15046$  18173$  20392$  
MMU_PRECONFIG_A    =D501           1531#   2421$   
MODES               6C17           9456    9507#   
MONTK              =00FA           3020#   3022    3547    3591    
MORCO1              55CC           5485#   5486    
MOREN1              7D38           12492   12494   12499#  12507   
MORSTS              4BCB           3480    3600#   
MOUT                987B           17406   17409#  
MOV1F               8BFC           15245#  16052   16779   
MOV2F               8BF9           15242#  16071   
MOVAF               8C38           5214    15089   15113   15283#  15575   15898   16740   16745   21101   
MOVAFL              8C3D           15287#  15290   
MOVCH0              693A           8953    8956#   
MOVCH1              6955           8962    8972#   
MOVCH2              695D           8974    8977#   
MOVCH3              6966           8978    8983#   
MOVCHR              6930           8950#   8990    
MOVDO               8763           14155   14403   14423#  
MOVEDOWN            5DDD           7032#   7044    
MOVEDOWN_10         5DE3           6876    7034    7036#   
MOVEF               8C3B           15285#  16004   
MOVEUP              5DF4           7053#   7065    
MOVEUP_10           5DFA           7055    7057#   
MOVEUP_20           5DFC           6858    7059#   
MOVE_INIT           5DC4           6856    6874    7012#   
MOVFA               8C28           3777    14640   15271#  21100   
MOVFA1              8C2A           15273#  15938   
MOVFM               8BD4           5892    7183    11864   13859   15119   15218#  15902   16788   21098   
MOVFND              506D           4452#   4909    5881    7133    7568    
MOVFR               8BC1           14947   15206#  
MOVFRM              7B22           12141#  21097   
MOVINS              874E           5291    14399   14410#  
MOVLP               8767           14427#  14432   
MOVMF               8C00           5193    5918    13885   14049   15248#  15925   16785   21099   
MOVPNT              93D2           16541   16570   16600   16631   16670#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-27
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

MOVRTS              8C46           15292#  15297   15299   15302   
MOVRVS              6951           8964    8969#   
MOVSPR              6D63           3188    9782#   
MOVSTR              875F           14420#  
MOVTOP              93E1           16566   16596   16628   16682#  
MOVTOS              5064           4316    4442#   7131    18863   
MUL10               8B17           5210    5224    15088#  15547   15565   15718   
MUL10R              8B2D           15091   15101#  
MUL80               AB89           20797   20909   20956#  
MULDIV              8AEC           14931   15053#  15134   
MULSHF              8962           14812#  14952   
MULTICOLOR_1        0084           1704#   2301$   8854    9157$   9208    13287   
MULTICOLOR_2        0085           1705#   2303$   8856    9160$   9351    13290   18180   
MULTRT              8A88           14929   14982#  
MUSIC_IRQ           A904           20467   20498   20507   20515#  
MUTABL              7089           10020   10291#  
MVDFLG              0076           1679#   2272$   18767   18783$  18846   18902   18907$  18943   18957   
MVDONE              8771           12030   14338   14425   14434#  
MVSTRT              877A           14437   14439#  
N0999               8E17           15656#  15711   15712   
N13107000           69FA           9067    9068    9104#   
N1_RESET            5D85           6593    6719    6891    6942#   
N20971200           69F5           9053    9054    9102#   
N32768              849A           13895#  13912   13913   
N9999               8E1C           15657#  15704   15705   
NAME1               A4EC           19678   19784#  
NAME2               A568           19835   19837   19854#  
NBR                 9808           17343#  17352   
NCRNCH              432A           2502    2657#   
NEGATE_STEP         A9EA           20589   20617   20655#  
NEGFAC              8926           14701   14772#  
NEGFCH              892C           14776#  15418   
NEGHLF              89C0           14869#  14894   14895   
NEGOFF             =0015           11951#  11954   
NEGOP               8FFA           3282    15556   15950#  16030   16763   16770   16825   16847   21079   
NEGPRC              78E8           11749#  11958   
NEGRTS              9004           15948   15952   15956#  
NEGTAB              485A           3281#   11951   
NEGXQS              8D99           15552   15555#  
NERROR              4D5C           2502    3884#   
NESCEX              4BC6           2503    3596#   
NESCLK              433E           2503    2671#   
NESCPR              51EA           2503    4764#   
NEVAL               7977           2502    11847#  
NEW                 51F3           3145    4779#   21111   
NEWBYT              1157           1920#   8434$   8438$   8443$   
NEWCHR              5574           5424#   5454    
NEWNAM              A5C9           19785   19855   19912#  
NEWSTT              4B13           3447    3467#   3913    6239    6409    6422    21115   
NEW_NUM             5DA6           6616    6964    6976#   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-28
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

NEXT                5811           3113    5859#   
NEXT10              5826           5859    5870#   
NEXT20              582B           5861    5873#   
NEXT25              5836           5821    5878#   
NEXT30              5839           5876    5880#   
NEXT35              5846           5889    5891#   
NEXT40              5872           5926    5931#   
NEXT45              5894           5867    5952#   
NEXT50              5817           5863#   5936    
NEXT6               A513           19805#  19823   
NEXT6A              A51A           19806   19808#  
NEXT6B              A520           19809   19817#  
NEXTTK             =0082           2860#   2862    7388    
NEXT_CHAR           5C2D           6725#   6734    6738    6752    6758    6762    
NEXT_LINE           5C1B           6716#   6731    6737    6749    
NF                  012D           1756#   17075   17127   17294   
NGONE               4ABF           2502    3417#   
NIBBLE              1239           2013#   10400$  10403   10457$  10461   10468$  10472   
NLINES             =0019           1505#   8758    9042    9042    18295   
NMAIN               4DE3           2502    3958#   
NMARY1              7DB2           12587   12591#  
NMIL                8E21           15658#  15697   15698   
NO4                 969D           17096   17100#  
NOCR                95E4           16994   16997#  
NODEL               4E87           3980    4060#   
NOML6               544F           5216    5220#   
NOMN                962D           17040   17042#  
NONO                990D           17496   17499#  
NONONO              84C1           13907   13916#  
NORM1               8908           14708   14752#  
NORM2               88FC           14745#  14753   
NORM3               88BA           14706#  14721   
NORMAL              88B6           13882   14700   14702#  15214   
NOS1                9705           17162   17165#  
NOS3                9727           17097   17188#  
NOS4                9708           17101   17167#  
NOSEC               7B7B           12198   12206#  
NOSFLT              84C9           12133   12981   13075   13450   13484   13533   13735   13771   13925#  
NOT500              5F12           7283    7285#   
NOTABR              55F1           5446    5502    5508#   
NOTDEL              5F02           6706    7255    7276#   
NOTDIM              7E1B           12676   12683#  
NOTEOS              5ECA           7240    7243#   
NOTES               7084           10005   10289#  
NOTEVE              7C43           12335   12337#  
NOTEVL              7C19           12282   12314#  
NOTFDD              7DE3           12581   12647#  
NOTFL1              7EC0           12794   12796#  
NOTFLT              7DF9           12656   12658#  
NOTFNS              7BE3           12243   12276#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-29
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

NOTIT               7BCF           12247   12255#  
NOTOP               79CD           3284    11898#  
NOTQTI              568E           5592    5602    5607#   
NOTSTR              7B85           12207   12212#  
NOTTK              =00A8           2914#   2916    11893   
NOT_QUOTE           5C3F           6729    6735#   
NOWGE1              574B           5727    5729#   
NOWGET              5740           5718    5723#   
NOWLIN              5803           5817    5830#   
NO_NUMBER_ERROR     5A37           6245    6280#   
NQPLOP              516E           2502    4652#   
NRANGE              5EA1           7224#   7228    
NSTT5               4B4E           3483    3486    3501#   
NTIME               1229           2004#   2367$   2368$   10148$  10150$  10153$  10154$  10239   10241   10245   10248   
NUMCNT              116E           1938#   8790$   8821    8874$   9784    9793    9850$   9863$   9874$   9902$   9916$   11334$  
                                   11338   
NUMINS              5757           5708    5736#   
NXTCMP              4D18           3835#   3853    
NXXX                A529           19802   19822#  
N_ESC_FN_VEC        4C95           2484    2486    3754#   
OBLK                958D           16942#  16948   
OCTAVE              122B           2005#   2371$   10092$  10171   
OFFTAB              70D6           10103   10261   10323#  10793   20537   20629   20651   
OFF_TK             =0024           3079#   7659    
OKNORM              4C58           3670    3672    3712#   
OLDBYT              1156           1919#   8437$   8451    8453    8458    
OLDCLR              A81D           16363   19144   20065   20303   20338#  
OLDLIN              1200           1967#   3631$   3632$   6354    6355    6771$   6773$   6778    6780    
OLDOV               0058           1620#   14643$  14660$  14685   14729   16003$  16027   
OLDSTK              0082           1697#   3475$   3910    
OLDTXT              1202           1968#   3507$   3508$   3894    4861$   5763    5764    6347    6351    18856   18857$  
OMERR               4D57           3881#   4013    4091    4433    6834    7642    7929    12772   16494   18781   
OMERR1              7E9A           12696   12703   12772#  12839   12850   
ON                  A592           19685   19848   19880#  
ON1                 A447           19663   19685#  19807   
ON2                 A55D           19831   19848#  19868   
ONEFUN             =00B4           2933#   2953    3718    11913   
ONGOTO              53C0           3128    5128#   
ONTK               =0091           2882#   2891    7652    19662   19805   19830   19867   
OPEN                918D           3142    16235#  
OPMASK              004F           1611#   3814$   11709$  11721   11722   11724$  11728   11767$  11780   
OPPTR               004D           1610#   11752   11822$  
OPTAB               4845           3267#   11744   11766   11771   11775   11777   11788   11951   21104   
OPTBYT              9E27           5994    5998    6002    6006    8602    9188    9474    9523    9691    9696    9706    9711    
                                   9716    9721    10374   10391   10450   10464   10479   10581   10742   18532#  19373   
OPTW99              9E23           18511#  18534   18537   
OPTWRD              9E0F           6545    6560    7971    8532    8535    8552    8556    8560    10490   10540   10717   10723   
                                   10751   18498#  
OPTZER              9E25           7766    7974    8399    8796    9467    9518    10706   10875   18529#  
OROP                4CA3           3280    3766#   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-30
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

OUT                 98AB           17375   17379   17386   17422   17438#  
OUTC                9599           16944   16951#  
OUTCH               90DF           5549    16118#  19354   
OUTDO               5629           3525    3528    3932    4632    4695    5469    5473    5533    5549#   6213    17478   17503   
OUTQST              5627           3926    5547#   5632    5699    
OUTS                98A8           17436#  17456   
OUTSPC              561D           5453    5516    5540#   
OVERR               895D           14764   14804#  15086   15598   17220   
P1L010              514B           4629#   4694    
P1L015              514F           4632#   4652    4654    4656    4709    4728    4769    
P1L019              515C           4634    4639#   
P1L020              5166           4642    4645#   
P1L026              5187           4672#   4719    4738    
P1L030              518D           4676#   4688    
P1L040              5190           4679#   4687    
P1L050              5199           4683    4685#   
P1L060              519E           4690#   4696    
P1L070              519F           4678    4692#   4766    
P1LINE              5140           4597    4623#   6192    
P1LRTS              51A8           4646    4698#   
P2CD10              5CB7           6810#   6821    
P2CD20              5CBD           6811    6813#   
P2CD30              5CD1           6806    6824#   6831    
P2CD40              5CDC           6828    6830#   
P2CD50              5CE0           6826    6832#   
P2CD60              5CE1           6818    6834#   
P2CODE              5CAC           6803#   6808    12900   
P2CODE_PATCH        7F2B           6793    12899#  
P3CD10              5CE5           6841#   6868    
P3CD15              5CFE           6847    6849    6856#   
P3CD20              5D0E           6854    6860    6863#   
P3CD30              5D16           6842    6870#   
P3CD40              5D1B           6873#   6882    
P3CODE              5CE4           6792    6839#   
PAINT               61C5           3156    7762#   
PAINT2              61DA           7768    7771#   
PAOC                91F6           16235   16244   16320#  
PAOC15              9239           16275   16350#  
PAOC20              91E3           16274   16276   16281   16299#  16331   16341   16348   
PAOC30              91EB           16292   16310#  16349   
PAOC32              91EE           16312#  16324   
PAOC5               9221           16337   16339#  
PAOCX               91EA           16301   16304#  16314   
PARAMS             =1150           1865#   1882    1898    1912    
PARCHK              79ED           3713    11914   11917#  14025   
PARCNT              123E           2016#   10449$  10458   10469   10475   
PAREND             =1168           1877#   1927    
PARS22              A536           19819   19828#  
PARSE1              A408           19641   19652#  19825   
PARSE2              A533           19827#  19866   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-31
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

PARSTS              0080           1693#   10919   18987   18993   19092   19145   19418   19434   19437   19439   19625$  19648   
                                   19798   19799$  19861   19862$  19922   19924$  19982   20131   20212   20216   20227   20231   
                                   20238   
PARSTX              0081           1695#   10926   19212   19626$  19644   19649   19769   19770$  19904   19905$  19992   
PCHAR               9911           17490   17502#  
PEEK                80C5           3238    13086#  
PEN                 82AE           3257    13468#  
PI                 =00FF           1499#   2685    4653    11860   
PI2                 9485           16724   16725   16802#  16841   16842   
PITCH               122D           2007#   10185$  10190$  10227$  10262   10264   
PIVAL               799B           11862   11863   11866#  
PLAY                6E7E           3186    9975#   
PLAY_BAD_VALUE      6F9A           10041   10058   10084   10091   10136#  
PLAY_COMMAND        6FEF           10022   10195#  
PLAY_DOT            6FA0           10017   10140#  
PLAY_FLAT           7009           10032   10218#  
PLAY_NOTE           6FBB           10002   10163#  
PLAY_ONE_CHARACTER  6E9F           9986    9993#   
PLAY_REST           7015           10013   10230#  
PLAY_REST_1         700F           10188   10226#  
PLAY_SHARP          7006           10028   10215#  
PLOT01              9C19           7844    8466    18037   18041   18047#  
PLOT10              9C40           18065#  18074   
PLOT20              9C43           18067#  18073   
PLOT30              9C46           18058   18071#  
PLOTGO              9C45           18051   18069#  
PLOT_80             AA78           9546    20779#  
PLOT_COLOR          03E6           1822#   18128   
PLOT_POINT          03E4           1821#   2492$   9514$   18048   18961   
PLOT_VIC            9C1C           2505    18049#  18962   
PLSV                91AE           16153   16172   16258#  
PLSV7               91DD           16277   16282   16292#  16332   16342   
PLUSTK             =00AA           2918#   2920    9911    11731   11874   15510   18705   
PNDD                98C8           17394   17458#  
PNDX                98D0           17462#  17467   
PNTERR              61EC           7777    7780    7782#   
PNTL                9711           17157   17173#  
PNTOK1              61E5           7775    7778#   
PNTOK2              61ED           7781    7794#   
POINT               0080           1694#   17015$  17032   17046   17048$  17094   17103   17156   17193$  17230$  17282$  17293   
                                   17323$  17334   17344$  
POINTER             82FA           3263    13516#  
POINTER_ERR         831B           13519   13535#  
POINTER_RET        =8307           12278   13521#  
POINTER_TK         =000A           3100#   3101    3735    
POIT                972E           17171   17192#  
POKE                80E5           3134    13105#  
POKER               0016           1574#   9663    13086   13088   13094   13098$  13100$  13108   13174   13176   13182   13185   
                                   13188$  13190$  13752   13754   13767   13770   13774$  13776$  14565$  14566$  19970   19971   
                                   20161   20163   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-32
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

POLY                909C           16033   16067#  
POLY1               90A0           16055   16070#  
POLY2               90B3           16082#  16097   
POLY3               90AF           16077   16079#  
POLY4               90C0           16088   16090#  
POLYPT              0072           1674#   16050$  16051$  16068$  16069$  16072   16074   16078$  16080$  16081   16084   16085   
                                   16091$  16092$  
POLYX               9086           14893   16049#  16774   16837   
POPDGO              60B8           7503    7565#   7590    7592    
POPERR              60D4           7567    7580#   
POPNGO              60DE           7553    7563    7591#   
POS                 84D0           3229    13931#  
POSINT              84AD           13905#  14536   
POSITN             =0063           1628#   17643$  17669   17680   17690$  17696$  17697   
POSP                012E           1757#   17066   17119   17466   17572   17574$  
POST                9879           17402   17407#  
POT                 824D           3255    13399#  
POT_ERROR           82AB           13403   13452#  13471   
POT_TEMP_1          12B1           2070#   13415$  13432   13476$  13481$  13483   
POT_TEMP_2          12B2           2071#   13430$  13448   
PRCHA               9587           16923   16928   16936#  
PREAM               864D           14127   14160   14183   14207#  
PREAMB              A83A           7674    20364#  
PRINT               5577           3136    5420    5426#   
PRINTC              5580           5429    5434#   5510    
PRINTK             =0099           2680    2891#   2895    
PRINTN              5557           3135    5408#   
PRINT_ESC_CMD       51A9           4663    4705#   
PRINT_ESC_FN        51C3           4665    4724#   
PRINT_FOREIGN_ESC   51DD           4712    4714    4731    4733    4755#   
PRMRPT              A62D           19647   19701   19715   19736   19840   19912   19921   19982#  
PRTDEC              A840           7731    20367#  
PRTRTS              55C5           5435    5465    5476#   5531    
PRXRPT              A632           19764   19775   19898   19992#  
PTARG1             =0059           1624#   17647$  17652   
PTARG2             =005B           1625#   17655   
PTBOTM              6220           7837    7839#   
PTDONE              6296           7887    7901#   
PTDORL              4860           3285#   11766   
PTDOWN              620E           7830#   7838    
PTDWN2              6216           7832    7834#   
PTERR               62B4           7925    7929#   
PTFIL2              6233           7846    7848#   
PTFIL3              624B           7857    7859#   
PTFIL4              625A           7865    7867#   
PTFIL6              6265           7870    7872#   
PTFILL              6228           7841    7843#   7875    
PTLOOP              6208           7825#   7900    
PTMAX               626C           7874    7876#   
PTMAX2              627C           7884    7888#   7897    

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-33
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

PTRGET              7B4C           5160    5659    5870    6043    6089    8204    11554   11965   12181#  13520   13990   
PTRGT1              7B51           5974    12183#  
PTRGT2              7B53           12184#  14014   
PTRGT3              7B60           12187   12192#  
PTSAVE              62BB           7924    7928    7936#   7945    
PUCHRS              1204           1973#   4834    4836$   7339$   
PUCOMA              1205           1975#   17374   
PUCTRL              5F51           3154    7331#   
PUDEFS              526D           4835    4867#   
PUDOT               1206           1976#   17385   
PUFILL              1204           1974#   17007   
PULSHI              1267           2022#   2395$   10111   10499$  
PULSLW              125D           2021#   10109   10501$  
PULSTK              7957           11756   11772   11823#  
PUMONY              1207           1977#   4834    17455   
PUNT                9846           17370   17381#  
PUSHF1              7921           11779   11786#  
PUTNEW              86E3           12031   14121   14156   14329   14346#  14407   16978   
PUT_GRAPNT          AB71           20789   20838   20934#  
PUT_IO_IN_MAP       A855           2418    6326    7637    8824    8862    9139    9203    9345    9372    9430    9527    9703    
                                   9742    10074   10099   10125   10260   10578   10587   10651   10794   10940   10958   10982   
                                   11013   11059   11276   11612   11633   12882   12891   13262   13350   13405   13486   13575   
                                   13624   13845   16113   16129   16140   16146   16159   16175   16245   16372   16378   16384   
                                   16389   16393   16397   16402   16407   16412   16417   16425   19024   19128   19152   19382   
                                   20389#  20736   20741   20746   20753   20853   20943   
PWHMUS              70CC           2394    10319#  
QCHNUM              794E           11745   11817#  
QCOMP               4D1E           3807    3840#   
QDATA               570C           5674    5693#   
QDATA1              5711           5694    5696#   
QDECT1              4E70           4041    4044#   
QDOT                79A0           11861   11869#  
QDSAV               7AD3           12089   12097#  
QERLIN              7AFD           12099   12123#  
QINLIN              56B9           5613    5629#   5701    
QINT                8CC7           5225    13919   14562   15409#  15728   21027   
QINT1               8CE9           15423   15429#  
QINTGO              84C6           13911   13916   13919#  
QINTGR              5400           5177#   5740    6059    
QINTRT              8CE8           15388   15427#  
QISHFT              8CDC           15414   15420#  
QNUM                0390           1795#   5232    
QNUMER              7B15           12126   12135#  
QOP                 7949           11730   11732   11812#  
QOPGO               794C           11755   11815#  
QOPRTS              7971           11816   11841#  
QPLUS               8D38           15488   15492#  
QPREC               78DE           11742#  11768   
QPREC1              7907           11753   11770#  
QSETNR              8455           13841   13857#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-34
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

QSHFT               8B86           15154   15160#  15193   
QST001              7BF4           12289#  12317   
QST002              7C08           12300#  12319   
QST003              7C0E           12304#  12321   
QST004              7BFE           12294#  12323   
QSTATV              7AC5           12072   12088#  
QTYER2              A4A5           19704   19722   19724   19739   19746#  
QTYERR              A58F           19843   19876#  19901   
QVARIA              5485           5248    5253#   
RADDC               8495           13863   13864   13889#  
RANGE               5F18           4575    7229    7295#   
RBITS               9D25           10199   11144   11145   11155   11158   18258   18262   18265#  20784   20787   20844   
RCLR                819B           3248    13261#  
RDCN                A713           20082   20161#  
RDFN                A733           20108   20182#  
RDOT                9B0C           3251    17867#  
RDRT0               A755           20171   20187   20199#  
RDRT1               A756           20180   20200#  
RDY                 9730           17155   17194#  
READ                56C6           3118    5637#   
READGO              9C75           18092   18114#  
READL1              9C6B           18102   18107#  
READL3              9C73           18110   18113#  
READLP              9C5C           18096#  18099   20849   
READPT              9C4C           7779    7836    7873    7914    8436    17873   18087#  
READY               4D54           2213    3501    3640    3878#   6172    7287    7401    
READYX              4DD4           3886    3943    3949#   
READ_80             AADC           9546    20841#  
READ_POINT          03E8           1823#   18088   
READ_VIC            9C4F           2505    18090#  
REALSP              5621           5543#   5633    
REASON              5034           4402#   12468   12649   12705   
REAY                95C7           16954   16982#  
REC4                A32A           19367   19376   19378   19397#  
REC5                A2E4           19301   19357#  
REC6                A32D           19384   19398#  
RECLEN              A46D           19655   19657   19713#  
RECON               A48B           19719   19729#  
RECORD              A2E7           3200    19362#  
REDDY               4D47           3874#   3949    16222   
REM                 52BA           2739    3126    4943#   5009    5073    5115    
REMER               52D2           4959#   4965    
REMN                52C2           4943    4950#   6247    
REMRTS              52B9           4937    4939#   4960    4962    
REMTK              =008F           2730    2879#   2882    5071    
RENAME              A37E           3178    19459#  
RENUM               5B15           3181    6514#   
RENUM_10            5B42           6536    6544#   
RENUM_20            5B52           6553#   6582    
RENUM_30            5B55           6546    6551    6559#   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-35
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

RENUM_TMP_1         1170           1941#   6521$   6522$   6539$   6540$   6572    6573    6943    6945    
RENUM_TMP_2         1172           1942#   6523$   6524$   6548$   6549$   6550    6979    6982    
REN_EXIT            5C15           6674    6705#   
REN_PASS_1          5B85           6529    6561    6592#   
REN_PASS_2          5BCB           6598    6611    6615    6644#   
REN_PASS_3          5BDC           6661#   
REN_PASS_4          5BE1           6672#   6694    6698    
RES00               87AA           14473   14475#  
RESCNT              5FF8           7384    7442#   
RESE10              4408           2817#   2821    
RESE20              4409           2818#   2842    
RESE30              4414           2827#   2830    
RESE40              441B           2828    2831#   
RESE50              4428           2837    2839#   
RESE60              442F           2823    2846#   
RESEND              5FE3           7420    7431#   
RESER               43FF           2705    2713    2721    2812#   
RESETC              573F           5715    5722#   
RESHO               0028           1582#   14812   14933$  14970   14972$  14974$  15206   
RESLO               002B           1586#   14936$  14961   14963$  14977$  15156$  15212   
RESLST              4434           2719    2720    2854#   4669    4670    
RESMO               002A           1585#   14935$  14964   14966$  14976$  15210   
RESMOH              0029           1583#   14934$  14967   14969$  14975$  15208   
RESNUM              5FC9           7387    7418#   
RESSNR              5FF5           7389    7439#   
RESSWP              5FD4           7386    7391    7423#   
RESTOR              5AE7           3123    6437#   
RESTORE$1           5AFE           4840    6438    6449#   
RESTORE$2           5B03           6447    6453#   
RESTTK             =008C           2874#   2876    6512    
RESUME              5F7F           3147    7381#   
RESUTK             =00D6           2979#   2981    6512    
RET010              528D           4905    4909#   
RETPA1              A854           20383   20385#  
RETPAT              A84B           4921    7601    20378#  
RETRN               976C           17200   17231#  17263   
RETURN              527F           3125    4891#   
RFAT                A6EB           20086   20131#  
RFATA               A6F1           20132   20134#  
RGR                 8182           3247    13223#  
RGRTK              =00CC           2964#   2967    3662    
RID                 A6F5           20080   20141#  
RIGHTD              860A           3245    14160#  
RIGHT_FLAG          0064           1650#   7828$   7860    7862$   
RLEFT               85E3           14135#  14168   
RLEFT2              85EB           14140#  14195   
RLEFT3              85EC           14141#  14198   14200   
RLSSTK              5076           4460#   4911    5864    7570    
RMULC               8490           13860   13861   13888#  
RND                 8434           3231    13838#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-36
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

RND1                846A           13840   13867#  
RNDD                96A9           17098   17104   17107#  
RNDRTS              8925           14761   14770#  
RNDSHF              8917           14762#  15303   
RNDX                121B           1993#   2278$   13857   13858   13883   13884   
RND_0               8437           13840#  21091   
RNGERR              5F4E           7298    7301    7303    7311    7314    7323#   
RNGRTS              5F4D           7317    7321#   
ROLSHF              8990           14674   14838#  15436   
ROMADD              8A12           13865   14884   14896   14910#  16093   16726   16767   
ROMDIV              8A1E           14887   14918#  16833   
ROMMLT              8A08           13862   14902#  15699   15994   16083   
ROMSUB              8A18           14890   14914#  16752   16843   
ROMUPK              8A89           9055    9069    14903   14911   14915   14919   14987#  21096   
ROTANG              1158           1870#   
ROUND               8C47           5178    7192    11799   15129   15248   15283   15295#  21026   21087   
ROUND_QINT          ABC1           15448   21025#  
ROWCNT              115F           1892#   8766$   8774    8779$   8810    8866    11078$  11123   11136   11137   11138   11242   
                                   11245$  11406   
RREG                58DA           3191    6036#   
RRTS                97FA           17295   17298   17301   17305   17309   17325   17328#  17348   
RSCA                A6E6           20078   20128#  
RSFN                A71D           20088   20170#  
RSPA                9676           17074   17077#  
RSPCOLOR            8361           3260    13617#  
RSPMOD              835B           13583   13597#  
RSPPOS              8397           3258    13687#  
RSPRITE             831E           3259    13559#  
RT                  99C0           17593   17595   17598   17601   17603   17605   17607#  
RTS_80              AB3D           20843   20899#  20905   20908   20916   
RTTS                9637           17047   17049#  
RUN                 5AB8           3121    6394#   21108   
RUN$10              5AD2           6394    6413#   
RUN$20              5AD8           6395    6418#   
RUNC                5210           4796#   6406    6414    16224   21109   
RUNMOD              007F           1691#   3417    3468    3482    3520    3626    3888    3953$   5044    6273    6343    6360$   
                                   6400$   7530    13941   13960   16197   16218   18842   19314   19340   20312   20384$  
RUNTK              =008A           2871#   2874    6512    
RUN_A_PROGRAM       5AC3           6403#   21118   
RWINDOW             8407           3262    13798#  
RWRT                A701           20084   20148#  
R_PASS1_10          5B91           6600#   6610    
R_PASS1_20          5BA7           6608    6613#   6619    
R_PASS1_30          5BB5           6617    6621#   
R_PASS4_10          5BFC           6682    6686#   
R_PASS4_20          5C0D           6681    6685    6695#   
SADJ2               552E           5362    5366#   
SADJ3               553B           5370    5373#   
SADJ4               5543           5375    5378#   
SADJ6               5552           5386    5388#   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-37
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

SADJ8               5554           5355    5363    5365    5369    5372    5377    5392#   
SAV60               A44A           19686#  19690   19694   19707   
SAV61               A58D           19810   19871#  
SAVE                9112           3131    16153#  
SAVEIT              5567           5412    5415#   
SAVENB              911D           16159#  19242   
SAVENP              9115           16155#  19170   
SAVINP              7819           11491   11528   11564#  
SAVQUO              8B79           15142   15145   15148   15151#  15168   15171   
SAVRAM              12B7           2076#   11073$  11170   11498$  11503$  11504$  11506$  11508$  11509   11510   19791$  20174   
SAVS50              77FD           11529   11550#  
SAVSIZ              03DB           1812#   8237$   8240$   8325$   8326$   8329    8339$   8341$   8343$   8344    8346    8363    
                                   8365    11518$  11519$  11520$  11533   11535   11538   11557   11559   
SBITS               6D50           9741    9745    9750#   9887    9891    10064   10067   10485   10548   10551   10745   11031   
                                   11197   13585   13713   20421   20451   
SCALE               697D           3166    9032#   
SCALEH              70A2           10186   10298#  
SCALEL              7096           10184   10295#  
SCALEM              116A           1934#   2276$   9037$   9493$   9525$   18307   
SCALEN              708F           10167   10293#  
SCALE_X             0087           1707#   9046$   9047$   9080$   9082$   18310   18311   
SCALE_Y             0089           1708#   9048$   9049$   9077$   9078$   18314   18315   
SCALXY              9D53           8549    9838    9856    18307#  18643   18678   
SCAN_THRU           5DA0           6697    6962    6966#   6968    
SCHS1               9586           16931   16934#  
SCLERR              6A66           9132    9138    9190#   
SCLRTS              9D6F           18308   18323#  
SCNCLR              6A96           3165    9228#   
SCNCLR_1            6AB2           9249#   9490    
SCNCLR_2            6AC2           9242    9255    9258#   
SCNCLR_80           AAEB           9232    9252    9521    20852#  
SCRATC              A2B1           3175    19332#  
SCRATK             =00A2           2902#   2904    3549    3553    3591    
SCREEN_FILL         6B2D           9332#   9354    9366    9375    
SCREEN_START       =0400           1518#   2336$   
SCRTCH              51F6           2356    4779    4782#   
SDP1                A681           20068#  20100   20106   20133   20200   
SDP2                A6B5           20092   20095#  
SDP3                A6BE           20096   20099#  
SDP4                A6C5           20098   20102#  
SDP5                A6C7           20076   20094   20104#  20129   20135   20145   20151   20155   20165   
SEARCH              4FC7           4315#   4904    5875    7121    7566    
SENDP               A677           19002   19109   19164   19195   19229   19267   19491   20062#  
SER                 9553           16899   16908#  
SETCOL              76DC           11126   11348   11399#  
SETEXC              5A9E           6274    6359#   6405    6413    6421    21119   
SETH30              9FD0           18837#  18938   
SETH40              9FFB           18864#  18891   18893   
SETH45              A007           18843   18871#  
SETH50              A008           18867   18870   18874#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-38
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

SETH60              A019           18877   18884#  
SETH70              A020           18882   18888#  
SETHIR              9F58           9459    10957   18767#  
SETQUT              5733           5710    5716#   
SETTWO              9D98           17729   17809   17814   18350   18369   18389#  
SET_END             5BCA           6631    6634#   
SET_ENVELOPE        6F4E           10050   10096#  
SET_ENVELOPE_1      6F4F           2409    10098#  
SET_FILTER          6F03           10055#  
SET_GRAPNT          AB79           20929   20936   20942#  
SET_NEXT            5BBA           6609    6614    6625#   
SET_NOTE_LENGTH     6FA4           10007   10146#  
SET_OCTAVE          6F45           10047   10089#  
SET_PACKED_COLOR    6A79           2304    9187    9196#   
SET_VOICE           6F3A           10044   10080#  
SET_VOLUME          6F7A           10053   10116#  
SET_WIDTH           7253           3210    10609#  
SEXP                9731           17199#  17218   17226   
SFUR                9903           17494#  17507   
SGN                 8C65           3224    15321#  
SGNFLG              0069           1658#   15489$  15551   
SHARP               122C           2006#   10175   10220$  10273$  
SHFARG              8B89           15163#  15188   
SHFTR2              8964           14813#  14825   14826   
SHFTR3              8986           14831#  14844   
SHFTR4              898C           14833   14835#  
SHFTRT              899A           14830   14845#  
SHIFTR              8979           14635   14823#  15425   
SHOW_SPRITE         766E           11069   11095   11184   11305   11325#  
SHPN                96EE           17080   17082   17151#  
SID                =D400           1528#   2377$   2378$   2379$   2385$   10075$  10106$  10108$  10110$  10112$  10126$  10263$  
                                   10265$  10267$  10269$  10652$  10797$  10800$  10802$  10806$  13426   13427   20540$  20631$  
                                   20633$  20652$  
SIGN                8C57           7190    13839   14872   15308#  15322   15364   21089   
SIGNON_END          4254           2463    2474#   
SIGNON_MESSAGE      419E           2222    2446#   
SIGNON_MSG          41BE           2448    2463    2468#   
SIGNRT              8C64           15310   15316   15318#  
SIN                 9410           3235    16739#  16782   21084   
SIN1                9442           16755   16762#  16799   
SIN2                9445           16758   16764#  
SIN3                9452           16769   16771#  
SINCON              9494           16772   16773   16808#  
SINVAL              114A           1854#   8058    8074    9808$   9810$   17782$  17784$  17800   
SIZEOK              8731           14393   14398#  
SLEEP               6C74           3193    9591#   
SLEEP_TIMES_2       6CA9           9603    9623    9624#   
SLEEP_TIMES_4       6CA6           9605    9611    9622#   
SLOW                7861           3220    11633#  
SLR1                93F0           16509   16651   16694#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-39
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

SLR2                9407           16707   16709#  
SNER                A5C6           19871   19884   19909#  19951   19965   19983   19993   
SNERR               7A09           3206    3598    3763    4548    5135    5513    6281    6320    7224    7323    7439    7506    
                                   7661    9786    9908    11784   11944   11947#  12188   12310   13536   14070   16315   16908   
                                   17529   18628   18990   19216   19357   19476   19677   19708   19909   20209   
SNERR1              4BC8           3548    3552    3583    3598#   3601    3659    
SNERR4              55F7           5497    5512#   
SNERR5              791E           11723   11783#  
SNERR6              4CA0           3734    3755    3763#   
SNGFLT              84D4           13101   13226   13312   13376   13496   13503   13592   13629   13663   13708   13823   13934#  
                                   14233   14253   17712   17877   
SNO                 0132           1761#   17011$  17068   17121   17418   17421   17567   17570$  
SNRJMP              605E           7464    7506#   7557    
SOFT_RESET          4009           2193    2201#   
SOUND               7289           3151    10679#  
SOUND_DIRECTION     1294           2048#   20570   20591$  20619$  
SOUND_FREQ_HI       12A0           2052#   20566   20568$  20582   20597$  20605   20625$  20632   
SOUND_FREQ_LO       129D           2051#   20562   20564$  20580   20595$  20609   20623$  20630   
SOUND_IRQ           A938           20551#  
SOUND_MAX_HI        128B           2045#   20596   20606   
SOUND_MAX_LO        1288           2044#   10782$  20594   20610   
SOUND_MIN_HI        1291           2047#   20583   20624   
SOUND_MIN_LO        128E           2046#   20581   20622   
SOUND_STEP_HI       129A           2050#   20567   20662   20665$  
SOUND_STEP_LO       1297           2049#   20563   20656   20660$  
SOUND_TIME_HI       1285           2042#   2399$   2400$   2401$   10775   10819$  20554   20642$  20645   
SOUND_TIME_LO       1282           2041#   10821$  20639   20643$  
SOUND_VOICE         1281           2039#   10685$  10768   10792   10814   
SPCTK              =00A6           2910#   2912    5440    
SPOS                998C           17568   17571#  17581   
SPRBIT              6D38           9694    9709    9714    9719    9724    9737#   
SPRCOLOR            722D           3190    10570#  
SPRCOR              6E3B           9783    9792    9901#   
SPRDEF              740F           3211    10957#  
SPRITE              6CEC           3189    9689#   
SPRITE_BASE        =0E00           1511#   2333    9379    11065   11292   11575   
SPRITE_DATA         117E           1953#   1955    2287$   2345$   2438$   9804$   9817$   9823$   9828$   11051$  13707   20425   
                                   20428$  20432   20442   20453$  20680   20681   20682$  20683   20684   20685$  
SPRITE_ERROR        6D35           9700    9728#   9739    9761    
SPRITE_NUMBER       12FC           2079#   11025$  11048   11060   11093   11196   11383   
SPROFF              6E76           2437    9802    9948#   11049   13706   20424   
SPRSAV              7789           3204    11491#  
SPRSUB              AA04           20438   20443   20678#  
SPRTMP_1            03E0           1814#   11525$  11550   
SPRTMP_2            03E1           1815#   11527$  11552   
SQR                 8FB7           3230    15897#  21078   
SQR05               89B6           14867#  14882   14883   
SQR20               89BB           14868#  14885   14886   
SQUEEZ              8915           14743   14760#  
SRCH05              4FCC           4320#   4371    4373    

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-40
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

SRCH10              4FD8           4322    4327#   
SRCH15              4FFA           4346    4352#   
SRCH20              4FFE           4331    4355#   
SRCH30              500C           4353    4364    4367#   
SRCH98              5018           4325    4375#   
SRCH99              501A           4340    4344    4350    4357    4376#   
SRCHTK              0002           1556#   4315$   4329    4356    
SSHAPE              6448           3161    8203#   
SSWE                9679           17067   17069   17079#  
ST2TXT              79BC           5731    11886#  
STASGN              4D13           3827    3829    3832#   
STASH               AA2F           3213    20707#  
STEPTK             =00A9           2916#   2918    7185    
STERR               7887           11669#  11706   
STKBOT             =09FF           1509#   4321    4324    4822    4823    18866   18869   
STKEND             =01FB           1497#   2231    4855    
STKINI              5255           2207    3937    4060    4850#   
STKRTS              526C           4807    4864#   
STKTOP             =0800           1508#   4392    
STLINE              770B           11007   11422#  
STMDSP              4719           3110#   3562    3564    
STOINT              84E5           11906   13925   13950#  
STOLD               9043           15997   16002#  
STOMLT              7E02           12662   12665#  
STOP                4BE8           3127    3622#   
STOPC               4BEB           3622    3625#   
STOPNB              008B           1709#   7774$   18101   
STOP_1              4BED           3613    3626#   
STOP_SPRITES        4190           2205    2434#   
STORTS              84EF           13942   13955#  
STOUT               96D8           17133#  17135   
STP                 95F8           17014#  17026   
STR1               =005D           1626#   6115$   6139    6146$   17654$  17671   17682   
STR2               =0060           1627#   6117$   6124    6126$   6128$   6131    6133    6144    17657$  17661   17668   17676   
                                   17686   
STRADJ              5513           5310    5324    5352#   14458   
STRADR              115F           1925#   8206$   8207$   8348    8350    
STRCMP              4CEB           3798    3811#   
STRCNT              1160           1893#   8868$   8870    8871$   11328$  11335   11337$  
STRD                85AE           3240    14095#  
STRDN2              5761           5734    5741#   
STRDON              5571           5422#   5449    
STREND              0033           1591#   4831$   4832$   7802    7804    7883    7886    12329   12330   12359   12361   12469$  
                                   12470$  12578   12580   12706$  12707$  12723   12727   12977   12980   16462   16465   
STRFI1              86BC           14305   14313#  
STRFI2              86BD           14312   14315#  
STRFIN              86B8           14307   14310#  
STRFRE              92C0           16464   16467#  
STRGET              86AA           14302#  14309   
STRINI              8688           5286    12019   14267#  14327   14398   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-41
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

STRLIT              869A           5451    5524    11884   14103   14292#  
STRLIT_1            86CC           11515   14326#  
STRLT2              86A0           5729    14296#  
STRNAM              7B9C           12213   12226#  
STRNEX              847A           13854   13876#  
STRNG1              0070           1667#   2598    2602    5289$   5290$   5293    5294    11511$  11512$  14297$  14298$  14318   
                                   14320   14384$  14386$  14404   14405   
STRNG2              0072           1673#   11886   11887   13001$  13004$  13007   13011$  13017$  13033$  13034$  13066$  13067$  
                                   13073   13074   14319$  14324$  
STROUT              55FF           5524#   15673   
STRPR2              5609           5530#   5536    5538    
STRPRT              5602           5423    5452    5526#   5606    
STRPTR              1155           1918#   8247$   8296$   8297    8419$   8429$   8430    
STRRTS              7AC4           12039   12086#  
STRRTS_1            7A50           11978   11988   11991   12003#  12006   12008   
STRSIZ             =0003           1500#   12433   14347   14347   14347   14522   
STRSPA              8690           8253    13136   13180   14113   14142   14272#  16968   
STRST2              86C9           14321   14323#  
STRSZ               1153           1916#   8392$   8406    
STRTX2              79B9           11882   11884#  
STRTXT              79B0           5603    11878#  
STXBUF              8F17           15805   15809#  
STXFND              7BB0           12238#  12260   
STXTPT              5271           4183    4796    4869#   6715    6947    16229   
STZ                 97A8           17277#  17280   
SUBFLG              0012           1569#   4862$   7118$   12214   12228   12234$  13989$  14013$  
SUBIT               888E           14680   14683#  
SUBTW2              9D88           18339   18371#  
SUBTWO              9D85           8568    8617    17951   17966   17977   18341   18368#  18405   
SUSMUS              70B8           10311#  
SUSTAB              1249           2019#   10107   10443   10507$  
SWAP                AA39           3217    20731#  
SWAPLP              9061           16020#  16026   
SWAPXY              8139           9833    13145   13149   13158#  
SWAP_01             AA3B           20708   20718   20733#  
SWE                 0127           1750#   17078$  17118$  17144$  17278$  17459   17461$  
SW_RAM0            =FF01           1546#   2516$   2534$   2553$   2559$   
SW_RAM1            =FF02           1547#   2541$   2547$   
SW_ROM_RAM0        =FF03           1548#   2519$   2536$   2555$   2561$   3884$   4327$   5931$   7338$   7483$   7796$   7894$   
                                   7939$   8205$   8254$   8304$   8333$   8391$   8414$   8433$   8789$   8873$   8932$   9976$   
                                   9985$   11542$  12130$  12135$  16421$  17006$  17373$  17384$  17454$  17701$  17706$  19790$  
                                   20191$  20351$  
SW_ROM_RAM1        =FF04           1549#   2543$   2549$   5182$   5192$   5314$   5328$   5917$   7937$   8302$   8331$   12444$  
                                   12654$  13139$  13183$  14048$  14077$  14116$  14333$  14462$  16472$  16513$  16970$  20257$  
                                   20286$  20344$  
SYNCHR              79FB           4991    5164    5414    5570    5589    5605    6107    7160    11939#  13994   14011   16914   
                                   19363   
SYNTMP              0079           1688#   3850$   3852    4496$   4498    4506$   4508    7688$   7695    7724    11941$  11943   
                                   12406$  12410   12615$  12617   12758$  12761   12766$  12767   14130$  14132   14163$  14166   
                                   14191$  14194   14389$  14392   15608$  15616   17684$  17688   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-42
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

SYS                 58A2           3141    5985#   
SYSSTK              0137           1768#   11705   
SZER                9816           17335   17350#  
T3                  1174           1944#   19028$  19038$  
T4                  1175           1945#   19031$  19035$  19043   19044   
TABER               55D6           5439    5442    5491#   
TABLD               A637           20019#  20023   20026   20029   20032   20035   20038   20041   20044   20047   20050   20053   
                                   20075   
TABTK              =00A3           2904#   2906    5438    
TACKY1              A4A3           19730   19743#  
TAG1                974D           17216#  17219   
TAG2                9758           17213   17215   17222#  17227   
TAG3                9782           17217   17247#  17314   
TAN                 9459           3236    16778#  21085   
TANSGN              0014           1572#   16759   16761$  16781$  16791   
TAT                 98DA           17468#  17475   
TELX                98A1           17415   17429#  
TEMPF1              0059           1623#   1624    1625    1626    1627    1628    1629    15245   16053   16056   16057   16786   
                                   16787   18374$  18379   20798$  20804   20910$  20918   
TEMPF2              005E           1636#   15242   16094   16095   16514$  16517$  16654$  16657$  16697$  16700$  16705   16706$  
                                   16708$  20799$  20806   20911$  20920   
TEMPF3              0050           1613#   15923   15924   15930   15931   15942   15943   16783   16784   16793   16794   
TEMPO               7074           3187    10278#  
TEMPO_RATE          1222           2002#   2374$   10281$  20523   
TEMPPT              0018           1576#   2306$   4851$   14346   14368$  14521$  16505   16647   
TEMPST              001B           1578#   2305    4850    7810$   7813$   7923    7927    14347   16507   16649   
TEMP_DIRECTION      12A9           2061#   10710$  
TEMP_FREQ_HI        12AD           2065#   10693$  
TEMP_FREQ_LO        12AC           2064#   10692$  10805   
TEMP_MAX_HI         12A6           2058#   10691$  
TEMP_MAX_LO         12A5           2057#   10690$  10781   
TEMP_MIN_HI         12A8           2060#   10719$  
TEMP_MIN_LO         12A7           2059#   10718$  
TEMP_PULSE_HI       12AF           2067#   10758$  
TEMP_PULSE_LO       12AE           2066#   10757$  
TEMP_STEP_HI        12AB           2063#   10735$  
TEMP_STEP_LO        12AA           2062#   10737$  
TEMP_TIME_HI        12A4           2055#   10701$  10763   10816   
TEMP_TIME_LO        12A3           2054#   10700$  10762   10815   
TEMP_WAVEFORM       12B0           2068#   10747$  
TENC                8B2E           15103#  15114   15115   
TENEXP             =0060           1642#   11994$  15525   15532   15536$  15541$  15548$  15592   15604   15620$  15744$  15832   
                                   15837   
TESTWD              5B0D           6511#   6741    
TEXT_TOP            1210           1986#   4004    4005    4019    4029    4030$   4032    4034$   4039    4068    4069    4093$   
                                   4094$   4265$   4266$   4791$   4794$   6647    6648    6859$   6861$   6877    6879$   6880$   
                                   7017    7019    7258    7259$   7261    7262$   7282$   7286$   12915   12917   12951   12954   
                                   16155   16156   16215$  16216$  18771   18784   18788   18790   18824   18826$  18921   18930   
                                   18932$  
THENTK             =00A7           2912#   2914    4990    6512    

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-43
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

TIMELP              5435           5207#   5223    
TIMEND              8FB7           15818   15891#  
TIMES2              7081           10061   10234   10287#  
TIMNUM              5465           5209    5213    5230#   
TIMSTR              85B8           12001   14101#  
TMERR               5774           5748    5752#   
TMPDES              03D6           1810#   17619$  17621$  17626$  17628$  17646   17703   17704   17707   17708   
TMPLIN              1216           1990#   7455$   7491    7494    7574    7575    
TMPTRP              120D           1983#   3904$   7435    
TMPTXT              1214           1989#   7453$   7485    7488    
TOGCUR              76E7           11081   11085   11406#  
TON110              71EB           10491   10496   10503#  
TONE10              7168           10436   10440#  
TONE20              717F           10449#  10478   
TONE30              719D           10451   10464#  
TONE40              71B6           10465   10475#  
TONE80              71D0           10483   10488#  
TONE90              71D3           10480   10490#  
TONERR              7165           10438#  10484   
TONNUM              123A           2014#   10440$  10498   10503   
TONVAL              123B           2015#   10442$  10444$  10446$  10459   10462$  10470   10473$  10488$  10494   10504   10506   
                                   10508   
TOS                 007D           1690#   4386    4387$   4388    4391$   4395    4442    4444    4453$   4455$   4462    4463$   
                                   4465$   4824$   4825$   6290$   6293$   6296$   6299$   6302$   7142$   7146$   7152$   7155$   
                                   7174$   7197$   7206$   7209$   7212$   7486$   7489$   7492$   7495$   7498$   
TOTK               =00A4           2906#   2908    6312    6750    7159    8711    8722    19808   
TRANR               A6CF           20070   20111#  
TRANS               A3A7           19312   19338   19395   19406   19423   19442   19452   19464   19491#  
TRAP                5F6A           3148    7349#   
TRAPNO              120B           1982#   3611    3899    3905    3909$   4812$   7353$   7356$   7436$   
TRAPTK             =00D7           2981#   3002    6512    
TRCFLG              116F           1939#   2270$   3517    4787$   6023$   
TRMN01              5778           5747    5755#   
TRMN02              577C           5750    5757#   
TRMN03              577E           5753    5758#   
TRMOK               57A1           5742    5744    5771#   
TRMPOS              000B           1561#   5494$   5501    
TROFF               58D4           3150    6021#   
TRON                58D1           3149    6017#   
TRTS                999A           17511   17577#  
TRYAG2              929B           16442#  16491   
TRYAG3              92A9           16450   16452#  
TRYAG4              92B6           16459   16461#  
TRYOFF              8AF9           15059   15064#  
TSTGO               62B7           7915    7916    7931#   
TSTOP               78A6           11710#  14408   
TSTVAL              6299           7851    7861    7912#   
TSTXIT              62BA           7918    7933#   
TTO                 4B51           3473    3505#   3628    
TURNON              7B95           12210   12221#  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-44
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

TWOBY1              9DD3           18443#  18458   
TWOBY2              9DE8           18446   18454#  
TWOBYT              9DB7           17817   18317   18430#  
TWOPI               948A           16741   16742   16804#  
TWORTS              9DF7           18461   18463#  
TXTPTR              003D           1596#   2513$   2515$   2518    2560    2658    2660    2729$   2744    2746$   2748$   2751    
                                   2774$   2777$   2789    2791    2798$   2818    3435    3437    3454$   3456$   3495    3496$   
                                   3498$   3505    3506    3962$   3963$   4063    4177    4872$   4875$   4915$   4918$   4935    
                                   4936$   4938$   5059    5060$   5062$   5096$   5098$   5664    5667$   5703$   5704$   5712$   
                                   5724    5725    5765$   5766$   5772    5775$   5942$   5945$   6256    6257    6269$   6272$   
                                   6289    6292    6352$   6353$   6632$   6633$   6688$   6691$   6770    6772    6779$   6781$   
                                   6784    6786$   6788$   6866$   6996$   6998$   7013    7015    7141    7143    7411    7412$   
                                   7414$   7427$   7452    7543    7544$   7546$   7595$   7598$   11524   11526   11551$  11553$  
                                   11694   11696$  11697$  11761   11763$  11765$  11879   11880   11888$  11889$  14000   14002   
                                   14050   14052   14055$  14058$  14073$  14075$  18852   18853$  
TXTTAB              002D           1588#   2311$   2312$   4226    4227    4485    4486    4784$   4786$   4788    4792    4870    
                                   4873    6262    6263    6451    6452    16157   16177   16178   18828   18830$  18926   18928$  
UEXP                0129           1752#   17044$  17056   17062$  17089   17204   17210   17397   17411   
UMLCNT              7F09           12842   12851#  
UMULT               7EDB           12689   12780   12820#  
UMULTC              7EF0           12832#  12853   
UMULTD              7EE6           12803   12826#  
UNIT                A59D           19689   19851   19886#  
UNIT1               A44D           19667   19689#  
UNIT2               A563           19833   19851#  19870   
UNPACK_GRAPHM       818C           9233    13224   13231#  
UNPSTK              7955           11819   11821#  
UNTLTK             =00FC           3024#   3026    7461    7556    
UN_QUOTE            5399           5067    5094#   7525    
UPPER_GRAPHIC       11EC           1958#   2352$   8840    8884    
UPPER_LOWER         11EB           1957#   2354$   8879    
UROUND              97B9           17081   17108   17291#  
USERR               5A32           6266    6277#   6444    
USETK              =00FB           3022#   3024    5428    
USGN                0128           1751#   17041$  17095   17214   17237   17240$  17405   
USING               9520           5430    16875#  
USING_PATCH         ABC7           17449   21033#  
USRPOK              1218           1992#   2241$   2245$   2246$   3227    
VAL                 804A           3241    12993#  
VALTYP              000F           1565#   3813$   5167    5448    5707    6046    8208    11565   11661   11733   11758$  11849$  
                                   11971   12193$  12209$  12533   12568$  13951$  14237$  14363$  16918   
VAL_1               8052           12994   12999#  21062   
VAL_2               8075           12967   13018#  
VARNAM              0047           1602#   11969   11970   12184$  12218   12219$  12226$  12246   12250   12314   12315   12443   
                                   12447   12539   12541   12545$  12547$  12586   12589   12653   12660   12793   12797   
VAROK               7C2D           12292   12298   12302   12308   12325#  
VARPNT              0049           1604#   12461$  12462$  12806$  12809$  12811   13996   13998   14033$  14038$  14041   14046   
                                   14059   14061   
VARTAB              002F           1589#   2316$   2317$   4827    4828    5255    5259    12235   12236   
VARTXT              004D           1609#   5665$   5774    

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-45
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

VDCGET             =CDD8           20775#  20930   
VDCIN              =CDDA           9432    9529    20776#  
VDCOUT             =CDCC           2498    9434    9437    9439    9441    9444    9531    9534    9537    9540    9543    20774#  
                                   20856   20859   20886   20889   20896   20946   20949   
VDCPUT             =CDCA           20773#  20861   20883   20938   
VERCK               000C           1562#   16171$  16176   16185   19184$  
VERIFY              9129           3132    16167#  
VF                  012C           1755#   17051   17070   17073$  17115   17153   17537$  17547$  
VIC                =D000           1524#   1525    1526    9704$   9743    9746$   10579$  10588$  10985   11033   11046$  11094$  
                                   11176$  11195   11198$  11374   11376   11379   11384   11460   11614   11616$  11619$  11636$  
                                   11638   11641$  13576   13587   13625   20413$  20420   20464   20465$  20476   20480$  20500   
                                   20502   
VIC_BACKGROUND     =D021           1526#   8863    9147$   9204    13280   
VIC_BORDER         =D020           1525#   9167$   13293   
VIC_SAVE            11D6           1954#   9869    9872$   9877    9878$   9882    9885$   9886    9893$   11039$  11041$  11043   
                                   11044$  13475   13478$  13658   13660$  13714   13731   20412   20450   20452$  20477   20478$  
                                   20501$  20503$  20690   20697$  
VN                  012A           1753#   17034$  17112$  17116   17128   17142   17154   17166$  17181$  17327$  
VOICE               122F           2008#   2407$   2410$   2412$   10060   10085$  10100   10233   
VOICES              1223           2003#   2402$   2403$   2404$   10062   10206   10236   10240$  10242$  10251   10252$  10254   
                                   10255$  10772   20518   20521   20524$  20526   20528$  
VOLTAB              70D9           10120   10124   10327#  
VOLUME              7262           3152    10632#  
VTEMP1              008E           1711#   8221$   8227    8243$   8244$   8275$   8295    11143$  11147   11148$  11152   11291$  
                                   11295$  11298   11382$  11385   11389$  11394   17756$  17764$  18431$  18444$  20956$  20963$  
                                   20997$  21000$  21003$  21006$  21014   
VTEMP2              008F           1712#   8289$   8314    11119$  11150   11156$  18432$  18445$  20958$  20962$  20968$  20972   
                                   20998$  20999$  21002$  21005$  
VTEMP3              1177           1946#   18441$  18450   18452$  18455$  18460   
VTEMP4              1178           1947#   18621$  18638   18647   18672$  18673$  18675   18680   18694   18713   
VTEMP5              1179           1948#   18645$  18654$  18664$  18686$  18711$  
VWORK               1131           1831#   7763    7967    7969    8053    8054    8058    8065$   8067$   8074    8077    8080    
                                   8107    8109    8110    8115$   8116$   8117$   8119$   8120$   8121$   8125$   8127$   8128    
                                   8131    8212    8215    8218    8219    8241    8242    8396    8530    8548    8566    8567    
                                   8573$   8575$   8615    8616    8623    8638    8663    8664    8677    8680    8728    9011    
                                   9799    9837    9839    9843$   9845$   9848    9855    17800   17802   17839   17843$  17845$  
                                   17848   17920   17921   17945   17946   17949   17950   17960   17967$  17969$  17974   18318$  
                                   18321$  18354   18357   18373   18376   18390   18392   18433   18434   18437$  18439$  18448   
                                   18451   18608$  18639   18640$  18641   18642$  18650$  18652$  18653   18656   18659$  18661$  
                                   18679   18689$  18691$  18693   18714$  18716$  
WAIT                6CCA           3129    9652#   
WAVE0               1230           2009#   10102$  10268   20534   
WAVMUS              70C2           10315#  
WAVTAB              1253           2020#   10101   10445   10509$  
WHILTK             =00FD           3026#   7463    7554    
WIDTH               116B           1935#   2275$   10614$  18036   
WINDOW              7369           3208    10845#  
WINDOW_TEMP         12B3           2074#   10851$  10856$  10864$  10865   10871$  10872   10881   10882   10886   10887   
WIPE_80             AB33           20863   20893#  
XABS                1139           1841#   17950   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-46
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

XCENTR              1150           1883#   8663    
XCIRCL              1150           1866#   8530    
XCNT                0110           1721#   20062$  20069$  
XCORD1              1150           1899#   7967    8018    8020    8109    
XCORD2              115C           1905#   7969    7996    8110    
XCOUNT              1156           1902#   8025$   8053    
XD1                =00D1           20008#  20021   20024   20027   20033   20036   20039   20042   20045   20048   20048   20051   
                                   20095   
XD2                =00D2           20009#  20030   20030   20042   20045   20099   
XDEST               1135           1835#   7763    8215    8242    8396    8487    8685$   8728    9011    9788$   9789$   9790$   
                                   9791$   9799    9837    9839    9853$   9854$   9855    9862    9873    9880$   9889$   17945   
                                   18478   18480   
XDIST1              1154           1885#   8591    8644$   8664    17839   
XDIST2              1158           1887#   8580$   8680    
XEQCHR              4BAE           3575#   3596    
XEQCM               4ABC           3413#   3499    3602    
XEQCM2              4B76           3518    3521    3532#   5140    
XEQCM3              4B5C           3465    3515#   5030    
XEQCM4              4B93           3550    3555#   
XEQCM5              4B9B           3557    3560#   3592    
XEQDIR              4B10           3465#   3971    
XEQESC              4BB1           3533    3581#   
XEQMID              4BA8           3540    3570#   
XEQRTS              4B5B           3509#   3515    
XFAT               =00F0           20013#  20027   20085   
XFN1               =00F1           20014#  20024   20027   20033   20036   20045   20048   20051   20087   
XFN2               =00F2           20015#  20030   20030   20045   20048   20089   
XID                =00D0           20007#  20036   20079   
XOR                 83E1           3261    13752#  
XPOS                1131           1833#   7845    7847$   7849$   7854    7856$   7858$   7864    7866$   7868$   7895$   7936    
                                   7997$   8034    8042$   8087$   8089$   8173    8175$   8176$   8178$   8180$   8231$   8233$   
                                   8248    8250    8259    8281    8282$   8284$   8360$   8362$   8468$   8470$   8488$   9293$   
                                   17882   17884   17946   18038$  18040$  18042   18044$  18045$  18250   18276   18279   18479$  
                                   18481$  18607   18653   18693   20800   20801   20912   20913   
XRADUS              1154           1868#   8533$   8534$   8539    8541    8548    8579    
XRCL               =00E2           20012#  20054   20081   
XRCOS               1160           1873#   8592$   8643    
XREC               =00E0           20010#  20027   20054   20091   
XRSIN               1164           1875#   
XSAVE               115D           1924#   8249$   8251$   8359    8361    8423$   8425$   8472    8478$   8479    8481$   8486$   
XSCA               =00C2           20006#  20054   20077   
XSGN                113D           1844#   
XSIZE               1159           1922#   8212    8230    8232    8236$   8239$   8241    8306    8313$   8316$   8364$   8366$   
                                   8415$   8422    8424    8485    
XSPAC               55ED           5499    5504#   
XSPAC1              55FA           5506    5515#   
XSPAC2              55EE           5505#   5517    
XWRT               =00E1           20011#  20027   20083   
XYABS               1139           1840#   17936$  17940$  17974   17985   17987$  17989   17991$  
XYPOS               1131           1832#   18018   18020$  

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-47
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

XYSGN               113D           1843#   8799$   8816    8829    8950    10967$  10989$  17924$  17925$  17928$  17929$  17935$  
                                   18019   
YABS                113B           1842#   17949   
YCENTR              1152           1884#   8677    
YCIRCL              1152           1867#   
YCORD1              1152           1900#   8131    
YCORD2              115E           1906#   8128    
YCOUNT              1158           1903#   8080    
YDEST               1137           1836#   8219    9848    17921   
YDIST1              1156           1886#   
YDIST2              115A           1888#   
YPOS                1133           1834#   7831    7833$   7835$   7840$   7842$   7869$   7871$   8356$   8358$   8492$   8494$   
                                   17920   18247   18288   18290   18656   18679   20794   20904   20906   
YRADUS              1156           1869#   8536$   8540$   8544$   8546$   
YRCOS               1166           1876#   
YRSIN               1162           1874#   
YSGN                113F           1845#   
YSIZE               115B           1923#   8218    8318    8320$   8355$   8496    8498$   8499    8501$   
ZEREMV              8B0F           15056   15065   15079#  
ZERITA              7E4D           12714#  12716   12720   
ZERO                03D2           1806#   5199    11987   11990   12062   12065   12284   12285   13529   
ZEROF1              88D8           14724#  15920   
ZEROFC              88D6           12995   14723#  14756   15082   
ZEROML              88DA           14725#  15069   
ZEROT               9898           17424#  17460   
ZEROT1              98B4           17426   17445#  
ZOUT                98A6           17428   17434#  17447   
ZZ2                =0201           5574#   5577    
ZZ3                =0202           5575#   5578    
ZZ4                =01FF           5688#   5690    5691    
ZZ5                =01FF           5460#   5462    5463    
Z_P_TEMP_1          0077           1681#   5559$   5676    6104$   6130    6646$   6662$   6791    7628$   7635    7671$   7677    
                                   7716    8561$   8563    8934$   8938$   8941$   8943    8960$   8963    8966    8975    8979    
                                   8981    8984    9133$   9142    9202$   9206    9209    9702    9740    9762$   9801    9858    
                                   9977$   9982    10635$  10643   10648   16915$  16986$  17145$  17185$  17262   17297   17324$  
                                   17326$  17361$  17425   17445$  17510   18149$  18152   18160$  18163   18634$  18636   20828$  
                                   20836   20874$  20882   
_6510_DATA_REG     =0001           2095#   9347    9350$   9356$   18176   18179$  18183$  
_8563_ADDR         =D600           1533#   9181$   13302$  13494$  13498   
_8563_ADJUST        6A69           9175    9184    9192#   
_8563_DATA         =D601           1534#   9182    9185$   13303   13495   
_8563_UNADJUST      81F3           13306   13315#  
_AUTOINSERT        =00F6           2177#   6365$   
_A_REG             =0006           2100#   5996$   6050    
_BANK              =0002           2096#   5992$   10930$  
_BASIN             =FFCF           2132#   16390   
_BOOT_CALL         =FF53           2111#   10941   
_BSOUT             =FFD2           2133#   16394   
_CHKIN             =FFC6           2129#   16141   19025   20279   
_CHKOUT            =FFC9           2130#   16130   

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-48
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

_CLALL             =FFE7           2140#   16408   
_CLOSE             =FFC3           2128#   16403   
_CLOSE_ALL         =FF4A           2108#   19153   
_CLRCH             =FFCC           2131#   2202    16398   
_COMPARE           =FF7A           2121#   
_CONFIG            =FF6B           2117#   
_DMA               =DF00           1543#   20737$  20738$  20742$  20743$  20747$  20748$  20754$  
_DOAKEY            =FF65           2115#   7638    
_DO_DMA            =FF50           2110#   20759   
_FA                =00BA           2166#   16360   
_FETCH             =FF74           2119#   9664    13095   
_GETIN             =FFE4           2139#   11014   11082   11277   16147   
_GO_64             =FF4D           2109#   6327    
_GRAPHM            =00D8           2169#   3923$   8260    8267    8277    8308    8323    8441    8462    8473    8542    8759    
                                   8805    8848    8956    9043    9369    9427$   9457$   9461    9499    9501$   10964$  11020$  
                                   13232   18057   18140   18251   18282   18568   
_INIT_STATUS       =0A04           2157#   2224    2226$   
_JJSR              =FF6E           2118#   6010    10935   
_JPLOT             =FFF0           2142#   12883   16422   
_KEYD              =034A           2156#   4210$   4217$   
_LDTB1             =C04C           2146#   8922    11452   18237   
_LDTB2             =C033           2145#   8920    11450   18131   18235   
_LKUPLA            =FF59           2112#   19383   
_LKUPSA            =FF5C           2113#   19129   
_LOADSP            =FFD5           2134#   16179   19276   
_MODE              =00D7           2168#   2452    3921    6210    9170    9268    9301    9315    9463    9497    10847   10860   
                                   13238   13297   13819   
_MONITOR           =B000           2151#   3183    
_NDX               =00D0           2167#   4219$   
_OPEN              =FFC0           2127#   16114   
_PCHI              =0003           2097#   5990$   10934$  
_PCLO              =0004           2098#   5988$   10932$  
_PHENIX            =FF56           2148#   2234    
_PKY_BUFFER        =100A           2183#   7684    
_PKY_LENGTHS       =1000           2182#   2183    7668    
_PKY_MAX           =000A           2181#   2183    
_PRIMM             =FF7D           2150#   16413   
_PRINT             =C00C           2149#   8825    12892   
_RDTIM             =FFDE           2137#   12080   
_READST            =FFB7           2124#   16373   
_RESTART_VECTOR    =0A00           2179#   2229$   
_SA                =00B9           2165#   
_SAVESP            =FFD8           2135#   16160   
_SCREEN_BOTTOM     =00E4           2172#   13807   
_SCREEN_LEFT       =00E6           2174#   13814   
_SCREEN_ORG        =FFED           2141#   8761    
_SCREEN_RIGHT      =00E7           2175#   13812   
_SCREEN_TOP        =00E5           2173#   13809   
_SETLFS            =FFBA           2125#   16379   
_SETMSG            =FF90           2123#   3951    6372    

C128 BASIC  (318018,19-03 RELEASE:  11/18/85)	CR6502/11 version 20.53.12	20-Mar-86  12:42:8	Page X-49
*************** cross reference *****************   BASIC.SRC

                     * * Cross Reference * *

Reference flags  (# = Definition, $ = Write, <BLANK> = Read)

Symbol              Value          References

_SETNAM            =FFBD           2126#   16385   
_SETTIM            =FFDB           2136#   5229    
_SET_BANK          =FF68           2116#   16418   
_SET_WINDOW        =C02D           2144#   10884   10889   
_SLEEP_COUNTER     =0A1D           2158#   9599$   9600$   9601$   9607    9608    9609    9616    9625$   9626$   9627$   9633    
                                   9634$   9636    9637$   9639    9640$   
_SPLIT             =0A34           2159#   9272    9482$   
_STARTING_ADDR     =00AC           2164#   10931   10933   
_STASH             =FF77           2120#   13111   
_STASH_VECTOR      =02B9           2154#   13109$  
_STOP              =FFE1           2138#   16426   
_SWAPPER           =FF5F           2114#   9271    9284    9304    9309    9318    9323    9465    
_S_REG             =0005           2099#   6008$   6053    
_TEXT_COLOR        =00F1           2155#   9173    9176$   10983   10986$  11001$  13296   
_X_REG             =0007           2101#   6000$   
_Y_REG             =0008           2102#   6004$   
