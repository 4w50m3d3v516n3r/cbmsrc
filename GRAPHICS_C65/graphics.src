	.nam C65 Graphic/BASIC 10.0 (C)1991 CBM
	.subttl *** Copyright (C) 1991	by  Commodore Business Machines, Inc. ***

;  ***************************************************************************
;  *				    //					     *
;  *		  CCCCCCC	   //	6666666	    555555555		     *
;  *		 CCC   CCC	  //   666   666    555			     *
;  *		CCC		 //   666	    555			     *
;  *		CCC		//    666 6666	    55555555		     *
;  *		CCC	       //     6666   666	  555		     *
;  *		CCC	      //      666     666	   555		     *
;  *		 CCC   CCC   //	       666   666    555	  555		     *
;  *		  CCCCCCC   //		6666666	     5555555		     *
;  *			   //						     *
;  *									     *
;  *		  GGG	RRR    AA   PPP	  H  H	I   CCC	   SSS		     *
;  *		 G	R  R  A	 A  P  P  H  H	I  C   C  S		     *
;  *		 G GGG	RRR   AAAA  PPP	  HHHH	I  C	   SSS		     *
;  *		 G   G	R  R  A	 A  P	  H  H	I  C   C      S		     *
;  *		  GGG	R  R  A	 A  P	  H  H	I   CCC	   SSS		     *
;  *									     *
;  *	      BBBBBBBBB	     AAAA      SSSSSSSS	  III	 CCCCCCC	     *
;  *	      BBB    BBB   AAA	AAA   SSS    SSS  III	CCC   CCC	     *
;  *	      BBB    BBB  AAA	 AAA  SSS	  III  CCC		     *
;  *	      BBBBBBBBB	  AAAAAAAAAA   SSSSSSSS	  III  CCC		     *
;  *	      BBB    BBB  AAA	 AAA	     SSS  III  CCC		     *
;  *	      BBB    BBB  AAA	 AAA  SSS    SSS  III	CCC   CCC	     *
;  *	      BBBBBBBBB	  AAA	 AAA   SSSSSSSS	  III	 CCCCCCC	     *
;  *									     *
;  *			   V E R S I O N   1 0 . 0			     *
;  *									     *
;  *	    Copyright (C)1991  by   Commodore Business Machines, Inc.	     *
;  *			    All	 Rights	 Reserved			     *
;  *									     *
;  ***************************************************************************

;			ROM VERSION  911119  (ver 0.9B)

;	******************************************************************
;	* This listing contains confidential and proprietary information *
;	* of CBM, Inc.	The reproduction, dissemination or disclosure to *
;	* others without express written permission is prohibited.  This *
;	* software is for use in prototype Commodore C/65 systems only.	 *
;	*								 *
;	*  The information in this document will change without notice.	 *
;	*								 *
;	*  No  responsibility  is  assumed  for the reliability of this	 *
;	*			   software.				 *
;	******************************************************************
	.page
;created	: 07/14/89	  a revolutionary date
;updated	: 11/12/90	  (add clipping)
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace,  Walrus Software Inc.
;application	: C65 Kernel Graphics ROM
;
; C65 Kernel Graphic ROM Routine Assembly Driver
;
; This module is composed of the following files, ported to VAX/VMS BSO format by Fred Bowen:
;
;	kernlabs
;	viclabs
;	fplabs
;	labs								[901112] mod for clip
;	vars								[901112] mod for clip
;	const
;	interf								[901112] mod for clip
;	screen
;	line								[901112] mod for clip
;	plotdot
;	subs
;	clip								[901112] new
;	drawmod
;	color
;	box
;	circle								[901112] mod for clip
;	polygon
;	ellipse
;	facet
;	blitter
;	loadiff
;	char
;	viewport

	.page
	.subttl C65 Kernel labels

;created	: 01/29/90
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal labels


; C65 Kernel Entries (8EG ROM versions)

c65.acptr	= $ffa5		;input byte serial
c65.chkin	= $ffc6		;open chnl input
c65.chkout	= $ffc9		;open chnl output
c65.chrin	= $ffcf		;input char _ chnl
c65.chrout	= $ffd2		;output char chnl
c65.ciout	= $ffa8		;output byt serial
c65.cint	= $ff81		;init screen edt
c65.clall	= $ffe7		;close all chnls
c65.close	= $ffc3		;close a file
c65.clrchn	= $ffcc		;clear channels
c65.getin	= $ffe4		;get char
c65.iobase	= $fff3		;read i/o base addr
c65.ioinit	= $ff84		;init i/o
c65.listen	= $ffb1		;set devc to listen
c65.load	= $ffd5		;load ram from devc
c65.membot	= $ff9c		;read/set mem. bot.
c65.memtop	= $ff99		;read/set mem. top
c65.open	= $ffc0		;open a file
c65.plot	= $fff0		;read/set x,y pos.
c65.ramtas	= $ff87		;init ram set scrn
c65.rdtim	= $ffde		;read clock
c65.readst	= $ffb7		;read i/o status
c65.restor	= $ff8a		;restore i/o addrs
c65.save	= $ffd8		;save ram to devc
c65.scnkey	= $ff9f		;scan keyboard
c65.screenk	= $ffed		;get x,y=window size, a=40/80
c65.second	= $ff93		;send secd addr
c65.setlfs	= $ffba		;set file parms
c65.setmsg	= $ff90		;control kernal msg
c65.setnam	= $ffbd		;set filename
c65.settim	= $ffdb		;set clock
c65.settmo	= $ffa2		;set serial timeout
c65.stop	= $ffe1		;scan stop key
c65.talk	= $ffb4		;serial devc to tlk
c65.tksa	= $ff96		;send talk secd adr
c65.udtim	= $ffea		;increment time
c65.unlsn	= $ffae		;serial devc unlsn
c65.untlk	= $ffab		;serial devc untlk
c65.untalk	= $ffab		;serial devc untlk
c65.vector	= $ff8d		;read/set i/o addrs

c65.spinot	= $ff4d		;setup fast serial
c65.closal	= $ff50		;close all on devic
c65.c64mod	= $ff53		;go 64 mode
c65.monitor	= $ff56		;go 65 monitor mode
c65.botcal	= $ff59		;boot disk
c65.phoenx	= $ff5c		;init function cart
c65.lkupla	= $ff5f		;search table for la
c65.lkupsa	= $ff62		;search table for sa
c65.swaper	= $ff65		;switch 40/80 col
c65.pfkey	= $ff68		;program funct key
c65.setbnk	= $ff6b		;set bank for i/o
c65.jsrfar	= $ff6e		;gosub any bank
c65.jmpfar	= $ff71		;goto any bank
c65.indfet	= $ff74		;lda(.),y any bank
c65.indsta	= $ff77		;sta(.),y any bank
c65.indcmp	= $ff7a		;cmp(.),y any bank
c65.primm	= $ff7d		;print immediate

c65.l.nmi	= $fffa		;nmi vector
c65.l.reset	= $fffc		;reset vector
c65.l.irqkrn	= $fffe		;irq kernal vector

; C65 Kernel RAM

c65.io.status	= $90		;io status
c65.io.flen	= $b7		;file length
c65.io.fadlo	= $bb		;file name address lo
c65.io.fadhi	= $bc		;file name address hi

;.end
	.page
	.subttl c65.vic.labels
;created	: 07/17/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system 	: C128 hcd65ce02 assembler
;application	: C65 rom


; C65 VIC Registers

c65.l.sprit0x	= $d000		;sprite 0 x position
c65.l.sprit0y	= $d001		;sprite 0 y position
c65.l.sprit1x	= $d002		;sprite 1 x position
c65.l.sprit1y	= $d003		;sprite 1 y position
c65.l.sprit2x	= $d004		;sprite 2 x position
c65.l.sprit2y	= $d005		;sprite 2 y position
c65.l.sprit3x	= $d006		;sprite 3 x position
c65.l.sprit3y	= $d007		;sprite 3 y position
c65.l.sprit4x	= $d008		;sprite 4 x position
c65.l.sprit4y	= $d009		;sprite 4 y position
c65.l.sprit5x	= $d00a		;sprite 5 x position
c65.l.sprit5y	= $d00b		;sprite 5 y position
c65.l.sprit6x	= $d00c		;sprite 6 x position
c65.l.sprit6y	= $d00d		;sprite 6 y position
c65.l.sprit7x	= $d00e		;sprite 7 x position
c65.l.sprit7y	= $d00f		;sprite 7 y position
c65.l.spirtxh	= $d010		;sprite 0-7 x high bit
c65.l.vicntla	= $d011		;vic control a for ecm, bmm, blnk, row select
c65.l.yscroll	= $d011		;smooth scroll to y dot position 0-7
c65.l.rascmph	= $d011		;raster compare bit 8
c65.l.rastcmp	= $d012		;raster compare bit 0-7
c65.l.litpenx	= $d013		;light pen latch x position
c65.l.litpeny	= $d014		;light pen latch y position
c65.l.spriten	= $d015		;sprite 0-7 enable bit field
c65.l.vicntlb	= $d016		;vic control b for mcm, column select
c65.l.xscroll	= $d016		;smooth scroll to x dot position 0-7
c65.l.sprexpy	= $d017		;sprite 0-7 expand y
c65.l.vicmemc	= $d018		;vic memory control register video matrix, char base
c65.l.vicintf	= $d019		;vic interrupt flag register enable, litpen, spr2spr,
				; spr2bg, raster compare
c65.l.vicintm	= $d01a		;vic interrupt mask register litpen, spr2spr,
				; spr2bg, aster compare
c65.l.spr2bgp	= $d01b		;sprite to background display priority
c65.l.sprmcme	= $d01c		;sprite 0-7 multi-color mode enable
c65.l.sprexpx	= $d01d		;sprite 0-7 expand x
c65.l.spr2spr	= $d01e		;sprite to sprite collision detect
c65.l.spr2bgd	= $d01f		;sprite to background collision detect
c65.l.borderc	= $d020		;border color
c65.l.bgcolr0	= $d021		;background color 0
c65.l.bgcolr1	= $d022		;background color 1
c65.l.bgcolr2	= $d023		;background color 2
c65.l.bgcolr3	= $d024		;background color 3
c65.l.sprmcr0	= $d025		;sprite multi-color 0
c65.l.sprmcr1	= $d026		;sprite multi-color 1
c65.l.spr0clr	= $d027		;sprite 0 color
c65.l.spr1clr	= $d028		;sprite 1 color
c65.l.spr2clr	= $d029		;sprite 2 color
c65.l.spr3clr	= $d02a		;sprite 3 color
c65.l.spr4clr	= $d02b		;sprite 4 color
c65.l.spr5clr	= $d02c		;sprite 5 color
c65.l.spr6clr	= $d02d		;sprite 6 color
c65.l.spr7clr	= $d02e		;sprite 7 color
c65.l.vickeyr	= $d02f		;vic key register
c65.l.vicntlc	= $d030		;vic control c for rom, pal, ext sync, color
c65.l.vicntld	= $d031		;vic control d for h640, fast,attr, bpm, v400,
				; h1280, mono, interlce
c65.l.bitplne	= $d032		;bitplane 0-7 enable
c65.l.bp0addr	= $d033		;bitplane 0 odd line, even line address
c65.l.bp1addr	= $d034		;bitplane 1 odd line, even line address
c65.l.bp2addr	= $d035		;bitplane 2 odd line, even line address
c65.l.bp3addr	= $d036		;bitplane 3 odd line, even line address
c65.l.bp4addr	= $d037		;bitplane 4 odd line, even line address
c65.l.bp5addr	= $d038		;bitplane 5 odd line, even line address
c65.l.bp6addr	= $d039		;bitplane 6 odd line, even line address
c65.l.bp7addr	= $d03a		;bitplane 7 odd line, even line address
c65.l.cassiob	= $d03a		;cassette i/o bit
c65.l.bpcompe	= $d03b		;bitplane 0-7 complement enable
c65.l.bpxcord	= $d03c		;bitplane x coordinate bits 0-6
c65.l.bpycrdh	= $d03c		;bitplane y coordinate high bit 8
c65.l.bpycrdl	= $d03d		;bitplane y coordinate low  bit 0-7
c65.l.horzpos	= $d03e		;screen horizontal position
c65.l.vertpos	= $d03f		;screen vertical position
c65.l.bp0pixd	= $d040		;bitplane 0 pixel data
c65.l.bp1pixd	= $d041		;bitplane 1 pixel data
c65.l.bp2pixd	= $d042		;bitplane 2 pixel data
c65.l.bp3pixd	= $d043		;bitplane 3 pixel data
c65.l.bp4pixd	= $d044		;bitplane 4 pixel data
c65.l.bp5pixd	= $d045		;bitplane 5 pixel data
c65.l.bp6pixd	= $d046		;bitplane 6 pixel data
c65.l.bp7pixd	= $d047		;bitplane 7 pixel data

; C65 Palette

c65.l.redcpba	= $d100		;red color palette beginning address
c65.l.grncpba	= $d200		;green color palette beginning address
c65.l.blucpba	= $d300		;blue color palette beginning address


; DMA Controller & DMA lists

c65.dma_ctlr		= $d700		;DMA controller					[910102]
c65.dma1_list		= $144		;DMA list #1					[910507]
c65.dma2_list		= $150		;DMA list #2					[910117]
c65.dma_lda_list	= $120		;Kernel's lda_far list				[910117]
c65.dma_sta_list	= $12c		;Kernel's sta_far list				[910117]

c65.dma_byte		= $15c		;Kernel's lda/sta_far byte			[910117]

c65.text_bank		= $84		;where BASIC text lives  (RAM0 default)		[910729]
c65.var_bank		= $85		;where BASIC vars live   (RAM1 default)		[910729]

;.end
	.page
	.subttl fp.labels

;created	: 6/6/86
;updated	:
;author		: david darus, louis wallace
;computer	: c-128
;assembler	: hcd65
;remarks	: floating point math labels

; Floating point registers

c65.facexp	= $63		;fp1 exponent
c65.facho	= $64		;fp1 msb
c65.facmoh	= $65		;fp1 mantissa hi
c65.facmo	= $66		;fp1 mantissa mid
c65.faclo	= $67		;fp1 mantissa lo
c65.facsgn	= $68		;fp1 sign $00=+ $ff=-

c65.argexp	= $6a		;fp2 exponent
c65.argho	= $6b		;fp2 msb
c65.argmoh	= $6c		;fp2 mantissa hi
c65.argmo	= $6d		;fp2 mantissa mid
c65.arglo	= $6e		;fp2 mantissa lo
c65.argsgn	= $6f		;fp2 sign $00=+ $ff=-

c65.argisgn	= $70		;resultant sign
c65.facov	= $71		;round off
c65.syntmp	= $78		;for chkcom, among others

; Format conversions

c65.indtxt	= $2393		;ldafar (indtxt),y			[910710]

c65.fpbs	= $7f00		;c65 jump table			(8,9 ROM version)

c65.ayint	= c65.fpbs+0	;cvrt fp 2 int
c65.givayf	= c65.fpbs+3	;cvrt int 2 fp
c65.fout	= c65.fpbs+6	;fp 2 $
c65.val1	= c65.fpbs+9	;$ 2 fp
c65.getadrfp	= c65.fpbs+12	;fp 2 addr
c65.floatc	= c65.fpbs+15	;addr 2 fp

; Math functions

c65.fsub	= c65.fpbs+18	;mem - facc
c65.fsubt	= c65.fpbs+21	;arg - facc
c65.fadd	= c65.fpbs+24	;mem + facc
c65.faddt	= c65.fpbs+27	;arg + facc
c65.fmult	= c65.fpbs+30	;mem * facc
c65.fmultt	= c65.fpbs+33	;arg * facc
c65.fdiv	= c65.fpbs+36	;mem / facc
c65.fdivt	= c65.fpbs+39	;arg / facc
c65.log		= c65.fpbs+42	;natural log of facc
c65.int		= c65.fpbs+45	;greatest int of facc
c65.sqr		= c65.fpbs+48	;square root of facc
c65.negop	= c65.fpbs+51	;negate (invert sign) of facc
c65.fpwr	= c65.fpbs+54	;arg to the mem power
c65.fpwrt	= c65.fpbs+57	;arg to the facc power
c65.exp		= c65.fpbs+60	;exp of facc
c65.cos		= c65.fpbs+63	;cos of facc
c65.sin		= c65.fpbs+66	;sin of facc
c65.tan		= c65.fpbs+69	;tan of facc
c65.atn		= c65.fpbs+72	;atn of facc
c65.round	= c65.fpbs+75	;round facc
c65.abs		= c65.fpbs+78	;absolute value of facc
c65.sign	= c65.fpbs+81	;sign of facc
c65.fcomp	= c65.fpbs+84	;compare facc with mem
c65.rnd0	= c65.fpbs+87	;generate random number in facc

; Movement

c65.conupk	= c65.fpbs+90	;move ram mem to arg
c65.romupk	= c65.fpbs+93	;move rom mem to arg
c65.movfrm	= c65.fpbs+96	;move ram mem to facc
c65.movfm	= c65.fpbs+99	;move rom mem to facc
c65.movmf	= c65.fpbs+102	;move facc to mem
c65.movfa	= c65.fpbs+105	;move arg to facc
c65.movaf	= c65.fpbs+108	;facc to arg


; Non-floating point os labels

c65.run		= c65.fpbs+111
c65.runc	= c65.fpbs+114
c65.clear	= c65.fpbs+117
c65.new		= c65.fpbs+120
c65.lnkprg	= c65.fpbs+123
c65.crunch	= c65.fpbs+126
c65.fndlin	= c65.fpbs+129
c65.newstt	= c65.fpbs+132
c65.eval	= c65.fpbs+135
c65.frmevl	= c65.fpbs+138
c65.runprog	= c65.fpbs+141
c65.setexc	= c65.fpbs+144
c65.linget	= c65.fpbs+147
c65.garba2	= c65.fpbs+150
c65.execlin	= c65.fpbs+153

c65.chrget	= c65.fpbs+156
c65.chrgot	= c65.fpbs+159
c65.chkcom	= c65.fpbs+162
c65.frmnum	= c65.fpbs+165
c65.getadr	= c65.fpbs+168
c65.getnum	= c65.fpbs+171
c65.getbyt	= c65.fpbs+174
c65.plsv	= c65.fpbs+177

c65.lda_far_0	= c65.fpbs+180		;				[910716]
c65.lda_far_1	= c65.fpbs+183
c65.sta_far_0	= c65.fpbs+186
c65.sta_far_1	= c65.fpbs+189

;.end
	.page
	.subttl kg65.labs
;created	: 07/17/89
;updated	: 11/12/90 (clipping)
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;

kg65.l.basepage		= >$1f00	;graphics basepage

kg65.l.scanline		= $1e00		;160 byte scanline buffer

kg65.l.bytebuffer	= $1d00		;256 byte buffer for IFF

kg65.l.wbufr		= $1d00		;128 byte buffer for character expansion

kg65.l.clipvars		= >$1c00	;clip variables					[901112]

;kg65.l.paint.stack	= $1800		;paint stack (4 pages????)			[910212]
;kg65.l.paint.stack.size = 4

kg65.l.temp.brush	= $1800		;temp to store brush (4 pages????)		[910212]

kg65.l.tilt		= %11000000
kg65.l.tiltdn		= %10000000
kg65.l.tiltup		= %01000000
kg65.l.mirror		= %00000100
kg65.l.flip		= %00001000

kg65.l.dirup		= %00000001
kg65.l.dirrt		= %00000010
kg65.l.dirdn		= %00000100
kg65.l.dirlf		= %00001000

;.end

	.page
	.subttl kg65 RAM variables

;created	: 07/17/89
;updated	: 11/12/90 (clipping)
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;


	* = $0000			;translates to wherever basepage is set to

kg65.parm1		*=*+1		;ml interface parm values
kg65.parm2		*=*+1
kg65.parm3		*=*+1
kg65.parm4		*=*+1
kg65.parm5		*=*+1
kg65.parm6		*=*+1
kg65.parm7		*=*+1
kg65.parm8		*=*+1
kg65.parm9		*=*+1
kg65.parm10		*=*+1
kg65.parm11		*=*+1
kg65.parm12		*=*+1
kg65.parm13		*=*+1
kg65.parm14		*=*+1
kg65.parm15		*=*+1
kg65.parm16		*=*+1
kg65.parm17		*=*+1

kg65.subparm1		*=*+1		;subroutine parm values
kg65.subparm2		*=*+1
kg65.subparm3		*=*+1
kg65.subparm4		*=*+1
kg65.subparm5		*=*+1

kg65.temp1		*=*+1		;local variables within subroutines
kg65.temp2		*=*+1
kg65.temp3		*=*+1
kg65.temp4		*=*+1
kg65.temp5		*=*+1
kg65.temp6		*=*+1
kg65.temp7		*=*+1
kg65.temp8		*=*+1
kg65.temp9		*=*+1
kg65.temp10		*=*+1
kg65.temp11		*=*+1
kg65.temp12		*=*+1
kg65.temp13		*=*+1
kg65.temp14		*=*+1
kg65.temp15		*=*+1
kg65.temp16		*=*+1
kg65.temp17		*=*+1

kg65.scrtabidx		*=*+1		;offset into screen tabl for screen# entry
					;screen# * table entry size
					;obtained from	kg65.c.scridx,screen#

kg65.bpptr1		*=*+2		;base page ptr # 1
kg65.bpptr2		*=*+2		;base page ptr # 2

	.page
;Screen Table Entry:
;
; size data:	bit 7	= valid entry?		1=yes 0=no
;		bit 6	= screen open?		1=yes 0=no
;		bit 5,4 = width			00=320, 01=640, 10=1280
;		bit 3	= height		0=200,1=400
;		bit 2-0 = depth			0-7 -> # of bitplanes
;
; bitplanes used	(1 byte bit field 1=used)
; 8k memory blocks used (2 byte bit field 1=used)  [2 banks  8 blocks/bank]


kg65.scrtab
			*=*+4		;screen #0
			*=*+4		;screen #1
			*=*+4		;screen #2				[910711]
			*=*+4		;screen #3				"
;			*=*+4		;screen #4
;			*=*+4		;screen #5
;			*=*+4		;screen #6
;			*=*+4		;screen #7
;			*=*+4		;screen #8
;			*=*+4		;screen #9
;			*=*+4		;screen #10
;			*=*+4		;screen #11
;			*=*+4		;screen #12
;			*=*+4		;screen #13
;			*=*+4		;screen #14
;			*=*+4		;screen #15

kg65.bankablks		*=*+1		;bank a 8k block allocation bit field 1=used
kg65.bankbblks		*=*+1		;bank b 8k block allocation bit field 1=used
kg65.banka		*=*+1		;here is where the screen is!			[910506]
kg65.bankb		*=*+1		;here is where the screen is!			[910506]

kg65.drawscrbyte	*=*+1		;byte to read/write to drawscreen

kg65.drawpens
kg65.drawscrpen1	*=*+1		;drawing pen 1	(on bits)
kg65.drawscrpen2	*=*+1		;drawing pen 2	(off bits in jam2 mode)
kg65.drawscrpen3	*=*+1		;drawing pen 3	(outline bits)		????unused

kg65.drawmode		*=*+1		;draw mode
					;	bit 0	= jam		0=jam1 1=jam2
					;	bit 1	= complement	0=off  1=on
					;	bit 2	= stencil	0=off  1=on
					;	bit 4,3	= style		00=solid 01=pattern
					;				10=tile  11=reserved
					;	bit 7,6,5 = thickness	1-8	????unused

kg65.dpatype		*=*+1		;draw pattern type 0=user defined 1-63=predefined
					;located in bits 2-7
					;bits 0,1 = # of pattern bytes 0-3 -> 1-4 bytes

kg65.dpattern		*=*+4		;draw pattern byte
kg65.patrbitnum		*=*+1		;bit# of pattern 0-31

kg65.drawscreen		*=*+1		;draw screen index		($ff=not set yet)
kg65.drawscrwidth	*=*+1		;draw screen width flag		(0=320, 1=640, 2=1280)
kg65.drawscrheight	*=*+1		;draw screen height flag	(0=200, 1=400)
kg65.drawscrdepth	*=*+1		;draw screen depth		(1-8)
kg65.drawscrcols	*=*+1		;draw screen width in bytes	(40 or 80)
kg65.drawscrbp		*=*+1		;draw screen bitplanes used mask
kg65.drawscrablks	*=*+1		;draw screen bank A blocks used mask
kg65.drawscrbblks	*=*+1		;draw screen bank B blocks used mask
kg65.drawscrvpx		*=*+2		;draw screen viewport x
kg65.drawscrvpy		*=*+2		;draw screen viewport y
kg65.drawscrvpdx	*=*+2		;draw screen viewport dx
kg65.drawscrvpdy	*=*+2		;draw screen viewport dy

kg65.drawscrinc		*=*+2		;draw screen increment for line routine
					;312 if 320 wide  632 if 640 wide

kg65.scanlineflag	*=*+1		;0=even (default) 1=odd
kg65.datflag		*=*+1		;0=initial entry  b7=1 subsequent entry
DAT_enable		*=*+1		;0=DAT disabled					[910612] FAB
; mode1280flag		*=*+1		;					removed	[910711]
; oddevenflag		*=*+1		;						[910517]
; kg65.colorflag	*=*+1		;used in color2index for color manips		[910823] FAB
kg65.tmp		*=*+1		;used by multiply/divide routine		[910506] FAB

; Format of bitplane addresses like hardware reg. odd & even hi 3 bits

kg65.dsbp0adr		*=*+1		;draw screen bitplane# 0 addr
kg65.dsbp1adr		*=*+1		;draw screen bitplane# 1 addr
kg65.dsbp2adr		*=*+1		;draw screen bitplane# 2 addr
kg65.dsbp3adr		*=*+1		;draw screen bitplane# 3 addr
kg65.dsbp4adr		*=*+1		;draw screen bitplane# 4 addr
kg65.dsbp5adr		*=*+1		;draw screen bitplane# 5 addr
kg65.dsbp6adr		*=*+1		;draw screen bitplane# 6 addr
kg65.dsbp7adr		*=*+1		;draw screen bitplane# 7 addr

kg65.viewscreen		*=*+1		;view screen index  ff=not set yet
kg65.viewscrwidth	*=*+1		;view screen width flag
kg65.viewscrheight	*=*+1		;view screen height flag
kg65.viewscrdepth	*=*+1		;view screen depth

kg65.linedata
kg65.x0			*=*+2
kg65.y0			*=*+2
kg65.x1			*=*+2
kg65.y1			*=*+2
kg65.dx			*=*+2
kg65.dy			*=*+2
kg65.flag		*=*+1
kg65.mask		*=*+1
kg65.octant		*=*+1
kg65.errfac		*=*+2
kg65.endpt		*=*+2
kg65.dsadr		*=*+2
kg65.doadr		*=*+1

kg65.linevars
kg65.linex0		*=*+2
kg65.liney0		*=*+2
kg65.linex1		*=*+2
kg65.liney1		*=*+2
kg65.linedx		*=*+2
kg65.linedy		*=*+2
kg65.lineflag		*=*+1
kg65.linemask		*=*+1
kg65.lineoctant		*=*+1
kg65.lineerrfac		*=*+2
kg65.lineendpt		*=*+2
kg65.linedsadr		*=*+2
kg65.linedoadr		*=*+1

; Areas below are multiply defined

kg65.blkfillval				;16 bytes of the linea area
kg65.linea
kg65.linea.x0		*=*+2
kg65.linea.y0		*=*+2
kg65.linea.x1		*=*+2
kg65.linea.y1		*=*+2
kg65.linea.dx		*=*+2
kg65.linea.dy		*=*+2
kg65.linea.flag		*=*+1
kg65.linea.mask		*=*+1
kg65.linea.octant	*=*+1
kg65.linea.errfac	*=*+2
kg65.linea.endpt	*=*+2
kg65.linea.dsadr	*=*+2
kg65.linea.doadr	*=*+1

kg65.lineb
kg65.lineb.x0		*=*+2
kg65.lineb.y0		*=*+2
kg65.lineb.x1		*=*+2
kg65.lineb.y1		*=*+2
kg65.lineb.dx		*=*+2
kg65.lineb.dy		*=*+2
kg65.lineb.flag		*=*+1
kg65.lineb.mask		*=*+1
kg65.lineb.octant	*=*+1
kg65.lineb.errfac	*=*+2
kg65.lineb.endpt	*=*+2
kg65.lineb.dsadr	*=*+2
kg65.lineb.doadr	*=*+1
			*=*+9		;needed in polygon				[910212]

	* = kg65.linea			;circle vars  19 bytes of linea area

kg65.cx0		*=*+2		;ellipse vars 19 bytes of linea area
kg65.cy0		*=*+2
kg65.cx1		*=*+2
kg65.cy1		*=*+2
kg65.cdx		*=*+2
kg65.cdy		*=*+2
kg65.cphi		*=*+2		;not used by ellipse
kg65.cx			*=*+2
kg65.cy			*=*+2
kg65.csolidflag		*=*+1		;this is at kg65.linea + 18

	* = kg65.lineb			;more ellipse vars 22 bytes of lineb area = whole

kg65.t1			*=*+3
kg65.t2			*=*+3
kg65.t3			*=*+3
kg65.t4			*=*+3
kg65.t5			*=*+3
kg65.t6			*=*+3
kg65.t7			*=*+4		;lineb area ends at last byte here
kg65.t8			*=*+4		;20 more bytes
kg65.t9			*=*+4
kg65.d1			*=*+4
kg65.d2			*=*+4

	* = kg65.linea			;polygon vars  22 bytes of linea area = whole area

kg65.px0		*=*+2
kg65.py0		*=*+2
kg65.px1		*=*+2
kg65.py1		*=*+2
			*=*+4
kg65.plineflag		*=*+1
kg65.plinemask		*=*+1
			*=*+5
kg65.plinedsadr		*=*+2
kg65.plinedoadr		*=*+1

	* = kg65.lineb			;31 byte area

kg65.pcx		*=*+2
kg65.pcy		*=*+2
kg65.its		*=*+1
kg65.tt			*=*+5
kg65.dgfp		*=*+5
kg65.xrfp		*=*+5
kg65.yrfp		*=*+5		;first byte is at end of 22 byte lineb area
kg65.savexy		*=*+4
kg65.ptemp1		*=*+1

kg65.facet.vars
kg65.fxmin		*=*+2
kg65.fymin		*=*+2
kg65.fxmid		*=*+2
kg65.fymid		*=*+2
kg65.fxmax		*=*+2
kg65.fymax		*=*+2
kg65.fx			*=*+2
kg65.fytop		*=*+2
kg65.fybot		*=*+2
kg65.fybase		*=*+2
kg65.fdx1		*=*+2
kg65.fdx2		*=*+2
kg65.fdx3		*=*+2
kg65.fdx		*=*+2
kg65.fdy1		*=*+2
kg65.fdy2		*=*+2
kg65.fdy3		*=*+2
kg65.fdy		*=*+2
kg65.fxdiff		*=*+2
kg65.fflag1		*=*+1
kg65.fflag2		*=*+1
kg65.fflag3		*=*+1
kg65.fflag		*=*+1

	* = kg65.linea			;brush & iff vars

kg65.area.x		*=*+2
kg65.area.y		*=*+2
kg65.area.dx		*=*+2
kg65.area.dy		*=*+2
kg65.area.txy		*=*+2
kg65.area.b2sl		*=*+1
kg65.area.bor		*=*+1
kg65.area.bwidth	*=*+1
kg65.area.bpn		*=*+1
kg65.area.bpc		*=*+1
kg65.area.brush		*=*+1
kg65.area.mask		*=*+1
kg65.area.t2		*=*+1		;brush masking work area
kg65.area.save.x	*=*+1		;orignal x coord. low byte
kg65.area.cmd		*=*+1		;command code 0=viewpclr 1=copy 2=cut
kg65.area.depth		*=*+1		;# of bitplane of brush
kg65.area.brushwidth	*=*+1		;brush byte width
kg65.area.maskflag	*=*+1		;*** extends into lineb area ***
kg65.area.compressflag	*=*+1
kg65.area.transparentcolor
			*=*+1
kg65.ChunkLen		*=*+4
kg65.ViewModes		*=*+4
kg65.scanlineidx	*=*+1
kg65.bufferindex	*=*+1
kg65.buffersize		*=*+1
kg65.compresscount	*=*+1
kg65.loadbufrflag	*=*+1		;0=initial load buffer	1=subsequent loads

	* = kg65.linea			;char vars

kg65.chrcol		*=*+1
kg65.chrrow		*=*+2
kg65.clipcol		*=*+1
kg65.cliprow		*=*+2
kg65.winsizecol		*=*+1
kg65.winsizey		*=*+2
kg65.ccount		*=*+1
kg65.charptr		*=*+2
kg65.charbuf1		*=*+8
kg65.charbuf2		*=*+8		;*** extends into lineb area ***
kg65.curchrmod		*=*+1
kg65.fsta		*=*+1
kg65.frvs		*=*+1
kg65.funder		*=*+1
kg65.hwidth		*=*+1
kg65.holda		*=*+1
kg65.hcount		*=*+1


	* = kg65.lineb			;paint vars					[910228]

kg65.paint.vars				;new paint routine			F.Bowen	[910716]
kg65.paint.sp		*=*+2		;paint stack pointer
kg65.paint.sl		*=*+2
kg65.paint.sr		*=*+2
kg65.paint.nl		*=*+2	;these are stacked
kg65.paint.nr		*=*+2	;
kg65.paint.lx		*=*+2	;
kg65.paint.rx		*=*+2	;
kg65.paint.ty		*=*+2	;
kg65.paint.pl		*=*+2	;
kg65.paint.pr		*=*+2	;
kg65.paint.rp		*=*+1	;	; 0-3
kg65.paint.d		*=*+1	;	; 1,-1
; kg65.paint.pixsts	*=*+1		; 0,1						unused????
kg65.paint.tmppt	*=*+2		;						[FAB]
; kg65.paint.tmpsp	*=*+2

kg65.paint.parms
kg65.paint.x		*=*+2		;xpos						[910716]
kg65.paint.y		*=*+2		;ypos
kg65.paint.mode		*=*+1
kg65.paint.bc		*=*+1		;colsel
paint_stack_bot		*=*+2
paint_stack_top		*=*+2
; paint_stack_ptr	*=*+2
; left_flag		*=*+1
; right_flag		*=*+1


	* = kg65.lineb			;SaveIFF vars					[911108] FAB

ChunkLen		*=*+4
FormLen			*=*+4
BMHDLen			*=*+4
;CAMGLen		*=*+4		;???? unused
ColorChunkLength	*=*+4
BodyChunkLength		*=*+4
CompressFlag		*=*+1
WhichPass		*=*+1
kg65.PTR1		*=*+1
kg65.PTR2		*=*+1
Temp1			*=*+1
Temp2			*=*+1
Temp3			*=*+1
Temp4			*=*+1
Temp5			*=*+1
BPCount			*=*+1
LineCount		*=*+2
LineTemp		*=*+2
kg65.Count		*=*+1
kg65.Preval		*=*+1
kg65.Curval		*=*+1

	.page
	* = $0000			;Clip vars					[901112]

kg65.clipcode		*=*+1
kg65.clipflag0		*=*+1
kg65.clipflag1		*=*+1
kg65.mx			*=*+2		;maxx-x0
kg65.my			*=*+2		;maxy-y0
kg65.nx			*=*+2		;-x0
kg65.ny			*=*+2		;-y0
kg65.tdxy1		*=*+2
kg65.tdxy2		*=*+2
kg65.xclip		*=*+2
kg65.yclip		*=*+2
kg65.maxx		*=*+2
kg65.maxy		*=*+2

;.end
	.page
	.subttl kg65 Graphic Jump Table

;created	: 07/18/89
;updated	: 09/17/90 FAB, 11/12/90 (viewportdef)
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom


	* = $8000			;8E ROM version (temporary!)

	.word kg65.start		;Graphics BASIC init (same as command=0)
	.word kg65.parse		;Graphics BASIC command parser

commandadr
	.word kg65.start-1			;0	commands
	.word kg65.screendef-1			;1
	.word kg65.screenopen-1			;2
	.word kg65.screenclose-1		;3
	.word kg65.screenclear-1		;4
	.word kg65.screen-1			;5
	.word kg65.setpen-1			;6
	.word kg65.setpalette-1			;7
	.word kg65.setdmode-1			;8
	.word kg65.setdpat-1			;9
	.word kg65.line-1			;10
	.word kg65.box-1			;11
	.word kg65.circle-1			;12
	.word kg65.polygon-1			;13
	.word kg65.ellipse-1			;14
	.word kg65.viewpclr-1			;15
	.word kg65.copy-1			;16
	.word kg65.cut-1			;17
	.word kg65.paste-1			;18
	.word kg65.load-1			;19
	.word kg65.char-1			;20
	.word kg65.paint-1			;21					[910212]
	.word kg65.viewportdef-1		;22					[910626]

	.word kg65.f.pixel-1			;23	function			[910801]
	.word kg65.f.rpalette-1			;24	   "				[910820]
	.word kg65.f.pencolor-1			;25	   "				[910820]
	.word kg65.f.rgraphic-1			;26	   "				[910823]

	.word kg65.saveiff-1			;27					[910930]

maxcommand	= 27

	.page
	.subttl kg65 Graphic ROM Constants

;created	: 07/18/89
;updated	: 
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom


kg65.c.bitsdn	.byte 128,64,32,16,8,4,2,1
kg65.c.bitsup	.byte 1,2,4,8,16,32,64,128

kg65.c.maskl	.byte 0,128,192,224,240,248,252,254
kg65.c.maskr	.byte 0,127,63,31,15,7,3,1

kg65.c.pi2	.byte $83,$49,$0f,$da,$a2		;3.14... * 2

kg65.c.scridx		;offset in screen table to each screen# 0-3 entry	[910711]
		.byte 0,4,8,12				;,16,20,24,28,32,36,40,44,48,52,56,60

kg65.c.incrow		;word wrap value for char multiples of 8 up to height = 16
		.byte 0,8,16,24,32,40,48,56,64,72,80,88,96,104,112,120

kg65.c.widthtabl			;width table low byte
		.byte <320
		.byte <640
		.byte <1280

kg65.c.widthtabh			;width table high byte
		.byte >320
		.byte >640
		.byte >1280

kg65.c.heightabl			;height table low byte
		.byte <200
		.byte <400

kg65.c.heightabh			;height table high byte
		.byte >200
		.byte >400

kg65.c.320x200bpp			;320 x 200 bitplane priority list
		.byte %00000100		;bitplane #2
		.byte %00000001		;bitplane #0
		.byte %00000010		;bitplane #1
		.byte %00010000		;bitplane #4
		.byte %00001000		;bitplane #3
		.byte %01000000		;bitplane #6
		.byte %00100000		;bitplane #5
		.byte %10000000		;bitplane #7

kg65.c.320x400bpp			;320 x 400 bitplane priority list
		.byte %00000100		;bitplane #2
		.byte %00000010		;bitplane #1
		.byte %00000001		;bitplane #0
		.byte %00001000		;bitplane #3
		.byte %00010000		;bitplane #4
		.byte %00100000		;bitplane #5
		.byte %10000000		;bitplane #7
		.byte %01000000		;bitplane #6

kg65.c.640xhtbpp			;640 x ht bitplane priority list
		.byte %00000100		;bitplane #2
		.byte %00000010		;bitplane #1
		.byte %00000001		;bitplane #0
		.byte %00001000		;bitplane #3

kg65.c.1280xhtbpp			;1280 x ht bitplane priority list
		.byte %00000011		;bitplanes 0 & 1
		.byte %00001100		;bitplanes 2 & 3

kg65.c.320xhtebkp			;320 x ht even bitplane priority list
					;ht=200 then 8k blocks grab one at a time
					;ht=400 then 8k blocks grab two at a time
		.byte %10000000		;a7
		.byte %01000000		;a6
		.byte %00100000		;a5
		.byte %00010000		;a4
		.byte %00001000		;a3
		.byte %00000100		;a2
		.byte %00000010		;a1
		.byte %00000001		;a0 or error

kg65.c.320xhtobkp			;320 x ht odd bitplane priority list
					;ht=200 then 8k blocks grab one at a time
					;ht=400 then 8k blocks grab two at a time
		.byte %01000000		;b6
		.byte %00100000		;b5
		.byte %00010000		;b4
		.byte %10000000		;b7
		.byte %00001000		;b3
		.byte %00000100		;b2
		.byte %00000010		;b1
		.byte %00000001		;b0 or error


kg65.c.640xhtebkp			;640 x ht even bitplane priority list
					;ht=200 then 16k blocks grab one at a time
					;ht=400 then 16k blocks grab two at a time
		.byte %11000000		;a6 & a7
		.byte %00110000		;a4 & a5
		.byte %00001100		;a2 & a3
		.byte %00000011		;a0 & a1  or error

kg65.c.640xhtobkp			;640 x ht odd bitplane priority list
					;ht=200 then 16k blocks grab one at a time
					;ht=400 then 16k blocks grab two at a time
		.byte %00110000		;b4 & b5
		.byte %11000000		;b6 & b7
		.byte %00001100		;b2 & b3
		.byte %00000011		;b0 & b1  or error

kg65.c.colrLblkadrl
		.byte <8000,<16192,<24384,<32576,<40768,<48960,<57152,<65344
kg65.c.colrLblkadrh
		.byte >8000,>16192,>24384,>32576,>40768,>48960,>57152,>65344

kg65.c.colrHblkadrl			;					[910819]
		.byte <16000,<16000,<32384,<32384,<48768,<48768,<65152,<65152
kg65.c.colrHblkadrh
		.byte >16000,>16000,>32384,>32384,>48768,>48768,>65152,>65152

kg65.c.width1lo
		.byte <0,<320,<640,<960,<1280,<1600,<1920,<2240,<2560,<2880,<3200,<3520
		.byte <3840,<4160,<4480,<4800,<5120,<5440,<5760,<6080,<6400,<6720,<7040
		.byte <7360,<7680
kg65.c.width1hi
		.byte >0,>320,>640,>960,>1280,>1600,>1920,>2240,>2560,>2880,>3200,>3520
		.byte >3840,>4160,>4480,>4800,>5120,>5440,>5760,>6080,>6400,>6720,>7040
		.byte >7360,>7680

kg65.c.patrbits				;length in bits of the possible pattern sizes
		.byte 8,16,24,32	;	1 to 4 bytes

kg65.c.dpatterns			;predefined patterns
		.byte %10001000		;	thin dot
		.byte %11001100		;	thick dot
		.byte %11101110		;	dashed
		.byte %10011100		;	dot/dash

kg65.c.form	.byte 'FORM'
kg65.c.ilbm	.byte 'ILBM'
kg65.c.bmhd	.byte 'BMHD'
kg65.c.camg	.byte 'CAMG'
kg65.c.cmap	.byte 'CMAP'
kg65.c.body	.byte 'BODY'

Numcolors	.byte 2,4,8,16,32,64,128,0	;				[911108] FAB

kg65.c.octable					;					[FAB]
		.word kg65.s.right
		.word kg65.s.downrt
		.word kg65.s.left
		.word kg65.s.lftdwn
		.word kg65.s.right
		.word kg65.s.uprght
		.word kg65.s.left
		.word kg65.s.upleft
		.word kg65.s.down
		.word kg65.s.downrt
		.word kg65.s.down
		.word kg65.s.lftdwn
		.word kg65.s.up
		.word kg65.s.uprght
		.word kg65.s.up
		.word kg65.s.upleft

;.end
	.page
	.subttl kg65.interface

;created	: 07/18/89
;updated	: 
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;


	clc			;????
kg65.start
	php
;	sei
	tba
	pha
	lda #kg65.l.basepage
	tab
	lda #0
	tax
10$	sta $00,x		;init graphics base-page
	inx
	bne 10$

;	lda #0
;	sta kg65.patrbitnum
	sta c65.l.bpcompe

;	lda #$ff
	dec a
	sta kg65.drawscreen	;no draw/view screen set
	sta kg65.viewscreen

	lda #0			;							[910506]
	sta kg65.banka
	lda #%00001111		;$00000-$07FFF rsvd for BASIC program & system vars
	sta kg65.bankablks
	lda #1			;							[910506]
	sta kg65.bankb
	lda #%10001111		;$10000-$17FFF rsvd for BASIC vars & DOS, $1F800 nybbles
	sta kg65.bankbblks	;$1E000-$1FFFF rsvd for BASIC vars & color nybbles

;	lda #$a5		;Set newVIC mode
;	sta c65.l.vickeyr
;	lda #$96
;	sta c65.l.vickeyr
;	lda c65.l.vicntld
;	ora #%01000000		;fast mode
;	sta c65.l.vicntld
;	lda c65.l.vicntlc
;	ora #%00000100		;palette
;	sta c65.l.vicntlc

	pla
	tab
	plp
	rts

	.page
kg65.parse
	ldx #0
	stx kg65.l.basepage*256+kg65.temp1
	bsr chkcom65
	jsr c65.getbyt
	stx kg65.l.basepage*256+kg65.temp2

2$	bsr chkcom65
	bcs 1$
	jsr c65.getbyt
	txa
	ldx kg65.l.basepage*256+kg65.temp1
	sta kg65.l.basepage*256+kg65.parm1,x
	inc kg65.l.basepage*256+kg65.temp1
	bra 2$

1$	lda kg65.l.basepage*256+kg65.temp2
	cmp #maxcommand+1
	bcs screen.error	;invalid command
	asl a			;make command# into command table index
	tax
	lda commandadr+1,x	;push address of handler onto stack
	pha
	lda commandadr,x
	pha
	rts			;execute command

	.page
chkcom65
	lda #$2c
	ldy #0
	sta c65.syntmp
	jsr c65.indtxt
	cmp c65.syntmp
	bne 1$
	jsr c65.chrget
	clc
	rts

1$	sec
	rts

;.end
	.page
	.subttl kg65.screen

;created	: 07/17/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;
; kernal graphics screen commands

;screen define
; parm1 = screen#	0-3
; parm2 = width	 flag 00=320 01=640 10=1280
; parm3 = height flag 0=200 1=400
; parm4 = depth		0-7 => 1-8

	clc			;????
kg65.screendef
;	sei
	tba			;save base page register on stack
	pha
	lda #kg65.l.basepage	;kernal graphics base page in bank0
	tab
	lda kg65.parm2		;screen width 0=320, 1=640, 2=1280
	and #%00000011		;keep bits 0 & 1, then move to bits 4 & 5
	asl a
	asl a
	asl a
	asl a
	sta kg65.temp1		;save area to build table entry screen size data
	lda kg65.parm3		;screen heigth 0=200, 1=400
	beq 1$			;br if a=0  bit 3 of temp byte is already 0
	smb3 kg65.temp1		;set bit 3 to 1

1$	ldy kg65.parm1		;screen# 0-3
	ldx kg65.c.scridx,y	;get offset to screen# entry
	lda kg65.parm4		;screen depth 0-7
	and #%00000111		;keep bits 0-2
	ora kg65.temp1		;merge into temp byte
	ora #%10000000		;set bit 7 to signify that this is a valid entry
	sta kg65.scrtab,x	;save in screen table for screen# entry
	pla			;restore base page register value
	tab
	clc
;	cli
	rts

	.page
;screen open
; parm1 = screen# 0-3

;error on invalid entry or screen already opened

	clc			;????
kg65.screenopen			;allocate screen memory
;	sei
	tba			;save base page register on stack
	pha
	lda #kg65.l.basepage	;kernal graphics base page in bank0
	tab
	ldy kg65.parm1		;screen#
	bsr kg65.s.allocscr 	;allocate screen
	bcs screen.error	;br if invalid entry or screen already opened
	pla
	tab
	clc
;	cli
	rts

screen.error
	pla			;restore base page register value
	tab
	sec
;	cli
	rts

	.page
;screen draw#, view#
;
; parm1 = draw screen# 0-3, $FF=leave as currently set
; parm2 = view screen# 0-3, $FF=text

;error on invalid entry or screen not open

	clc			;????
kg65.screen			;set screen bitplane addresses
;	sei
	tba			;save base page register on stack
	pha
	lda #kg65.l.basepage	;kernal graphics base page in bank0
	tab

	ldy kg65.parm1
	bmi 255$		;leave current drawscreen settings			[910930]
	cpy #4
	bcs screen.error
	bsr kg65.s.xpdscrdata
252$	bcs screen.error			;br if screen definition not valid
	bbr6 kg65.subparm4,screen.error		;br if open bit reset (0)

	sty kg65.drawscreen 	;draw screen index
	sta kg65.drawscrwidth
	stx kg65.drawscrheight
	stz kg65.drawscrdepth

	ldx #40			;init to 40 bytes wide (320)
	ldz #<312		;draw screen increment for (320 mode)
	ldy #>312
	cmp #0			;width flag
	beq 1$			;br if 00 -> 320
	ldx #80			;width 80 bytes (640 or 1280)
	ldz #<632		;draw screen increment for (640 mode)
	ldy #>632

1$	stx kg65.drawscrcols
	sty kg65.drawscrinc+1
	stz kg65.drawscrinc
	ldx kg65.drawscreen 	;index into screen table
	lda kg65.scrtab+1,x
	sta kg65.drawscrbp	;draw screen bitplane mask
	lda kg65.scrtab+2,x
	sta kg65.drawscrablks	;draw screen bank A blks mask
	lda kg65.scrtab+3,x
	sta kg65.drawscrbblks	;draw screen bank B blks mask
	lda #0			;x,y = 0
	sta kg65.drawscrvpx 	;draw screen viewport x
	sta kg65.drawscrvpx+1
	sta kg65.drawscrvpy 	;draw screen viewport y
	sta kg65.drawscrvpy+1
	ldy kg65.drawscrwidth
	lda kg65.c.widthtabl,y	;set proper viewport width
	sta kg65.drawscrvpdx
	lda kg65.c.widthtabh,y
	sta kg65.drawscrvpdx+1
	ldy kg65.drawscrheight
	lda kg65.c.heightabl,y	;set proper viewport height
	sta kg65.drawscrvpdy
	lda kg65.c.heightabh,y
	sta kg65.drawscrvpdy+1

	ldx kg65.drawscreen	;					moved	[910930]
	lda #<kg65.dsbp0adr
	sta kg65.bpptr1
	lda #kg65.l.basepage
	sta kg65.bpptr1+1
	bsr 99$			;set bitplane address for draw screen
	bcs screen.error	;based on bitplanes used and blocks allocated

	.page
255$				;						[910930]
	ldy kg65.parm2
	bmi 254$		;$ff=text					[910930]
	cpy #4
	bcs 252$
	bsr kg65.s.xpdscrdata
	bcs 252$			;screen# definition not valid
	sec
	bbr6 kg65.subparm4,252$		;br if open bit reset (0)

	sty kg65.viewscreen 	;view screen index
	sta kg65.viewscrwidth
	stx kg65.viewscrheight
	stz kg65.viewscrdepth

; for color# = 0 to (#colors on screen - 1)
;  read palette for screen#,color#
;  convert color# to color index
;  write to hardware palette
;  next

	sty kg65.parm7		;view screen index
	ldx kg65.viewscrdepth
	lda kg65.c.bitsup,x 	;1,2,4,...,64,128
	asl a			;*2 => 2,4,8,...,128,256 which is 0
	sta kg65.parm9
	lda kg65.parm2		;view screen#
	sta kg65.parm8		;save area
	lda #0
	sta kg65.parm2		;color#

2$	lda kg65.parm8		;view screen#
	sta kg65.parm1
	bsr kg65.s.read.palette	;sets parm6
	lda kg65.parm7		;view screen index
	sta kg65.parm1
	bsr kg65.s.color2index
	ldx kg65.temp4		;color index
	lda kg65.parm3
	sta c65.l.redcpba,x
	lda kg65.parm4
	sta c65.l.grncpba,x
	lda kg65.parm5
	sta c65.l.blucpba,x
	inc kg65.parm2
	lda kg65.parm2
	cmp kg65.parm9
	bne 2$

	lda c65.l.vicntld	;get current vic control reg. d settings
	and #%01000000		;leave fast bit alone, everything else to zero
	ora #%00010000		;set bitplane mode bit
	sta kg65.temp1		;vic control reg. d work byte

;	rmb0 c65.l.xscroll	;assume 320 wide
	lda kg65.viewscrwidth
	beq 3$			;br if width flag = 0 -> 320
	cmp #%00000001		;is 640 flag set
	beq 4$			;br if yes
	smb2 kg65.temp1		;turn 1280 mode on
4$	smb7 kg65.temp1		;turn 640 mode on
;	smb0 c65.l.xscroll

3$	lda kg65.viewscrheight
	beq 5$			;br if 200 ht
	smb3 kg65.temp1		;turn on 400 ht
	smb0 kg65.temp1		;turn on interlace

5$	ldx kg65.viewscreen
	lda #<c65.l.bp0addr
	sta kg65.bpptr1
	lda #>c65.l.bp0addr
	sta kg65.bpptr1+1
	bsr 99$			;set bitplane address for view screen
	bcs screen.error	;based on bitplanes used and blocks allocated

;	ldx kg65.drawscreen	;					moved	[910930] FAB
;	lda #<kg65.dsbp0adr
;	sta kg65.bpptr1
;	lda #kg65.l.basepage
;	sta kg65.bpptr1+1
;	bsr 99$			;set bitplane address for draw screen
;	bcs screen.error	;based on bitplanes used and blocks allocated

	lda kg65.temp1		;new vic control reg. d settings
	sta c65.l.vicntld	;turn on new modes
	asl a
	lda #%00101000
	bcc 10$			; (320 wide- adjust x-scroll register)
	inc a			; (640 wide-   "	"	 "   )		[910815]
10$	sta c65.l.xscroll

;	lda kg65.temp1		;						[910517]
;	and #%100
;	lsr a
;	lsr a
;	sta mode1280flag
	
	ldx kg65.viewscreen
	lda kg65.scrtab+1,x 	;bitplanes used mask
	sta c65.l.bitplne	;set bitplane enable bit mask

	pla
	tab
	clc
;	cli
	rts

254$	sty kg65.viewscreen	;switch to text screen (y=$ff)			[910930]
	pla
	tab
	bra CheckViewScreen


99$	;don't use temp1 in this routine
	;set bitplane address of bitplanes used. info. found in screen table entry
	;for the screen index in x

	;preserve x in this routine!

	lda #%01010101		;even bitplane #'s  (bank A)
	sta kg65.temp7
	bsr 98$
	lda #%10101010		;odd bitplane #'s  (bank B)
	sta kg65.temp7
	bsr 98$
	rts


98$	ldy #0
	sty kg65.temp2		;bitplane# 0-7
	iny
	sty kg65.temp3		;bitplane# test mask 1,2,4,8,16,32,64,128
	lda #7
	sta kg65.temp4		;block# 7-0
	lda #128
	sta kg65.temp5		;block# test mask 128,64,32,16,8,4,2,1

9$	lda kg65.scrtab+1,x 	;get bitplane# used bit field
	and kg65.temp3		;mask with current bitplane bit# to test for
	beq 6$			;br if bitplane not used for this screen
	and kg65.temp7		;test bitplane# type odd or even
	beq 6$			;br if not of type desired
	lda kg65.temp7
	and #%00000001		;test if odd
	bne 8$			;br if not
	lda kg65.scrtab+3,x 	;get bank B block# used bit field
	  .byte $2c		;bit opcode  next instruction must be two bytes

8$	lda kg65.scrtab+2,x 	;get bank A block# used bit field
	sta kg65.temp6		;block# bit used field

	lda kg65.subparm5	;width & height value
	beq 20$			;320x200
	cmp #%00001000
	beq 30$			;320x400
	cmp #%00010000
	beq 40$			;640x200
	cmp #%00011000
	beq 50$			;640x400
	cmp #%00100000
	beq 40$			;1280x200
	cmp #%00101000
	beq 50$			;1280x400
	bra 11$

6$	inc kg65.temp2		;bitplane# + 1
	asl kg65.temp3		;do next bitplane# in bit fields
	bcc 9$			;br unless carry set meaning all done
				;infinite loop if temp3=0 or no bitplanes for this screen
	clc			;shouldn't get here if that's the case
	rts

11$	sec
	rts


12$				;next bitplane# loop logic for 640 wide mode
	inc kg65.temp2
	asl kg65.temp3
	iny			;bitplane#
	cpy #4
	bcc 9$			;br if <
	clc
	rts


20$				;320x200
	lda kg65.temp6		;block# bit used field
	and kg65.temp5		;mask with current block bit# to test for
	bne 21$			;br if block to be used for bitplane in this screen
	dec kg65.temp4		;block# - 1
	lsr kg65.temp5		;else test next block# in bit field
	bcc 20$			;br until bit shift out to carry
	bcs 11$

21$	lda kg65.temp4		;block# 7-0
	asl a			;put in bits 1-3 of a
	ldy kg65.temp2		;bitplane #
	sta (kg65.bpptr1),y 	;bitplane address register ptr
	dec kg65.temp4		;block# - 1
	lsr kg65.temp5		;next block# in bit field
	bra 6$

30$				;320x400
	lda kg65.temp6		;block# bit used field
	and kg65.temp5		;mask with current block bit# to test for
	bne 31$			;br if block to be used for bitplane in this screen
	dec kg65.temp4		;block# - 1
	lsr kg65.temp5		;else test next block# in bit field
	bcc 30$			;br until bit shift out to carry
	bcs 11$

31$	lda kg65.temp4		;block# 7-0
	asl a			;put in bits 1-3 of a
	ldy kg65.temp2		;bitplane #
	sta (kg65.bpptr1),y 	;bitplane address register ptr
	dec kg65.temp4		;block# - 1
	lsr kg65.temp5		;next block# in bit field

32$	lda kg65.temp6		;block# bit used field
	and kg65.temp5		;mask with current block bit# to test for
	bne 33$			;br if block to be used for bitplane in this screen
	dec kg65.temp4		;block# - 1
	lsr kg65.temp5		;else test next block# in bit field
	bcc 32$			;br until bit shift out to carry
	bcs 11$

33$	lda kg65.temp4		;block# in bits 2-0
	asl a			;put in bits 3-1
	asl a			;put in bits 4-2
	asl a			;put in bits 5-3
	asl a			;put in bits 6-4
	asl a			;put in bits 7-5
	ldy kg65.temp2		;bitplane #
	ora (kg65.bpptr1),y 	;merge with previously set even scanline addr.
	sta (kg65.bpptr1),y 	;bitplane address register ptr
	dec kg65.temp4		;block# - 1
	lsr kg65.temp5		;next block# in bit field
	bra 6$

40$				;640x200 & 1280x200
	lda kg65.temp6
	and kg65.temp5
	bne 41$
	dec kg65.temp4		;block# - 2 because each bitplane uses 16k blocks
	dec kg65.temp4
	lsr kg65.temp5
	lsr kg65.temp5
	bcc 40$
	bcs 11$

41$	lda kg65.temp4
	dec a			;put on low block# of 8k pair
	asl a			;put in bits 3-1
	ldy kg65.temp2
	sta (kg65.bpptr1),y
	dec kg65.temp4		;block# - 2 because each bitplane uses 16k blocks
	dec kg65.temp4
	lsr kg65.temp5
	lsr kg65.temp5
	bra 12$

50$				;640x400 & 1280x400
	lda kg65.temp6
	and kg65.temp5
	bne 51$
	dec kg65.temp4		;block# - 2 because each bitplane uses 16k blocks
	dec kg65.temp4
	lsr kg65.temp5
	lsr kg65.temp5
	bcc 50$
	bcs 11$

51$	lda kg65.temp4
	dec a			;put low block# of 8k pair
	asl a			;put in bits 3-1
	ldy kg65.temp2
	sta (kg65.bpptr1),y
	dec kg65.temp4		;block# - 2 because each bitplane uses 16k blocks
	dec kg65.temp4
	lsr kg65.temp5
	lsr kg65.temp5

52$	lda kg65.temp6
	and kg65.temp5
	bne 53$
	dec kg65.temp4		;block# - 2 because each bitplane uses 16k blocks
	dec kg65.temp4
	lsr kg65.temp5
	lsr kg65.temp5
	bcc 52$
	bcs 11$

53$	lda kg65.temp4
	dec a			;put low block# of 8k pair
	asl a			;put in bits 7-5 from 2-0
	asl a
	asl a
	asl a
	asl a
	ldy kg65.temp2
	ora (kg65.bpptr1),y
	sta (kg65.bpptr1),y
	dec kg65.temp4		;block# - 2 because each bitplane uses 16k blocks
	dec kg65.temp4
	lsr kg65.temp5
	lsr kg65.temp5
	bra 12$

	.page
;screen close
; parm1 = screen# 0-3

;error on invalid entry or screen already closed

	clc			;????
kg65.screenclose
;	sei
	tba			;save base page register on stack
	pha
	lda #kg65.l.basepage	;kernal graphics base page in bank0
	tab
	ldy kg65.parm1		;screen#
	bsr kg65.s.deallocscr	;deallocate screen
	bcs screen.error	;br if invalid entry or screen already opened
	pla
	tab

CheckViewScreen			;Enter here to do it if necessary
CheckViewScreen_1	= 10$	;Entry to set display back to text

	lda kg65.l.basepage*256+kg65.viewscreen					[910815]
	bpl 30$			;exit if view screen still active

10$	bit c65.l.rascmph	;busywait for vertical blank			[910930]
	bpl 10$

	sei
	ldx #%00101000		;vic+22: reset+#col
	lda c65.l.vicntld
	and #%01100010		;vic+49: turn all modes off except speed, attribute, mono
	bbs7 $d7,20$		;40/80 mode, 0=80 128=40			[910815]
	ora #%10000000
	inx			;set smooth scroll to 1
20$	sta c65.l.vicntld
	stx c65.l.xscroll

30$	clc
	cli
	rts

	.page
;screen clear
; parm1 = clear color#

	clc			;????
kg65.screenclear
;	sei
	tba			;save base page register on stack
	pha
	lda #kg65.l.basepage	;kernal graphics base page in bank0
	tab

;	lda kg65.drawscreen	;						[910930]
;	inc a			;screen not set yet
;	beq screen.error

	lda kg65.parm1		;color#
	sta kg65.parm2
	lda kg65.drawscreen 	;draw screen index
	bmi screen.error	;	error, not set yet			[910930]
	sta kg65.parm1
	bsr kg65.s.color2index
	lda kg65.temp4
	sta kg65.parm1		;color index

	ldx #0			;bitplane#
	stx kg65.temp1		;init. to do even block#
	stx kg65.temp2		;init. to do low 8k block on 640 wide bitplane

1$	lda kg65.drawscrwidth
	beq 26$			;br if 320
	inc kg65.temp2		;set flag to do both 8k blocks low then hi

26$	lda kg65.drawscrheight	;200 or 400 (interlaced)
	beq 23$			;br if 200 (non-interlaced)
	inc kg65.temp1		;set flag to do both blocks even then odd
	bra 23$
25$				;only can get here if in interlaced mode, even line done
	lda kg65.drawscrwidth	;test if 640
	beq 27$			;br if no
	inc kg65.temp2		;else must set this flag so that lo & hi blocks
				; of this odd line block can be done
27$	lda #0
	sta kg65.temp1		;reset to do even line block# at next bitplane#
	lda kg65.dsbp0adr,x 	;get bitplane odd line block#
	lsr a			;put block# in lower nybble
	lsr a
	lsr a
	lsr a
	bra 24$			;skip over even line block# set

35$	lda #0			;reset to do low block at next bitplane#
	sta kg65.temp2
	bra 34$			;y=hi block#  (original block# + 1)

23$	lda kg65.c.bitsup,x 	;bitplane# mask
	and kg65.drawscrbp	;does draw screen use that bitplane?
	beq 40$			;br if no to increment x (bitplane#)

	lda kg65.dsbp0adr,x 	;get bitplane even line block#
24$	lsr a			;put in lower 3 bits of lower nybble
	and #%00000111		;keep only A13,A14,A15 (8K block address)
	tay			;y=block#

34$				;come here to do hi 8k block of 640 wide bitplane
	lda kg65.parm1		;clear values -> color reg#
	and kg65.c.bitsup,x 	;128,64,32,16,8,4,2,1
	beq 2$			;if bit = 0 then fill byte = 0

	lda #255		;else fill byte = 255  (all 1's)
2$	pha			;save a
	txa			;bitplane#
	and #%00000001		;test if odd
	beq 21$			;br if even

	pla			;restore a
	phx			;save x
	phy			;tyx
	plx			;x now = block#
	sta kg65.blkfillval+8,x	;put in bank B block fill vals
	plx			;restore x
	bra 22$

21$	pla			;restore a
	phx			;save x
	phy			;tyx
	plx			;x now = block#
	sta kg65.blkfillval,x	;put in bank A block fil vals
	plx			;restore x

22$	iny			;set to do hi 8k block of 640 wide bitplane
	lda kg65.temp2
	bne 35$			;br if 640 wide
	lda kg65.temp1		;do odd line block# if branch taken
	bne 25$

40$	inx
	cpx #8			;do bitplanes 0 to 7  even if in 640 mode
	bne 1$

	.page
	ldx kg65.drawscreen 		;screen entry index		recoded	[910709] FAB
	lda kg65.scrtab+2,x 		;bank A blocks used mask
	sta kg65.temp1
	ldx #0
	ldz kg65.l.basepage*256+kg65.banka
	bsr 100$			;clear blocks used in bank A
			
	ldx kg65.drawscreen
	lda kg65.scrtab+3,x 		;bank B blocks used mask
	sta kg65.temp1
	ldx #8
	ldz kg65.l.basepage*256+kg65.bankb
	bsr 100$			;clear blocks used in bank B
	pla
	tab
	clc
;	cli
	rts

	.page
; Clear Bitplanes							recoded	[910709] FAB

100$	bbr0 kg65.temp1,110$				;block 0 not used
	lda #>$0000					;fill $0000-$1FFF
	ldy kg65.blkfillval,x				;fill byte
	bsr kg65.dmafill

110$	bbr1 kg65.temp1,120$				;block 1 not used
	lda kg65.drawscrwidth				;block 1 top of 16K block
	bne 120$
	lda #>$2000					;fill $2000-$3FFF
	ldy kg65.blkfillval+1,x				;fill byte
	bsr kg65.dmafill

120$	bbr2 kg65.temp1,130$				;block 2 not used
	lda #>$4000					;fill $4000-$5FFF
	ldy kg65.blkfillval+2,x				;fill byte
	bsr kg65.dmafill

130$	bbr3 kg65.temp1,140$				;block 3 not used
	lda kg65.drawscrwidth				;block 3 top of 16K block
	bne 140$
	lda #>$6000					;fill $6000-$7FFF
	ldy kg65.blkfillval+3,x				;fill byte
	bsr kg65.dmafill

140$	bbr4 kg65.temp1,150$				;block 4 not used
	lda #>$8000					;fill $8000-$9FFF
	ldy kg65.blkfillval+4,x				;fill byte
	bsr kg65.dmafill

150$	bbr5 kg65.temp1,160$				;block 5 not used
	lda kg65.drawscrwidth				;block 5 top of 16K block
	bne 160$
	lda #>$a000					;fill $A000-$BFFF
	ldy kg65.blkfillval+5,x				;fill byte
	bsr kg65.dmafill

160$	bbr6 kg65.temp1,170$				;block 6 not used
	lda #>$c000					;fill $C000-$DFFF
	ldy kg65.blkfillval+6,x				;fill byte
	bsr kg65.dmafill

170$	bbr7 kg65.temp1,180$				;block 7 not used
	lda kg65.drawscrwidth				;block 7 top of 16K block
	bne 180$
	lda #>$e000					;fill $E000-$FFFF
	ldy kg65.blkfillval+7,x				;fill byte
	bsr kg65.dmafill

180$	rts

	.page
; Graphics Kernel DMA, requires rev2A PCB & ver0.9 ROM code.				[910102]
;
;  DMAlist structure:						F018A DMA Chip		[910517]
;
;	command		byte		0=copy 1=mix 2=swap 3=fill, b4,5=d,s direction	[910517]
;	length (l/h)	word		0=64K
;	source (l/h/b)	word+byte	address, bank	(fill=low is fill value)
;	dest   (l/h/b)	word+byte	address, bank
;	subcmd		byte		minterms, modulus, hold
;	mod    (l/h)	word		modulus
;
;  DMAgic registers:
;
;	$D700		DMAlist address low  & trigger
;	$D701		DMAlist address high
;	$D702		DMAlist address bank
;	$D703		status
;
;  BASIC's user DMAlist is located at C65.DMA2_LIST ($00150)

kg65.dmafill			;enter with (a/z)=(h/b) area to fill, y=fill byte
	phx			;save x
	ldx #3			;fill command				recoded	[910709]
	stx c65.dma2_list

	ldx kg65.drawscrwidth
	beq 10$	
	ldx #<16000		;count (16K bitplane)				[910709]
	stx c65.dma2_list+1
	ldx #>16000
	stx c65.dma2_list+2
	bra 20$

10$	ldx #<8000		;count (8K bitplane)				[910709]
	stx c65.dma2_list+1
	ldx #>8000
	stx c65.dma2_list+2

20$	sty c65.dma2_list+3	;fill byte

	stz c65.dma2_list+8	;destination	bank
	sta c65.dma2_list+7	;		high
	lda #0
	sta c65.dma2_list+6	;		low

	sta c65.dma2_list+9	;cmd2						[910520] F018A
	sta c65.dma_ctlr+2	;DMAlist	bank
	lda #>c65.dma2_list	;		high
	sta c65.dma_ctlr+1
	lda #<c65.dma2_list	;		low & trigger
	sta c65.dma_ctlr
	plx			;restore x
	rts			;all done

	.page
;	ALLOCATE SCREEN BITPLANES AND MEMORY
;
;	y=screen# 0-3
;
; error on invalid entry or screen already openned

kg65.s.allocscr
	bsr kg65.s.xpdscrdata	;expand screen size data into seperate bytes
	bcs 7$			;error not a valid screen# entry in table
	bbs6 kg65.subparm4,7$	;br if open bit set (1)
	lda #0
	sta kg65.temp3		;initialize temp. vars
	sta kg65.temp4
	sta kg65.temp5
	lda kg65.subparm3	;depth value
	sta kg65.temp6		;depth counter
	lda kg65.bankablks
	sta kg65.temp7
	lda kg65.bankbblks
	sta kg65.temp8

	ldy #0
6$	lda kg65.subparm5	;draw screen height & width flags merged
	beq 20$			;br if 320 x 200
	cmp #%00001000		; 00wwh000  ww=wdith flag  h=height flag
	beq 30$			;320x400
	cmp #%00010000
	beq 40$			;640x200
	cmp #%00011000
	beq 50$			;640x400
	cmp #%00100000
	beq 60$			;1280x200
	cmp #%00101000
	beq 70$			;1280x400

7$	sec			;error
	rts

	.page
20$				;320 x 200
	ldx #0
	lda kg65.c.320x200bpp,y	;bitplane# priority list
	sta kg65.temp1		;current bitplane# mask 128,64,...,2,1
	and #%10101010		;test if odd or even
	beq 21$			;br if bitplane# is even  0,2,4,8

22$	lda kg65.c.320xhtobkp,x	;block# from odd bitplane#'s allocation list
	sta kg65.temp2		;current block#
	and kg65.temp8		;test if bank B block available
	beq 9$			;br if not used yet
	inx			;x index to next block#
	cpx #8			;8 possible choices
	bcc 22$			;keep searching
	bra 23$			;br around even bitplane# logic

21$	lda kg65.c.320xhtebkp,x	;block# from even bitplane#'s allocation list
	sta kg65.temp2		;current block#
	and kg65.temp7		;test if bank A block available
	beq 5$			;br if not used yet
	inx			;x index to next block#
	cpx #8			;8 possible choices
	bcc 21$			;keep searching

23$	iny			;all blocks gone for this bitplane# try another
	cpy #8			;bitplane# until all bitplanes tried
	bcc 20$
	bcs 7$

	.page
30$				;320x400   grab two 8k blocks
	lda kg65.temp1		;save bitplane# allocated temp var
	pha
	lda kg65.temp2		;save block# allocated temp var
	pha
	ldx #0
	lda kg65.c.320x400bpp,y	;search thru bitplane# allocation priority list
	sta kg65.temp1
	and #%10101010		;odd or even bitplane# ?
	beq 31$			;br on even

32$	lda kg65.c.320xhtobkp,x	;search thru block# allocation priority list
	sta kg65.temp2
	and kg65.temp8		;test if already allocated
	beq 39$			;br if no
	inx
	cpx #8			;try next block	until all 8 are checked
	bne 32$
	beq 34$			;restore temp vars and try next bitplane#

33$	lda kg65.c.320xhtobkp,x	;grab a second block
	taz
	and kg65.temp8		;test if alloated
	beq 35$			;br if no
39$	inx			; enter here to make sure not out of blocks
	cpx #8			;try next block until all 8 are checked
	bcc 33$

34$	pla
	sta kg65.temp2		;restore temp vars
	pla
	sta kg65.temp1
	iny
	cpy #8			;try next bitplane# until all 8 are checked
	bcc 30$
	bcs 7$			;allocation error

35$	tza
;	ora kg65.temp2		;allocate this block along with prev. block
;	sta kg65.temp2
	tsb kg65.temp2
	pla			;cleanup stack
	pla
	bra 9$			;finish updating alloation vars.


31$	lda kg65.c.320xhtebkp,x	;search thru block# allocation priority list
	sta kg65.temp2
	and kg65.temp7		;test if already allocated
	beq 37$			;br if no
	inx
	cpx #8			;try next block	until all 8 are checked
	bcc 31$
	bra 34$			;restore temp vars and try next bitplane#

36$	lda kg65.c.320xhtebkp,x	;grab a second block
	taz
	and kg65.temp7		;test if alloated
	beq 38$			;br if no
37$	inx			; enter here to make sure not out of blocks
	cpx #8			;try next block until all 8 are checked
	bcc 36$
	bra 34$

38$	tza
;	ora kg65.temp2		;allocate this block along with prev. block
;	sta kg65.temp2
	tsb kg65.temp2
	pla			;cleanup stack
	pla
	bra 5$			;finish updating alloation vars.

	.page
40$				;640x200
	ldx #0
	lda kg65.c.640xhtbpp,y	;bitplane# priority list
	sta kg65.temp1		;current bitplane# mask 128,64,...,2,1
	and #%10101010		;test if odd or even
	beq 41$			;br if bitplane# is even  0,2,4,8

42$	lda kg65.c.640xhtobkp,x	;block# from odd bitplane#'s allocation list
	sta kg65.temp2		;current block#
	and kg65.temp8		;test if bank B block available
	beq 9$			;br if not used yet
	inx			;x index to next block#
	cpx #4			;4 possible choices
	bcc 42$			;keep searching
	bra 43$			;br around even bitplane# logic

41$	lda kg65.c.640xhtebkp,x	;block# from even bitplane#'s allocation list
	sta kg65.temp2		;current block#
	and kg65.temp7		;test if bank A block available
	beq 5$			;br if not used yet
	inx			;x index to next block#
	cpx #4			;4 possible choices
	bcc 41$			;keep searching

43$	iny			;all blocks gone for this bitplane# try another
	cpy #4			;bitplane# until all bitplanes tried
	bcc 40$
	bcs 7$

	.page
50$				;640x400
	lda kg65.temp1		;save bitplane# allocated temp var
	pha
	lda kg65.temp2		;save block# allocated temp var
	pha
	ldx #0
	lda kg65.c.640xhtbpp,y	;search thru bitplane# allocation priority list
	sta kg65.temp1
	and #%10101010		;odd or even bitplane# ?
	beq 51$			;br on even

52$	lda kg65.c.640xhtobkp,x	;search thru block# allocation priority list
	sta kg65.temp2
	and kg65.temp8		;test if already allocated
	beq 59$			;br if no
	inx
	cpx #4			;try next block	until all 4 are checked
	bcc 52$
	bra 54$			;restore temp vars and try next bitplane#

53$	lda kg65.c.640xhtobkp,x	;grab a second block
	taz
	and kg65.temp8		;test if allocated
	beq 55$			;br if no

59$	inx			; enter here to make sure not out of blocks
	cpx #4			;try next block until all 4 are checked
	bcc 53$

54$	pla
	sta kg65.temp2		;restore temp vars
	pla
	sta kg65.temp1
	iny
	cpy #4			;try next bitplane# until all 4 are checked
	bcc 50$
	bcs 7$			;allocation error

55$	tza
;	ora kg65.temp2		;allocate this block along with prev. block
;	sta kg65.temp2
	tsb kg65.temp2
	pla			;cleanup stack
	pla
	bra 9$			;finish updating alloation vars.


51$	lda kg65.c.640xhtebkp,x	;search thru block# allocation priority list
	sta kg65.temp2
	and kg65.temp7		;test if already allocated
	beq 57$			;br if no
	inx
	cpx #4			;try next block	until all 4 are checked
	bcc 51$
	bra 54$			;restore temp vars and try next bitplane#

56$	lda kg65.c.640xhtebkp,x	;grab a second block
	taz
	and kg65.temp7		;test if alloated
	beq 58$			;br if no

57$	inx			; enter here to make sure not out of blocks
	cpx #4			;try next block until all 4 are checked
	bcc 56$
	bra 54$

58$	tza
;	ora kg65.temp2		;allocate this block along with prev. block
;	sta kg65.temp2
	tsb kg65.temp2
	pla			;cleanup stack
	pla
	bra 5$			;finish updating alloation vars.

	.page
60$				;1280x200  allocate 16k blocks in bank A & B per bitplane
	ldx #0
	stx kg65.temp9
	lda kg65.c.1280xhtbpp,y	;bitplane# priority list
	sta kg65.temp1		;current bitplane mask 128,64,...,2,1

61$	lda kg65.c.640xhtebkp,x	;block# from even bitplane#'s allocation list
	sta kg65.temp2		;current block#
	and kg65.temp7		;test if bank A block available
	beq 62$			;br if not used yet
	inx			;x index to next block#
	cpx #4			;4 possible choices
	bcc 61$			;keep searching
	bra 63$			;try next bitplane#

62$	ldx #0
64$	lda kg65.c.640xhtobkp,x	;find odd bitplane block#
	taz
	and kg65.temp8		;test if bank B block available
	beq 65$			;br if not used yet
	inx			;try up to 4 blocks
	cpx #4
	bcc 64$
	bra 63$

65$	tza
;	ora kg65.temp9		;save in temp9 the bank B block#'s
;	sta kg65.temp9
	tsb kg65.temp9

66$	lda kg65.temp2
;	ora kg65.temp4
;	sta kg65.temp4
	tsb kg65.temp4
	lda kg65.temp2
;	ora kg65.temp7
;	sta kg65.temp7
	tsb kg65.temp7
	lda kg65.temp9
;	ora kg65.temp5
;	sta kg65.temp5
	tsb kg65.temp5
	lda kg65.temp9
;	ora kg65.temp8
;	sta kg65.temp8
	tsb kg65.temp8
	bra 10$

63$	iny
	cpy #2
	bcc 60$
	bcs 7$

	.page
70$				;1280x400  allocate 2 16k blocks in bank A & B per bitplane
	lda kg65.temp1
	pha
	lda kg65.temp2
	pha
	ldx #0
	stx kg65.temp9
	lda kg65.c.1280xhtbpp,y
	sta kg65.temp1

71$	lda kg65.c.640xhtebkp,x
	sta kg65.temp2
	and kg65.temp7
	beq 77$
	inx
	cpx #4
	bcc 71$
	bra 74$

76$	lda kg65.c.640xhtebkp,x
	taz
	and kg65.temp7
	beq 78$

77$	inx
	cpx #4
	bcc 76$
	bra 74$

78$	tza
;	ora kg65.temp2
;	sta kg65.temp2
	tsb kg65.temp2
	ldx #0

72$	lda kg65.c.640xhtobkp,x
;	pha
;	ora kg65.temp9
;	sta kg65.temp9
;	pla
	tsb kg65.temp9
	and kg65.temp8
	beq 79$
	inx
	cpx #4
	bcc 72$
	bra 74$

73$	lda kg65.c.640xhtobkp,x
	taz
	and kg65.temp8
	beq 75$

79$	inx
	cpx #4
	bcc 73$

74$	pla
	sta kg65.temp2
	pla
	sta kg65.temp1
	iny
	cpy #2
	bcc 70$
	bcs 7$

75$	tza
;	ora kg65.temp9
;	sta kg65.temp9
	tsb kg65.temp9
	pla
	pla
	bra 66$

	.page
5$				;preserve y & x
	lda kg65.temp2		;current block# bit mask
;	ora kg65.temp4		;screen bank A blocks used mask
;	sta kg65.temp4
	tsb kg65.temp4
	lda kg65.temp2
;	ora kg65.temp7
;	sta kg65.temp7
	tsb kg65.temp7
	bra 10$			;br around bitplane# odd logic

9$	lda kg65.temp2		;current block# bit mask
;	ora kg65.temp5		;screen bank B blocks used mask
;	sta kg65.temp5
	tsb kg65.temp5
	lda kg65.temp2
;	ora kg65.temp8
;	sta kg65.temp8
	tsb kg65.temp8

10$	lda kg65.temp1		;current bitplane# bit mask
;	ora kg65.temp3		;bitplanes used mask for screen
;	sta kg65.temp3
	tsb kg65.temp3
	iny			;next bitplane# index
	dec kg65.temp6		;screen depth counter
	bpl 6$			;go allocate a block for another bitplane

	ldx kg65.scrtabidx	;y & x free now
	lda kg65.scrtab,x
	ora #%01000000		;screen open bit set on
	sta kg65.scrtab,x
	lda kg65.temp3
	sta kg65.scrtab+1,x 	;save bitplanes used mask in screen table entry
	lda kg65.temp4
	sta kg65.scrtab+2,x 	;save bank a blocks used mask in screen table
;	ora kg65.bankablks
;	sta kg65.bankablks	;merge new blocks used into existing used mask
	tsb kg65.bankablks	;merge new blocks used into existing used mask
	lda kg65.temp5
	sta kg65.scrtab+3,x 	;save bank b blocks used mask in screen table
;	ora kg65.bankbblks
;	sta kg65.bankbblks	;merge new blocks used into existing used mask
	tsb kg65.bankbblks	;merge new blocks used into existing used mask
	clc			;no errors
	rts

	.page
;	DEALLOCATE SCREEN BITPLANES AND MEMORY
;
;	y = screen# 0-3
;
; for each bit in bank block# bit fields of screen reset global bit field
; reset screen entry bitplane, bank bit fields, mark screen closed.
;
; if closing drawscreen then make drawscreen=viewscreen
; if closing viewscreen then set viewscreen to text.
; if draw=view then set draw to text also

; error on invalid entry or screen already closed

kg65.s.deallocscr		;keep y as screen# in this subroutine
	ldx kg65.c.scridx,y
	stx kg65.scrtabidx
	lda kg65.scrtab,x
	bpl 1$			;not a valid entry
	and #%01000000
	bne 6$			;br if screen open

1$	sec
	rts


6$	lda kg65.scrtab+2,x 	;bank A blocks used bit mask
;	eor #%11111111		;invert bit pattern
;	and kg65.bankablks	;reset bits for bocks used
;	sta kg65.bankablks
	trb kg65.bankablks
	lda kg65.scrtab+3,x 	;bank B blocks used bit mask
;	eor #%11111111
;	and kg65.bankbblks
;	sta kg65.bankbblks
	trb kg65.bankbblks

	lda #0
	sta kg65.scrtab+1,x
	sta kg65.scrtab+2,x
	sta kg65.scrtab+3,x
	lda kg65.scrtab,x
	and #%10111111		;set screen closed bit off
	sta kg65.scrtab,x
	ldy kg65.scrtabidx	;current screen index
	cpy kg65.drawscreen
	bne 2$

	ldx #3
3$	lda kg65.viewscreen,x	;draw=view if closing draw screen
	sta kg65.drawscreen,x
	dex
	bpl 3$

2$	cpy kg65.viewscreen
	bne 4$			;br if not closing view, draw cannot = view
	lda kg65.viewscreen
	cmp kg65.drawscreen
	bne 5$			;br if closing view, draw not = view

; close drawscreen and set draw to text
; clear out draw screen parms
; currently 26 bytes

	lda #0
	ldx #7
8$	sta kg65.drawscreen,x
	sta kg65.dsbp0adr,x
	sta kg65.drawscrvpx,x
	dex
	bpl 8$
	sta kg65.drawscrinc
	sta kg65.drawscrinc+1
	stx kg65.drawscreen	;set drawscreen to not used

; close viewscreen and set view to text

5$	lda #0
	sta c65.l.bitplne

;	lda c65.l.vicntld						removed	[910930]
;	and #%01000000		;keep fast, turn everything else off
;	ora #%00100000		;add attribute
;;	sta kg65.temp1		;vic control reg. d work byte
;;	jsr c65.screenk		;get 40/80 mode (???? wrong basepage in context)
;;	asl a			;msb set if 80
;;	and #$80
;;	ora kg65.temp1
;;;	ora #%10000000		;add 80-col
;	sta c65.l.vicntld	;restore display to text
;;;	smb0 c65.l.xscroll	; (adjust x-scroll register)
;
;;	lda c65.l.vicntlc
;;	and #%11111011		;turn palette off
;;	sta c65.l.vicntld

	lda #0
	ldx #7
7$	sta c65.l.bp0addr,x	;zap all viewscreen bitplanes
	dex
	bpl 7$

	ldx #3
10$	sta kg65.viewscreen,x	;zap viewscreen params
	dex
	bpl 10$

;	sta c65.l.vickeyr	;old vic mode?
	stx kg65.viewscreen	;set viewscreen to not used ($ff)
	jsr CheckViewScreen_1	;get text screen			new	[910930]

4$	clc
	rts

	.page
; Expand screen# table entry data from bit packed byte to seperate bytes
; Input:	y = screen# 0-3
;
; Output:	y = screen index
;		a = width
;		x = height
;		z = depth
;
; Error on invalid entry

kg65.s.xpdscrdata
	ldx kg65.c.scridx,y 	;get screen entry offset based on screen# in x
	stx kg65.scrtabidx	;save index into screen table for latter use
	lda kg65.scrtab,x	;get screen size packed byte
	bpl 1$			;br if hi bit not set => not a valid entry

	sta kg65.subparm1	;keep value here during routine
	and #%00111000		;mask in only width & height bits
	sta kg65.subparm5

	lda kg65.subparm1	;restore original value to a
	and #%01000000		;mask in only open flag bit
	sta kg65.subparm4

	lda kg65.subparm1	;restore original value to a
	and #%00000111		;mask in only depth value
	sta kg65.subparm3
	taz			;depth

	lda kg65.subparm1	;restore original value to a
	and #%00001000		;mask in only height flag bit
	lsr a			;move bit 3 down to bit 0
	lsr a
	lsr a
	sta kg65.subparm2
	tax			;height

	lda kg65.subparm1	;restore original value to a
	and #%00110000		;mask in only width flag bits
	lsr a			;move bit 5 & 4 to bit 1 & 0
	lsr a
	lsr a
	lsr a
	sta kg65.subparm1	;width
	ldy kg65.scrtabidx	;screen index
	clc
	rts

; y = screen index into screen table
; a = subparm1	= width	 flag		bits 0,1  00=320 01=640 10=1280
; x = subparm2	= height flag		bit  0	   0=200  1=400
; z = subparm3	= depth value		0-7
; subparm4	= open flag		0=closed  64=open (bit 6 set)
; subparm5	=width & height value	00wwh000  ww=width flag	 h=height flag

1$	sec
	rts

;.end
	.page
	.subttl line

;created	: 08/14/89
;updated	: 11/12/90 (clipping)
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;

kg65.line_patr
	lda #0
	sta kg65.patrbitnum	;(kludge for patterns)				[911007]

	clc			;????
kg65.line
	tba
	pha
	lda #kg65.l.basepage
	tab

	ldx #7
10$	lda kg65.parm1,x
	sta kg65.linedata,x
	dex
	bpl 10$

	lda #0
	sta kg65.flag		;init for 1st entry (kg65.lineflag)
	sta kg65.doadr		;calculate screen address

	lda #<kg65.linedata
	sta kg65.bpptr1
	lda #kg65.l.basepage
	sta kg65.bpptr1+1
	bra 30$			;							[FAB]

20$	bsr kg65.s.plotdot	;draw the line
30$	bsr kg65.s.line
	bcc 20$

	pla
	tab
	clc
	rts

	.page
; Input: screen clipped x,y coords.  & lineflag of parm set = 0

kg65.s.line
;	ldx #22-1		;							[FAB]
;	ldz #22-1
;2$	lda (kg65.bpptr1),z	;move parms to working vars
;	sta kg65.linevars,x
;	dex
;	dez
;	bpl 2$			;(264 cycles)

	lda kg65.bpptr1		;source		low		Swap in working vars	[910507]
	sta c65.dma2_list+3
	lda kg65.bpptr1+1
	sta c65.dma2_list+4	;		high

	lda #kg65.linevars
	sta c65.dma2_list+6	;destination	low
	tba
	sta c65.dma2_list+7	;		high

	lda #22			;count
	sta c65.dma2_list+1
	lda #0
	sta c65.dma2_list	;copy commands
	sta c65.dma2_list+9	;						[910520] F018A
	sta c65.dma2_list+2
	sta c65.dma2_list+5	;banks
	sta c65.dma2_list+8
	sta c65.dma_ctlr+2	;dma list	bank
	lda #>c65.dma2_list	;		high
	sta c65.dma_ctlr+1
	lda #<c65.dma2_list	;		low & trigger
	sta c65.dma_ctlr	;(66uP + 44+10dma = 120 cycles)

;	bbs7 kg65.lineflag,1$	;test which entry,  br if not first			[FAB]
	bit kg65.lineflag
	bmi 1$			;
	smb7 kg65.lineflag	;set flag to not be first entry				"
;	inc kg65.lineflag
	lda kg65.linedoadr	;	(clip only if calculating addresses)		[910919] FAB
	bne 11$
	bsr kg65.clip		;							[901112]
	bcs 12$			;	can't calc address- point is offscreen		"
	bsr kg65.s.calcadr	;calc drawscreen address from x0,y0

11$	lda #0
	sta kg65.lineoctant	;init octant

	sec
	lda kg65.linex1		;calc ABS(dx)
	sbc kg65.linex0
	sta kg65.linedx
	lda kg65.linex1+1
	sbc kg65.linex0+1
	sta kg65.linedx+1
	bpl 3$			;							[FAB]
	clc			;dx=-dx							[FAB]
	lda kg65.linedx
	eor #255
	adc #1			;							[FAB]
	sta kg65.linedx
	lda kg65.linedx+1
	eor #255
	adc #0
	sta kg65.linedx+1
;	lda #2			;octant
	smb1 kg65.lineoctant

3$	sec			;calc ABS(dy)
	lda kg65.liney1
	sbc kg65.liney0
	sta kg65.linedy
	lda kg65.liney1+1
	sbc kg65.liney0+1
	sta kg65.linedy+1
	bpl 4$

	clc			;							[FAB]
	lda kg65.linedy		;dy=-dy
	eor #255
	adc #1
	sta kg65.linedy
	lda kg65.linedy+1
	eor #255
	adc #0
	sta kg65.linedy+1
;	clc
;	lda kg65.lineoctant
;	ora #4			;							[FAB]
	smb2 kg65.lineoctant

4$	ldx kg65.linedx
	cpx kg65.linedy
	lda kg65.linedx+1
	tay
	sbc kg65.linedy+1
	bpl 5$			;br if dx-dy > 0  (dx is greater)

	lda kg65.linedy		;swap dx & dy
	sta kg65.linedx
	lda kg65.linedy+1
	sta kg65.linedx+1
	stx kg65.linedy
	sty kg65.linedy+1
;	clc
;	lda kg65.lineoctant
;	ora #8			;							[FAB]
	smb3 kg65.lineoctant

5$	clc			;							[FAB]
	lda kg65.linedx		;e=-dx/2
	eor #255
	adc #1			;							[FAB]
	sta kg65.lineerrfac
	lda kg65.linedx+1
	eor #255
	adc #0
	asr a			;							[FAB]
	sta kg65.lineerrfac+1	;							[FAB]
	ror kg65.lineerrfac	;/2

	ldy #255		;init endpt						[FAB]
	sty kg65.lineendpt
	sty kg65.lineendpt+1
;	bcc 12$			;round up?						[910506]
	clc
;	bit #$80		;							[910506]
;	bmi 12$
;	inw kg65.linedx		;							[FAB]

12$	php			;							[901112]
	bra 8$

	.page
1$				;next line point
	clc
	ldx kg65.lineoctant
	lda kg65.lineerrfac	;e=e+dy
	adc kg65.linedy
	sta kg65.lineerrfac
	lda kg65.lineerrfac+1
	adc kg65.linedy+1
	sta kg65.lineerrfac+1
;	bcc 10$
	bmi 10$			;							[FAB]
	sec
	lda kg65.lineerrfac	;e=e-dx
	sbc kg65.linedx
	sta kg65.lineerrfac
	lda kg65.lineerrfac+1
	sbc kg65.linedx+1
	sta kg65.lineerrfac+1
	inx			;++octant

10$				;perform proper octant routine
;	lda kg65.c.octabh,x
;	pha
;	lda kg65.c.octabl,x
;	pha
;	rts
;	lda #>7$		;setup return address
;	pha
;	lda #<7$
;	pha
	txa			;make octant a word pointer				[FAB]
	asl a
	tax
	jsr (kg65.c.octable,x)	;go draw

7$
;	clc			;not executed  this is make the rts to here work
	inw kg65.lineendpt	;++endpt
	lda kg65.lineendpt
	cmp kg65.linedx
	lda kg65.lineendpt+1
	sbc kg65.linedx+1
	php

8$
;	ldx #22-1		;move vars to parms
;	ldz #22-1
;9$	lda kg65.linevars,x
;	sta (kg65.bpptr1),z
;	dex
;	dez
;	bpl 9$

	lda kg65.bpptr1		;source		low		Swap out working vars	[910507]
	sta c65.dma2_list+6
	lda kg65.bpptr1+1
	sta c65.dma2_list+7	;		high

	lda #kg65.linevars
	sta c65.dma2_list+3	;destination	low
	tba
	sta c65.dma2_list+4	;		high

	lda #<c65.dma2_list	;dma list low & trigger
	sta c65.dma_ctlr

	plp			;carry set when done
	rts

	.page
kg65.s.lftdwn
;	clc			;not executed  this is make the rts to here work
	bsr kg65.s.left
kg65.s.down			;y=y+1
;	clc			;this is make the rts to here work
	inw kg65.liney0
	lda kg65.drawscrheight	;test if in 400 interlace mode
	beq 2$			;br if no
	lda kg65.liney0		;test if scanline odd or even
	and #%00000001

2$	sta kg65.scanlineflag	;0=even 1=odd  if 200 mode then always 0
	bne 1$			;don't inc addr. if on odd interlace scanline
	lda kg65.linedoadr
	bne 1$
	inw kg65.linedsadr
	lda kg65.linedsadr
	and #%00000111
	bne 1$
	clc
	lda kg65.linedsadr
	adc kg65.drawscrinc
	sta kg65.linedsadr
	lda kg65.linedsadr+1
	adc kg65.drawscrinc+1
	sta kg65.linedsadr+1
1$	rts


kg65.s.uprght
;	clc			;not executed  this is make the rts to here work
	bsr kg65.s.right
kg65.s.up			;y=y-1
;	clc			;this is make the rts to here work
	dew kg65.liney0
	lda kg65.drawscrheight	;test if in 400 interlace mode
	beq 2$			;br if no
	lda kg65.liney0		;test if scanline odd or even
	and #%00000001
	sta kg65.scanlineflag	;0=even 1=odd  if 200 mode then always 0
	beq 1$			;don't dec addr. if on odd interlace scanline

2$	sta kg65.scanlineflag
	lda kg65.linedoadr
	bne 1$
	dew kg65.linedsadr
;	lda kg65.linedsadr	;br to rts if linedsadr = 0			[910506]
;	bne 3$
;	lda kg65.linedsadr+1
	beq 1$

3$	lda kg65.linedsadr
	and #%00000111
	cmp #%00000111
	bne 1$
	sec
	lda kg65.linedsadr
	sbc kg65.drawscrinc
	sta kg65.linedsadr
	lda kg65.linedsadr+1
	sbc kg65.drawscrinc+1
	sta kg65.linedsadr+1
1$	rts

	.page
kg65.s.upleft
;	clc			;not executed  this is make the rts to here work
;	bsr kg65.s.up
	bsr kg65.s.left		;for symmetry						[FAB]
	bra kg65.s.up

kg65.s.left			;x=x-1
;	clc			;this is make the rts to here work
	dew kg65.linex0
	lda kg65.linedoadr
	bne 1$
	asl kg65.linemask
	bcc 1$
	rol kg65.linemask
	sec
	lda kg65.linedsadr
	sbc #8
	sta kg65.linedsadr
	bcs 1$
	dec kg65.linedsadr+1
1$	rts


kg65.s.downrt
;	clc			;not executed  this is make the rts to here work
;	bsr kg65.s.down
	bsr kg65.s.right	;for symmetry						[FAB]
	bra kg65.s.down

kg65.s.right			;x=x+1
;	clc			;this is make the rts to here work
	inw kg65.linex0
	lda kg65.linedoadr
	bne 1$
	lsr kg65.linemask
	bcc 1$
	ror kg65.linemask
	clc
	lda kg65.linedsadr
	adc #8
	sta kg65.linedsadr
	bcc 1$
	inc kg65.linedsadr+1
1$	rts

;.end
	.page
	.subttl plotdot

;created	: 08/15/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom

kg65.s.plotdot
	lda #0
	sta kg65.temp4		;bitplane #		removed 1280 stuff	[910711]
	sta kg65.datflag	;reset DAT flag
	inc a
	sta kg65.temp3		;bitplane bit code
	sta kg65.temp5		;init to bit on

	bbr3 kg65.drawmode,10$	;branch if not plotting patterns		[911028]
;	lda kg65.drawmode 	;determine style
;	beq 4$			;	solid,jam0,nothing special
;	and #%00011000
;	cmp #%00001000		;	pattern?
;	bne 4$			;		br if no & assume solid

	lda kg65.patrbitnum	;	0-7 scale
	and #%00000111
	tax
	lda kg65.c.bitsdn,x
	sta kg65.temp5		;	bit# of byte for pattern
	lda kg65.patrbitnum	;		0-31
	lsr a
	lsr a			;		/8 -> 0-3
	lsr a
	tax			;	byte# of pattern
	lda kg65.dpattern,x
	and kg65.temp5
	sta kg65.temp5		;	set temp5 with bit on/off
	inc kg65.patrbitnum
	lda kg65.dpatype
	and #%00000011
	tax
	lda kg65.patrbitnum	;	done all pattern bits?
	cmp kg65.c.patrbits,x
	bne 10$			;		br if no
	lda #0
	sta kg65.patrbitnum	;		else reset to beginning

	.page
10$	lda kg65.drawscrbp	;is bitplane used in screen?	completely rewritten	[911028] FAB
	and kg65.temp3
	beq 200$		;	br if no

	ldx kg65.temp4		;bitplane #
	bsr kg65.s.readdsbyte	;read byte from draw screen for current bitplane

	lda kg65.drawmode	;Any drawmodes?
	and #7
	beq 100$		;	no
	lda kg65.drawscrpen1	;	is this bitplane used by drawpen?
	and kg65.temp3
	beq 200$		;		no
	bbr1 kg65.drawmode,20$	;	XOR mode
	bbr3 kg65.drawmode,15$	;		pattern?
	lda kg65.temp5		;			yes-
	beq 200$		;			skip- nothing to plot
15$	lda kg65.drawscrbyte
	eor kg65.mask		;		ignore JAM modes, etc.
	bra 130$

20$	bbr0 kg65.drawmode,100$	;	JAM2 mode
	lda kg65.temp5
	bne 105$		;		skip- not background
	lda kg65.drawscrpen2	;		and use background color
	bra 110$

100$	lda kg65.temp5		;anything to plotting?
	beq 200$		;	no

105$	lda kg65.drawscrpen1	;plot the dot
110$	and kg65.temp3		;ia bitplane used in color index?
	bne 120$		;	yes

	lda kg65.mask		;		bit off
	eor #$ff
	and kg65.drawscrbyte
	bra 130$

120$	lda kg65.drawscrbyte	;		bit on
	ora kg65.mask

130$	sta kg65.drawscrbyte
	ldx kg65.temp4		;bitplane #
	bsr kg65.s.writedsbyte	;write byte to draw screen for current bitplane

200$	inc kg65.temp4		;next bitplane#
	asl kg65.temp3		;next bitplane bit code
	bcc 10$			;loop until all 8 bitplanes checked

	rmb7 kg65.datflag	;							[910506] ????
	rts

	.page
;	and #%00011000		;???? removed- too complicated, slow, and buggy		[911028] FAB
;	cmp #%00001000		;pattern?
;	beq 12$			;	br if yes
;	lda kg65.drawmode
;	and #%00000010		;complement?
;	bne 10$			;	br if yes
;	lda kg65.drawmode
;	and #%00000001		;jam2?
;	bne 8$			;	br if yes
;
;7$	lda kg65.temp5
;	bne 5$			;br if bit on
;	beq 1$			;br if bit off
;
;
;8$	lda kg65.temp5		;jam2 mode
;	bne 5$
;	lda kg65.drawscrpen2	;if off use 2nd color
;	bra 9$
;				;do complement
;10$	lda kg65.drawmode 	;reverse effect of jam mode
;	and #%00000001		;jam1
;	bne 11$
;	lda kg65.temp5
;	beq 5$
;	bne 1$
;
;11$	lda kg65.temp5
;	beq 5$
;	lda kg65.drawscrpen2
;	bra 9$
;
;12$	lda kg65.drawmode	;do pattern
;	and #%00000010
;	beq 7$			;br if no complement	(was 5$)		[911003] FAB
;	lda kg65.drawscrbyte	;complement draw mode
;	and kg65.mask
;	bne 2$
;	beq 6$
;
;5$	lda kg65.drawscrpen1	;bitplane used in color index
;9$	and kg65.temp3
;	beq 2$			;br if no
;
;6$	lda kg65.mask		;turn bit on
;	ora kg65.drawscrbyte
;	bra 3$
;
;2$	lda kg65.mask		;turn bit off
;	eor #255
;	and kg65.drawscrbyte
;
;3$	sta kg65.drawscrbyte
;	ldx kg65.temp4
;	bsr kg65.s.writedsbyte	;write byte to draw screen for current bitplane
;1$
;;	lda mode1280flag	;						[910517]
;;	beq 101$
;;	inc kg65.temp4		;next bitplane#
;;	asl kg65.temp3		;next bitplane bit code
;
;101$	inc kg65.temp4		;next bitplane#
;	asl kg65.temp3		;next bitplane bit code
;	bcc 4$			;br until all 8 bitplanes checked
;
;	rmb7 kg65.datflag	;						[910506] ????
;	rts

;.end
	.page
	.subttl subs

;created	: 08/14/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;


;calc draw screen address based on x,y
;adr = (drawscrcols * (y and %11111000)) + (y and %00000111)
;	+ (x and %11111000) + hi byt of x
; input: linex0,y0
; output: linedsadr,linemask -> x bit within column byte

;if 640 wide then multiply linedsadr by 2
;if 400 high then y=y/2
;if interlaced then set scanline flag to odd or even, else set to even


kg65.s.calcadr			;be careful with temp vars
	lda kg65.liney0
	sta kg65.temp1
	lda kg65.drawscrheight
	beq 2$			;br if 200 also scanline flag set to even
	lda kg65.liney0+1
	lsr a			;if interlaced then y=y/2
	ror kg65.temp1
	lda kg65.liney0
	and #%00000001		;set odd or even scanline# flag

2$	sta kg65.scanlineflag	;0=even 1=odd
	lda kg65.temp1
	tay
	and #%00000111		;scanline within row
	sta kg65.temp1
	tya			; row/8
	lsr a			; to act as index into multiplication table of
	lsr a			; row start addresses.
	lsr a			; table is in mults of 320
	tay
	clc
	lda kg65.c.width1hi,y
	sta kg65.linedsadr+1
	lda kg65.c.width1lo,y
	sta kg65.linedsadr

	lda kg65.drawscrwidth
	beq 3$			;br if 320
	asl kg65.linedsadr	;else draw screen addr * 2
	rol kg65.linedsadr+1

3$	lda kg65.linex0
	tax			;save a
	and #%00000111		;bit within column byte
	tay
	lda kg65.c.bitsdn,y	;bit within column byte mask
	sta kg65.linemask
	txa
	and #%11111000		;round down to column boundary
	clc
	adc kg65.temp1		; + scanline within row
	clc
	adc kg65.linedsadr	; add into draw screen address
	sta kg65.linedsadr
	lda kg65.linedsadr+1
	adc kg65.linex0+1
	sta kg65.linedsadr+1
	rts

	.page
; Input:	.x=bitplane#  dsadr, scanline-flag set
; Output:	drawscrbyte
;
; If odd bitplane# then map in bank B  else bank A
;
; Use kg65.linex0,liney0 for DAT; should only do this once to get all bitplanes


kg65.s.readdsbyte
kg65.s.readdsbyte.nodat = 1$
	bbr7 DAT_enable,1$	;branch if DAT disabled				[910612]
	bbs7 kg65.datflag,70$	;branch if subsequent DAT access		[910506]
	  lda kg65.banka
	  bne 1$
	  lda kg65.drawscreen							[910506] ????
	  cmp kg65.viewscreen
	  beq 40$		;br if draw screen is visible

1$	bbr0 kg65.scanlineflag,10$
	lda kg65.dsbp0adr,x	;odd scanline
	and #%11100000		;	keep only odd hi 3 bits of blk addr
	bra 20$

10$	lda kg65.dsbp0adr,x	;even scanline
	and #%00001110		;	keep only even hi 3 bits of blk addr
	asl a
	asl a
	asl a
	asl a			;make into real hi byte addr

20$	clc
	adc kg65.dsadr+1 	;calc. actual address from logical draw screen addr
	sta kg65.temp2
	lda kg65.dsadr
	sta kg65.temp1

;	phx
;	phy
	txa			;bitplane#
	and #%00000001		;determine if even=0 or odd=1  this is also logical bank#
	taz			;bank#
;	ldx #<kg65.temp1	;vector ptr.
;	ldy #0			;index
;	bsr c65.indfet		;lda (kg65.temp1),y from bank z
	bsr lda_temp1
	sta kg65.drawscrbyte
;	ply
;	plx

;		ldz #0
;		lda (kg65.temp1),z	;read byte from memory
;		sta kg65.drawscrbyte
	rts

	.page
; Test flag for subsequent entry if yes then goto 70$
;
40$				;							[910506] ????
;	bbs7 kg65.datflag,70$	;0=do initial read else subsequent			[FAB]
;;	bne 70$
;;	lda #255		;set flag that initial access is done
	smb7 kg65.datflag	;							[FAB]

;	phx			;save x because it is used in divby8 routine
;	lda kg65.linex0+1
;	ldy kg65.linex0
;	bsr kg65.s.divby8	;get column #
;	plx
	lda kg65.linex0+1	;					faster /8	[910506]
	asl a
	asl a
	asl a
	asl a
	asl a
	sta kg65.tmp
	lda kg65.linex0
	lsr a
	lsr a
	lsr a
	ora kg65.tmp
	tay

	lda kg65.liney0+1	;y=col#, x=bitplane#
;;	and #%00000001		;							[FAB]
	beq 60$			;br i y<256
	tya
	ora #%10000000		;set y hi bit in bpx reg
	tay
;;	bra 60$
;;
;;50$	tya
;;	and #%01111111		;ensure hi bit is not on

60$	sty c65.l.bpxcord
	lda kg65.liney0
	sta c65.l.bpycrdl
	jsr 80$			;delay							[FAB]

70$	lda c65.l.bp0pixd,x
	sta kg65.drawscrbyte
80$	rts			;							[FAB]

;;** externally the flag must be reset (plotdot type routine probably)

	.page
; Input:	x=bitplane#  dsadr, scanline-flag, drawscrbyte set
;
; Use kg65.linex0,liney0 for DAT; should only do this once to get all bitplanes

kg65.s.writedsbyte
kg65.s.writedsbyte.nodat = 1$
	bbs7 kg65.datflag,70$	;branch if subsequent DAT access		[910506]
	bbr7 DAT_enable,1$	;branch if DAT disabled				[910612]
	  lda kg65.banka
	  bne 1$
	  lda kg65.drawscreen	;							[910506] ????
	  cmp kg65.viewscreen
	  beq 40$		;br if draw screen is visible

1$	lda kg65.scanlineflag
	beq 10$			;br if even scanline#
	lda kg65.dsbp0adr,x
	and #%11100000		;keep only odd hi 3 bits of blk addr
	bra 20$

10$	lda kg65.dsbp0adr,x
	and #%00001110		;keep only even hi 3 bits of blk addr
	asl a
	asl a
	asl a
	asl a			;make into real hi byte addr

20$	clc
	adc kg65.dsadr+1 	;calc. actual address from logical draw screen addr
	sta kg65.temp2
	lda kg65.dsadr
	sta kg65.temp1

;	phy
;	phx
	txa			;bitplane#
	and #%00000001		;determine if even=0 or odd=1  this is also logical bank#
	taz			;bank#
;	ldx #<kg65.temp1	;vector ptr.
;	ldy #0			;index
	lda kg65.drawscrbyte
	bra sta_temp1		;							[FAB]

;	bsr c65.indsta		;sta (kg65.temp1),y to bank z
;	ply
;	plx

;;	lda kg65.drawscrbyte
;;	ldz #0
;;	sta (kg65.temp1),z	;write bte to memory
;;	rts			;							[FAB]

	.page
;; Test flag for subsequent entry if yes then goto 70$

40$
;	bbs7 kg65.datflag,70$	;0=do initial write else subsequent			[910506] ????
;;	bne 70$
;;	lda #255		;set flag that initial access is done
	smb7 kg65.datflag	;							[FAB]

;	phx			;save x because it is used in divby8 routine
;	lda kg65.linex0+1
;	ldy kg65.linex0
;	bsr kg65.s.divby8	;y=col#
;	plx			;restore x to bitplane# value
	lda kg65.linex0+1	;					faster /8	[910506]
	asl a
	asl a
	asl a
	asl a
	asl a
	sta kg65.tmp
	lda kg65.linex0
	lsr a
	lsr a
	lsr a
	ora kg65.tmp
	tay

	lda kg65.liney0+1
;;	and #%00000001
	beq 60$			;br i y<256
	tya
	ora #%10000000		;set y hi bit in bpx reg
	tay
;;	bra 60$
;;50$
;;	tya
;;	and #%01111111		;ensure hi bit is not on

60$	sty c65.l.bpxcord
	lda kg65.liney0
	sta c65.l.bpycrdl
	jsr 80$			;delay							[FAB]

70$	lda kg65.drawscrbyte
	sta c65.l.bp0pixd,x
80$	rts

;;** externally the flag must be reset (plotdot type routine probably)

	.page
;	.a = 1st val x/y is lo/hi 2nd val
;	returns answer in x/y

kg65.s.mulply
	sta kg65.temp1
	stx kg65.temp2		;store
	sty kg65.temp3
	ldx #0
	stx kg65.temp4		;initialize
	stx kg65.temp5
;	and #1			;check for 1
;	beq 1$
	lsr a			;							[FAB]
	bcc 1$
	sty kg65.temp5		;one time
	ldx kg65.temp2
	stx kg65.temp4

1$	lda #$80
	sta kg65.temp6		;initialize

2$	and kg65.temp1
	beq 4$			;2 multiply
	ldx kg65.temp2
	ldy kg65.temp3
	stx kg65.temp7		;initialize
	sty kg65.temp7+1

3$	asl kg65.temp7
	rol kg65.temp7+1	;times 2
	lsr a			;count down
	cmp #1
	bne 3$

	clc
	lda kg65.temp7		;add sub total
	adc kg65.temp4
	sta kg65.temp4
	lda kg65.temp7+1
	adc kg65.temp5
	sta kg65.temp5

4$	lsr kg65.temp6		;decrement
	lda kg65.temp6
	cmp #1			;check end
	bne 2$

	ldx kg65.temp4		;get result
	ldy kg65.temp5
	rts			;complete

	.page
; 16bit * 16bit = 32 bit
; Input:	a=lo z=hi    x=lo y=hi
; Output	x=lo y=hi1 a=hi2 z=hi3

; kg65.temp1,2		mult1
; kg65.temp3,4		mult2
; kg65.temp5		multiplier temp for compare w/power of 2 in temp10,11
; kg65.temp6,7,8,9	answer
; kg65.temp10,11	power of 2 bit# 15 -> 0
; kg65.temp12,13,14,15	temp 32bit answer
; kg65.temp16,17	count down for power of 2 multiplier

kg65.s.mulply32
	sta kg65.temp1
	stz kg65.temp2
	stx kg65.temp3
	sty kg65.temp4

	lda #0
	sta kg65.temp10
	sta kg65.temp6
	sta kg65.temp7
	sta kg65.temp8
	sta kg65.temp9
	lda kg65.temp1		;check for 0 in one of the multipliers
	bne 7$
	lda kg65.temp2
	beq 5$

7$	lda kg65.temp3
	bne 6$
	lda kg65.temp4
	beq 5$

6$	lda kg65.temp2
	sta kg65.temp5
;	lda kg65.temp1
;	and #1
;	beq 1$
	bbr0 kg65.temp1,1$	;							[FAB]
	lda kg65.temp3
	sta kg65.temp6
	lda kg65.temp4
	sta kg65.temp7

1$	lda #128
	sta kg65.temp11

2$	and kg65.temp5
	beq 4$
	lda kg65.temp10
	sta kg65.temp16
	lda kg65.temp11
	sta kg65.temp17
	ldx #0
	stx kg65.temp14
	stx kg65.temp15
	ldx kg65.temp3
	stx kg65.temp12
	ldx kg65.temp4
	stx kg65.temp13

3$	asl kg65.temp12
	rol kg65.temp13
	rol kg65.temp14
	rol kg65.temp15
	lsr kg65.temp17
	ror kg65.temp16
	lda kg65.temp17
	bne 3$
	lda kg65.temp16
	cmp #1
	bne 3$

	clc
	lda kg65.temp12
	adc kg65.temp6
	sta kg65.temp6
	lda kg65.temp13
	adc kg65.temp7
	sta kg65.temp7
	lda kg65.temp14
	adc kg65.temp8
	sta kg65.temp8
	lda kg65.temp15
	adc kg65.temp9
	sta kg65.temp9

4$	lsr kg65.temp11
	ror kg65.temp10
	lda kg65.temp11
	bne 2$
	lda kg65.temp1
	sta kg65.temp5
	lda kg65.temp10
	cmp #1
	bne 2$

5$	ldx kg65.temp6
	ldy kg65.temp7
	lda kg65.temp9
	taz
;	ldz kg65.temp9		;No LDZ basepage!					[FAB]
	lda kg65.temp8
	clc
	rts

	.page
kg65.s.divby8			;don't use temp vars in this routine

	ldx #3			;divide by 2  3 times =>  2^3 = 8


kg65.s.divby2			;y=lo a=hi  x=# of times to divide by 2

	sty kg65.tmp		;subparm1
1$	lsr a
	ror kg65.tmp		;subparm1
	dex
	bne 1$

	ldy kg65.tmp		;subparm1
	rts			;y=lo a=hi

	.page
;z-page divide	16bit / 8bit
;  30 2*15 bytes for compar macro
; 146 total bytes used
;
; Prepare:
;	x,y	hold the dividend
;	a	holds divisor
; Returns:
;	x,y	is unknown divisor
;	a	holds remainer
;
; Idea:
;	enter p1 known product
;	dv divisor
;	set p2	(unknown product)=0
;	temp(temp quotient)  =256*p1
;	pt (current quotient)=256
; More:
;	if dv>=temp
;	 dv=dv-temp
;	 p2=p2+pt
;	 endif
;	temp=temp/2
;	pt=pt/2
;	if pt <> 0 go more
;	if dv>=p1
;	 dv=dv-p1
;	 p2=p2+1
; Return:
;	dv = remainder
;	p2 is solved product


kg65.s.divide
	stx kg65.temp7		;store inputs
	sty kg65.temp8		;dividend hi
	sta kg65.temp9		;product one
	sta kg65.temp4		;p1 * 256

	ldx #0			;initialize
	stx kg65.temp1		;products
	stx kg65.temp2
	stx kg65.temp3		;p1*256 low
	stx kg65.temp5		;temp quotient
	inx
	stx kg65.temp6		;temp set to 256

1$	lda kg65.temp8		;remainder of
	cmp kg65.temp4		;dividend
	bcc 3$			;no skip over
	bne 2$			;yes temp<div
	lda kg65.temp7		;check low byte
	cmp kg65.temp3
	bcc 3$			;br to small

2$	lda kg65.temp7		;subtract temp from
	sbc kg65.temp3		;dividend
	sta kg65.temp7
	lda kg65.temp8
	sbc kg65.temp4
	sta kg65.temp8

	lda kg65.temp5		;add current quotient
	clc			;to product2
	adc kg65.temp1
	sta kg65.temp1
	lda kg65.temp6		;test more the same
	adc kg65.temp2		;quotient
	sta kg65.temp2
	bra 1$

3$	lsr kg65.temp4		;divide temp&pt
	ror kg65.temp3		;by 2
	lsr kg65.temp6
	ror kg65.temp5		;by two
;	lda kg65.temp5		;check more
	bne 1$			;factors

	lda kg65.temp7
	cmp kg65.temp9
	bcc 5$			;br to big
;	inc kg65.temp1		;1 more product
;	bne 4$
;	inc kg65.temp2
	inw kg65.temp1		;							[910923]
4$	lda kg65.temp7		;.c is set
	sbc kg65.temp9		;in 'a'
;	sta kg65.temp7

5$
;	lda kg65.temp7		;							[FAB]
	ldx kg65.temp1
	ldy kg65.temp2
	rts


;.end
	.page
	.subttl kg65.clip

;created	: 06/03/86
;updated	: 10/10/90 (installed 901112 FAB)
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace,  Walrus Software Inc.
;application	: C65 Kernel Graphics ROM
;remarks	: Clipping of points to be inside a window
;

kg65.clip					;		save code & speedup	[910715]
	tba
	pha
	lda #kg65.l.basepage
	tab

	ldx #3
90$	lda kg65.drawscrvpdx,x			;copy viewport def into working vars
	sta kg65.l.clipvars*256+kg65.maxx,x
	dex
	bpl 90$

	lda #kg65.l.clipvars			;					[910919]
	tab

	dew kg65.l.clipvars*256+kg65.maxx	;want max x, not max+1 viewport definition
;	lda kg65.l.clipvars*256+kg65.maxx
;	bne 92$
;	dec kg65.l.clipvars*256+kg65.maxx+1
;92$	dec kg65.l.clipvars*256+kg65.maxx

	dew kg65.l.clipvars*256+kg65.maxy	;want max y, not max+1 viewport definition
;	lda kg65.l.clipvars*256+kg65.maxy
;	bne 93$
;	dec kg65.l.clipvars*256+kg65.maxy+1
;93$	dec kg65.l.clipvars*256+kg65.maxy


91$	lda #kg65.l.basepage			;					[910919]
	tab
	lda #0					;init to 0
	sta kg65.l.clipvars*256+kg65.clipflag0
	sta kg65.l.clipvars*256+kg65.clipflag1

;	bbs7 kg65.liney0+1,1$			;----- Y -----------------------------------------
;	bit kg65.liney0+1
;	bmi 1$					;br if y0<0
	lda kg65.liney0
	cmp kg65.drawscrvpdy
	lda kg65.liney0+1
	bmi 1$					;br if y0<0
	sbc kg65.drawscrvpdy+1
	bcc 2$					;br if y0 <= drawscrvpdy
;	lda kg65.l.clipvars*256+kg65.clipflag0
;	ora #8					;y0>drawscrvpdy bit set
;	sta kg65.l.clipvars*256+kg65.clipflag0
;	bra 2$					;forced br
	lda #8
	   .byte $2c
1$
;	lda kg65.l.clipvars*256+kg65.clipflag0	;y0<0 bit set
;	ora #2
;	sta kg65.l.clipvars*256+kg65.clipflag0
	lda #2
	tsb kg65.l.clipvars*256+kg65.clipflag0

2$
;	bbs7 kg65.linex0+1,3$			;----- X -----------------------------------------
;	bit kg65.linex0+1
;	bmi 3$					;br if x0<0
	lda kg65.linex0
	cmp kg65.drawscrvpdx
	lda kg65.linex0+1
	bmi 3$
	sbc kg65.drawscrvpdx+1
	bcc 4$					;br if x0 <= drawscrvpdx
;	lda kg65.l.clipvars*256+kg65.clipflag0
;	ora #4					;x0 > drawscrvpdx bit set
;	sta kg65.l.clipvars*256+kg65.clipflag0
;	bra 4$
	lda #4
	   .byte $2c
3$
;	lda kg65.l.clipvars*256+kg65.clipflag0	;x0<0 bit set
;	ora #1
;	sta kg65.l.clipvars*256+kg65.clipflag0
	lda #1
	tsb kg65.l.clipvars*256+kg65.clipflag0

4$
;	bbs7 kg65.liney1+1,11$
;	bit kg65.liney1+1
;	bmi 11$
	lda kg65.liney1				;same checks as pt 0
	cmp kg65.drawscrvpdy
	lda kg65.liney1+1
	bmi 11$
	sbc kg65.drawscrvpdy+1
	bcc 21$
;	lda kg65.l.clipvars*256+kg65.clipflag1
;	ora #8
;	sta kg65.l.clipvars*256+kg65.clipflag1
;	bra 21$
	lda #8
	   .byte $2c
11$
;	lda kg65.l.clipvars*256+kg65.clipflag1
;	ora #2
;	sta kg65.l.clipvars*256+kg65.clipflag1
	lda #2
	tsb kg65.l.clipvars*256+kg65.clipflag1

21$
;	bbs7 kg65.linex1+1,31$
;	bit kg65.linex1+1
;	bmi 31$
	lda kg65.linex1
	cmp kg65.drawscrvpdx
	lda kg65.linex1+1
	bmi 31$
	sbc kg65.drawscrvpdx+1
	bcc 41$
;	lda kg65.l.clipvars*256+kg65.clipflag1
;	ora #4
;	sta kg65.l.clipvars*256+kg65.clipflag1
;	bra 41$
	lda #4
	   .byte $2c
31$
;	lda kg65.l.clipvars*256+kg65.clipflag1
;	ora #1
;	sta kg65.l.clipvars*256+kg65.clipflag1
	lda #1
	tsb kg65.l.clipvars*256+kg65.clipflag1

41$	lda kg65.l.clipvars*256+kg65.clipflag0
	and kg65.l.clipvars*256+kg65.clipflag1
	beq 5$					;if both anded = 0 then br
	pla
	tab
	sec
	rts					;else out of bounds status bad


5$	bsr kg65.calconst			;calc constants
	lda kg65.l.clipvars*256+kg65.clipflag0
	bne 7$
	lda kg65.l.clipvars*256+kg65.clipflag1
	bne 6$
	pla
	tab
	clc					;if both = 0 then in bounds status okay
	rts


6$	bsr kg65.clip1				;code0=0 and code1 <> 0
	bra 91$

7$	bsr kg65.clip0				;code1=0 and code0 <> 0
	bra 91$					;both <> 0 but on different sides



kg65.clip0
	lda kg65.l.clipvars*256+kg65.clipflag0
	ldy #3
	bsr kg65.clip01				;clip pt 0

	ldx #3
1$	lda kg65.l.clipvars*256+kg65.xclip,x
	sta kg65.linex0,x
	dex
	bpl 1$
	rts


kg65.clip1
	lda kg65.l.clipvars*256+kg65.clipflag1
	ldy #7
	bsr kg65.clip01				;clip pt 1

	ldx #3
1$	lda kg65.l.clipvars*256+kg65.xclip,x
	sta kg65.linex1,x
	dex
	bpl 1$
	rts


kg65.clip01
	sta kg65.l.clipvars*256+kg65.clipcode
	ldx #3
11$
;	lda kg65.linex0,y			;no LDA bp,y				[910212]
	lda kg65.l.basepage*256+kg65.linex0,y
	sta kg65.l.clipvars*256+kg65.xclip,x
	dey
	dex
	bpl 11$
	lda kg65.l.clipvars*256+kg65.clipcode
	and #8
	beq 1$
	lda kg65.l.clipvars*256+kg65.my+1
	ldy kg65.l.clipvars*256+kg65.my
	bsr kg65.calcx0				;x=x+ dx/dy * my
	sty kg65.l.clipvars*256+kg65.xclip
	sta kg65.l.clipvars*256+kg65.xclip+1
	lda kg65.l.clipvars*256+kg65.maxy
	sta kg65.l.clipvars*256+kg65.yclip	;y=maxy
	lda kg65.l.clipvars*256+kg65.maxy+1
	sta kg65.l.clipvars*256+kg65.yclip+1
	rts

1$	lda kg65.l.clipvars*256+kg65.clipcode
	and #2
	beq 2$
	lda kg65.l.clipvars*256+kg65.ny+1
	ldy kg65.l.clipvars*256+kg65.ny
	bsr kg65.calcx0				;x=x+ dx/dy * ny
	sty kg65.l.clipvars*256+kg65.xclip
	sta kg65.l.clipvars*256+kg65.xclip+1
	stx kg65.l.clipvars*256+kg65.yclip	;y=0   (miny)
	stx kg65.l.clipvars*256+kg65.yclip+1
	rts

2$	lda kg65.l.clipvars*256+kg65.clipcode
	and #4
	beq 3$
	lda kg65.l.clipvars*256+kg65.mx+1
	ldy kg65.l.clipvars*256+kg65.mx
	bsr kg65.calcy0				;y=y+ dy/dx * mx
	sty kg65.l.clipvars*256+kg65.yclip
	sta kg65.l.clipvars*256+kg65.yclip+1
	lda kg65.l.clipvars*256+kg65.maxx
	sta kg65.l.clipvars*256+kg65.xclip	;x=maxx
	lda kg65.l.clipvars*256+kg65.maxx+1
	sta kg65.l.clipvars*256+kg65.xclip+1
	rts

3$	lda kg65.l.clipvars*256+kg65.clipcode
	and #1
	beq 4$
	lda kg65.l.clipvars*256+kg65.nx+1
	ldy kg65.l.clipvars*256+kg65.nx
	bsr kg65.calcy0				;y=y+ dy/dx * nx
	sty kg65.l.clipvars*256+kg65.yclip
	sta kg65.l.clipvars*256+kg65.yclip+1
	stx kg65.l.clipvars*256+kg65.xclip	;x=0  (minx)
	stx kg65.l.clipvars*256+kg65.xclip+1
4$	rts


kg65.calcdxdy
	sec
	lda kg65.linex1
	sbc kg65.linex0
	sta kg65.linedx				;dx=x1-x0
	lda kg65.linex1+1
	sbc kg65.linex0+1
	sta kg65.linedx+1
	sec
	lda kg65.liney1
	sbc kg65.liney0
	sta kg65.linedy				;dy=y1-y0
	lda kg65.liney1+1
	sbc kg65.liney0+1
	sta kg65.linedy+1
	rts


kg65.calconst
	bsr kg65.calcdxdy
	sec
	lda kg65.l.clipvars*256+kg65.maxx
	sbc kg65.linex0
	sta kg65.l.clipvars*256+kg65.mx		;mx=maxx-x0
	lda kg65.l.clipvars*256+kg65.maxx+1
	sbc kg65.linex0+1
	sta kg65.l.clipvars*256+kg65.mx+1
	sec
	lda kg65.l.clipvars*256+kg65.maxy	;my=maxy-y0
	sbc kg65.liney0
	sta kg65.l.clipvars*256+kg65.my
	lda kg65.l.clipvars*256+kg65.maxy+1
	sbc kg65.liney0+1
	sta kg65.l.clipvars*256+kg65.my+1
	lda kg65.linex0
	sec					;complement lo
	eor #255
	adc #0
	sta kg65.l.clipvars*256+kg65.nx		;nx= -x0
	lda kg65.linex0+1
	eor #255				;complement hi
	adc #0
	sta kg65.l.clipvars*256+kg65.nx+1
	lda kg65.liney0
	sec					;complement lo
	eor #255
	adc #0
	sta kg65.l.clipvars*256+kg65.ny		;ny = -y0
	lda kg65.liney0+1
	eor #255				;complement hi
	adc #0
	sta kg65.l.clipvars*256+kg65.ny+1
	rts


kg65.calcx0					;set up local variables to do math
	ldx kg65.linedx+1
	stx kg65.l.clipvars*256+kg65.tdxy1+1
	ldx kg65.linedx
	stx kg65.l.clipvars*256+kg65.tdxy1
	ldx kg65.linedy+1
	stx kg65.l.clipvars*256+kg65.tdxy2+1
	ldx kg65.linedy
	stx kg65.l.clipvars*256+kg65.tdxy2
	bsr kg65.calcxypt
	lda #0
	tab
	clc
	lda c65.faclo
	adc kg65.l.basepage*256+kg65.linex0
	tay
	lda c65.facmo
	adc kg65.l.basepage*256+kg65.linex0+1
	ldx #0
	pha
	lda #kg65.l.basepage
	tab
	pla
	rts


kg65.calcy0
	ldx kg65.linedy+1
	stx kg65.l.clipvars*256+kg65.tdxy1+1
	ldx kg65.linedy
	stx kg65.l.clipvars*256+kg65.tdxy1
	ldx kg65.linedx+1
	stx kg65.l.clipvars*256+kg65.tdxy2+1
	ldx kg65.linedx
	stx kg65.l.clipvars*256+kg65.tdxy2
	bsr kg65.calcxypt
	lda #0
	tab
	clc
	lda c65.faclo
	adc kg65.l.basepage*256+kg65.liney0
	tay
	lda c65.facmo
	adc kg65.l.basepage*256+kg65.liney0+1
	ldx #0
	pha
	lda #kg65.l.basepage
	tab
	pla
	rts


kg65.calcxypt					;a,y input
	pha
	lda #0
	tab
	pla
	ldx #0
	stx c65.argisgn
	jsr c65.givayf
	jsr c65.movaf
	lda kg65.l.clipvars*256+kg65.tdxy1+1	;delt? * n? or m?
	ldy kg65.l.clipvars*256+kg65.tdxy1
	jsr c65.givayf
;	lda c65.facsgn		;			not necessary on c65	[910918]
;	eor c65.argsgn
;	sta c65.argisgn
;	lda c65.facexp
	jsr c65.fmultt
	jsr c65.movaf
	lda kg65.l.clipvars*256+kg65.tdxy2+1
	ldy kg65.l.clipvars*256+kg65.tdxy2
	jsr c65.givayf
;	lda c65.facsgn		;			not necessary on c65	[910918]
;	eor c65.argsgn
;	sta c65.argisgn
	lda c65.facexp
	beq 1$
	jsr c65.fdivt

1$	jsr c65.ayint
	lda #kg65.l.basepage
	tab
	rts

;.end
	.page
	.subttl drawmodes

;created	: 08/23/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;


	clc			;????
kg65.setpen
; parm1 = pen# 0-2
; parm2 = color# 0-255

	tba
	pha
	lda #kg65.l.basepage
	tab
	lda kg65.parm1		;move pen# parm
	sta kg65.parm3
	lda kg65.drawscreen  	;screen index
	sta kg65.parm1
	bsr kg65.s.color2index	;sets temp4 w/ color index
	ldx kg65.parm3		;pen#
	lda kg65.temp4		;color index
	sta kg65.drawpens,x
	pla
	tab
	clc
	rts

	.page
	clc			;????

kg65.setdmode

; parm1 = jam: 0=jam1 1=jam2
; parm2 = complement 0/1 off/on
; parm3 = stencil 0/1 off/on
; parm4 = style: 0=solid 1=pattern 2=tile 3=reserved
; parm5 = thickness: 0-7 -> 1 to 8

	tba
	pha
	lda #kg65.l.basepage
	tab

	lda kg65.parm1		;jam mode					mods [911003] FAB
	and #%00000001		;	save only bit 0
	sta kg65.drawmode	;	put in temp drawmode byte

	lda kg65.parm2		;complement flag
	and #%00000001		;	save only bit 0
	asl a			;	put in bit 1
	tsb kg65.drawmode	;	merge in with temp drawmode byte

	lda kg65.parm3		;stencil flag
	and #%00000001		;	save only bit 0
	asl a			;	put in bit 2
	asl a
	tsb kg65.drawmode	;	merge in with temp drawmode byte

	lda kg65.parm4		;style flag
	and #%00000011		;	save only bit 0,1
	asl a			;	put in bit 3,4
	asl a
	asl a
	tsb kg65.drawmode	;	merge in with temp drawmode byte

	lda kg65.parm5		;thickness mode
	and #%00000111		;	save only bits 2,1,0
	lsr a			;	put in bits 7,5,6
	ror a
	ror a
	ror a
	tsb kg65.drawmode	;	merge in with drawmode byte

	lda #0
	sta kg65.patrbitnum 	;initialize to zero

	pla
	tab
	clc
	rts

	.page

	clc			;????

kg65.setdpat

; parm1 = pattern type
;	   0 - user defined
;	   1 - thin dot	  %10001000
;	   2 - thick dot  %11001100
;	   3 - dashed	  %11101110
;	   4 - dot/dashed %10011100
;	up to 63????
; below parms are only valid if type = 0
; parm2 = # of pattern bytes specified	1-4
; parm3 = pattern byte 1  0-255
; parm4 = pattern byte 2  0-255
; parm5 = pattern byte 3  0-255
; parm6 = pattern byte 4  0-255

	tba			;						mods	[911003] FAB
	pha
	lda #kg65.l.basepage
	tab

	lda #0			;clear out old pattern
	sta kg65.dpattern
	sta kg65.dpattern+1
	sta kg65.dpattern+2
	sta kg65.dpattern+3
	sta kg65.patrbitnum 	;initialize to zero

	lda kg65.parm1		;pattern type
	asl a			;	put in bits 2-7  0-63 range
	asl a			;	length defaults to 0 -> 1 byte
	sta kg65.dpatype
	bne 20$

	lda kg65.parm2		;#bytes in pattern
	dec a
	and #%00000011		;	ensure only 0-3
	tax
	tsb kg65.dpatype

10$	lda kg65.parm3,x	;copy # of pattern bytes
	sta kg65.dpattern,x
	dex
	bpl 10$
	bra 30$			;	done

20$				;set pre-defined pattern
	lsr a			;	back to 1-63 range for pattern#
	lsr a			;	 (pattern# 0 doesn't come here)
	dec a			;	0 to 62 range
	tax
	lda kg65.c.dpatterns,x
	sta kg65.dpattern	;length is 1 for pattern

30$
	pla
	tab
	clc
	rts


;.end
	.page
	.subttl color

;created	: 08/23/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;

	clc			;????
kg65.setpalette
; parm1 = screen# 0-3,  must be opened
; parm2 = color# 0-255
; parm3 = red value 0-15
; parm4 = green value 0-15
; parm5 = blue value 0-15

; if < 128 colors and 320 wide then 1 - 192 byte area after 1st block
; if >= 128 colors and 320 wide then 2 - 192 byte area after 1st & 2nd block
; if 640 & 1280 wide then 1 - 384 byte area at end of 2nd block
;
; format: only save number of colors that can be used by screen addressed by
; color#. convert from color# to color index when writing to hardware palette
;  red nybble,green nybble  blue nybble,red nybble  green nybble,blue nybble
;  repeated. two colors in three bytes.
;
;  # bitplanes	   # of colors   # bytes
;  -------------!---------------!----------
;	1	!	2	!   3
;	2	!	4	!   6
;	3	!	8	!  12
;	4	!      16	!  24
;	5	!      32	!  48
;	6	!      64	!  96
;	7	!     128	! 192
;	8	!     256	! 384
;
; if view screen also write to hardware regs

;	sei
	tba
	pha
	lda #kg65.l.basepage
	tab
	clc				;nop
	bsr kg65.s.write.palette	;write to screen palette area
	bcs 4$				;br if error, exit with .c=1
	ldy kg65.parm1			;screen#
	ldx kg65.c.scridx,y
	cpx kg65.viewscreen		;screen index = viewscreen index
	bne 1$				;br if no
	stx kg65.parm1			;screen index
	bsr kg65.s.color2index		;else write to hardware palette
	ldx kg65.temp4			;color index#
	lda kg65.parm3
	sta c65.l.redcpba,x
	lda kg65.parm4
	sta c65.l.grncpba,x
	lda kg65.parm5
	sta c65.l.blucpba,x

1$	clc				;success, exit with .c=0
4$	pla
	tab
;	cli
	rts

;4$	pla
;	tab
;	sec
;	cli
;	rts

	.page
kg65.s.read.palette

;read palette function
;input: screen#(parm1),color#(parm2)
;output: r(parm3),g(parm4),b(parm5)

	lda #0
;	sta kg65.parm6		;read palette flag
;	bra kg65.s.palette.io
	  .byte $2c

kg65.s.write.palette

;write screen palette function
;input: screen#(parm1),color#(parm2),r(parm3),g(parm4),b(parm5)
;screen palette format: by color# r,g,b nybbles 0 to #colors in scrn - 1
; based on depth

	lda #1
	sta kg65.parm6		;write palette flag
;	bra kg65.s.palette.io

kg65.s.palette.io
	ldy kg65.parm1		;screen#
	ldx kg65.c.scridx,y
	lda kg65.scrtab,x
	and #%01000000		;screen open?
	bne 4$			;	yes
	sec			;	no
	rts

4$	lda kg65.parm2		;color#
;	cmp #128
;	bcs 1$			;	>= then br
	bmi 1$

	lda kg65.scrtab,x
	and #%00110000
	bne 1$			;br if 640 or 1280
	lda kg65.scrtab+2,x  	;find 1st block in bank A used for screen
	bsr 99$
;	bcs 7$			;	not found
	bcc 28$			;	found

7$	lda kg65.scrtab+3,x	;find 1st block in bank B used for screen
	bsr 99$
	bcc 27$			;	found
	rts			;	not found, exit with .c=1


1$				; 640, 1280, or color>=128
	lda kg65.scrtab+2,x	;Therefore use 2nd block used for screen found in bank A
	bsr 99$			;find block in bank A
	bcs 22$			;	not found
	inc kg65.temp1		;	bitplane#
	asl kg65.temp2		;	bitplane mask
	lda kg65.scrtab+2,x
	sta kg65.temp3
	bsr 91$			;second block
	bcc 28$			;	found, go set color block addr
;	bcs 22$			;	not found, go try bank B

22$				;find block in bank B
	lda kg65.scrtab+3,x
	bsr 99$
	bcs 255$		;	not found, exit with .c=1
;	bcc 25$
;	rts

25$	inc kg65.temp1
	asl kg65.temp2
	lda kg65.scrtab+3,x
	sta kg65.temp3
	bsr 91$			;second block
	bcs 255$		;	not found, exit with .c=1
;	bcc 27$
;	rts

27$	lda kg65.bankb		;bank B						[910823] FAB
	  .byte $2c
28$	lda kg65.banka		;bank A						[910823] FAB
	sta kg65.parm17
	lda kg65.scrtab,x
	and #%00110000
	bne 29$

;if 320 wide then use lores color block addr

	ldx kg65.temp1
	lda kg65.c.colrLblkadrl,x	;bank A
	sta kg65.bpptr1
	lda kg65.c.colrLblkadrh,x
	sta kg65.bpptr1+1
	bra 10$

29$					;hires
	ldx kg65.temp1
	lda kg65.c.colrHblkadrl,x	;bank A
	sta kg65.bpptr1
	lda kg65.c.colrHblkadrh,x
	sta kg65.bpptr1+1
	bra 10$


99$	sta kg65.temp3		;bank block used mask
	lda #0
	sta kg65.temp1		;bitplane#
	inc a
	sta kg65.temp2		;bitplane mask

91$	lda kg65.temp3		;bitplane used
	and kg65.temp2
	bne 92$			;br if yes
	inc kg65.temp1		;try next bitplane
	asl kg65.temp2
	bcc 91$
255$	rts			;rts w/ sec if no bitplanes used in block

92$	clc
	rts


10$	lda kg65.parm2
	sta kg65.subparm1
;	cmp #128
;	bcc 11$			;br if < 128
	bpl 11$

;	lda kg65.subparm1
	and #127
	sta kg65.subparm1
	ldy kg65.parm1
	ldx kg65.c.scridx,y
	lda kg65.scrtab,x
	and #%00110000
	beq 11$			;br if 320 wide
	clc
	lda kg65.bpptr1
	adc #192
	sta kg65.bpptr1
	bcc 11$
	inc kg65.bpptr1+1

11$	lda kg65.subparm1	;???? color>128 causes problems			[910823] FAB
;	lda kg65.parm2
	lsr a
	ldx #3
	ldy #0
	bsr kg65.s.mulply
	txa
	tay			; y=index	color#/2*3 = index into color area
	lda kg65.subparm1 	; pack rgb nybbles into color slot
	and #%00000001		; each color gets 1.5 bytes
	bne 2$			; br if odd color# 1,3,5

	lda kg65.parm6		;read or write palette?
	beq 30$
				;write palette
	lda kg65.parm3		; else even color# 0,2,4
	asl a
	asl a
	asl a
	asl a
	ora kg65.parm4

;  sta (kg65.bpptr1),z	;r,g
;	phy
;	ldx #<kg65.bpptr1
	ldz kg65.l.basepage*256+kg65.parm17			;--------------
;	bsr c65.indsta		;sta (kg65.bpptr1),y to bank z
;	ply
	bsr sta_bpptr1

	iny

;  lda (kg65.bpptr1),z	;b,next r
;	phy
;	ldx #<kg65.bpptr1
;	ldz kg65.l.basepage*256+kg65.parm17			;---
;	bsr c65.indfet		;lda (kg65.bpptr1),y from bank z
;	ply
	bsr lda_bpptr1

	and #%00001111
	sta kg65.temp1
	lda kg65.parm5
	asl a
	asl a
	asl a
	asl a
	ora kg65.temp1

;  sta (kg65.bpptr1),z
;	phy
;	ldx #<kg65.bpptr1
;	ldz kg65.l.basepage*256+kg65.parm17			;---
;	bsr c65.indsta		;sta (kg65.bpptr1),y to bank z
;	ply
	bsr sta_bpptr1

	bra 3$


30$				;read palette for even color#
;  lda (kg65.bpptr1),z
;	phy
;	ldx #<kg65.bpptr1
	ldz kg65.l.basepage*256+kg65.parm17			;--------------
;	bsr c65.indfet		;lda (kg65.bpptr1),y from bank z
;	ply
	bsr lda_bpptr1

	tax
;	and #%11110000		;mask red
	lsr a			;put into low nybble
	lsr a
	lsr a
	lsr a
	sta kg65.parm3
	txa
	and #%00001111		;mask green
	sta kg65.parm4

	iny
;  lda (kg65.bpptr1),z
;	phy
;	ldx #<kg65.bpptr1
;	ldz kg65.l.basepage*256+kg65.parm17			;---
;	bsr c65.indfet		;lda (kg65.bpptr1),y from bank z
;	ply
	bsr lda_bpptr1

;	and #%11110000		;mask blue
	lsr a			;put into low nybble
	lsr a
	lsr a
	lsr a
	sta kg65.parm5
	bra 3$

2$	lda kg65.parm6
	beq 32$
	iny			;write palette

;  lda (kg65.bpptr1),z		;prev. b,r
;	phy
;	ldx #<kg65.bpptr1
	ldz kg65.l.basepage*256+kg65.parm17			;--------------
;	bsr c65.indfet		;lda (kg65.bpptr1),y from bank z
;	ply
	bsr lda_bpptr1

	and #%11110000
	ora kg65.parm3

;  sta (kg65.bpptr1),z
;	phy
;	ldx #<kg65.bpptr1
;	ldz kg65.l.basepage*256+kg65.parm17			;---
;	bsr c65.indsta		;sta (kg65.bpptr1),y to bank z
;	ply
	bsr sta_bpptr1

	iny
	lda kg65.parm4
	asl a
	asl a
	asl a
	asl a
	ora kg65.parm5

;  sta (kg65.bpptr1),z		;b,g
;	phy
;	ldx #<kg65.bpptr1
;	ldz kg65.l.basepage*256+kg65.parm17			;---
;	bsr c65.indsta		;sta (kg65.bpptr1),y to bank z
;	ply
	bsr sta_bpptr1

	bra 3$


32$	iny			;read palette for odd color#

;  lda (kg65.bpptr1),z
;	phy
;	ldx #<kg65.bpptr1
	ldz kg65.l.basepage*256+kg65.parm17			;-------------
;	bsr c65.indfet		;lda (kg65.bpptr1),y from bank z
;	ply
	bsr lda_bpptr1

	and #%00001111		;mask red
	sta kg65.parm3
	iny

;  lda (kg65.bpptr1),z
;	phy
;	ldx #<kg65.bpptr1
;	ldz kg65.l.basepage*256+kg65.parm17			;---
;	bsr c65.indfet		;lda (kg65.bpptr1),y from bank z
;	ply
	bsr lda_bpptr1

	tax
;	and #%11110000		;mask green
	lsr a			;put into low nybble
	lsr a
	lsr a
	lsr a
	sta kg65.parm4
	txa
	and #%00001111		;mask blue
	sta kg65.parm5

3$	clc
	rts

	.page
kg65.s.color2index		;				mods	[910820] FAB

;color# to color index
;input: screen index(parm1), color#(parm2)
;output: color index for screen (temp4)

	ldx kg65.parm1		;screen index
	lda #0
	sta kg65.temp4		;color index
	inc a
	sta kg65.temp2		;bitplane#
	sta kg65.temp3		;color# bit#

10$	lda kg65.parm2		;color#
	and kg65.temp3		;bit in color# mask set
	sta kg65.temp1		;color# bit mask

20$	lda kg65.scrtab+1,x	;screen bitplanes
	and kg65.temp2
	bne 30$			;	br if bitplane used
	asl kg65.temp2
	bcc 20$			;try next bitplane
	rts			;	no more- done

30$	lda kg65.temp1		;color bit on in mask?
	beq 40$			;	br if no
	lda kg65.temp2
	tsb kg65.temp4		;	else save bit mask into color index

40$	asl kg65.temp2
	asl kg65.temp3
	bcc 10$
	rts

;.end
	.page
	.subttl box

;created	: 09/07/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;

; parm1-8  = side 1 x0,y0,x1,y1
; parm9-16 = side 2 x0,y0,x1,y1
; parm17   = solid flag 0=no 1=yes

; calculate point on each side and draw a line between them to make
; a solid block. two line sets are done so that the box could be sheared
; in two directions which means none of the points are in common
; (ie diamond shape possible)

	clc			;????
kg65.box
;	sei			;remove
	tba
	pha
	lda #kg65.l.basepage
	tab

	ldx #7			;move parms into linea & b vars
1$	lda kg65.parm1,x
	sta kg65.linea.x0,x
	lda kg65.parm9,x
	sta kg65.lineb.x0,x
	dex
	bpl 1$

	lda kg65.parm17		;solid flag
	beq 4$			;br if frame only

;-----------------------------------------------------------------------------
;  Draw solid box
;-----------------------------------------------------------------------------

	lda #0
	sta kg65.linea.flag
	sta kg65.lineb.flag
	inc a
	sta kg65.linea.doadr	;don't calc screen address
	sta kg65.lineb.doadr

	lda #kg65.l.basepage	;						[911002]
	sta kg65.bpptr1+1

3$	lda #<kg65.linea	;calculate linea point
	sta kg65.bpptr1
;	lda #kg65.l.basepage	;						[911002]
;	sta kg65.bpptr1+1
	bsr kg65.s.line		;	calcs only x,y
	bcs 5$			;	br when done--------------------------->

	lda #<kg65.lineb	;calculate lineb point
	sta kg65.bpptr1
;	lda #kg65.l.basepage	;						[911002]
;	sta kg65.bpptr1+1
	lda #0
	sta kg65.patrbitnum	;(kludge for patterns)				[911007]
	bsr kg65.s.line		;calcs only x,y

	ldx #3			;draw a line in between linea & lineb points
2$	lda kg65.linea.x0,x	;in order to make solid box
	sta kg65.parm1,x	;move in parms for line command
	lda kg65.lineb.x0,x
	sta kg65.parm5,x
	dex
	bpl 2$
	bsr kg65.line
	bra 3$			;do next point along box edge

;-----------------------------------------------------------------------------
;  Draw frame box
;-----------------------------------------------------------------------------

4$	ldx #3
6$	lda kg65.linea.x0,x
	sta kg65.parm1,x
	lda kg65.lineb.x0,x
	sta kg65.parm5,x
	dex
	bpl 6$
	bsr kg65.line_patr

	ldx #3
7$	lda kg65.lineb.x0,x
	sta kg65.parm1,x
	lda kg65.lineb.x1,x
	sta kg65.parm5,x
	dex
	bpl 7$
	bsr kg65.line

	ldx #3
8$	lda kg65.lineb.x1,x
	sta kg65.parm1,x
	lda kg65.linea.x1,x
	sta kg65.parm5,x
	dex
	bpl 8$
	bsr kg65.line

	ldx #3
9$	lda kg65.linea.x1,x
	sta kg65.parm1,x
	lda kg65.linea.x0,x
	sta kg65.parm5,x
	dex
	bpl 9$
	bsr kg65.line

;-----------------------------------------------------------------------------
;  Exit
;-----------------------------------------------------------------------------

5$	pla
	tab
	clc
;	cli			;remove
	rts

;.end
	.page
	.subttl circle

;created	: 09/11/89
;updated	: 11/12/90 (clipping)
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;

	clc			;????
kg65.circle
; parm1,2 = cx
; parm3,4 = cy
; parm5,6 = radius
; parm7	  = solidflag 1=yes 0=no

;	sei			;remove
	tba
	pha
	lda #kg65.l.basepage
	tab

	ldx #3
10$	lda kg65.parm1,x
	sta kg65.cx,x
	dex
	bpl 10$

	lda kg65.parm7
	sta kg65.csolidflag
	lda #0
	sta kg65.cdy		;y=0
	sta kg65.cdy+1
	lda kg65.parm5		;x=radius
	sta kg65.cdx
	lda kg65.parm6
	sta kg65.cdx+1
	sec			;d=1-raduis
	lda #1
	sbc kg65.cdx
	sta kg65.cphi
	lda #0
	sbc kg65.cdx+1
	sta kg65.cphi+1

20$	lda kg65.cdx+1
	taz			;No LDZ basepage
	lda kg65.cdx
	ldx kg65.cdy
	ldy kg65.cdy+1
	bsr kg65.s.quadplot	;plot around four sides of x-axis ------------------------------------

	lda kg65.cdy+1
	taz
	lda kg65.cdy
	ldx kg65.cdx
	ldy kg65.cdx+1
	bsr kg65.s.quadplot	;plot around four sides of y-axis ------------------------------------

	inw kg65.cdy		;y=y+1
	lda kg65.cdy+1		;(2*y)
	sta kg65.temp2
	lda kg65.cdy
	asl a
	sta kg65.temp1
	rol kg65.temp2
	inw kg65.temp1		;+1

	lda kg65.cphi+1		;d < 0	bit 7 = 1 -> negative
	bpl 30$			;br if no
	clc
	lda kg65.cphi		;d=d+(2*y)+1
	adc kg65.temp1
	sta kg65.cphi
	lda kg65.cphi+1
	adc kg65.temp2
	sta kg65.cphi+1
	bra 40$
				;else
30$	dew kg65.cdx		;x=x-1
	lda kg65.cdx+1		;d=(d-(2*x))+(2*y)+1
	sta kg65.temp4
	lda kg65.cdx		;2*x
	asl a
	sta kg65.temp3
	rol kg65.temp4

	sec			;d=d-(2*x)
	lda kg65.cphi
	sbc kg65.temp3
	sta kg65.cphi
	lda kg65.cphi+1
	sbc kg65.temp4
	sta kg65.cphi+1

	clc			;d=d+(2*y)+1
	lda kg65.cphi
	adc kg65.temp1
	sta kg65.cphi
	lda kg65.cphi+1
	adc kg65.temp2
	sta kg65.cphi+1

40$	lda kg65.drawmode
	beq 42$
	lda kg65.dpatype	;(circle & ellipse kludge for patterns)			[911007]
	and #%00000011
	tax
	lda kg65.patrbitnum
	inc a
	cmp kg65.c.patrbits,x	;	done all pattern bits?
	bcc 41$			;		br if no
	lda #0
41$	sta kg65.patrbitnum	;		else reset to beginning

42$	lda kg65.cdx
	cmp kg65.cdy
	lda kg65.cdx+1
	sbc kg65.cdy+1
	bcs 20$			;br if cdx >= cdy
	pla
	tab
	clc
;	cli			;remove
	rts			;exit circle

	.page
kg65.s.quadplot			;plot around x & y axis
	sta kg65.subparm1
	stz kg65.subparm2
	stx kg65.subparm3
	sty kg65.subparm4	;plotting order:
	clc			;		 /|\
	lda kg65.cx		;		7 | 6
	adc kg65.subparm1	;		  |
	sta kg65.cx0		;		  |
	sta kg65.cx1		;	  3	  |	  4
	lda kg65.cx+1		;	 <--------+-------->
	adc kg65.subparm2	;	  2	  |	  1
	sta kg65.cx0+1		;		  |
	sta kg65.cx1+1		;		  |
	clc			;		8 | 5
	lda kg65.cy		;		 \|/
	adc kg65.subparm3
	sta kg65.cy0
	lda kg65.cy+1
	adc kg65.subparm4
	sta kg65.cy0+1
	bsr kg65.s.dot		;1

	sec
	lda kg65.cx
	sbc kg65.subparm1
	sta kg65.cx0
	lda kg65.cx+1
	sbc kg65.subparm2
	sta kg65.cx0+1
	bsr kg65.s.dot		;2

	sec
	lda kg65.cy
	sbc kg65.subparm3
	sta kg65.cy0
	lda kg65.cy+1
	sbc kg65.subparm4
	sta kg65.cy0+1
	bsr kg65.s.dot		;3

	lda kg65.cx1
	sta kg65.cx0
	lda kg65.cx1+1
	sta kg65.cx0+1
	bra kg65.s.dot		;4

	.page
kg65.s.dot
	lda kg65.csolidflag
	beq 20$

	ldx #3			;solid
10$	lda kg65.cx0,x
	sta kg65.parm1,x
	dex
	bpl 10$

	lda kg65.cx
	sta kg65.parm5
	lda kg65.cx+1
	sta kg65.parm6
	lda kg65.cy0
	sta kg65.parm7
	lda kg65.cy0+1
	sta kg65.parm8
	bra kg65.line_patr


20$	lda kg65.patrbitnum	;(circle & ellipse kludge for patterns)			[911007]
	pha
	ldx #3			;frame
30$	lda kg65.cx0,x
	sta kg65.linex0,x
	sta kg65.linex1,x
	dex
	bpl 30$

	bsr kg65.clip
	bcs 40$
	bsr kg65.s.calcadr
	lda kg65.linemask
	sta kg65.mask
	lda kg65.linedsadr
	sta kg65.dsadr
	lda kg65.linedsadr+1
	sta kg65.dsadr+1
	bsr kg65.s.plotdot

40$	pla
	sta kg65.patrbitnum	;(circle & ellipse kludge for patterns)			[911007]
	rts

;.end
	.page
	.subttl polygon

;created	: 09/07/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;


	clc			;????
kg65.polygon
; parm1,2   = cx
; parm3,4   = cy
; parm5,6   = xr
; parm7,8   = yr
; parm9	    = solid flag
; parm10,11 = sa
; parm12    = # of sides to draw  3 to ?  < 127
; parm13    = # of sides	  parm12 <= parm13
; parm14    = subtend flag

;	sei			;remove
	tba
	pha
	lda #kg65.l.basepage
	tab

	ldx #3
1$	lda kg65.parm1,x	;copy x,y, xr,yr
	sta kg65.pcx,x
	dex
	bpl 1$

	sec
	lda #<360		;make starting angle clockwise				[910923] FAB
	sbc kg65.parm10
	tay
	lda #>360
	sbc kg65.parm11
	tax
	lda #0
	tab			;map in mathpack's base page
	txa
	jsr c65.givayf		;	float sa
	bsr kg65.s.cvtrad 	;tt=sa/360*(2*pi)
	ldx #<kg65.tt
	ldy #kg65.l.basepage
	jsr c65.movmf		;	round & store in tt

	ldy #<360		;360/# of sides
	lda #>360
	jsr c65.givayf		;	float 360
	jsr c65.movaf		;	round & copy FAC to ARG
	ldy kg65.l.basepage*256+kg65.parm13
	lda #0
	bsr kg65.s.fpdivt	;	FAC=ARG/FAC
	bsr kg65.s.cvtrad 	;dgfp=dg/360*(2*pi)
	ldx #<kg65.dgfp
	ldy #kg65.l.basepage
	jsr c65.movmf

;	lda #kg65.l.basepage
;	tab
	ldy kg65.l.basepage*256+kg65.parm5		;xrfp=fp(xr)
	lda kg65.l.basepage*256+kg65.parm6
;	lda #0
;	tab
;	txa
	jsr c65.givayf
	ldx #<kg65.xrfp
	ldy #kg65.l.basepage
	jsr c65.movmf

;	lda #kg65.l.basepage
;	tab
	ldy kg65.l.basepage*256+kg65.parm7		;yrfp=fp(yr)
	lda kg65.l.basepage*256+kg65.parm8
;	lda #0
;	tab
;	txa
	jsr c65.givayf
	ldx #<kg65.yrfp
	ldy #kg65.l.basepage
	jsr c65.movmf

;Loop of the circle
; LOOP sa TO ea STEP dg
;  calc iteration store in its
;   its=# of sides to draw

	lda #kg65.l.basepage
	tab
	lda kg65.parm12		;# of sides to draw
	sta kg65.its
;	lda #0
	sta kg65.ptemp1		;first time flag (b7=0)

2$	lda #0			;set base page to use mathpack----------------------------
	tab
	lda #<kg65.tt
	ldy #kg65.l.basepage
	jsr c65.movfm
	jsr c65.cos		;fac=cos(tt)
	lda #<kg65.xrfp
	ldy #kg65.l.basepage
	jsr c65.romupk
	jsr c65.fmultt		;fac=fac*xrfp
	jsr c65.ayint

	clc			;x1=fac+cx
	lda c65.faclo
	adc kg65.l.basepage*256+kg65.pcx
	sta kg65.l.basepage*256+kg65.px1
	lda c65.facmo
	adc kg65.l.basepage*256+kg65.pcx+1
	sta kg65.l.basepage*256+kg65.px1+1

	lda #<kg65.tt
	ldy #kg65.l.basepage
	jsr c65.movfm
	jsr c65.sin		;fac=sin(tt)
	lda #<kg65.yrfp
	ldy #kg65.l.basepage
	jsr c65.romupk
	jsr c65.fmultt		;fac=fac*yrfp
	jsr c65.ayint

	sec			;y1=cy-fac
	lda kg65.l.basepage*256+kg65.pcy
	sbc c65.faclo
	sta kg65.l.basepage*256+kg65.py1
	lda kg65.l.basepage*256+kg65.pcy+1
	sbc c65.facmo
	sta kg65.l.basepage*256+kg65.py1+1

	lda #kg65.l.basepage	;base page set for kg65-----------------------------------
	tab
	bbr7 kg65.ptemp1,20$	;br first time in, we need to calc 2nd point

	lda kg65.parm9
	bne 10$			;br if solid

; wireframe polygon

;9$	lda #0
;	sta kg65.plineflag	;init for 1st entry to line subroutine
;	sta kg65.plinedoadr	;calc address
	bsr 200$		;drawing line x0,y0  to x1,y1
	bra 20$

; solid polygon:  call facet with (pcx,pcy),(px0,py0),(px1,py1)

10$	ldx #3
11$	lda kg65.pcx,x
	sta kg65.fxmid,x
	lda kg65.px0,x
	sta kg65.fxmax,x
	lda kg65.px1,x
	sta kg65.fxmin,x
	lda kg65.px1,x		;move px1,py1 to px0,py0 to setup next point
	sta kg65.px0,x
	dex
	bpl 11$
	bsr kg65.s.facet
	bra 50$

20$	ldx #3
30$	lda kg65.px1,x		;saved x,y  first x,y = first point calculated
	sta kg65.px0,x
	bbs7 kg65.ptemp1,40$
	sta kg65.savexy,x
40$	dex
	bpl 30$

50$	smb7 kg65.ptemp1	;set to non zero
	dec kg65.its		;for each side...
;	lda kg65.its
	bmi 70$			;	if zero then done

60$	lda #0			;set to 0 for mathpack-------------------------------------
	tab
	lda #<kg65.dgfp
	ldy #kg65.l.basepage
	jsr c65.movfm
	lda #<kg65.tt
	ldy #kg65.l.basepage
	jsr c65.romupk
;	lda c65.facsgn		;			not necessary on c65	[910918]
;	eor c65.argsgn
;	sta c65.argisgn
;	lda c65.facexp
	jsr c65.faddt		;tt=tt+dgfp
	ldx #<kg65.tt
	ldy #kg65.l.basepage
	jsr c65.movmf

	lda #kg65.l.basepage	;set for graphics------------------------------------
	tab
	bra 2$


70$	lda kg65.parm14		;subtend?
	beq 100$		;br if 0 -> no, we're done...rts

; draw px0,py0 to pcx,pcy

	ldx #3
80$	lda kg65.pcx,x
	sta kg65.px1,x
	dex
	bpl 80$

;	lda #0
;	sta kg65.plineflag	;init for 1st entry to line subroutine
;	sta kg65.plinedoadr	;calc address
	bsr 200$		;draw line

; draw savex,y to pcx,pcy

	ldx #3
90$	lda kg65.savexy,x
	sta kg65.px0,x
	lda kg65.pcx,x
	sta kg65.px1,x
	dex
	bpl 90$

;	lda #0
;	sta kg65.plineflag	;init for 1st entry to line subroutine
;	sta kg65.plinedoadr	;calc address
	bsr 200$		;draw line

100$	pla
	tab
;	cli			;remove
	clc
	rts			;exit ellipse

	.page
;99$				;internal line drawing interface routine
;	lda #0
;	sta kg65.plineflag	;init for 1st entry to line subroutine
;	sta kg65.plinedoadr	;calc address
;
;98$	lda #<kg65.linea
;	sta kg65.bpptr1
;	lda #kg65.l.basepage
;	sta kg65.bpptr1+1
;	bsr kg65.s.line
;	bcs 97$
;
;	lda kg65.plinemask
;	sta kg65.mask
;	lda kg65.plinedsadr
;	sta kg65.dsadr
;	lda kg65.plinedsadr+1
;	sta kg65.dsadr+1
;	bsr kg65.s.plotdot
;	bra 98$
;
;97$	rts
;

200$	ldx #3			;replace so that clipping works			[910919] FAB
210$	lda kg65.px1,x
	sta kg65.parm1,x
	lda kg65.px0,x
	sta kg65.parm5,x
	dex
	bpl 210$
	bra kg65.line

	.page
kg65.s.fpmult			;floating point multiply setup and call
	jsr c65.movfm		;move mem to fac
;	lda c65.facsgn		;				not necessary on C65	[910918]
;	eor c65.argsgn
;	sta c65.argisgn		;set resultant sign
;	lda c65.facexp
	jsr c65.fmultt		;fp multiply
	jsr c65.ayint		;fp to int
	ldy c65.facmo		;y=hi
	lda c65.faclo		;a=lo
	rts


kg65.s.fpmult1
;	lda c65.facsgn		;				not necessary on C65	[910918]
;	eor c65.argsgn
;	sta c65.argisgn		;set resultant sign
;	lda c65.facexp
	jsr c65.fmultt
	jmp c65.movaf		;mov arg to fac   w/rts


kg65.s.fpdivt			;floating point divide setup and call
	jsr c65.givayf		;a y to flt. pt.
kg65.s.fpdivt1
;	lda c65.facsgn		;				not necessary on C65	[910918]
;	eor c65.argsgn
;	sta c65.argisgn		;set resultant sign
	lda c65.facexp
	beq 1$			;br if 0 to avoid div by 0
	jsr c65.fdivt

1$	rts


kg65.s.cvtrad
	jsr c65.movaf		;calc fac
	ldy #<360		;fac=arg/360*2pi
	lda #>360
	bsr kg65.s.fpdivt
	lda #<kg65.c.pi2
	ldy #>kg65.c.pi2
	jsr c65.romupk
	jmp c65.fmultt

;.end
	.page
	.subttl ellipse

;created	: 09/07/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;


	clc			;????
kg65.ellipse
; parm1,2   = cx
; parm3,4   = cy
; parm5,6   = xr
; parm7,8   = yr
; parm9	    = solid flag

;	sei			;remove
	tba
	pha
	lda #kg65.l.basepage
	tab

	ldx #3
12$	lda kg65.parm1,x
	sta kg65.cx,x
	dex
	bpl 12$

	lda kg65.parm9
	sta kg65.csolidflag
	lda #0			;cdx=xradius  cdy=0
	sta kg65.cdy
	sta kg65.cdy+1
	lda kg65.parm5
	sta kg65.cdx
	lda kg65.parm6
	sta kg65.cdx+1

	lda kg65.cdx+1		;t1=xr * xr
	taz
	tay
	lda kg65.cdx
	tax
	bsr kg65.s.mulply32	;16bit * 16bit  a=lo z=hi  x=lo y=hi  return x=lo y=hi
	stx kg65.t1
	sty kg65.t1+1
	sty kg65.t2+1
	sta kg65.t1+2
	sta kg65.t2+2
	txa
	asl a
	sta kg65.t2
	rol kg65.t2+1		;t2=t1 * 2
	rol kg65.t2+2
	lda kg65.t2+1
	sta kg65.t3+1
	lda kg65.t2+2
	sta kg65.t3+2
	lda kg65.t2
	asl a
	sta kg65.t3
	rol kg65.t3+1		;t3=t2 * 2
	rol kg65.t3+2

	lda kg65.parm8		;t4=yr * yr
	taz
	tay
	lda kg65.parm7
	tax
	bsr kg65.s.mulply32	;16bit * 16bit  a=lo z=hi  x=lo y=hi  return x=lo y=hi
	stx kg65.t4
	sty kg65.t4+1
	sty kg65.t5+1
	sta kg65.t4+2
	sta kg65.t5+2
	txa
	asl a
	sta kg65.t5
	rol kg65.t5+1		;t5=t4 * 2
	rol kg65.t5+2
	lda kg65.t5+1
	sta kg65.t6+1
	lda kg65.t5+2
	sta kg65.t6+2
	lda kg65.t5
	asl a
	sta kg65.t6
	rol kg65.t6+1		;t6=t5 * 2
	rol kg65.t6+2

	lda kg65.cdx+1		;t7=xr * t5
	taz
	lda kg65.cdx		;do xr * lo 16bits of t5
	ldx kg65.t5
	ldy kg65.t5+1
	bsr kg65.s.mulply32	;16bit * 16bit  a=lo z=hi  x=lo y=hi  return x=lo y=hi
	stx kg65.t7
	sty kg65.t7+1
	sta kg65.t7+2
	tza
	sta kg65.t7+3

	lda kg65.cdx+1		;do xr * hi 16bits of t5
	taz
	lda kg65.cdx
	ldx kg65.t5+2
	ldy #0
	bsr kg65.s.mulply32
	stx kg65.temp1
	sty kg65.temp2
	sta kg65.temp3
	tza
	sta kg65.temp4

	clc			;add two multiply results together
	lda kg65.t7
	adc kg65.temp1
	sta kg65.t7
	lda kg65.t7+1
	adc kg65.temp2
	sta kg65.t7+1
	lda kg65.t7+2
	adc kg65.temp3
	sta kg65.t7+2
	lda kg65.t7+3
	adc kg65.temp4
	sta kg65.t7+3

	lda kg65.t7+1
	sta kg65.t8+1
	lda kg65.t7+2
	sta kg65.t8+2
	lda kg65.t7+3
	sta kg65.t8+3

	lda kg65.t7
	asl a
	sta kg65.t8
	rol kg65.t8+1		;t8=t7 * 2
	rol kg65.t8+2
	rol kg65.t8+3
	lda #0			;t9=0
	sta kg65.t9
	sta kg65.t9+1
	sta kg65.t9+2
	sta kg65.t9+3

	lda kg65.t4		;t4/2
	sta kg65.temp1
	lda kg65.t4+1
	sta kg65.temp2
	lda kg65.t4+2
	lsr a
	sta kg65.temp3
	ror kg65.temp2
	ror kg65.temp1
	sec			;t2-t7
	lda kg65.t2
	sbc kg65.t7
	sta kg65.d1
	lda kg65.t2+1
	sbc kg65.t7+1
	sta kg65.d1+1
	lda kg65.t2+2
	sbc kg65.t7+2
	sta kg65.d1+2
	lda #0
	sbc kg65.t7+3
	sta kg65.d1+3
	clc			;d1=t2-t7+(t4/2)
	lda kg65.d1
	adc kg65.temp1
	sta kg65.d1
	lda kg65.d1+1
	adc kg65.temp2
	sta kg65.d1+1
	lda kg65.d1+2
	adc kg65.temp3
	sta kg65.d1+2
	lda kg65.d1+3
	adc #0
	sta kg65.d1+3

	lda kg65.t1		;t1/2
	sta kg65.temp1
	lda kg65.t1+1
	sta kg65.temp2
	lda kg65.t1+2
	lsr a
	sta kg65.temp3
	ror kg65.temp2
	ror kg65.temp1
	sec			;d2=(t1/2)-t8+t5
	lda kg65.temp1
	sbc kg65.t8
	sta kg65.d2
	lda kg65.temp2
	sbc kg65.t8+1
	sta kg65.d2+1
	lda kg65.temp3
	sbc kg65.t8+2
	sta kg65.d2+2
	lda #0
	sbc kg65.t8+3
	sta kg65.d2+3
	clc
	lda kg65.d2
	adc kg65.t5
	sta kg65.d2
	lda kg65.d2+1
	adc kg65.t5+1
	sta kg65.d2+1
	lda kg65.d2+2
	adc kg65.t5+2
	sta kg65.d2+2
	lda kg65.d2+3
	adc #0
	sta kg65.d2+3

	.page
; region 1

1$	lda kg65.d2+3		;while d2 < 0
	bpl 2$
	lda kg65.cdx+1		;quadplot pixel(x,y)
	taz
	lda kg65.cdx
	ldx kg65.cdy
	ldy kg65.cdy+1
	bsr kg65.s.quadplot	;plot around four side of x-axis
	lda kg65.drawmode
	beq 112$
	lda kg65.dpatype	;(circle & ellipse kludge for patterns)			[911007]
	and #%00000011
	tax
	lda kg65.patrbitnum
	inc a
	cmp kg65.c.patrbits,x	;	done all pattern bits?
	bcc 111$		;		br if no
	lda #0
111$	sta kg65.patrbitnum	;		else reset to beginning

112$	inw kg65.cdy		;y=y+1
	bsr 7$			;t9=t9+t3
	lda kg65.d1+3		;if d1 < 0 then
	bpl 3$
	clc			;d1=d1+t9+t2
	lda kg65.d1
	adc kg65.t9
	sta kg65.d1
	lda kg65.d1+1
	adc kg65.t9+1
	sta kg65.d1+1
	lda kg65.d1+2
	adc kg65.t9+2
	sta kg65.d1+2
	lda kg65.d1+3
	adc kg65.t9+3
	sta kg65.d1+3
	clc
	lda kg65.d1
	adc kg65.t2
	sta kg65.d1
	lda kg65.d1+1
	adc kg65.t2+1
	sta kg65.d1+1
	lda kg65.d1+2
	adc kg65.t2+2
	sta kg65.d1+2
	lda kg65.d1+3
	adc #0
	sta kg65.d1+3
	clc			;d2=d2+t9
	lda kg65.d2
	adc kg65.t9
	sta kg65.d2
	lda kg65.d2+1
	adc kg65.t9+1
	sta kg65.d2+1
	lda kg65.d2+2
	adc kg65.t9+2
	sta kg65.d2+2
	lda kg65.d2+3
	adc kg65.t9+3
	sta kg65.d2+3
	bra 1$			;while loop

3$				;else
	dew kg65.cdx		;x=x-1
	bsr 8$			;t8=t8-t6
	sec			;d1=d1-t8+t9+t2
	lda kg65.d1
	sbc kg65.t8
	sta kg65.d1
	lda kg65.d1+1
	sbc kg65.t8+1
	sta kg65.d1+1
	lda kg65.d1+2
	sbc kg65.t8+2
	sta kg65.d1+2
	lda kg65.d1+3
	sbc kg65.t8+3
	sta kg65.d1+3
	clc
	lda kg65.d1
	adc kg65.t9
	sta kg65.d1
	lda kg65.d1+1
	adc kg65.t9+1
	sta kg65.d1+1
	lda kg65.d1+2
	adc kg65.t9+2
	sta kg65.d1+2
	lda kg65.d1+3
	adc kg65.t9+3
	sta kg65.d1+3
	clc
	lda kg65.d1
	adc kg65.t2
	sta kg65.d1
	lda kg65.d1+1
	adc kg65.t2+1
	sta kg65.d1+1
	lda kg65.d1+2
	adc kg65.t2+2
	sta kg65.d1+2
	lda kg65.d1+3
	adc #0
	sta kg65.d1+3
	bsr 6$			;d2=d2-t8+t5
	bsr 9$			;d2=d2+t9
	bra 1$			;while loop

	.page
; region 2

2$	lda kg65.cdx+1		;repeat
	taz			;quadplot pixel(x,y)
	lda kg65.cdx
	ldx kg65.cdy
	ldy kg65.cdy+1
	bsr kg65.s.quadplot	;plot around four side of x-axis
	lda kg65.drawmode
	beq 223$
	lda kg65.dpatype	;(circle & ellipse kludge for patterns)			[911007]
	and #%00000011
	tax
	lda kg65.patrbitnum
	inc a
	cmp kg65.c.patrbits,x	;	done all pattern bits?
	bcc 222$		;		br if no
	lda #0
222$	sta kg65.patrbitnum	;		else reset to beginning

223$	dew kg65.cdx		;x=x-1
	bsr 8$			;t8=t8-t6
	lda kg65.d2+3		;if d2 < 0 then
	bpl 4$
	inw kg65.cdy		;y=y+1
	bsr 7$			;t9=t9+t3
	bsr 6$			;d2=d2-t8+t5
	bsr 9$			;d2=d2+t9
	bra 5$

4$				;else
	bsr 6$			;d2=d2-t8+t5
5$	lda kg65.cdx+1
	bpl 2$			;until x < 0

	pla
	tab
;	cli			;remove
	clc
	rts

	.page
6$	sec			;d2=d2-t8+t5
	lda kg65.d2
	sbc kg65.t8
	sta kg65.d2
	lda kg65.d2+1
	sbc kg65.t8+1
	sta kg65.d2+1
	lda kg65.d2+2
	sbc kg65.t8+2
	sta kg65.d2+2
	lda kg65.d2+3
	sbc kg65.t8+3
	sta kg65.d2+3
	clc
	lda kg65.d2
	adc kg65.t5
	sta kg65.d2
	lda kg65.d2+1
	adc kg65.t5+1
	sta kg65.d2+1
	lda kg65.d2+2
	adc kg65.t5+2
	sta kg65.d2+2
	lda kg65.d2+3
	adc #0
	sta kg65.d2+3
	rts

7$	clc			;t9=t9+t3
	lda kg65.t9
	adc kg65.t3
	sta kg65.t9
	lda kg65.t9+1
	adc kg65.t3+1
	sta kg65.t9+1
	lda kg65.t9+2
	adc kg65.t3+2
	sta kg65.t9+2
	lda kg65.t9+3
	adc #0
	sta kg65.t9+3
	rts

8$	sec			;t8=t8-t6
	lda kg65.t8
	sbc kg65.t6
	sta kg65.t8
	lda kg65.t8+1
	sbc kg65.t6+1
	sta kg65.t8+1
	lda kg65.t8+2
	sbc kg65.t6+2
	sta kg65.t8+2
	lda kg65.t8+3
	sbc #0
	sta kg65.t8+3
	rts

9$	clc			;d2=d2+t9
	lda kg65.d2
	adc kg65.t9
	sta kg65.d2
	lda kg65.d2+1
	adc kg65.t9+1
	sta kg65.d2+1
	lda kg65.d2+2
	adc kg65.t9+2
	sta kg65.d2+2
	lda kg65.d2+3
	adc kg65.t9+3
	sta kg65.d2+3
	rts


;.end
	.page
	.subttl facet

;created	: 10/24/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;

; draw a solid triangle given three points

kg65.s.facet
	bsr kg65.s.sortx
	bsr kg65.s.findxy
	lda kg65.fxmin
	sta kg65.fx
	lda kg65.fxmin+1
	sta kg65.fx+1

2$	sec
	lda kg65.fx
	sbc kg65.fxmin
	sta kg65.fxdiff

	lda kg65.fdx1
	beq 3$
	sta kg65.fdx
	lda kg65.fdy1
	sta kg65.fdy
	lda kg65.fdy1+1
	sta kg65.fdy+1
	lda kg65.fflag1
	sta kg65.fflag
	lda kg65.fymin
	sta kg65.fybase
	lda kg65.fymin+1
	sta kg65.fybase+1
	bsr kg65.s.endpts
	sta kg65.fytop+1
	tza
	sta kg65.fytop

	lda kg65.fdx3
	beq 3$
	sta kg65.fdx
	lda kg65.fdy3
	sta kg65.fdy
	lda kg65.fdy3+1
	sta kg65.fdy+1
	lda kg65.fflag3
	sta kg65.fflag
	bsr kg65.s.endpts
	sta kg65.fybot+1
	tza
	sta kg65.fybot

	bsr kg65.s.vline

	lda kg65.fx+1
	cmp kg65.fxmid+1
	bne 4$
	lda kg65.fx
	cmp kg65.fxmid
	beq 3$

4$	inw kg65.fx
	bra 2$

3$	sec
	lda kg65.fx
	sbc kg65.fxmin
	sta kg65.fxdiff
	lda kg65.fdx3
	beq 5$
	sta kg65.fdx
	lda kg65.fdy3
	sta kg65.fdy
	lda kg65.fdy3+1
	sta kg65.fdy+1
	lda kg65.fflag3
	sta kg65.fflag
	lda kg65.fymin
	sta kg65.fybase
	lda kg65.fymin+1
	sta kg65.fybase+1
	bsr kg65.s.endpts
	sta kg65.fybot+1
	tza
	sta kg65.fybot

	sec
	lda kg65.fx
	sbc kg65.fxmid
	sta kg65.fxdiff
	lda kg65.fdx2
	beq 5$
	sta kg65.fdx
	lda kg65.fdy2
	sta kg65.fdy
	lda kg65.fdy2+1
	sta kg65.fdy+1
	lda kg65.fflag2
	sta kg65.fflag
	lda kg65.fymid
	sta kg65.fybase
	lda kg65.fymid+1
	sta kg65.fybase+1
	bsr kg65.s.endpts
	sta kg65.fytop+1
	tza
	sta kg65.fytop

	bsr kg65.s.vline

	lda kg65.fx+1
	cmp kg65.fxmax+1
	bne 6$
	lda kg65.fx
	cmp kg65.fxmax
	beq 5$

6$	inw kg65.fx
	bra 3$

5$	rts

	.page
kg65.s.sortx			;sort coord.'s so that smallest x is in min, then mid,max
	bsr 2$			;fix negatives
	ldx #2
3$	sec
	lda kg65.fxmid
	sbc kg65.fxmin
	lda kg65.fxmid+1
	sbc kg65.fxmin+1
	bcs 1$			;br if min < mid
	bsr kg65.s.swap12

1$	dex
	beq 2$
	sec
	lda kg65.fxmax
	sbc kg65.fxmid
	lda kg65.fxmax+1
	sbc kg65.fxmid+1
	bcs 3$			;br if mid < max
	bsr kg65.s.swap23
	bra 3$

2$	lda kg65.fxmin+1
	eor #$80		;add $8000 to sort negative numbers properly		[910923] FAB
	sta kg65.fxmin+1
	lda kg65.fxmid+1
	eor #$80
	sta kg65.fxmid+1
	lda kg65.fxmax+1
	eor #$80
	sta kg65.fxmax+1
	rts

	.page
kg65.s.swap12			;swap min and mid
	phx
	ldx #3
1$	lda kg65.fxmin,x
	pha
	lda kg65.fxmid,x
	sta kg65.fxmin,x
	pla
	sta kg65.fxmid,x
	dex
	bpl 1$
	plx
	rts


kg65.s.swap23			;swap mid and max
	phx
	ldx #3
1$	lda kg65.fxmid,x
	pha
	lda kg65.fxmax,x
	sta kg65.fxmid,x
	pla
	sta kg65.fxmax,x
	dex
	bpl 1$
	plx
	rts

	.page
kg65.s.findxy			;calc dx, dy b/w all three points
	sec
	lda kg65.fxmid		;	mid-min
	sbc kg65.fxmin
	sta kg65.fdx1
	lda kg65.fxmid+1
	sbc kg65.fxmin+1
	sta kg65.fdx1+1

	sec
	lda kg65.fxmax		;	max-mid
	sbc kg65.fxmid
	sta kg65.fdx2
	sec
	lda kg65.fxmax		;	max-min
	sbc kg65.fxmin
	sta kg65.fdx3

	lda #0
	sta kg65.fflag1
	sta kg65.fflag2
	sta kg65.fflag3

	bsr 4$			;fix negative numbers				[910923] FAB
	sec
	lda kg65.fymid
	sbc kg65.fymin
	sta kg65.fdy1
	lda kg65.fymid+1
	sbc kg65.fymin+1
	bcs 1$

	inc kg65.fflag1		;indicate fymin > fymid
	sec
	lda kg65.fymin
	sbc kg65.fymid
	sta kg65.fdy1
	lda kg65.fymin+1
	sbc kg65.fymid+1

1$	sta kg65.fdy1+1
	sec
	lda kg65.fymax
	sbc kg65.fymid
	sta kg65.fdy2
	lda kg65.fymax+1
	sbc kg65.fymid+1
	bcs 2$

	inc kg65.fflag2		;indicate fymid > fymax
	sec
	lda kg65.fymid
	sbc kg65.fymax
	sta kg65.fdy2
	lda kg65.fymid+1
	sbc kg65.fymax+1

2$	sta kg65.fdy2+1
	sec
	lda kg65.fymax
	sbc kg65.fymin
	sta kg65.fdy3
	lda kg65.fymax+1
	sbc kg65.fymin+1
	bcs 3$

	inc kg65.fflag3		;indicate fymin > fymax
	sec
	lda kg65.fymin
	sbc kg65.fymax
	sta kg65.fdy3
	lda kg65.fymin+1
	sbc kg65.fymax+1

3$	sta kg65.fdy3+1

4$	lda kg65.fymin+1	;handle negative numbers		[910923] FAB
	eor #$80
	sta kg65.fymin+1
	lda kg65.fymid+1
	eor #$80
	sta kg65.fymid+1
	lda kg65.fymax+1
	eor #$80
	sta kg65.fymax+1
	rts

	.page
kg65.s.endpts
	lda kg65.fxdiff+1
	taz
	lda kg65.fxdiff
	inw kg65.fdy		;		rounding patch????		[910923] FAB
	ldx kg65.fdy
	ldy kg65.fdy+1
	dew kg65.fdy		;		rounding patch????		[910923] FAB
	bsr kg65.s.mulply32	;returns x,y
	lda kg65.fdx
	inc a			;		rounding patch????		[910923] FAB
	bsr kg65.s.divide	;x,y / a
	stx kg65.temp1
	sty kg65.temp2
	lda kg65.fflag
	bne 1$
	clc
	lda kg65.fybase
	adc kg65.temp1
	taz
	lda kg65.fybase+1
	adc kg65.temp2
;	bcc 2$
	rts			;						[910923] FAB

1$	sec
	lda kg65.fybase
	sbc kg65.temp1
	taz
	lda kg65.fybase+1
	sbc kg65.temp2
2$	rts


kg65.s.vline
	lda kg65.fx
	sta kg65.parm1		;x0
	sta kg65.parm5		;x1
	lda kg65.fx+1
	sta kg65.parm2
	sta kg65.parm6

	lda kg65.fytop
	sta kg65.parm3		;y0
	lda kg65.fytop+1
	sta kg65.parm4

	lda kg65.fybot
	sta kg65.parm7		;y1
	lda kg65.fybot+1
	sta kg65.parm8

	bra kg65.line_patr

;.end
	.page
	.subttl blitter

;created	: 11/21/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;

	clc			;????
kg65.copy
;copy x,y,dx,dy
;	sei
	tba
	pha
	lda #kg65.l.basepage
	tab

	ldx #7
2$	lda kg65.parm1,x
	sta kg65.area.x,x
	dex
	bpl 2$

	lda #1
	sta kg65.area.cmd
	bra kg65.s.bltread

	.page
	clc			;????
kg65.cut
;cut x,y,dx,dy
;	sei
	tba
	pha
	lda #kg65.l.basepage
	tab

	ldx #7
2$	lda kg65.parm1,x
	sta kg65.area.x,x
	dex
	bpl 2$

	lda #2
	sta kg65.area.cmd
	bra kg65.s.bltread


	clc			;????
kg65.viewpclr
;viewport clear x,y,dx,dy
;	sei
	tba
	pha
	lda #kg65.l.basepage
	tab

	ldx #7
2$	lda kg65.parm1,x
	sta kg65.area.x,x
	dex
	bpl 2$

	lda #0
	sta kg65.area.cmd
	bra kg65.s.bltread

	.page
kg65.s.bltread			;blitter read
	lda kg65.area.x
	sta kg65.area.save.x
	and #%00000111
	sta kg65.area.b2sl
	lda kg65.area.x		;x rounded down
	and #%11111000
	sta kg65.area.x
	clc
	lda kg65.area.b2sl	;(b2sl + dx)/8 rounded up = # of bytes in scanline
	adc kg65.area.dx
	tay
	and #%00000111
	sta kg65.area.bor 	;# of bits in last byte of scanline  0 = all 8 bits
	lda #0
	adc kg65.area.dx+1
	bsr kg65.s.divby8	;y=lo a=hi
	sty kg65.area.bwidth
	lda kg65.area.bor	;round up logic
	beq 1$
	inc kg65.area.bwidth

1$	lda kg65.area.cmd
	beq 8$			;br if viewport clear
	bsr kg65.s.write.header

8$	lda #0			;init temp dy
	sta kg65.area.txy
	sta kg65.area.txy+1
	lda kg65.area.y		;init y & x
	sta kg65.liney0
	lda kg65.area.y+1
	sta kg65.liney0+1
	lda kg65.area.x
	sta kg65.linex0
	lda kg65.area.x+1
	sta kg65.linex0+1

4$				;for each scanline
	lda #0			;preserve linex0
	sta kg65.area.bpn	;bitplane #
	inc a
	sta kg65.area.bpc	;bitplane bit code
	bsr kg65.s.calcadr 	;scanline flag set in this routine

5$				;for each bitplane
	lda kg65.drawscrbp 	;test if bitplane used in drawscreen
	and kg65.area.bpc
	beq 7$			;br if no
	lda kg65.linedsadr 	;init draw screen low level address
	sta kg65.dsadr
	lda kg65.linedsadr+1
	sta kg65.dsadr+1
	lda kg65.area.cmd
	beq 9$

; copy & cut extra logic

	bsr kg65.s.read.scanline	;returns w/ y = bwidth
	dey
	ldx kg65.area.bor
	lda kg65.c.maskr,x
	eor #%11111111
	and kg65.l.scanline,y
	sta kg65.l.scanline,y
	bsr kg65.s.shiftleft
	bsr kg65.s.scanline.2.output
	lda kg65.area.cmd
	cmp #2			;br if cut command
	bne 7$

11$	lda kg65.linedsadr
	sta kg65.dsadr
	lda kg65.linedsadr+1
	sta kg65.dsadr+1

9$	bsr kg65.s.clr.scanline

7$	inc kg65.area.bpn	;next bitplane#
	asl kg65.area.bpc	;next bitplane code
	bcc 5$			;br if not shift out of 7th bit
	inw kg65.area.txy	;temp dy++
	inw kg65.liney0		;y++
	lda kg65.area.txy	;all scanlines done?
	cmp kg65.area.dy
	bne 4$
	lda kg65.area.txy+1
	cmp kg65.area.dy+1
	bne 4$			;br if no
	pla
	tab
;	cli
	clc
	rts

	.page
	.subttl  LOADIFF, CUT, PASTE

;parm1 = channel #								[910402] FAB

	clc			;????
kg65.load			;load IFF
;	sei			; (File was opened by BASIC and will be closed by BASIC)
;	lda kg65.l.basepage*256+kg65.parm1
;	sta c65.io.flen
;	lda kg65.l.basepage*256+kg65.parm2
;	sta c65.io.fadlo
;	lda kg65.l.basepage*256+kg65.parm3
;	sta c65.io.fadhi

	tba
	pha
	lda #kg65.l.basepage		;Get graphics base page
	tab

;	ldx #3
;	lda #0
;1$	sta kg65.parm1,x
;	dex
;	bpl 1$

	lda #$ff			;kg65.l.basepage*256+kg65.parm1			[911119]
	sta kg65.parm16			;disk I/O flag = channel# (not RAM)
	inc a				;=0
	sta kg65.parm1
	sta kg65.parm2
	sta kg65.parm3
	sta kg65.parm4

	bra kg65.s.paste

	.page
	clc				;????
kg65.paste				;paste x,y
;	sei
	tba
	pha
	lda #kg65.l.basepage		;Get graphics base page
	tab

	lda #0
	sta kg65.parm16			;ram I/O flag

kg65.s.paste
	ldx #3
2$	lda kg65.parm1,x
	sta kg65.area.x,x
	dex
	bpl 2$

	bsr kg65.s.read.header		;dx,dy set to brush size. alter for paste size
;	bcs 99$				;	error				[910402] FAB

;;	sei				;					[911119]
;	lda #kg65.l.basepage
;	tab
	sec				;(draw screen width - brush x)
	ldy kg65.drawscrwidth
	lda kg65.c.widthtabl,y
	sbc kg65.area.x
	sta kg65.area.txy
	lda kg65.c.widthtabh,y
	sbc kg65.area.x+1
	sta kg65.area.txy+1

	lda kg65.area.txy		;if txy < brush dx
	cmp kg65.area.dx
	lda kg65.area.txy+1
	sbc kg65.area.dx+1
	bcs 13$				;	br if txy >= dx

	lda kg65.area.txy		;then paste dx = txy
	sta kg65.area.dx
	lda kg65.area.txy+1
	sta kg65.area.dx+1

13$	sec				;else  paste dx = brush dx  which is already done
	ldy kg65.drawscrheight		;(draw screen height - brush y)
	lda kg65.c.heightabl,y
	sbc kg65.area.y
	sta kg65.area.txy
	lda kg65.c.heightabh,y
	sbc kg65.area.y+1
	sta kg65.area.txy+1

	lda kg65.area.txy		;if txy < brush dy
	cmp kg65.area.dy
	lda kg65.area.txy+1
	sbc kg65.area.dy+1
	bcs 15$				;	br if txy >= dy

	lda kg65.area.txy		;then paste dy = txy
	sta kg65.area.dy
	lda kg65.area.txy+1
	sta kg65.area.dy+1

15$	lda kg65.area.x			;else  paste dy = brush dy  which is already done
	and #%00000111
	sta kg65.area.b2sl
	lda kg65.area.x			;x rounded down
	and #%11111000
	sta kg65.area.x
	clc
	lda kg65.area.b2sl
	adc kg65.area.dx
	tay
	and #%00000111
	sta kg65.area.bor
	lda #0
	adc kg65.area.dx+1
	bsr kg65.s.divby8		;y=lo,	a=hi
	sty kg65.area.bwidth
	lda kg65.area.bor
	beq 1$
	inc kg65.area.bwidth

1$	lda #0
	sta kg65.area.txy
	sta kg65.area.txy+1
	lda kg65.area.y
	sta kg65.liney0
	lda kg65.area.y+1
	sta kg65.liney0+1
	lda kg65.area.x
	sta kg65.linex0
	lda kg65.area.x+1
	sta kg65.linex0+1

4$	lda #0
	sta kg65.area.bpn		;bitplane #
	inc a
	sta kg65.area.bpc		;bitplane bit code
	bsr kg65.s.calcadr

5$	lda kg65.drawscrbp
	and kg65.area.bpc
	beq 7$
	lda kg65.linedsadr
	sta kg65.dsadr
	lda kg65.linedsadr+1
	sta kg65.dsadr+1

	lda kg65.area.depth		;brush depth <= screen depth
	cmp kg65.drawscrdepth
	bcc 10$				;	br if yes
	beq 10$
	bra 7$				;just read remaining brush bitplanes for current scanline

10$	lda kg65.drawscrdepth		;screen depth <= brush depth
	cmp kg65.area.depth
	bcc 11$				;br if yes
	beq 11$
	bsr kg65.s.clr.scanline
	bra 7$

11$	bsr kg65.s.input.2.scanline
	bsr kg65.s.shiftright
	bsr kg65.s.paste.scanline

7$
;	jsr c65.stop			;						[910402] FAB
;	beq stop_key_exit		;	exit if stop key down
	bit $dc01			;because kernel ram not in context and I'm lazy
	bpl stop_key_exit

	inc kg65.area.bpn
	asl kg65.area.bpc
	bcc 5$
	inw kg65.area.txy
	inw kg65.liney0
	lda kg65.area.txy
	cmp kg65.area.dy
	bne 4$
	lda kg65.area.txy+1
	cmp kg65.area.dy+1
	bne 4$

;	bbr7 kg65.parm16,8$		;I/O flag:	branch if internal structure
;	bsr kg65.s.CloseIFF		;		else close IFF file
					;		(file will be closed by BASIC)
8$	pla
	tab
;	cli
	lda #0				;no error #
	tax
	clc				;success
	rts

;99$	pla				;					[910402] FAB
;	tab
;	cli
;	txa				;error #
;	sec
;	rts

	.page
kg65.s.shiftleft
	lda kg65.area.b2sl		;a=# of bits to shift left
	beq 3$
	sta kg65.temp1

1$	ldx kg65.area.bwidth		;# of columns	1 - 255
	dex				;adjusted for indexing
	clc				;bring a zero into bit on right
	asl kg65.l.scanline,x		;shift bit left
	php				;save carry bit setting
	dex				;prev. byte of buffer
	cpx #255
	beq 4$

2$	plp				;restore carry bit setting
	rol kg65.l.scanline,x		;continue to shift bits left
	php				;save carry it setting
	dex				;prev. byte
	cpx #255
	bne 2$				;br until all columns down

4$	plp				;restore carry bit setting and take off stack
	dec kg65.temp1			;br if more bits to shift
	bne 1$

3$	rts


kg65.s.shiftright
	lda kg65.area.b2sl
	beq 3$
	sta kg65.temp1

1$	ldy kg65.area.bwidth		;# of columns  1 - 255
	ldx #1
	clc
	lsr kg65.l.scanline

2$	ror kg65.l.scanline,x
	inx
	dey
	bne 2$
	dec kg65.temp1
	bne 1$

3$	rts

	.page
kg65.s.maskleft
	sta kg65.area.brush
	ldy kg65.area.b2sl
	lda kg65.c.maskl,y
	bra kg65.s.merge

kg65.s.maskright
	sta kg65.area.brush
	ldy kg65.area.bor
	lda kg65.c.maskr,y
	bra kg65.s.merge

kg65.s.masklr
	sta kg65.area.brush
	ldy kg65.area.b2sl
	lda kg65.c.maskl,y
	sta kg65.area.mask
	ldy kg65.area.bor
	lda kg65.c.maskr,y
	ora kg65.area.mask
	bra kg65.s.merge

kg65.s.merge
	sta kg65.area.mask
	eor #255
	and kg65.area.brush
	sta kg65.area.t2
	lda kg65.drawscrbyte
	and kg65.area.mask
	ora kg65.area.t2
	rts

kg65.s.clr.scanline
	lda kg65.drawscrpen1
	and kg65.area.bpc
	beq 1$
	lda #255
     ;	  .byte $2c			;						[911119]
1$   ;	lda #0
	sta kg65.area.brush

	ldy kg65.area.bwidth		;						[911119]
4$	sta kg65.l.scanline-1,y
	dey
	bne 4$

	.page
kg65.s.paste.scanline
	ldx kg65.area.bpn
;	rmb7 kg65.datflag		;						[910506]
	bsr kg65.s.readdsbyte.nodat
;	rmb7 kg65.datflag		;						[910506]
	lda kg65.area.bwidth
	cmp #1
	beq 2$
	lda kg65.l.scanline
	bsr kg65.s.maskleft
	sta kg65.l.scanline
	ldx #8
	ldy #0
	lda kg65.area.bwidth
	dec a				;get last byte of area scanline
	bsr kg65.s.mulply
	stx kg65.temp1
	sty kg65.temp2
	clc
	lda kg65.dsadr
	adc kg65.temp1
	sta kg65.dsadr
	lda kg65.dsadr+1
	adc kg65.temp2
	sta kg65.dsadr+1
	ldx kg65.area.bpn
;	rmb7 kg65.datflag		;						[910506]
	bsr kg65.s.readdsbyte.nodat
;	rmb7 kg65.datflag		;						[910506]
	ldy kg65.area.bwidth
	dey
	lda kg65.l.scanline,y
	bsr kg65.s.maskright
	ldy kg65.area.bwidth
	dey
	sta kg65.l.scanline,y
	lda kg65.linedsadr
	sta kg65.dsadr
	lda kg65.linedsadr+1
	sta kg65.dsadr+1
	bra 3$

2$	lda kg65.l.scanline
	bsr kg65.s.masklr
	sta kg65.l.scanline

3$					;Fall into kg65.s.write.scanline		[911119] FAB
;	bsr kg65.s.write.scanline
;	rts

	.page
kg65.s.write.scanline			;dsadr set, bwidth=# of bytes to write from scanline buffer
;	ldy #0
;	sty kg65.datflag		;						[910506]
;2$	sty kg65.temp3			;pointer to the byte to write
;	lda kg65.l.scanline,y
;	sta kg65.drawscrbyte		;the byte to write
	ldx kg65.area.bpn		;the bitplane to write to
;????	bsr kg65.s.writedsbyte.nodat

;Use DMA device to copy scanline buffer into display memory				[911119] FAB

	bbr0 kg65.scanlineflag,10$
	lda kg65.dsbp0adr,x		;odd scanline
	and #%11100000			;	keep only odd hi 3 bits of blk addr
	bra 20$

10$	lda kg65.dsbp0adr,x		;even scanline
	and #%00001110			;	keep only even hi 3 bits of blk addr
	asl a
	asl a
	asl a
	asl a				;make into real hi byte addr

20$	lsr a
	ldy kg65.drawscrwidth
	beq 30$
	ora #$08			;set 640/1280 bit (M11)
30$ ;	ldy kg65.drawscrheight
;	beq 40$
;	ora #$80			;set 200/400 bit (M15) (not required)
40$	sta c65.dma2_list+11		;scrloc = high 3 bits of bp_adr in bits 6:4

	lda #>kg65.l.scanline
	sta c65.dma2_list+4		;source hi
	lda #<kg65.l.scanline
	sta c65.dma2_list+3		;source lo
;	lda #0
	sta c65.dma2_list+5		;source bank			(???? system bank ????)

	lda kg65.liney0+1
	lsr a
	lda kg65.liney0
	ror a
	ldy kg65.drawscrheight		;adjust for 200/400 screens
	beq 50$
	lsr a
50$	sta c65.dma2_list+7		;destination hi (scanline #)
	lda #0
	ror a
	sta c65.dma2_list+6		;destination lo (column #)
	txa				;bitplane#
	and #%00000001			;determine if even=0 or odd=1; this is also logical bank#
	ora kg65.banka
	sta c65.dma2_list+8		;destination bank

	lda kg65.area.bwidth
	sta c65.dma2_list+1		;columns (cntlo)
	lda #1
	sta c65.dma2_list+2		;rows (cnthi) = 1 scanline

	lda #$0c
	sta c65.dma2_list+9		;command hi = source normal, dest uses XYmode
	lda #0
	sta c65.dma2_list		;command lo = copy

	sta c65.dma_ctlr+2		;dma list bank			(???? system bank ????)
	clc
	lda #128
	sbc kg65.area.bwidth
	sta c65.dma2_list+10		;xymod = 128-width+1

	lda #>c65.dma2_list		;		high
	sta c65.dma_ctlr+1
	lda #<c65.dma2_list		;		low & trigger
	sta c65.dma_ctlr

;;	rmb7 kg65.datflag		;						[910506]
;	clc
;	lda kg65.dsadr
;	adc #8
;	sta kg65.dsadr
;	bcc 1$
;	inc kg65.dsadr+1
;
;1$	ldy kg65.temp3
;	iny
;	cpy kg65.area.bwidth
;	bcc 2$
	rts

	.page
kg65.s.read.scanline			;dsadr set  bwidth=# of bytes to read
;	ldy #0
;	sty kg65.datflag		;						[910506]
;2$	sty kg65.temp3			;pointer to where to put the byte
	ldx kg65.area.bpn		;the bitplane to read from
;????	bsr kg65.s.readdsbyte.nodat

;Use DMA device to copy a scanline from memory into scanline buffer			[911119] FAB

	bbr0 kg65.scanlineflag,10$
	lda kg65.dsbp0adr,x		;odd scanline
	and #%11100000			;	keep only odd hi 3 bits of blk addr
	bra 20$

10$	lda kg65.dsbp0adr,x		;even scanline
	and #%00001110			;	keep only even hi 3 bits of blk addr
	asl a
	asl a
	asl a
	asl a				;make into real hi byte addr

20$	lsr a
	ldy kg65.drawscrwidth
	beq 30$
	ora #$08			;set 640/1280 bit (M11)
30$ ;	ldy kg65.drawscrheight
;	beq 40$
;	ora #$80			;set 200/400 bit (M15) (not required)
40$	sta c65.dma2_list+11		;scrloc = high 3 bits of bp_adr in bits 6:4

	lda #>kg65.l.scanline
	sta c65.dma2_list+7		;destination hi
	lda #<kg65.l.scanline
	sta c65.dma2_list+6		;destination lo
;	lda #0
	sta c65.dma2_list+8		;destination bank		(???? system bank ????)

	lda kg65.liney0+1
	lsr a
	lda kg65.liney0
	ror a
	ldy kg65.drawscrheight		;adjust for 200/400 screens
	beq 50$
	lsr a
50$	sta c65.dma2_list+4		;source hi (scanline #)
	lda #0
	ror a
	sta c65.dma2_list+3		;source lo (column #)
	txa				;bitplane#
	and #%00000001			;determine if even=0 or odd=1; this is also logical bank#
	ora kg65.banka
	sta c65.dma2_list+5		;source bank

	lda kg65.area.bwidth
	sta c65.dma2_list+1		;columns (cntlo)
	lda #1
	sta c65.dma2_list+2		;rows (cnthi) = 1 scanline

	lda #$03
	sta c65.dma2_list+9		;command hi = source uses XYmode, dest normal
	lda #0
	sta c65.dma2_list		;command lo = copy

	sta c65.dma_ctlr+2		;dma list bank			(???? system bank ????)
	clc
	lda #128
	sbc kg65.area.bwidth
	sta c65.dma2_list+10		;xymod = 128-width+1

	lda #>c65.dma2_list		;		high
	sta c65.dma_ctlr+1
	lda #<c65.dma2_list		;		low & trigger
	sta c65.dma_ctlr

;;	rmb7 kg65.datflag		;						[910506]
;	ldy kg65.temp3
;	sta kg65.l.scanline,y
;	clc
;	lda kg65.dsadr
;	adc #8
;	sta kg65.dsadr
;	bcc 1$
;	inc kg65.dsadr+1
;
;1$	iny
;	cpy kg65.area.bwidth
;	bcc 2$
	ldy kg65.area.bwidth		;return with y=bwidth
	rts

	.page
kg65.s.write.header			;determine if output is to iff routine or internal structure
	lda kg65.area.save.x		;internal structure logic
	sta kg65.l.temp.brush
	lda kg65.area.x+1
	sta kg65.l.temp.brush+1
	lda kg65.area.y
	sta kg65.l.temp.brush+2
	lda kg65.area.y+1
	sta kg65.l.temp.brush+3
	lda kg65.area.dx
	sta kg65.l.temp.brush+4
	lda kg65.area.dx+1
	sta kg65.l.temp.brush+5
	lda kg65.area.dy
	sta kg65.l.temp.brush+6
	lda kg65.area.dy+1
	sta kg65.l.temp.brush+7
	lda kg65.drawscrdepth
	sta kg65.l.temp.brush+8
	lda kg65.area.bwidth
	sta kg65.l.temp.brush+9
	lda #<kg65.l.temp.brush+10
	sta kg65.bpptr1
	lda #>kg65.l.temp.brush+10
	sta kg65.bpptr1+1
	rts

	.page
kg65.s.read.header
	bbs7 kg65.parm16,kg65.s.OpenIFFr	;branch if input is from iff routine

1$	lda kg65.l.temp.brush+4			;else it's from internal structure
	sta kg65.area.dx
	lda kg65.l.temp.brush+5
	sta kg65.area.dx+1
	lda kg65.l.temp.brush+6
	sta kg65.area.dy
	lda kg65.l.temp.brush+7
	sta kg65.area.dy+1
	lda kg65.l.temp.brush+8
	sta kg65.area.depth
	lda kg65.l.temp.brush+9
	sta kg65.area.brushwidth
	lda #<kg65.l.temp.brush+10
	sta kg65.bpptr1
	lda #>kg65.l.temp.brush+10
	sta kg65.bpptr1+1
	rts

	.page
kg65.s.scanline.2.output		;determine if output is to iff routine or internal structure
	ldy #0				;internal structure logic
1$	lda kg65.l.scanline,y
	sta (kg65.bpptr1),y
	iny
	cpy kg65.area.bwidth
	bcc 1$

	clc
	lda kg65.bpptr1
	adc kg65.area.bwidth
	sta kg65.bpptr1
	bcc 2$
	inc kg65.bpptr1+1
2$	rts


kg65.s.input.2.scanline
	bbr7 kg65.parm16,3$			;branch if input is from internal structure
	bsr kg65.s.GetRaster			;else input from IFF file
	bra 4$

3$	ldy #0					;internal structure
1$	lda (kg65.bpptr1),y
	sta kg65.l.scanline,y
	iny
	cpy kg65.area.brushwidth
	bcc 1$

4$	clc
	lda kg65.bpptr1
	adc kg65.area.brushwidth		;next scanline
	sta kg65.bpptr1
	bcc 2$
	inc kg65.bpptr1+1
2$	rts

;.end
	.page
	.subttl LoadIFF

;created	: 10/27/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom


kg65.s.OpenIFFr
;;	sei
;	tba
;	pha
	lda #0
;	tab
	sta kg65.loadbufrflag							[911119] FAB

;	lda c65.io.flen								[910402] FAB
;	ldx c65.io.fadlo
;	ldy c65.io.fadhi
;	bsr c65.setnam			;File was opened by BASIC and will be closed by BASIC
;	lda #8
;	ldx #8
;	ldy #8
;	bsr c65.setlfs
;	bsr c65.open			;open file for input
;	ldx #8
;	bsr c65.chkin

	.page
	ldx #4				;get FORM
	bsr kg65.s.getXbytes

	ldy #3
1$	lda kg65.l.bytebuffer,y
	cmp kg65.c.form,y
	bne kg65.liff.e1
	dey
	bpl 1$

	ldx #4				;get length of FORM in ByteBuffer  (not needed by us)
	bsr kg65.s.getXbytes

	ldx #4				;get ILBM
	bsr kg65.s.getXbytes

	ldy #3
2$	lda kg65.l.bytebuffer,y
	cmp kg65.c.ilbm,y
	bne kg65.liff.e2
	dey
	bpl 2$

	ldx #4				;get BMHD
	bsr kg65.s.getXbytes

	ldy #3
3$	lda kg65.l.bytebuffer,y
	cmp kg65.c.bmhd,y
	bne kg65.liff.e3
	dey
	bpl 3$

	ldx #4				;get BMHD length
	bsr kg65.s.getXbytes

; Get in BMHD info using length from previous data.
; ByteBuffer+3 holds least significant byte of BMHD length.
; So far all IFF BMHD files are twenty bytes long.

	ldx kg65.l.bytebuffer+3
	bsr kg65.s.getXbytes

	lda kg65.l.bytebuffer		;get pict width in pixels
	sta kg65.area.dx+1
	tay
	lda kg65.l.bytebuffer+1
	sta kg65.area.dx

	ldx #3
	sta kg65.area.brushwidth	;dx lo
	tya				;a = dx hi
4$	lsr a
	ror kg65.area.brushwidth
	dex
	bne 4$

	lda kg65.l.bytebuffer+2		;get pict height in scanlines
	sta kg65.area.dy+1
	lda kg65.l.bytebuffer+3
	sta kg65.area.dy

; Dest X and Y in bytes 4-7
; This could be initialized to 0 by the IFF SAVE routine and
; simply ignored if we want.  Or we can save the coordinates
; of the saved ILBM and load it back (if we want to).

;  lda kg65.l.bytebuffer+4
;  sta kg65.l.basepage*256+kg65.area.x+1
;  lda kg65.l.bytebuffer+5
;  sta kg65.l.basepage*256+kg65.area.x
;  lda kg65.l.bytebuffer+6
;  sta kg65.l.basepage*256+kg65.area.y+1
;  lda kg65.l.bytebuffer+7
;  sta kg65.l.basepage*256+kg65.area.y

	lda kg65.l.bytebuffer+8		;get Depth (this does not include any mask bitplane)
	dec a				;adjust depth 1-8 to 0-7 to match internal encoding
	sta kg65.area.depth

	.page
; get Mask Flag
; if maskflag=0 then no mask is present
;    maskflag=1 then maskhasmask
;			An extra 'mask' bitplane is present and
;			should be included in the decoding.  It
;			remains to be seen what to do with it, but
;			for now it is discarded.
;    maskflag=2 then maskHasTransparentColor
;			This means use the data found in Transparent
;			color (below) as the color to be used as a
;			transparent color.
;    maskflag=3 then mskLasso
;			This is a MacPaint like lasso mask. Ignore

	lda kg65.l.bytebuffer+9
	sta kg65.area.maskflag

	lda kg65.l.bytebuffer+10		;get Compression Flag
	sta kg65.area.compressflag

	lda kg65.l.bytebuffer+12		;ignore pad byte (ByteBuffer+11)
	sta kg65.area.transparentcolor
	lda kg65.l.bytebuffer+13
	sta kg65.area.transparentcolor+1

; ignore x&y aspect ratio, pg wd & ht
; 6 bytes total ByteBuffer+14 to ByteBuffer+19

	.page
	;========================
	; Descendent Chunk Parser
	;========================

kg65.s.GetChunkHeader			;get next chunk header
	ldx #4
	bsr kg65.s.getXbytes

	ldy #3
1$	lda kg65.l.bytebuffer,y
	cmp kg65.c.camg,y
	bne 3$
	dey
	bpl 1$

	bsr kg65.s.HandleCAMG
	bra kg65.s.GetChunkHeader

3$	ldy #3				;check to see if it is a CMAP chunk
2$	lda kg65.l.bytebuffer,y
	cmp kg65.c.cmap,y
	bne 4$
	dey
	bpl 2$

	bsr kg65.s.HandleCMAP
	bra kg65.s.GetChunkHeader

4$	ldy #3				;check to see if it is a BODY chunk
5$	lda kg65.l.bytebuffer,y
	cmp kg65.c.body,y
	bne 6$
	dey
	bpl 5$
	bra kg65.s.HandleBODY		;w/ RTS------------------------------------------->>>

6$	ldx #4				;no, it is some unknown chunk so get the length,
	bsr kg65.s.getXbytes		;    pull it in and discard

	ldy kg65.l.bytebuffer+2		;now get data from unknown chunk
	ldx kg65.l.bytebuffer+3
	bsr kg65.s.getNbytes

;	bcc kg65.s.GetChunkHeader	;					[910402] FAB

	ldz c65.io.status		;$90 (LDZ: kludge to load from system base page!)
	tza				;	serial: err if dnp, r/w timeout errors	[911119]
	and #%10000111			;	rs232:	err if brk, ovr, frm, par errors
	beq kg65.s.GetChunkHeader

	.page

disk_error_exit				;					[910402] FAB
	ldx #41				;FILE READ error
	  .byte $2c

kg65.liff.e1
;	ldx #1
;	  .byte $2c
kg65.liff.e2
;	ldx #2
;	  .byte $2c
kg65.liff.e3
;	ldx #3
	ldx #24				;indicates FILE DATA error

;	stx kg65.l.basepage*256+kg65.errortype
;	sei
	lda #0				;					[910402] FAB
	tab
	txa
	ldx #$fa-2-2			;????????????? gotta blow back to call ????????????
	txs
	tax
	sec
;	cli
	rts


stop_key_exit				;					[910528] FAB
	lda #0
	tab
	ldx #$fa-2-2			;????????????? gotta blow back to call ????????????
	txs

	lda #$7f
	sta c65.io.status+1		;$91 (I'll hate myself for this later)	[910528] FAB
	ldx #30				;BREAK error
	sec
	rts

	.page
kg65.s.HandleCMAP
; get palette info and set palette
; get number of bytes of palette
; making sure it is an even number of bytes
; if not add a pad byte

	ldx #4					;get len
	bsr kg65.s.getXbytes

	lda kg65.l.bytebuffer+2
	sta kg65.chunklen+1
	lda kg65.l.bytebuffer+3
	sta kg65.chunklen
	lsr a					;put bit 0 in carry flag
	bcc 1$					;if bit 0 is clear, then number of bytes is even

; if bit 0 is set, then this is an odd chunksize and must be
; incremented by one to get pad byte into size

	inw kg65.chunklen		;						[911119]
1$	lda #0
	sta kg65.parm2			;color#

14$	lda kg65.drawscreen		;draw screen idx
	lsr a
	lsr a				;divide by 4 to get draw screen #
	sta kg65.parm1			;changed in setpalette routine

13$	lda kg65.chunklen+1
	bne 10$				;if not zero there are lots of triplets left
	ldx kg65.chunklen
	cpx #3
	bcc 2$				;if less than three bytes then finish up

10$	ldx #3				;now get color triplets
	bsr kg65.s.getXbytes

	ldy #0
12$	lda kg65.l.bytebuffer,y		;data from ByteBuffer
	lsr a				;shift it right 4 times
	lsr a
	lsr a
	lsr a
	sta kg65.l.basepage*256+kg65.parm3,y	;RGB triplet storage area (no BP,Y)
	iny
	cpy #3
	bcc 12$
	bsr kg65.setpalette

;	sei				;set interrupt again. it was cleared in setpalette
	sec				;subtract 3 from length of cmap chunk
	lda kg65.chunklen
	sbc #3
	bcs 15$
	dec kg65.chunklen+1
15$	sta kg65.chunklen
	inc kg65.parm2
	bra 14$

2$	bsr kg65.s.getXbytes
99$	rts

	.page
kg65.s.HandleCAMG
; get a long word (4 bytes) indicating special amiga viewmodes
; this data would indicate modes such as halfbrite and ham

	ldx #4				;get len
	bsr kg65.s.getXbytes

	ldx kg65.l.bytebuffer+3		;get data
	bsr kg65.s.getXbytes

; At this point get viewmode data:
;	if viewmode is halfbrite fill color regs 32-63 with reg's 0-31 div 2
;	if it is ham mode get out with an error
;	if it is any 1.4 weird mode get out

	ldy #4-1					;			[911119]
1$	lda kg65.l.bytebuffer,y
	sta kg65.l.basepage*256+kg65.ViewModes,y	;(no BP,Y)
	dey
	bpl 1$

99$	rts



kg65.s.HandleBODY			;get data for bitmap

	ldx #4				;get length
	bsr kg65.s.getXbytes

	ldy #4-1			;save body length value
1$	lda kg65.l.bytebuffer,y
	sta kg65.l.basepage*256+kg65.chunklen,y		;(no BP,Y)
	dey
	bpl 1$

;;	sei
;	pla				;pop base page????		removed	[911119] FAB
;;	tab
	clc				;exit with carry clear to indicate success
	rts

	.page
kg65.s.GetRaster
;	sei				;begin decoding the file
;	tba
;	pha
	lda #0				;					[911119]
;	tab
	sta kg65.scanlineidx
	lda kg65.loadbufrflag
	bne 10$				;skip over initial load
	bsr kg65.s.LoadBuffer		;do initial load

10$	bsr kg65.s.nextbyte
	cmp #128
	bcc 30$
	beq 10$				;this is 128 so ignore it

					;Yes Compression
	neg a				;perform 2's complement
;	inc a				;the number of times to repeat the next value
	sta kg65.compresscount		; save n

	ldx kg65.compresscount
	bsr kg65.s.nextbyte
	ldy kg65.scanlineidx
20$	sta kg65.l.scanline,y
	iny
	dex
	bpl 20$
	bra 50$


30$ ;	inc a				;NO compression
;	sta kg65.compresscount
;	ldx #0

	tax
	ldy kg65.scanlineidx
40$	bsr kg65.s.nextbyte
	sta kg65.l.scanline,y
	iny
	dex
	bpl 40$

50$	sty kg65.scanlineidx
	cpy kg65.area.brushwidth	;in bytes
	bcc 10$				;not done so continue getting bytes
;	bra 60$

	.page
; if you have real data in the bitplane buffer
; load A with 0 and return, else load A with 1 and return
; before returning it may be necessary to continue to get
;  some data from file (discarding it as you go) if there
;  is still some data left on the raster in the file.  Always
;  exit here with the file pointer ready to grab the first byte
;  of the next raster when this routine is re-entered.

; do that here

; come back

60$
;;	sei
;	pla									[911119]
;	tab
;	lda #0
	rts




;kg65.s.CloseIFF
;;	sei			;File will be closed by BASIC		removed	[911119] FAB
;	tba
;	pha
;	lda #0
;	tab
;	clc			;nop
;	jsr c65.clrchn
;;	lda #8			;						[910402] FAB
;;	bsr c65.close
;;	sei
;	pla
;	tab
;	rts


	.page
kg65.s.nextbyte
	phx
	phy
	ldy kg65.bufferindex	;						[911119]
	lda kg65.l.bytebuffer,y
	iny
	sty kg65.bufferindex
	cpy kg65.buffersize
	bne 21$

	pha
	bsr kg65.s.LoadBuffer
	pla

21$	ply
	plx
	rts


kg65.s.getNbytes		;get bytes and throw them away
	stx kg65.temp1
	sty kg65.temp2
3$  ;	cpx #0
	txa
	bne 1$
 ;	cpy #0
	tya
	beq 2$
1$
;	ldx #8
;	jsr c65.chrin
	bsr read_byte
;	bcs 5$

;	lda kg65.temp1
;	bne 4$
;	dec kg65.temp2
;4$	dec kg65.temp1
	dew kg65.temp1		;						[911119]
	ldx kg65.temp1
	ldy kg65.temp2
	bra 3$

2$	clc
5$	rts


kg65.s.getXbytes
; This routine will get X (0-255) bytes from a currently opened device
; and leave them in ByteBuffer

	stx kg65.temp1
;	cpx #0
	txa
	beq 5$
;	ldx #8
	ldy #0
2$	bsr read_byte
;	jsr c65.chrin
;	bcs 6$
	sta kg65.l.bytebuffer,y
	iny
	cpy kg65.temp1
	bcc 2$

5$	clc
6$	rts

	.page
kg65.s.LoadBuffer
	lda #0
	sta kg65.bufferindex		;					[911119]
	sta kg65.buffersize
	inc a				; = 1
	sta kg65.loadbufrflag

	lda kg65.chunklen
	bne 1$
	lda kg65.chunklen+1
	bne 1$
	lda kg65.chunklen+2
	bne 1$

	ldx kg65.chunklen+3
	stx kg65.buffersize
	bsr kg65.s.getXbytes
	rts

1$	ldx #255
	bsr kg65.s.getXbytes
;	bcs 3$
;	ldx #8
;	jsr c65.chrin
	bsr read_byte			;kludge to get the 256-th byte
;	bcs 3$
	sta kg65.l.bytebuffer+255

	lda #$ff			;					[911119] FAB
	dec kg65.chunklen+2
	cmp kg65.chunklen+2
	bne 2$
	dec kg65.chunklen+1
	cmp kg65.chunklen+1
	bne 2$
	dec kg65.chunklen
2$	clc
3$	rts

;.end
	.page
	.subttl  SaveIFF

;created     : 11/03/90
;updated     : 11/08/91
;version     : 0.98
;author      : Louis R. Wallace
;dev system  : C128 hcd65ce02 assembler
;application : C65 kernal graphics rom
;
; parm1 = channel # ????							[910930] FAB

	clc			;????
kg65.saveiff			;Save IFF
;	sei
;	lda #$ff				;kg65.l.basepage*256+kg65.parm1
;	sta kg65.l.basepage*256+kg65.parm16	;disk I/O flag = channel# (not RAM)
;	lda kg65.l.basepage*256+kg65.parm1
;	sta c65.io.flen				;File has been opened by BASIC	[910930] FAB
;	lda kg65.l.basepage*256+kg65.parm2	;and will be closed by BASIC
;	sta c65.io.fadlo
;	lda kg65.l.basepage*256+kg65.parm3
;	sta c65.io.fadhi
;	tba
;	pha
;	lda #0
;	tab
;	sta kg65.l.basepage*256+kg65.loadbufrflag
;	lda c65.io.flen
;	ldx c65.io.fadlo
;	ldy c65.io.fadhi
;	bsr c65.setnam
;	lda #8
;	ldx #8
;	ldy #8
;	bsr c65.setlfs
;	bsr c65.open		;open file for output
;	ldx #8
;	bsr c65.chkout

	.page
;SaveIFF				;File has been opened by BASIC
	tba
	pha
	lda #kg65.l.basepage		;Get graphics' base page
	tab
					;Init vars
	lda #$ff			;kg65.parm1
	sta kg65.parm16			;disk I/O flag = channel# (not RAM)
					; (???? internal structures not implemented ????)
	sta CompressFlag		;0=none, 1=compressed
	jsr ClearChunkLen_1
	sta FormLen			;a=0
	sta FormLen+1
	sta FormLen+2
	sta FormLen+3
;	sta CompressFlag		;0=none, 1=compressed
	sta WhichPass			;initialize pass

	jsr WriteBMHD			;PASS 1 finds chunk lengths ---------------------------
	jsr WriteCMAP
	jsr WriteBODY

	inc WhichPass

	jsr WriteBMHD			;PASS 2 actually writes file --------------------------
	jsr WriteCMAP
	jsr WriteBODY

	pla				;Restore caller's base page
	tab
	clc				;success
	rts				;File will be closed by BASIC

	.page
WriteBMHD
	lda #<kg65.c.form		;'FORM'
	ldx #>kg65.c.form
	jsr WriteFourBytes
	
	lda #FormLen			;pointer to overall length of ILBM
	ldx #kg65.l.basepage
	jsr WriteFourBytes

	lda #<kg65.c.ilbm		;'ILBM'
	ldx #>kg65.c.ilbm
	jsr WriteFourBytes

	lda #<kg65.c.bmhd		;'BMHD'
	ldx #>kg65.c.bmhd
	jsr WriteFourBytes

	lda #BmhdLen			;pointer to length of BMHD chunk
	ldx #kg65.l.basepage
	jsr WriteFourBytes

;	lda kg65.drawscreen		;get screen index	???? save screen # ????
;	lsr a
;	lsr a				;divide by 4 to get draw screen #
;	tay
;	jsr kg65.s.xpdscrdata		;Expand screen table data from packed byte to seperate bytes
;	phz				;   (y=screen index, a=width, x=height, z=depth)
;	phx
;	pha

	jsr ClearChunkLen			;start counting BMHDlen			[911114] FAB

;	lda kg65.area.dx+1			;width hi/lo		(2)
	ldy kg65.drawscrwidth
	lda kg65.c.widthtabh,y
	jsr WriteByte
;	lda kg65.area.dx
	lda kg65.c.widthtabl,y
	jsr WriteByte

;	lda kg65.area.dy+1			;height hi/lo		(2)
	ldy kg65.drawscrheight
	lda kg65.c.heightabh,y
	jsr WriteByte
;	lda kg65.area.dy
	lda kg65.c.heightabl,y
	jsr WriteByte

;	lda kg65.area.x+1			;x-origin hi/lo		(2)
;	jsr WriteByte
;	lda kg65.area.x
;	jsr WriteByte
;	lda kg65.area.y+1			;y-origin hi/lo		(2)
;	jsr WriteByte
;	lda kg65.area.y
;	jsr WriteByte
	lda #0
	jsr WriteByte
	lda #0
	jsr WriteByte
	lda #0
	jsr WriteByte
	lda #0
	jsr WriteByte

;	lda kg65.area.depth			;#planes		(1)
;	inc a
	lda kg65.drawscrdepth
	inc a
	jsr WriteByte

	lda #0					;mask flag		(1)
	jsr WriteByte				;   (0=none, 2=has transp. color)

	lda CompressFlag			;compression		(1)
	and #$01				;   (0=none, 1=compressed)
	jsr WriteByte

	ldy #5					;pad, transp. color, x/yaspect
10$	lda #0					;			(5)
	jsr WriteByte
	dey					;???? make aspect $0a/$0b ????
	bne 10$
	
;	lda kg65.area.dx+1			;page width hi/lo	(2)
	ldy kg65.drawscrwidth
	lda kg65.c.widthtabh,y
	jsr WriteByte
;	lda kg65.area.dx
	lda kg65.c.widthtabl,y
	jsr WriteByte

;	lda kg65.area.dy+1			;page height hi/lo	(2)
	ldy kg65.drawscrheight
	lda kg65.c.heightabh,y
	jsr WriteByte
;	lda kg65.area.dy
	lda kg65.c.heightabl,y
	jsr WriteByte

;	bbr0 ChunkLen+3,15$		;???? should not happen
;	lda #0
;	jsr WriteByte

	ldx #4-1			;copy ChunkLen to BMHDLen
20$	lda ChunkLen,x			; (no bp,y)
	sta BMHDLen,x
	dex
	bpl 20$

;	jsr ClearChunkLen
	rts

	.page
WriteCMAP
	lda #<kg65.c.cmap		;'CMAP'
	ldx #>kg65.c.cmap
	jsr WriteFourBytes

	lda #ColorChunkLength		;Pointer to length of colormap chunk
	ldx #kg65.l.basepage
	jsr WriteFourBytes

	jsr ClearChunkLen		;Start counting Color bytes		[911114] FAB

	ldy kg65.drawscrdepth		;# of bitplanes 0-7
	lda NumColors,y			;constant 2,4,8,16,32,64,128,0
	sta temp1			;# of colors				[911114] FAB
	ldy #0

10$	phy				;read the drawscreen's palette
	lda kg65.drawscreen		;drawscreen index
	lsr a
	lsr a				;divide by 4 to get logical drawscreen #
	sta kg65.parm1
	sty kg65.parm2			;color#
	bsr kg65.s.read.palette		;in: screen#,color#	out:RGB

	ldx #0
20$	lda kg65.parm3,x		;output R,G,B
	asl a				;					[911114] FAB
	asl a
	asl a
	asl a
	ora kg65.parm3,x		;kludge an 8-bit value by duplicating both nybbles
	jsr WriteByte
	inx
	cpx #3				;next value
	bcc 20$

	ply
	iny
	cpy temp1
	bcc 10$				;next color


	bbr0 ChunkLen+3,30$		;test if pad byte is needed
	lda #0				;add a pad byte for an even count
	bsr WriteByte

30$	ldx #4-1			;copy temp chunklen to colorchunklen
40$	lda ChunkLen,x			; (no bp,y)
	sta ColorChunkLength,x
	dex
	bpl 40$

;	jsr ClearChunkLen		;now clear ChunkLen
	rts

	.page
WriteBODY
	lda #<kg65.c.body		;'BODY'
	ldx #>kg65.c.body
	bsr WriteFourBytes

	lda #BodyChunkLength		;Pointer to length of body chunk
	ldx #kg65.l.basepage
	bsr WriteFourBytes

	jsr ClearChunkLen		;Start counting Body bytes		[911114] FAB

	lda kg65.drawscrcols		;get screen width, height, & depth
	sta temp1			; 40 or 80 bytes
	sta kg65.area.bwidth

	lda kg65.drawscrdepth
	inc a
	sta temp3			; 1-8

	ldy kg65.drawscrheight		; 0-1
	sty temp2
	lda kg65.c.heightabl,y		;init scanline count
	ldx kg65.c.heightabh,y
	sta LineCount
	stx LineCount+1

	lda temp1
	inc a				;+2
	inc a
	sta temp4			;max line width in bytes for compression

	.page
StartBody				;Output IFF body
	lda #0
	sta LineTemp			;	start with scanline 0
	sta LineTemp+1

StartBody_1				;FOR EACH SCANLINE...
	lda #0
	sta BPCount			;	start with bitplane 0

StartBody_2				;FOR EACH BITPLANE...
	ldy BPCount			;	is this bitplane used?
	lda kg65.c.bitsup,y		;	bitplane# mask	(???? adjust for bp2 priority)
	and kg65.drawscrbp
	beq CheckForMoreBitPlanes	;		no

	lda LineTemp
	ldx LineTemp+1
	ldz kg65.area.bwidth		;	FOR EACH BYTE IN SCANLINE...
	jsr GetAScanLine		;		Read a scanline from bitplane into buffer
	lda CompressFlag		;		Compress if necessary, then write to file
	beq StoreUnCompressed


StoreCompressed
	jsr CompressScanLine		;scanline to output buffer, compress if possible
	bcs StoreUnCompressed		;	not advantageous

;	lda kg65.PTR2			;check output buffer size
;	cmp temp4
;	bcc 10$				;	nothing compressed
;	bra StoreUncompressed

;	ldy kg65.PTR2			;size of compressed buffer
	jsr OutputScanline		;output buffer to file
	bra CheckForMoreBitplanes


StoreUnCompressed
	lda kg65.area.bwidth		;number of literal bytes		[911113] LRW
	dec a				; -1 (0-39 or 0-79)			[911118] FAB
	jsr WriteByte			; (entire scanline)

	ldy #0
10$	lda kg65.l.scanline,y		;No compression; simply output scanline buffer
;	sta kg65.l.bytebuffer,y
	jsr WriteByte			;c65.chrout
	iny
	cpy kg65.area.bwidth
	bcc 10$

	.page
CheckForMoreBitPlanes
	inc BPCount			;...NEXT BITPLANE
	lda BPCount
	cmp #8				;	# of BP's
	bcc StartBody_2			;	more to do


CheckForNextScanline
	inw LineTemp			;...NEXT SCANLINE
	lda LineTemp+1
	cmp LineCount+1			;	# of scanlines
	bne StartBody_1			;	more to do
	lda LineTemp
	cmp LineCount
	bcc StartBody_1			;	more to do



AllDone					;copy temp chunklen to bodychunklen
	ldx #4-1
10$	lda ChunkLen,x			; (no bp,y)
	sta BodyChunkLength,x
	dex
	bpl 10$

	bbr0 ChunkLen+3,20$		;test if pad byte is needed
	lda #0				;add a pad byte for an even count
	bsr WriteByte

20$	jsr ClearChunkLen		;now clear ChunkLen
	rts				;Done this pass

	.page
; Compress scanline buffer into another buffer:
;   More than 2 consecutive bytes the same, output -count-1 byte with msb set & replicate byte.
;   Else output count-1 of literal bytes with msb clear followed by the string of literal bytes.
;   Count = $80 is a 'nop'.

CompressScanLine
	ldy #0				;position in scanline
	ldx #0				;position in output line

10$	ldz #$ff			;count-1 of bytes in run
	lda kg65.l.scanline,y		;current byte

20$	inz				;count string of = bytes
	iny				;next byte
	cpy kg65.area.bwidth
	beq 30$				;	no more bytes- done this run
	bcs 90$				;	no more bytes- done this scanline
	cmp kg65.l.scanline,y		;is current byte = to start of run?
	beq 20$				;	yes- continue

30$	cpz #3-1			;number of bytes in this run
	bcc 40$				;	if < 3, don't compress

	tza				;Compress run of bytes
	neg a				;	Count = -count
	sta kg65.l.bytebuffer,x
	inx
	lda kg65.l.scanline-1,y		;	byte to replicate
	sta kg65.l.bytebuffer,x
	inx
	bra 10$				;	continue


40$	tza				;Literal bytes
	sta kg65.l.bytebuffer,x		;	Count = msb clear + # of literal bytes
	inx
	lda kg65.l.scanline-1,y		;Output byte 'count' number of times
50$	sta kg65.l.bytebuffer,x
	inx				;	increment output buffer pointer
	dez				;	decrement count
	bpl 50$
	bra 10$				;	continue


90$
;	jsr c65.stop			;					[910402] FAB
;	beq stop_key_exit		;Exit if stop key down
;	bit $dc01			; (because kernel ram not in context and I'm lazy)
;	bpl stop_key_exit
	phx
	ply				;.y=length of output buffer
	cpy kg65.area.bwidth		;.c=1 if better to output scanline uncompressed
	rts

	.page
WriteFourBytes				;write 4 bytes pointed to by a,x
	phx				;hi
	pha				;lo

	ldy #0
10$	lda (1,SP),y			;					[911114] FAB
	jsr WriteByte
	iny
	cpy #4
	bcc 10$

	pla
	plx
	rts


WriteByte				;write byte in .a (must preserve .y)
	bbr0 WhichPass,IncChunkLen	;					[911114] FAB
	bra write_byte			;c65.chrout



OutputScanline
	sty temp5			;buffer size (scanline width)

	ldy #0				;output 'temp5' bytes
10$	lda kg65.l.bytebuffer,y
	jsr WriteByte			;c65.chrout
	iny
	dec temp5
	bne 10$

	rts

	.page
IncChunkLen				;this adds one to 32 bit value ChunkLen
	inc ChunkLen+3			;(note motorola format:  hi -> lo)
	bne DoneIncChunkLen

	inc ChunkLen+2
	bne DoneIncChunkLen

	inc ChunkLen+1
	bne DoneIncChunkLen

	inc ChunkLen

DoneIncChunkLen
	rts



ClearChunkLen				;Clears ChunkLen after adding it to FormLen
	bbr0 WhichPass,10$		; (only during pass 1)
	rts

10$	clc
	lda ChunkLen+3			;add ChunkLen to FormLen here
	adc FormLen+3			;(note motorola format:  hi -> lo)
	sta FormLen+3				;lo

	lda ChunkLen+2
	adc FormLen+2
	sta FormLen+2

	lda ChunkLen+1				;mid
	adc FormLen+1
	sta FormLen+1

	lda ChunkLen
	adc FormLen
	sta FormLen				;hi
	
ClearChunkLen_1
	lda #0
	sta ChunkLen			;Clear ChunkLen
	sta ChunkLen+1
	sta ChunkLen+2
	sta ChunkLen+3

	rts

	.page
; Get a scanline from drawscreen.  This gets 40 or 80 bytes from screen
; into buffer at KG65.L.SCANLINE
;
; Enter routine with:			a = lo byte of scanline #
;					x = hi byte of scanline #
;					y = which bitplane needed (0-7)
;					z = desired number of bytes

GetAScanLine
	sty kg65.area.bpn		;bitplane desired
	sta kg65.liney0			;scanline desired
	stx kg65.liney0+1
	lda #0
	sta kg65.linex0			;want full scanline (start + width)
	sta kg65.linex0+1
;	stz kg65.area.bwidth		;   (it already has this value)
	jsr kg65.s.calcadr		;get the memory address of this scanline

	lda kg65.linedsadr		;init draw screen low level address
	sta kg65.dsadr
	lda kg65.linedsadr+1
	sta kg65.dsadr+1

	ldx kg65.area.bpn		;Read scanline into buffer
	bra kg65.s.read.scanline	;Input: .x=bitplane#, dsadr set, scanline flag set



;.end
	.page
	.subttl Char

;created	: 09/11/89
;updated	:
;version	: 1.0
;author		: David P. Darus, Louis R. Wallace	 Walrus Software Inc.
;dev system	: C128 hcd65ce02 assembler
;application	: C65 kernal graphics rom
;

;char,column,row,height,width,direction,"string"

;parm1	= column#
;parm2	= row lo
;parm3	= row hi
;parm4	= height
;parm5	= width
;parm6	= direction
;parm7	= len of string
;parm8	= lo addr of string
;parm9	= hi addr of string
;parm10 = lo addr of character set
;parm11 = hi addr of character set
;parm12 = bank of character set

; * doesn't remember drawmodes from last call of char routine

	clc			;????
kg65.char
;	sei
	tba
	pha
	lda #kg65.l.basepage
	tab
	lda #0
	sta kg65.ccount		;byte# in string
	sta kg65.fsta
	sta kg65.frvs
	sta kg65.funder
	sta kg65.curchrmod

; winsizecol = drawscrvpdx / 8

	ldy kg65.drawscrvpdx
	lda kg65.drawscrvpdx+1
	bsr kg65.s.divby8
	sty kg65.winsizecol

; winsizey   = drawscrvpy + drawscrvpdy

	clc
	lda kg65.drawscrvpy
	adc kg65.drawscrvpdy
	sta kg65.winsizey
	lda kg65.drawscrvpy+1
	adc kg65.drawscrvpdy+1
	sta kg65.winsizey+1

; chrcol, chrrow = current position

nxtchr
	ldx #2
1$	lda kg65.parm1,x
	sta kg65.chrcol,x	;temp col,row = col,row
	dex
	bpl 1$

; Calc screen address given row & column

2$	bsr clcpos		;recalc position assuming ctl chr changed it	[910912] FAB

	ldy kg65.ccount		;current char# in string
	cpy kg65.parm7		;compare w/ string length
	beq charexit		;br if at end of string
	bsr getchar		;get character from string
	inc kg65.ccount		;inc index into string
	bsr petpok		;check for control character
	cpx #0
	bne 2$			;	skip if not printable

	ldx #8
	ldy #0
	bsr kg65.s.mulply	;a = char# * 8 for position in charset
	txa
	clc
	adc kg65.parm10		;add character offset to charset base adr
	sta kg65.charptr
	tya
	adc kg65.parm11
	sta kg65.charptr+1

	ldx #7
3$	bsr getdefn		;copy character definition into buffer
	sta kg65.charbuf1,x
	dex
	bpl 3$

	ldx #2
11$	lda kg65.chrcol,x
	sta kg65.clipcol,x
	dex
	bpl 11$

; Alter defn

	lda kg65.charbuf1+7	;					[910506]
	ora kg65.funder		;0 or 255 sets underline
	sta kg65.charbuf1+7

	ldx #7
4$	lda kg65.charbuf1,x
	eor kg65.frvs		;0 or 255 sets rvs
	sta kg65.charbuf1,x
	lda #0
	sta kg65.charbuf2,x
	dex
	bpl 4$

	lda kg65.curchrmod
	and #kg65.l.tilt	;tilt char +/- 90 deg.
	beq 5$			;	br if no
	bsr tiltchr

5$	lda kg65.curchrmod
	and #kg65.l.mirror	;mirror
	beq 6$			;	br if no
	bsr mirrorchr

6$	lda kg65.curchrmod
	and #kg65.l.flip	;flip
	beq 7$			;	br if no
	bsr flipchr

7$	ldy kg65.parm5		;width
	dey
	sty kg65.hwidth
	beq draw1		;	no multiwidth drawing

; Do multi widths here

expwd2	lda #0			;Clear width buffer
	tax
	ldy #127		;size of buffer=128
6$	sta kg65.l.wbufr,y
	dey
	bpl 6$

7$	ldy #0			;loop through 8 bits (0-7)			FAB	[910318]
3$	lda kg65.parm5		;test if on
	sta kg65.hwidth		;yes then lda 255
	lda kg65.c.bitsdn,y	;else a=0
	and kg65.charbuf1,x
	beq 4$
	lda #255		;bit set
4$	sta kg65.holda

5$	lda kg65.holda
	asl a			;chain shift
	rol kg65.l.wbufr,x	;bufr at this
	rol kg65.l.wbufr+8,x	;line of defn
	rol kg65.l.wbufr+16,x
	php
	lda kg65.parm5		;width
	cmp #4
	bcc 1$
	plp
	rol kg65.l.wbufr+24,x
	rol kg65.l.wbufr+32,x
	rol kg65.l.wbufr+40,x
	php
	lda kg65.parm5		;width
	cmp #7
	bcc 1$
	plp
	rol kg65.l.wbufr+48,x
	rol kg65.l.wbufr+56,x
	rol kg65.l.wbufr+64,x
	rol kg65.l.wbufr+72,x
	php
	lda kg65.parm5		;width
	cmp #11
	bcc 1$
	plp
	rol kg65.l.wbufr+80,x
	rol kg65.l.wbufr+88,x
	rol kg65.l.wbufr+96,x
	rol kg65.l.wbufr+104,x
	rol kg65.l.wbufr+112,x
	rol kg65.l.wbufr+120,x

2$	clc
	dec kg65.hwidth		;more width
	bne 5$
	iny			;next bit						[FAB]
	cpy #8
	bcc 3$
	inx
	cpx #8			;next byte of defn
	bne 7$
	bra draw0

1$	plp
	bra 2$

	.page
draw0	ldy kg65.parm5		;draw bit width times
	dey
	sty kg65.hwidth		;hwidth = width-1   loop controller

hihaab	ldx #0
	ldy kg65.hwidth
	lda kg65.c.incrow,y	;word wrap value
	tay

1$	lda kg65.l.wbufr,y	;move part of
	sta kg65.charbuf1,x	;defn into draw
	iny			;bufr
	inx
	cpx #8
	bcc 1$
				;draw scan line height times
draw1				;preserve y thru out this routine
	ldy #0			;scanline # in char defn.

hihaaa	lda kg65.parm4		;height
	sta kg65.hcount

hihcaa	ldx #0			;clip flag okay
	lda kg65.clipcol
	cmp kg65.winsizecol
	bcc 10$			;br on clipcol < winsizecol
	inx

10$	lda kg65.cliprow
	cmp kg65.winsizey
	lda kg65.cliprow+1
	sbc kg65.winsizey+1
	bcc 20$			;br on cliprow < winsizey
	inx
20$	cpx #0
	bne charaaa		;br if out of bounds

; Plot byte

	lda kg65.linedsadr
	sta kg65.dsadr
	lda kg65.linedsadr+1
	sta kg65.dsadr+1

	lda #0
	sta kg65.temp4
	inc a
	sta kg65.temp3

	.page
; ** drawmode stuff **			completely rewritten				[910923] FAB

30$	lda kg65.drawscrbp		;is this bitplane used in screen?
	and kg65.temp3
 	beq 50$				;	no

	ldx kg65.temp4			;read byte from screen
	phy
	ldy #0
	sty kg65.drawscrbyte
	bbs0 kg65.fsta,31$		;blank cell?
	bsr kg65.s.readdsbyte		;	no
31$	ply

	lda kg65.fsta			;doing any logical ops?
	and #$0e
	beq 34$				;	no
	lda kg65.drawscrpen1		;is this bitplane used by drawpen?
	and kg65.temp3
	beq 45$				;	no

	lda kg65.l.basepage*256+kg65.charbuf1,y
	bbr2 kg65.fsta,32$
	and kg65.drawscrbyte		;and
32$	bbr1 kg65.fsta,33$
	ora kg65.drawscrbyte		;or
33$	bbr3 kg65.fsta,40$
	eor kg65.drawscrbyte		;xor						[910506]
	bra 40$

34$	lda kg65.drawscrpen1		;is this bitplane used by drawpen?
	and kg65.temp3
	bne 35$				;	yes
	lda kg65.l.basepage*256+kg65.charbuf1,y
	eor #$ff			;	no- just mask active bits
	and kg65.drawscrbyte
	bra 40$

35$	lda kg65.l.basepage*256+kg65.charbuf1,y
	eor #$ff			;invert chr def'n
	and kg65.drawscrbyte		;keep bits from screen bgnd & merge bits from def'n
	ora kg65.l.basepage*256+kg65.charbuf1,y
40$	sta kg65.drawscrbyte

45$	ldx kg65.temp4
	lda kg65.drawscrbyte
	phy				;						[910207]
	ldy #0
	bsr kg65.s.writedsbyte
	ply

50$	inc kg65.temp4
	asl kg65.temp3
	bcc 30$
	rmb7 kg65.datflag		;						[910506] ????

	.page
charaaa				;next position						[910318] FAB
	inw kg65.liney0
	lda kg65.drawscrheight	;interlace mode?
	beq 12$			;	no
	lda kg65.liney0		;	yes- scanline odd or even?
	and #%00000001
12$	sta kg65.scanlineflag	;	0=even 1=odd  (if not interlaced then always 0)
	bne 1$			;		branch if interlaced & odd scanline, don't inc adr

	inw kg65.linedsadr
	lda kg65.linedsadr
	and #%00000111		;does it cross a character row
	bne 1$			;br if no

	dew kg65.linedsadr
	lda #7			;							[910207]
	trb kg65.linedsadr
	lda #0
	sta kg65.temp4		;a=0
	lda kg65.drawscrcols	; * 8
	asl a
	rol kg65.temp4
	asl a
	rol kg65.temp4
	asl a
	rol kg65.temp4		;hi
	sta kg65.temp3		;lo
	clc
	lda kg65.linedsadr
	adc kg65.temp3		;next scan line	  moves from top to bottom
	sta kg65.linedsadr
	lda kg65.linedsadr+1
	adc kg65.temp4
	sta kg65.linedsadr+1

1$	inw kg65.cliprow
	dec kg65.hcount		;temp height cntr
	bne hihcaa		;loop height times
	iny
	cpy #8			;do all 8 bytes of char defn
	bne hihaaa		;br if more

	inc kg65.chrcol		;column# +1    moves from left to right
	inc kg65.clipcol
	bsr clcpos		;set scrn ptr

	lda kg65.chrrow		;cliprow = chrrow
	sta kg65.cliprow
	lda kg65.chrrow+1
	sta kg65.cliprow+1

	dec kg65.hwidth		;loop until width times
	bpl hihaab		;more width

; Direction logic   w/wrap

	lda kg65.parm6
	and #kg65.l.dirup
	beq 2$

	bsr htx8		;move up
	bsr rowpht2
	bpl 2$
	bsr upchrclip
	bsr lfwdth
	bpl 2$
	bsr lfchrclip

2$	lda kg65.parm6
	and #kg65.l.dirrt
	beq 3$

	bsr rtwdth		;move right
	bcc 3$
	ldy #0
	sty kg65.parm1
	bsr htx8
	bsr rowpht1
	bcc 3$
	sty kg65.parm2		;y=0
	sty kg65.parm3

3$	lda kg65.parm6
	and #kg65.l.dirdn
	beq 4$

	bsr htx8		;move down
	bsr rowpht1
	bcc 4$
	ldx #0
	stx kg65.parm2
	stx kg65.parm3
	bsr rtwdth
	bcc 4$
	stx kg65.parm1		;x=0

4$	lda kg65.parm6
	and #kg65.l.dirlf
	beq 5$

	bsr lfwdth		;move left
	bpl 5$
	bsr lfchrclip
	bsr htx8
	bsr rowpht2
	bpl 5$
	bsr upchrclip
5$	bra nxtchr		;next char in str$  recalc scrn position


charexit
	clc
	pla
	tab
;	cli
	rts

	.page
getchar				;y = index into char string				[910207]
;	lda (kg65.parm8),y
;	rts
	ldz #1			;strings are in RAM1 (varbank)????
	ldx #<kg65.parm8
	jsr c65.indfet		;lda (kg65.parm8),y from RAM bank "B"
	rts



getdefn				;x = index into char definition
	txa
	tay			;bank number for charrom fetch				[910912]
	ldz kg65.l.basepage*256+kg65.parm12
	ldx #<kg65.charptr
	jsr c65.indfet		;lda (kg65.charptr),y from charrom
	phy
	plx
	rts

;------------------------------------------------------

clcpos
	lda kg65.chrcol
	ldx #8
	ldy #0
	bsr kg65.s.mulply	;column# x 8						[910207]
	stx kg65.linex0
	sty kg65.linex0+1

	lda kg65.chrrow
	sta kg65.liney0
	lda kg65.chrrow+1
	sta kg65.liney0+1
	bsr kg65.s.calcadr	;sets linedsadr
	rts


htx8
	lda #0
	sta kg65.temp1

	ldx #3
	lda kg65.parm4		;height
1$	asl a
	rol kg65.temp1
	dex
	bne 1$

	sta kg65.temp2
	rts

rowpht1
	clc
	adc kg65.parm2
	sta kg65.parm2
	lda kg65.parm3
	adc kg65.temp1
	sta kg65.parm3
	lda kg65.parm2
	cmp kg65.winsizey
	lda kg65.parm3
	sbc kg65.winsizey+1
	rts

rowpht2
	sec
	lda kg65.parm2
	sbc kg65.temp2
	sta kg65.parm2
	lda kg65.parm3
	sbc kg65.temp1
	sta kg65.parm3
	bit kg65.parm3
	rts

upchrclip
	sec
	lda kg65.winsizey
	sbc kg65.temp2
	sta kg65.parm2
	lda kg65.winsizey+1
	sbc kg65.temp1
	sta kg65.parm3
	rts

rtwdth
	clc
	lda kg65.parm5
	adc kg65.parm1		;move right width columns
	sta kg65.parm1
	cmp kg65.winsizecol
	rts

lfwdth
	sec
	lda kg65.parm1		;current text column
	sbc kg65.parm5		;subtract width column				FAB	[910318]
	sta kg65.parm1
	bit kg65.parm1
	rts

lfchrclip
	sec
	lda kg65.winsizecol
	sbc kg65.temp1
	sta kg65.parm1
	rts

	.page
;convert ascii to point pokes
;check for control characters
;clear,reverse on/off
;
;will return x = 0 if character
;if control character then
;x<>0 check before printing
;cpx #0 then beq no print
;

petpok				;convert pet to poke
	ldx #0
	cmp #32			;less than 32
	bcc petctr		;check control
	cmp #64			;less than 64
	bcs 1$
	rts			;32 =< a <= 63

1$	cmp #128 		; > 127
	bcs 2$			;then check further

3$	sec			;64 =< a <= 127 -> 0-63
	sbc #64			;160 <= a <= 191  -> 104-127
	rts			;done

2$	cmp #160
	bcc petctr		;control  128 <= a <= 159
	cmp #192
	bcc 3$			;160 <= a <= 191
	sec			;192 <= a <= 255  -> 64-127
	sbc #128
	rts

	.page
petctr
	bsr 9$
	ldx #255 		;set flag for control char
	rts

9$	tax			;.x=cntl char
;	ldy #255 		;useful values
;	lda #0
	cpx #2			;^B	blank cell under char
	bne 1$
	smb0 kg65.fsta
	rts

1$	cpx #6			;^F	flip char toggle
	bne 2$
	lda #kg65.l.flip
	bra 4$

2$	cpx #9			;^I	(inverse) AND with screen
	bne 3$
	smb2 kg65.fsta
;	smb7 kg65.frvs		;force rvs on????  why not let user use ^R
	rts

3$	cpx #26			;^Z	mirror char toggle
	bne 5$
	lda #kg65.l.mirror
4$	eor kg65.curchrmod
	sta kg65.curchrmod
	rts

5$	cpx #15			;^O	OR cell with screen
	bne 6$
	smb1 kg65.fsta
	rts

6$	cpx #18			;^R	rvs on
	bne 7$
	lda #255
	bra 71$

7$	cpx #146 		;^R+128	rvs off
	bne 8$
	lda #0
71$	sta kg65.frvs
	rts

8$	cpx #25			;^Y	tilt[+/-]	+=up -=down  not +/- => off
	bne 15$

	ldy kg65.ccount		;	char count
	cpy kg65.parm7		;	at end
	beq 12$			;	br if yes to turn off tilt
	bsr getchar
	tax
	lda #%00111111		;	tilt bits to 0
	and kg65.curchrmod
	sta kg65.curchrmod
	cpx #'-'
	beq 13$			; -	tilt face up (90deg counterclockwise)
	cpx #'+'
	beq 14$			; +	tilt face down (90deg clockwise)
12$				;	tilt off if no more chars or not +/-
	rts


13$	lda #kg65.l.tiltdn
	  .byte $2c
14$	lda #kg65.l.tiltup
	ora kg65.curchrmod
	sta kg65.curchrmod
	inc kg65.ccount		;	this char was used so go past it
	rts

15$	cpx #21			;^U	underline toggle
	bne 10$
	lda #255
	eor kg65.funder
	sta kg65.funder
	rts

10$	cpx #24			;^X	xor cell w/char					[910506]
	bne 11$
;	smb7 kg65.feor
	smb3 kg65.fsta
	rts
11$

	.page
curcntl				;cursor control: 	up,down,right,left,home,clr,color
	cpx #17			;cursor down
	bne 1$
	clc
	lda kg65.parm2
	adc #8
	sta kg65.parm2
	bcc ckcend
	inc kg65.parm3

1$	cpx #145 		;cursor up
	bne 2$
	sec
	lda kg65.parm2
	sbc #8
	sta kg65.parm2
	bcs ckcend
	dec kg65.parm3

2$	cpx #157		;cursor left
	bne 3$
	dec kg65.parm1

3$	cpx #29			;cursor right
	bne 4$
	inc kg65.parm1

4$	cpx #147		;clr home
	bne 5$

; clear viewport

	ldx #19			;set so that home occurs
5$	cpx #19
	bne 6$
	lda #0
	sta kg65.parm1		;col=0
	sta kg65.parm2		;row=0
	sta kg65.parm3
6$

ckcend
	ldx #2
1$	lda kg65.parm1,x	;move col,row to temp col,row
	sta kg65.chrcol,x
	dex
	bpl 1$
	rts

	.page
tiltchr
;	lda kg65.curchrmod	;		removed self modifying code	[910912] FAB
;	and #kg65.l.tiltdn
;	beq tup			;br if tilt up
;
;tdn	lda #<kg65.c.bitsup
;	ldy #>kg65.c.bitsup
;	ldx #$4a		;lsr a opcode
;	bne tiltit		;forced
;
;tup	lda #<kg65.c.bitsdn
;	ldy #>kg65.c.bitsdn
;	ldx #$0a		;asl a opcode
;
;tiltit	sta 6$+1		;lo byt
;	sty 6$+2		;hi byt
;	stx 4$+1

	ldx #0
	ldy #7

10$	bbs7 kg65.curchrmod,20$	;tilt up or down?
	lda kg65.c.bitsdn,y	;<<<<<<<<<<<<<<<<< was self modifying code
	  bra 25$
20$	lda kg65.c.bitsup,y
25$	sta kg65.mask
	sty kg65.temp1
	stx kg65.temp2
	lda kg65.charbuf1,x
	pha

	ldx #7
30$	pla			;<<<<<<<<<<<<<<<<< was self-modifying code below
	bbs7 kg65.curchrmod,40$	;tilt up or down?
	lsr a
	  .byte $89
40$	asl a
	pha
	lda kg65.mask
	bcs 50$			;set or clear bit?

	eor #255
	and kg65.charbuf2,x	;move top row to last column of defn
	bra 55$

50$	ora kg65.charbuf2,x
55$	sta kg65.charbuf2,x
	dex
	bpl 30$

60$	pla
	ldx kg65.temp2
	inx
	ldy kg65.temp1
	dey
	bpl 10$

	ldx #7
70$	lda kg65.charbuf2,x	;done- copy modified definition
	sta kg65.charbuf1,x
	dex
	bpl 70$
	rts

	.page
mirrorchr
	ldx #7
2$	lda kg65.charbuf1,x	;get defn byte

	ldy #7
1$	lsr a			;flip bit order
	rol kg65.temp1
	dey
	bpl 1$
	lda kg65.temp1
	sta kg65.charbuf1,x	;restore into bufr
	dex
	bpl 2$
	rts

flipchr				;swap scanlines
	ldx #7			; 0=7  7=0
1$	lda kg65.charbuf1,x	; 1=6  6=1
	pha			; 2=5  5=2
	dex			; 3=4  4=3
	bpl 1$

	ldx #7
2$	pla
	sta kg65.charbuf1,x
	dex
	bpl 2$
	rts

;.end
	.page
	.subttl  Viewport
;created     : 08/02/89
;updated     :
;version     : 1.0
;author      : David P. Darus, Louis R. Wallace  Walrus Software Inc.
;dev system  : C128 HCD65CE02 assembler
;application : C65 Kernal Graphics ROM
;
; kernal graphics viewport commands

;viewport define
; parm1,parm2 = x
; parm3,parm4 = y
; parm5,parm6 = dx
; parm7,parm8 = dy

	clc			;????					[910711]

kg65.viewportdef
	tba
	pha
	lda #kg65.l.basepage
	tab

	ldx #7			;					[910626] FAB
1$	lda kg65.parm1,x
	sta kg65.drawscrvpx,x
	dex
	bpl 1$

	pla
	tab
	clc
	rts

;.end
	.page
	.subttl	 Paint
;created	: 08/01/90
;updated	: added to ROM F.Bowen 03/04/91
;version	: 1.0
;author		: david p. darus, louis r. wallace	 walrus software inc.
;dev system	: c128 hcd65ce02 assembler
;application	: c65 kernal graphics rom
;

; PAINT x,y,mode[,border-color]
;
;	parm1,2 = x
;	parm3,4 = y
;	parm5 = mode
;	parm6 = border-color
;
;	pen-a = fill color
;	mode 0: fill region defined by color at x,y (default)	new modes	[910916] FAB
;	mode 1: fill region using given color as boundary
;	mode 2: fill connected region

	clc				;????

kg65.paint
;	sei				;basepage init	**
	tba
	pha
	lda #kg65.l.basepage
	tab

	ldx #kg65.paint.parms-kg65.paint.vars-1
	lda #0
10$	sta kg65.paint.vars,x		;init working vars
	dex
	bpl 10$

	ldx #10-1			;						[910725]
20$	lda kg65.parm1,x		;copy initial params into work area
	sta kg65.paint.parms,x
	dex
	bpl 20$

	lda paint_stack_bot		;init paint stack pointer
	sta kg65.paint.sp
	lda paint_stack_bot+1
	sta kg65.paint.sp+1

	ldx kg65.paint.mode		;determine boundary color or fill region	[910916] FAB
	bne 21$

; MODE 0: fill colored region at x,y, any other color is a boundary

	bsr kg65.pixel			;read pixel at x,y
	lda kg65.temp5			;this defines region to fill
	bra 28$

; MODE 1: fill region bounded by given color

21$	dex
	bne 22$
	phd kg65.l.basepage*256+kg65.parm1
	lda kg65.drawscreen		;this is the screen				[910802]
	sta kg65.parm1
	lda kg65.paint.bc		;this is the given boundary color
	sta kg65.parm2
	jsr kg65.s.color2index		;convert color selection to drawscreen color index
	pla
	sta kg65.parm2
	pla
	sta kg65.parm1
	lda kg65.temp4
	bra 28$

; MODE 2: fill connected region

22$	dex
	bne 50$				;???? illegal mode
	lda kg65.drawscrpen1
	sta kg65.paint.bc
	bsr kg65.pixel			;read pixel at x,y
	lda kg65.temp5
	bne 29$				;	okay, starting dot has something
	bra 50$				;	exit- starting dot is empty????

28$	sta kg65.paint.bc

29$	bsr kg65.pixel			;test 1st point, exit if it's a boundary
	beq 50$				;	boogie

	lda kg65.paint.x		;Start scanning...
	sta kg65.paint.sl
	lda kg65.paint.x+1
	sta kg65.paint.sl+1

30$	dew kg65.paint.sl		;go left
	lda kg65.paint.sl
	sta kg65.parm1
	lda kg65.paint.sl+1
	sta kg65.parm2
	bsr kg65.pixel
	bne 30$				;	loop until boundary
	inw kg65.paint.sl

	lda kg65.paint.x
	sta kg65.paint.sr
	lda kg65.paint.x+1
	sta kg65.paint.sr+1

40$	inw kg65.paint.sr		;go right
	lda kg65.paint.sr
	sta kg65.parm1
	lda kg65.paint.sr+1
	sta kg65.parm2
	bsr kg65.pixel
	bne 40$				;	loop until boundary
	dew kg65.paint.sr

	lda kg65.paint.sl		;line sl,y,sr,y
	sta kg65.parm1
	lda kg65.paint.sl+1
	sta kg65.parm2
	lda kg65.paint.sr
	sta kg65.parm5
	lda kg65.paint.sr+1
	sta kg65.parm6
	lda kg65.paint.y
	sta kg65.parm3
	sta kg65.parm7
	lda kg65.paint.y+1
	sta kg65.parm4
	sta kg65.parm8
	bsr kg65.line_patr		;draw a line from left border to right border

	lda kg65.paint.sl
	sta kg65.paint.lx		; lx=sl
	sta kg65.paint.pl		; pl=sl
	lda kg65.paint.sl+1
	sta kg65.paint.lx+1
	sta kg65.paint.pl+1

	lda kg65.paint.sr
	sta kg65.paint.rx		; rx=sr
	sta kg65.paint.pr		; pr=sr
	lda kg65.paint.sr+1
	sta kg65.paint.rx+1
	sta kg65.paint.pr+1

	lda kg65.paint.y
	sta kg65.paint.ty		; ty=y
	lda kg65.paint.y+1
	sta kg65.paint.ty+1

	dew kg65.paint.ty		;move up one line
	lda #1
	sta kg65.paint.d		;left to right
	bsr kg65.s.rfill

	lda kg65.paint.sl
	sta kg65.paint.lx		; lx=sl
	sta kg65.paint.pl		; pl=sl
	lda kg65.paint.sl+1
	sta kg65.paint.lx+1
	sta kg65.paint.pl+1

	lda kg65.paint.sr
	sta kg65.paint.rx		; rx=sr
	sta kg65.paint.pr		; pr=sr
	lda kg65.paint.sr+1
	sta kg65.paint.rx+1
	sta kg65.paint.pr+1

	lda kg65.paint.y
	sta kg65.paint.ty		; ty=y
	lda kg65.paint.y+1
	sta kg65.paint.ty+1

	inw kg65.paint.ty		;move down one line
	lda #$ff
	sta kg65.paint.d		;right to left
	bsr kg65.s.rfill

50$	pla				;basepage cleanup **
	tab
;	cli
	clc
	rts

	.page
kg65.s.rfill
	lda kg65.paint.lx		; nl=lx
	sta kg65.paint.nl
	lda kg65.paint.lx+1
	sta kg65.paint.nl+1

15$	lda kg65.paint.nl		; x=nl
	sta kg65.parm1
	lda kg65.paint.nl+1
	sta kg65.parm2
	lda kg65.paint.ty		; y=ty
	sta kg65.parm3
	lda kg65.paint.ty+1
	sta kg65.parm4
	bsr kg65.pixel
	beq 1$				;	at boundary

	lda kg65.paint.nl
	sta kg65.paint.nr
	lda kg65.paint.nl+1
	sta kg65.paint.nr+1

2$	dew kg65.paint.nl		;go left
	lda kg65.paint.nl
	sta kg65.parm1
	lda kg65.paint.nl+1
	sta kg65.parm2
	lda kg65.paint.ty
	sta kg65.parm3
	lda kg65.paint.ty+1
	sta kg65.parm4
	bsr kg65.pixel
	bne 2$				;	loop until boundary
	inw kg65.paint.nl
	bra 3$


1$	inw kg65.paint.nl
	lda kg65.paint.nl
	sta kg65.parm1
	lda kg65.paint.nl+1
	sta kg65.parm2
	lda kg65.paint.ty
	sta kg65.parm3
	lda kg65.paint.ty+1
	sta kg65.parm4
	bsr kg65.pixel
	bne 4$

;	lda kg65.paint.nl		;nl=rx
;	cmp kg65.paint.rx
;	bne 6$
;	lda kg65.paint.nl+1
;	cmp kg65.paint.rx+1
;	beq 1$				;	br if yes
;
;	lda kg65.paint.nl		;try nl > rx
;	cmp kg65.paint.rx
;6$	lda kg65.paint.nl+1
;	sbc kg65.paint.rx+1
;	bcc 1$
;	bcs 4$				;br if yes
;
;5$	bra 1$				;nl <= rx and a=1

	lda kg65.paint.nl+1		;if nl <= rx then 1$ else 4$			[FAB]
	cmp kg65.paint.rx+1
	bcc 1$				;	<
	bne 4$				;	>
	lda kg65.paint.nl
	cmp kg65.paint.rx
	bcc 1$				;	<
	beq 1$				;	=
					;	>
4$	lda kg65.paint.nl
	sta kg65.paint.nr
	lda kg65.paint.nl+1
	sta kg65.paint.nr+1

;3$	lda kg65.paint.nl		;nl=rx
;	cmp kg65.paint.rx
;	bne 7$				;br if no
;	lda kg65.paint.nl+1
;	cmp kg65.paint.rx+1
;	beq 8$				;br if yes
;
;	lda kg65.paint.nl		;nl > rx
;	cmp kg65.paint.rx
;7$	lda kg65.paint.nl+1
;	sbc kg65.paint.rx+1
;	bcs 9$				;br if yes

3$	lda kg65.paint.nl+1		;if nl <= rx then 8$ else 9$			[FAB]
	cmp kg65.paint.rx+1
	bcc 8$				;	<
	bne 9$				;	>
	lda kg65.paint.nl
	cmp kg65.paint.rx
	beq 8$				;	=
	bcs 9$				;	>
					;	<
8$	inw kg65.paint.nr
	lda kg65.paint.nr
	sta kg65.parm1
	lda kg65.paint.nr+1
	sta kg65.parm2
	lda kg65.paint.ty
	sta kg65.parm3
	lda kg65.paint.ty+1
	sta kg65.parm4
	bsr kg65.pixel
	bne 8$				;loop until boundary
	dew kg65.paint.nr

	lda kg65.paint.nl		;line nl,ty,nr,ty
	sta kg65.parm1
	lda kg65.paint.nl+1
	sta kg65.parm2
	lda kg65.paint.nr
	sta kg65.parm5
	lda kg65.paint.nr+1
	sta kg65.parm6
	lda kg65.paint.ty
	sta kg65.parm3
	sta kg65.parm7
	lda kg65.paint.ty+1
	sta kg65.parm4
	sta kg65.parm8
	bsr kg65.line_patr

	lda #1
	sta kg65.paint.rp
	bsr kg65.s.push

	lda kg65.paint.nl
	sta kg65.paint.lx		; lx=nl
	sta kg65.paint.pl		; pl=nl
	lda kg65.paint.nl+1
	sta kg65.paint.lx+1
	sta kg65.paint.pl+1

	lda kg65.paint.nr
	sta kg65.paint.rx		; rx=nr
	sta kg65.paint.pr		; pr=nr
	lda kg65.paint.nr+1
	sta kg65.paint.rx+1
	sta kg65.paint.pr+1

;	sec				; ty=ty-d
;	lda kg65.paint.ty
;	sbc kg65.paint.d
;	sta kg65.paint.ty
;?	lda kg65.paint.ty+1
;	sbc #0
;	sta kg65.paint.ty+1
;	bra kg65.s.rfill

	bbs7 kg65.paint.d,212$		; ty=ty-d					[FAB]
	dew kg65.paint.ty
	bra kg65.s.rfill
212$	inw kg65.paint.ty
	bra kg65.s.rfill		;---------------------------------------------


12$	sec				; tmppt=pl-2
	lda kg65.paint.pl
	sbc #2
	sta kg65.paint.tmppt
	lda kg65.paint.pl+1
	sbc #0
	sta kg65.paint.tmppt+1
	bmi 13$				;???? overflow, which means nl > 13$

;	lda kg65.paint.nl		;if nl > tmppt then 13$
;	cmp kg65.paint.tmppt
;	lda kg65.paint.nl+1
;	sbc kg65.paint.tmppt+1
;	beq 113$			;br if equal
;	bcs 13$				;br if >  falls thru if <

	lda kg65.paint.nl+1		;if nl > tmppt then 13$ else 113$		[FAB]
	cmp kg65.paint.tmppt+1
	bcc 113$			;	<
	bne 13$				;	>
	lda kg65.paint.nl
	cmp kg65.paint.tmppt
	beq 113$			;	=
	bcs 13$				;	>
					;	<
113$	lda #2
	sta kg65.paint.rp
	bsr kg65.s.push

	lda kg65.paint.nl
	sta kg65.paint.lx		; lx=nl
	sta kg65.paint.pl		; pl=nl
	lda kg65.paint.nl+1
	sta kg65.paint.lx+1
	sta kg65.paint.pl+1

	lda kg65.paint.tmppt		; rx=tmppt   (pl-2)
	sta kg65.paint.rx
	lda kg65.paint.tmppt+1
	sta kg65.paint.rx+1

	lda kg65.paint.nr		; pr=nr
	sta kg65.paint.pr
	lda kg65.paint.nr+1
	sta kg65.paint.pr+1

;	clc				; ty=ty+d
;	lda kg65.paint.ty
;	adc kg65.paint.d
;?	sta kg65.paint.ty
;	lda kg65.paint.ty+1
;	adc #0
;	sta kg65.paint.ty+1

	bbr7 kg65.paint.d,213$		; ty=ty+d					[FAB]
	dew kg65.paint.ty
	  .byte $2c
213$	inw kg65.paint.ty

	lda kg65.paint.d		; d=-d
	neg a
	sta kg65.paint.d
	bra kg65.s.rfill		;---------------------------------------------


13$	clc				; tmppt=pr+2
	lda kg65.paint.pr
	adc #2
	sta kg65.paint.tmppt
	lda kg65.paint.pr+1
	adc #0
	sta kg65.paint.tmppt+1

;	lda kg65.paint.tmppt		;if tmppt > nr then 14$
;	cmp kg65.paint.nr
;	lda kg65.paint.tmppt+1
;	sbc kg65.paint.nr+1
;	beq 114$			;br if equal
;	bcs 14$				;br if >  falls thru if <

	lda kg65.paint.tmppt+1		;if tmppt > nr then 14$ else 114$		[FAB]
	cmp kg65.paint.nr+1
	bcc 114$			;	<
	bne 14$				;	>
	lda kg65.paint.tmppt
	cmp kg65.paint.nr
	beq 114$			;	=
	bcs 14$				;	>
					;	<
114$	lda #3
	sta kg65.paint.rp
	bsr kg65.s.push

	lda kg65.paint.tmppt		; lx=tmppt   (pr+2)
	sta kg65.paint.lx
	lda kg65.paint.tmppt+1
	sta kg65.paint.lx+1

	lda kg65.paint.nr		; rx=nr
	sta kg65.paint.rx
	sta kg65.paint.pr
	lda kg65.paint.nr+1
	sta kg65.paint.rx+1
	sta kg65.paint.pr+1

;	clc				; ty=ty+d
;	lda kg65.paint.ty
;?	adc kg65.paint.d
;	sta kg65.paint.ty
;	lda kg65.paint.ty+1
;	adc #0
;	sta kg65.paint.ty+1

	bbr7 kg65.paint.d,214$		; ty=ty+d					[FAB]
	dew kg65.paint.ty
	  .byte $2c
214$	inw kg65.paint.ty

	lda kg65.paint.nl		; pl=nl
	sta kg65.paint.pl
	lda kg65.paint.nl+1
	sta kg65.paint.pl+1

	lda kg65.paint.d		; d=-d
	neg a
	sta kg65.paint.d
	bra kg65.s.rfill		;---------------------------------------------


14$	clc				; nl=nr+2
	lda kg65.paint.nr
	adc #2
	sta kg65.paint.nl
	lda kg65.paint.nr+1
	adc #0
	sta kg65.paint.nl+1

;	lda kg65.paint.nl		;if nl <= rx then 15$
;	cmp kg65.paint.rx
;	lda kg65.paint.nl+1
;	sbc kg65.paint.rx+1
;	beq 15$				;br if equal
;	bcc 15$				;br if <

	lda kg65.paint.nl+1		;if nl <= rx then 15$ else 9$			[FAB]
	cmp kg65.paint.rx+1
	bcc 15$				;	<
	bne 9$				;	>
	lda kg65.paint.nl
	cmp kg65.paint.rx
	bcc 15$				;	<
	beq 15$				;	=
					;	>
9$	lda kg65.paint.sp+1		;pop next coordinate from stack
	cmp paint_stack_bot+1
	bne 91$				;		something more to do
	lda kg65.paint.sp
	cmp paint_stack_bot
	beq 11$				;		nothing more to do, exit????????????????????????????

;91$	sec
;	lda kg65.paint.sp		;	backup stack pointer
;	sbc #16
;	sta kg65.paint.sp		;paint_stack_ptr
;	sta kg65.bpptr1
;	bcs 92$
;	dec kg65.paint.sp+1		;paint_stack_ptr+1
;92$	lda kg65.paint.sp+1		;paint_stack_ptr+1
;	sta kg65.bpptr1+1
;;	ldx #paint_stack_ptr		;	pop (xpos,ypos) from stack
;	ldz #1
;	ldy #16-1
;93$	jsr lda_bpptr1			;c65.lda_far_1
;	sta kg65.l.basepage*256+kg65.paint.nl,y
;	dey
;	bpl 93$

91$	sec
	lda kg65.paint.sp		;	backup stack pointer
	sbc #16
	sta kg65.paint.sp		;paint_stack_ptr
	sta c65.dma2_list+3		;dma source lo					[910729]
	bcs 92$
	dec kg65.paint.sp+1		;paint_stack_ptr+1
92$	lda kg65.paint.sp+1		;paint_stack_ptr+1
	sta c65.dma2_list+4		;dma source hi
	lda #1
	sta c65.dma2_list+5		;dma source bank		(???? c65.var_bank)

	lda #kg65.paint.nl		;dma destination lo
	sta c65.dma2_list+6
	lda #kg65.l.basepage
	sta c65.dma2_list+7		;dma destination hi
	lda #0
	sta c65.dma2_list+8		;dma destination bank		(???? c65.text_bank)

	ldx #16				;dma count lo
	stx c65.dma2_list+1
;	lda #0
	sta c65.dma2_list+2		;dma count hi
	sta c65.dma2_list		;dma copy commands
	sta c65.dma2_list+9
	sta c65.dma_ctlr+2		;dma list	bank		(???? c65.sys_bank)
	lda #>c65.dma2_list		;		high
	sta c65.dma_ctlr+1
	lda #<c65.dma2_list		;		low & trigger
	sta c65.dma_ctlr

;9$	lda kg65.paint.sp
;	ora kg65.paint.sp+1		;						[FAB]
;	beq 11$				;stack empty
;
;10$
;;	dew kg65.paint.sp		;						[FAB]
;	sec				;pop one 16-byte entry
;	lda kg65.paint.sp
;	sbc #16
;	sta kg65.paint.sp
;	lda kg65.paint.sp+1
;	sbc #0
;	sta kg65.paint.sp+1
;
;	clc
;	lda #<kg65.l.paint.stack
;	adc kg65.paint.sp
;	sta kg65.paint.tmpsp
;	lda #>kg65.l.paint.stack
;	adc kg65.paint.sp+1
;	sta kg65.paint.tmpsp+1
;
;	ldy #16-1
;	lda (kg65.paint.tmpsp),y	;pop stack
;	sta kg65.paint.rp
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.d
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.nr+1
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.nr
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.nl+1
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.nl
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.pr+1
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.pr
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.pl+1
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.pl
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.ty+1
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.ty
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.rx+1
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.rx
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.lx+1
;	dey
;;	dew kg65.paint.tmpsp
;;	dew kg65.paint.sp
;	lda (kg65.paint.tmpsp),y
;	sta kg65.paint.lx
;;	dew kg65.paint.tmpsp		;leave SP pointing to next *free* spot		[FAB]
;;	dew kg65.paint.sp

	lda kg65.paint.rp
;	cmp #1				;						[910506]
	dec a
	beq 12$
;	cmp #2
	dec a
	beq 13$
;	cmp #3
	dec a
	beq 14$
11$	rts

	.page
kg65.s.push
;;	inw kg65.paint.sp								[FAB]
;	clc
;	lda kg65.paint.sp
;	adc #<kg65.l.paint.stack
;	tay
;	lda kg65.paint.sp+1
;	adc #>kg65.l.paint.stack
;	cmp #>kg65.l.paint.stack+kg65.l.paint.stack.size
;	bcc 2$
;	rts
;;1$	inc $d020
;;	bra 1$				;???? stack overflow debug
;
;2$	sty kg65.paint.tmpsp
;	sta kg65.paint.tmpsp+1
;
;	ldy #0
;	lda kg65.paint.lx
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;	lda kg65.paint.lx+1
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;
;	lda kg65.paint.rx
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;	lda kg65.paint.rx+1
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;
;	lda kg65.paint.ty
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;	lda kg65.paint.ty+1
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;
;	lda kg65.paint.pl
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;	lda kg65.paint.pl+1
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;
;	lda kg65.paint.pr
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;	lda kg65.paint.pr+1
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;
;	lda kg65.paint.nl
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;	lda kg65.paint.nl+1
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;
;	lda kg65.paint.nr
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;	lda kg65.paint.nr+1
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;
;	lda kg65.paint.d
;	sta (kg65.paint.tmpsp),y
;	iny
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp
;
;	lda kg65.paint.rp
;	sta (kg65.paint.tmpsp),y
;;	inw kg65.paint.tmpsp
;;	inw kg65.paint.sp

	lda kg65.paint.sp+1	;test if there is room on stack for another 4 bytes.
	cmp paint_stack_top+1
	bcc 3$			;	..lots of room
	bne 99$			;	..no room
	lda kg65.paint.sp	;	..getting tight
	cmp paint_stack_top
	bcc 3$			;		..but still some room

99$ ;	inc $d020		;???? debug only
	lda #0
	tab
	ldx #$fa-2-2		;????????????? gotta blow back to call ????????????
	txs
	ldx #16			;OUT OF MEMORY error
	sec
;	cli
	rts

;3$
;;	ldx #paint_stack_ptr	;push (xpos,ypos) onto stack
;	lda kg65.paint.sp	;paint_stack_ptr
;	sta kg65.bpptr1
;	lda kg65.paint.sp+1	;paint_stack_ptr+1
;	sta kg65.bpptr1+1
;	ldz #1
;	ldy #16-1
;2$	lda kg65.l.basepage*256+kg65.paint.nl,y
;;	jsr c65.sta_far_1
;	jsr sta_bpptr1
;	dey
;	bpl 2$

3$	clc
	lda kg65.paint.sp		;advance stack pointer
	sta c65.dma2_list+6		;dma destination lo			[910729]
	adc #16
	sta kg65.paint.sp		;paint_stack_ptr
	lda kg65.paint.sp+1		;paint_stack_ptr+1
	sta c65.dma2_list+7		;dma destination hi
	adc #0
	sta kg65.paint.sp+1		;paint_stack_ptr+1
	lda #1
	sta c65.dma2_list+8		;dma destination bank		(???? c65.var_bank)

	lda #kg65.paint.nl		;dma source lo
	sta c65.dma2_list+3
	lda #kg65.l.basepage
	sta c65.dma2_list+4		;dma source hi
	lda #0
	sta c65.dma2_list+5		;dma source bank		(???? c65.text_bank)

	ldx #16				;dma count lo
	stx c65.dma2_list+1
;	lda #0
	sta c65.dma2_list+2		;dma count hi
	sta c65.dma2_list		;dma copy commands
	sta c65.dma2_list+9
	sta c65.dma_ctlr+2		;dma list	bank		(???? c65.sys_bank)
	lda #>c65.dma2_list		;		high
	sta c65.dma_ctlr+1
	lda #<c65.dma2_list		;		low & trigger
	sta c65.dma_ctlr

;	clc
;	lda #16
;	adc kg65.paint.sp
;	sta kg65.paint.sp
;	bcc 10$
;	inc kg65.paint.sp+1
10$	rts

	.page
kg65.pixel
	lda $dc01			;because kernel ram not in context and I'm lazy
	bpl stop_key_exit

kg65.s.pixel				;entry by PIXEL function to get BP data at x,y	[910801]
	lda #0				;init:
	sta kg65.datflag		;	dat
	sta kg65.temp4			;	bitplane #
	sta kg65.temp5			;	color index value from bitplanes
	inc a
	sta kg65.temp3			;	bitplane bit code

	ldx #3				;	screen coordinate, parm1,2 = x	parm3,4 =y
1$	lda kg65.parm1,x
	sta kg65.linex0,x
	dex
	bpl 1$

;-------------------------------------------------------------------------------------------
	lda kg65.linex0+1			;test for X position out of bounds	[910715]
	cmp kg65.drawscrvpdx+1
	bcc 10$
	bne 60$					;	way out
	lda kg65.linex0
	cmp kg65.drawscrvpdx
	bcs 60$					;	out

10$	lda kg65.liney0+1			;test for Y position out of bounds
	cmp kg65.drawscrvpdy+1
	bcc 20$
	bne 60$					;	way out
	lda kg65.liney0
	cmp kg65.drawscrvpdy
	bcs 60$					;	out
;-------------------------------------------------------------------------------------------

20$	bsr kg65.s.calcadr		;get physical address of pixel
	lda kg65.linedsadr
	sta kg65.dsadr			;	this is the address of the byte
	lda kg65.linedsadr+1
	sta kg65.dsadr+1
	lda kg65.linemask		;	this is the bit offset			[910305]
	sta kg65.mask

30$	lda kg65.drawscrbp		;do for each bitplane
	and kg65.temp3			;	is this bitplane used?
	beq 40$				;		no

	ldx kg65.temp4			;	this is the bitplane#
	bsr kg65.s.readdsbyte		;	read the byte containing the pixel
	and kg65.mask
	beq 40$				;	br if pixel = 0, not a boundary

	lda kg65.c.bitsup,x		;	a = bitplane pixel value
	tsb kg65.temp5			;	color index				[FAB]

40$	inc kg65.temp4			;	next bitplane...
	asl kg65.temp3			;	...and bitplane mask
	bcc 30$				;	loop until done all bitplanes

	rmb7 kg65.datflag		;						[910506] ????

; Is color index at this pixel a boundary color?		many changes		[910916] FAB
;	return = if boundary, <> if not boundary

	ldx kg65.paint.mode		;						[910711] FAB
	bne 51$
	lda kg65.paint.bc		;mode 0: any color <> paint.bc is a boundary
	cmp kg65.temp5
	beq 70$
	bne 60$

51$	dex
	bne 52$
	lda kg65.temp5			;mode 1: color = paint.bc is a boundary
	cmp kg65.drawscrpen1
	beq 53$				;	(well, except for current pen color)
	cmp kg65.paint.bc
	rts

52$	lda kg65.temp5			;mode 2: emptyness is only boundary
	beq 53$
	cmp kg65.paint.bc		;	(well, except for current pen color)
53$	rts

60$	lda #0				;BOUNDARY
	rts

70$	lda #255			;NOT BOUNDARY
80$	rts

	.page
;;******************************************************************
;;  paint (p) (,m) -  fill an area with a specified color
;;                  area is defined by all points within a border
;;                  p = starting coordinate position
;;                  m = mode: 0=area defined by any color (default)
;;                            1=area defined by given color
;;******************************************************************
;
;	clc			;????
;
;kg65.paint
;;	sei
;	tba			;get graphic's base page
;	pha
;	lda #kg65.l.basepage
;	tab
;
;	ldx #10-1
;10$	lda kg65.parm1,x	;get paint coords, params
;	sta kg65.paint.parms,x
;	dex
;	bpl 10$
;
;	jsr kg65.pixel		;test 1st point
;	bcs 15$			;	abort if 1st point out of bounds
;	bne 20$			;	abort if point already = color
;15$	rts
;
;; A large block of ram is necessary for the stack required by 'paint'.  Rather than
;; allocate a fixed block of ram just for paint, it would be more frugal to use any
;; free ram in BASIC's area.  I used the area between the end of arrays (strend) and
;; the bottom of strings (fretop).  BASIC performed a garbage collect & passed pointers
;; to this space.
;
;20$	lda paint_stack_bot	;init paint stack pointer
;	sta paint_stack_ptr
;	lda paint_stack_bot+1
;	sta paint_stack_ptr+1
;
;	.page
;; To fill the shape:
;;	1) Move current position down until a dot is found that is on.
;;	2) Move up (down) until a dot is found that is on.
;;		a. Set each dot that is off to the color specified.
;;		b. Test the dot to the right and save each coordinate that begins
;;		   a string of reset points.
;;		c. Test each dot on the left in the same way as (b).
;;	3) Remove a saved coordinate and repeat from (1).
;;	4) Done when there are no more saved coordinates.
;
;ptloop
;	lda #0
;	sta left_flag		;init flags = 0 - prev point set
;	sta right_flag		;use to test if previous point was on or off
;
;10$	dew ypos		;LOOK UP
;	jsr kg65.pixel		;	test if point set or reset
;	bcs 20$			;	loop until edge of screen
;	bne 10$			;		   or border
;20$	inw ypos		;	restore ypos
;
;30$	ldx #4-1		;ptfill. get current screen coordinates
;40$	lda xpos,x
;	sta kg65.linex0,x
;	dex
;	bpl 40$
;	bsr kg65.s.calcadr	;set the point at linex0, liney0
;	lda kg65.linemask
;	sta kg65.mask
;	lda kg65.linedsadr
;	sta kg65.dsadr
;	lda kg65.linedsadr+1
;	sta kg65.dsadr+1
;	jsr kg65.s.plotdot
;
;	dew xpos		;LOOK LEFT
;	lda left_flag		;	get left flag value
;	jsr tstval		;	test if there's a need to save this coordinate
;	sta left_flag		;	save new flag value
;	inw xpos		;	restore xpos
;
;	inw xpos		;LOOK RIGHT
;	lda right_flag		;	get right flag value
;	jsr tstval		;	test if there's a need to save this coordinate
;	sta right_flag		;	save new flag value
;	dew xpos		;	restore xpos
;
;	inw ypos		;LOOK DOWN
;	jsr kg65.pixel		;	test if set
;	bcs 50$			;	loop until edge
;	bne 30$			;		   or border color
;
;50$	lda paint_stack_ptr+1	;pop next coordinate from stack
;	cmp paint_stack_bot+1
;	bne 60$			;		something more to do
;	lda paint_stack_ptr
;	cmp paint_stack_bot
;	beq 90$			;		nothing more to do, exit
;
;60$	sec
;	lda paint_stack_ptr	;	backup stack pointer
;	sbc #4
;	sta paint_stack_ptr
;	sta kg65.bpptr1
;	bcs 70$
;	dec paint_stack_ptr+1
;70$	lda paint_stack_ptr+1
;	sta kg65.bpptr1+1
;;	ldx #paint_stack_ptr	;	pop (xpos,ypos) from stack
;	ldz #1
;	ldy #4-1
;80$	jsr lda_bpptr1		;c65.lda_far_1
;	sta kg65.l.basepage*256+xpos,y
;	dey
;	bpl 80$
;
;;	jsr is_stop_key_down
;	bra ptloop		;loop for another pass
;
;
;90$	pla			;ptdone.  Done, normal exit from paint
;	tab			;	restore system basepage
;	clc			;	good return
;;	cli
;	rts
;
;	.page
;; TSTVAL - Test pixel color at current (xpos,ypos) position
;;	if set then set flag to zero
;;	if reset and flag = 1 then do nothing
;;	if reset and flag = 0 then save position on stack and set flag = 1
;
;tstval
;	pha			;save flag value
;	jsr kg65.pixel		;test pixel at (xpos,ypos)
;	bcs 20$			;	skip if out of bounds
;	beq 20$			;	exit if pixel = colsel (border color)
;	pla
;	bne 30$			;	exit if previous point reset
;
;	lda paint_stack_ptr+1   ;test if there is room on stack for another 4 bytes.
;	cmp paint_stack_top+1
;	bcc ptsave		;	..lots of room
;	bne 10$			;	..no room
;	lda paint_stack_ptr	;	..getting tight
;	cmp paint_stack_top
;	bcc ptsave		;		..but still some room
;
;10$	pla			;pterr.  pop return address
;	pla
;	pla			;restore system basepage
;	tab
;;	cli
;	sec			;exit, return 'out of memory' error
;	rts
;
;20$	pla			;tstgo.
;	lda #0			;set flag - last point set
;30$	rts			;tstxit.
;
;
;ptsave
;;	ldx #paint_stack_ptr	;push (xpos,ypos) onto stack
;	lda paint_stack_ptr
;	sta kg65.bpptr1
;	lda paint_stack_ptr+1
;	sta kg65.bpptr1+1
;	ldz #1
;	ldy #4-1
;10$	lda kg65.l.basepage*256+xpos,y
;;	jsr c65.sta_far_1
;	jsr sta_bpptr1
;	dey
;	bpl 10$
;	clc
;	lda paint_stack_ptr	;bump stack pointer
;	adc #4
;	sta paint_stack_ptr
;	bcc 20$
;	inc paint_stack_ptr+1
;
;20$	lda #$80		;set flag - last point reset
;	rts
;
;	.page
;kg65.pixel			;modified for new paint routine			F.Bowen	[910716]
;	lda #0			;init:
;	sta kg65.datflag	;	dat
;	sta kg65.temp4		;	bitplane #
;	sta kg65.temp5		;	color index value from bitplanes?
;	inc a
;	sta kg65.temp3		;	bitplane bit code
;
;	ldx #4-1		;	screen coordinates
;1$	lda xpos,x
;	sta kg65.linex0,x
;	dex
;	bpl 1$
;
;	lda kg65.linex0+1	;test for X position out of bounds		[910715]
;	cmp kg65.drawscrvpdx+1	;return .c set if out
;	bcc 10$
;	bne 7$			;	way out
;	lda kg65.linex0
;	cmp kg65.drawscrvpdx
;	bcs 7$			;	out
;
;10$	lda kg65.liney0+1	;test for Y position out of bounds
;	cmp kg65.drawscrvpdy+1
;	bcc 20$
;	bne 7$			;	way out
;	lda kg65.liney0
;	cmp kg65.drawscrvpdy
;	bcs 7$			;	out
;
;20$	bsr kg65.s.calcadr	;get physical address of pixel
;	lda kg65.linedsadr
;	sta kg65.dsadr		;	this is the address of the byte
;	lda kg65.linedsadr+1
;	sta kg65.dsadr+1
;	lda kg65.linemask	;	this is the bit offset			[910305]
;	sta kg65.mask
;
;2$	lda kg65.drawscrbp	;do for each bitplane
;	and kg65.temp3		;	is this bitplane used?
;	beq 3$			;		no
;
;	ldx kg65.temp4		;	this is the bitplane#
;	bsr kg65.s.readdsbyte	;	read the byte containing the pixel
;	and kg65.mask
;	beq 3$			;	br if pixel = 0, not a boundary
;
;	lda kg65.c.bitsup,x	;	a = bitplane pixel value
;	tsb kg65.temp5		;	color index				[FAB]
;
;3$	inc kg65.temp4		;	next bitplane...
;	asl kg65.temp3		;	...and bitplane mask
;	bcc 2$			;	loop until done all bitplanes
;
;	rmb7 kg65.datflag	;						[910506] ????
;
;	lda kg65.paint.mode	;						[910711] FAB
;	bne 6$
;	lda kg65.paint.bc	;is color index at this pixel a boundary color?
;	cmp kg65.temp5
;	clc
;7$	rts
;
;
;6$	lda kg65.temp5		;	return = if boundary, <> if not boundary
;	beq 4$
;
;5$	lda #0
;	clc
;	rts
;
;4$	dec a
;	clc
;	rts
;
;;.end
	.page
	.subttl Graphic Functions

	clc			;????

kg65.f.rgraphic			;Return Screen definition & status		[910823] FAB
;	sei
	tba			;	save caller base page
	pha
	lda #kg65.l.basepage	;	get our base page
	tab

	ldx kg65.parm1		;screen#
	cpx #4
	bcs 99$			;	illegal screen #, exit with .c=1

	lda kg65.c.scridx,x	;	convert screen# into screen table index
	tax
	ldy #0
10$	lda kg65.scrtab,x	;copy screen info from table into parm area
	sta kg65.l.basepage*256+kg65.parm2,y	;(no BP,Y)
	inx
	iny
	cpy #4
	bcc 10$

	lda kg65.drawscreen	;Also pass along current draw&view screens
	ldy #3			;	convert from screen index to logical screen#
20$	cmp kg65.c.scridx,y
	beq 25$
	dey
	bpl 20$
25$	sty kg65.parm6		;	($ff= not set)

	lda kg65.viewscreen
	ldy #3
30$	cmp kg65.c.scridx,y
	beq 35$
	dey
	bpl 30$
35$	sty kg65.parm7		;	($ff= not set, text)

	lda kg65.drawmode	;And return DrawModes & Patterns		[911028]
	sta kg65.parm8
	lda kg65.dpatype
;	lsr a			;	strip user length
;	lsr a
	sta kg65.parm9

	clc			;success flag
99$	pla			;restore caller base page
	tab
;	cli
	rts

	.page
	clc			;????

kg65.f.pixel			;Return color index at screen# (x,y)		[910826] FAB
;	sei
	tba			;	save caller base page
	pha
	lda #kg65.l.basepage	;	get our base page
	tab

;	clc			;nop
	jsr kg65.s.pixel	;	read pixel data
	ldy kg65.temp5		;return color index in .y

	pla			;	restore caller base page
	tab
	clc
;	cli
	rts



	clc			;????

kg65.f.pencolor			;Return color of a drawscreen pen		[910820] FAB
;	sei
	tba			;	save caller base page
	pha
	lda #kg65.l.basepage	;	get our base page
	tab

	ldx kg65.parm1		;pen#
	lda kg65.drawpens,x	;get color index (pixel mask)
	tay			;return in .y

	pla			;restore caller base page
	tab
	clc
;	cli
	rts

	.page
	clc			;????

kg65.f.rpalette			;Return rgb values of screen's palette			[910820] FAB
;	sei
	tba			;	save caller base page
	pha
	lda #kg65.l.basepage	;	get our base page
	tab
				;parm1 = screen#,  parm2 = color#
;	clc			;nop
	jsr kg65.s.read.palette	;read palette
				;parm3,4,5 = rgb values

	pla			;	restore caller base page
	tab
	clc
;	cli
	rts

	.page
	.subttl System I/O routines

read_byte			;Read a byte from an I/O channel, return status		[910402] FAB
	tba
	pha
	lda #0			;must use system base page for system call		[911119] FAB
	tab

	bbs6 c65.io.status,10$		;test for eof, return null if eof		[910506] FAB
	;	bit c65.io.status
	;	bvs 10$		

	jsr c65.chrin			;else get a byte from channel
;	sta kg65.l.basepage*256+kg65.tmp	;					[911119]
	taz
	;	pha
	;	jsr c65.readst		;check channel status, exit if I/O error
	lda c65.io.status
	and #%10000111			;	serial: err if dnp, r/w timeout errors	[911119]
	bne disk_error_exit		;	rs232:	err if brk, ovr, frm, par errors
	;	jsr c65.stop
	;	beq disk_error_exit	;exit if stop key down

	pla				;						[911119] FAB
	tab
;	pla
;	lda kg65.tmp
	tza
	rts


10$	pla			;							[911119] FAB
	tab
	lda #0
	rts

	.page
write_byte			;Write a byte to an I/O channel, return status		[910930] FAB
	sta kg65.tmp			;byte to write
	tba
	pha
	lda #0				;must use system base page for system call
	tab
	lda kg65.l.basepage*256+kg65.tmp

	jsr c65.chrout			;write byte to channel
	;	pha			; (no need to save byte????)
	;	jsr c65.readst		;	check channel status, exit if I/O error
	lda c65.io.status
	and #%10000111			;	serial: err if dnp, r/w timeout errors	[911119]
	bne disk_error_exit		;	rs232:	err if brk, ovr, frm, par errors
	;	jsr c65.stop
	;	beq disk_error_exit	;exit if stop key down????
	;	pla			; (no need to save byte????)
	pla
	tab
	rts


;.end
	.page
	.subttl DMA display routines

lda_temp1
	lda kg65.temp1			;set up DMA RAM list for LDA (temp1),Y from bank Z
	sta c65.dma_lda_list+3		;source lo
	lda kg65.temp1+1
	sta c65.dma_lda_list+4		;source hi
	tza
	ora kg65.banka
	sta c65.dma_lda_list+5		;source bank

	lda #0				;set up DMA controller
	sta c65.dma_ctlr+2
	lda #>c65.dma_lda_list
	sta c65.dma_ctlr+1
	lda #<c65.dma_lda_list
	sta c65.dma_ctlr		;(triggers DMA op)
	lda c65.dma_byte		;data
	rts

lda_bpptr1
	tya				;set up DMA RAM list for LDA (bpptr1),Y from bank Z
	clc
	adc kg65.bpptr1
	sta c65.dma_lda_list+3		;source lo
	lda #0
	sta c65.dma_ctlr+2
	adc kg65.bpptr1+1
	sta c65.dma_lda_list+4		;source hi
	tza
	ora kg65.banka
	sta c65.dma_lda_list+5		;source bank

	lda #>c65.dma_lda_list		;set up DMA controller (list in bank 0 always)
	sta c65.dma_ctlr+1
	lda #<c65.dma_lda_list
	sta c65.dma_ctlr		;(triggers DMA op)
	lda c65.dma_byte		;data
	rts

	.page
sta_temp1
	sta c65.dma_byte		;save data
	lda kg65.temp1
	sta c65.dma_sta_list+6		;destination lo
	lda kg65.temp1+1
	sta c65.dma_sta_list+7		;destination hi
	tza
	ora kg65.banka
	sta c65.dma_sta_list+8		;destination bank

	lda #0				;set up DMA controller
	sta c65.dma_ctlr+2
	lda #>c65.dma_sta_list
	sta c65.dma_ctlr+1
	lda #<c65.dma_sta_list
	sta c65.dma_ctlr		;(triggers DMA op)
;	lda c65.dma_byte		;data						[FAB]
	rts


sta_bpptr1
	sta c65.dma_byte		;save data
	tya
	clc				;set up DMA RAM list for STA (X),Y from bank Z
	adc kg65.bpptr1
	sta c65.dma_sta_list+6		;destination lo
	lda #0
	sta c65.dma_ctlr+2
	adc kg65.bpptr1+1
	sta c65.dma_sta_list+7		;destination hi
	tza
	ora kg65.banka
	sta c65.dma_sta_list+8		;destination bank

	lda #>c65.dma_sta_list		;set up DMA controller
	sta c65.dma_ctlr+1
	lda #<c65.dma_sta_list
	sta c65.dma_ctlr		;(triggers DMA op)
;	lda c65.dma_byte		;data						[FAB]
	rts

	.end
