.PAGE 'DOT PATTERNS'
; ADDRESS TABLE FOR EACH PRINT COLUMN.
; EACH TBL CONTAINS DOT PATTERNS FOR 1 OF 5 COLUMNS.
;   DATA ARE STORED WITH EACH BYTE DEFINING ONE COLUMN..
; OF A CHARACTER, WITH THE TOP DOT CORRESPONDING TO THE..
; LSB IN THE BYTE
MTBL	.WOR COL0,COL1,COL2,COL3,COL4
;DOT PATTERNS FOR COLUMN ZERO (LEFTMOST COLUMN)
COL0	.BYT $3E,$7E,$7F,$3E,$7F,$7F,$7F,$3E
	.BYT $7F,$00,$20,$7F,$7F,$7F,$7F,$3E
	.BYT $7F,$3E,$7F,$46,$01,$3F,$07,$7F
	.BYT $63,$07,$61,$7F,$03,$00,$02,$40
	.BYT $00,$00,$00,$14,$24,$63,$60,$00
	.BYT $00,$00,$14,$08,$40,$08,$40,$60
	.BYT $3E,$44,$62,$41,$18,$27,$3C,$01
	.BYT $36,$46,$00,$40,$08,$14,$41,$02

;DOT PATTERNS FOR COLUMN 1
COL1	.BYT $41,$09,$49,$41,$41,$49,$09,$41
	.BYT $08,$41,$40,$08,$40,$02,$06,$41
	.BYT $09,$41,$09,$49,$01,$40,$18,$20
	.BYT $14,$08,$51,$41,$04,$00,$01,$40
	.BYT $00,$00,$07,$7F,$2A,$13,$4E,$04
	.BYT $1C,$41,$08,$08,$30,$08,$00,$10
	.BYT $51,$42,$51,$41,$14,$45,$4A,$71
	.BYT $49,$49,$00,$34,$14,$14,$41,$01

;DOT PATTERNS FOR COLUMN 2
COL2	.BYT $5D,$09,$49,$41,$41,$49,$09,$41
	.BYT $08,$7F,$41,$14,$40,$0C,$08,$41
	.BYT $09,$51,$19,$49,$7F,$40,$60,$18   P -- W
	.BYT $08,$78,$49,$41,$08,$41,$01,$40
	.BYT $00,$4F,$00,$14,$7F,$08,$59,$02
	.BYT $22,$22,$3E,$3E,$00,$08,$00,$08
	.BYT $49,$7F,$51,$49,$12,$45,$49,$09
	.BYT $49,$49,$44,$00,$22,$14,$22,$51

;DOT PATTERNS FOR COLUMN 3
COL3	.BYT $55,$09,$49,$41,$22,$49,$09,$49
	.BYT $08,$41,$3F,$22,$40,$02,$30,$41
	.BYT $09,$21,$29,$49,$01,$40,$18,$20
	.BYT $14,$08,$45,$00,$10,$41,$01,$40
	.BYT $00,$00,$07,$7F,$2A,$64,$26,$01
	.BYT $41,$1C,$08,$08,$00,$08,$00,$04
	.BYT $45,$40,$49,$55,$7F,$45,$49,$05
	.BYT $49,$29,$00,$00,$41,$14,$14,$09

;DOT PATTERNS FOR COLUMN 4
COL4	.BYT $1E,$7E,$36,$22,$1C,$41,$01,$7A
	.BYT $7F,$00,$01,$41,$40,$7F,$7F,$3E
	.BYT $06,$5E,$46,$31,$01,$3F,$07,$7F
	.BYT $63,$07,$43,$00,$60,$7F,$02,$40
	.BYT $00,$00,$00,$14,$12,$63,$50,$00
	.BYT $00,$00,$14,$08,$00,$08,$00,$03
	.BYT $3E,$40,$46,$22,$10,$39,$31,$03
	.BYT $36,$1E,$00,$00,$41,$14,$08,$06

;ASCII CHARACTERS FOR KB
ROW1	.BYT $20,$08,$00,$0D,$00,$00,$00,$00
ROW2	.BYT $00,$60,'\',$00,$00,$00,$7F,$00
ROW3	.BYT '.LP-:0;/'
ROW4	.BYT 'MJIO98K,'
ROW5	.BYT 'BGYU76HN'
ROW6	.BYT 'CDRT54FV'
ROW7	.BYT 'ZAWE32SX'
ROW8	.BYT $00,$00,$1B, 'Q1',$5E,']['
.PAGE 'DISASSEMBLER'
;DISASSEMBLE INSTRUCTION AND SHOW REGS IS REGF SET
REGQ	LDA REGF         ;GET FLAG
	BEQ DISASM
	JSR REG1         ;SHOW THE SIX REGS
	JSR CRCK         ;(CR)

DISASM	JSR PRBL2
	JSR PRPC         ;OUTPUT PROG COUNTER
	LDY #0
	JSR PCLLD
	TAY
	LSR A
	BCC IEVEN
	LSR A
	BCS ERR
	CMP #$22
	BEQ ERR
	AND #7
	ORA #$80
IEVEN	LSR A
	TAX
	LDA MODE,X
	BCS RTMODE
	LSR A
	LSR A
	LSR A
	LSR A
RTMODE	AND #$F
	BNE GETFMT
ERR	LDY #$80
	LDA #0
GETFMT	TAX
	LDA MODE2,X
	STA FORMA
	AND #3
	STA LENGTH
	TYA              ;OPCODE
	AND #$8F
	TAX
	TYA              ;OPCODE IN A AGAIN
	LDY #3
	CPX #$8A
	BEQ MNNDX3
MNNDX1	LSR A
	BCC MNNDX3
	LSR A
MNNDX2	LSR A
	ORA #$20
	DEY
	BNE MNNDX2
	INY
MNNDX3	DEY
	BNE MNNDX1
	PHA              ;SAVE MNEMONIC TABLE INDEX
	JSR PCLLD
	JSR NUMA
	JSR PRBL2        ;PRINT LAST BALNK
	PLA
	TAY
	LDA MNEML,Y
	STA LMNEM
	LDA MNEMR,Y
	STA RMNEM
	LDX #3           ;MUST BE
PRMN1	LDA #0
	LDY #5
PRMN2	ASL RMNEM
	ROL LMNEM
	ROL A
	DEY
	BNE PRMN2
	ADC #$BF         ;ADD '?' OFFSET
	JSR OUTALL
	DEX
	BNE PRMN1
	JSR PRBL2
	LDX #6
	LDA #0
	STA STIY+2       ;FLAG
PRADR1	CPX #3
	BNE PRADR3       ;IF X=3 PRINT ADDR VALUE
	LDY LENGTH
	BEQ PRADR3       ;1 BYTE INSTR
PRADR2	LDA FORMA
	CMP #$E8         ;RELATIVE ADDRESSING
	JSR PCLLD
	BCS RELADR
;SEE IF SYMBOL
	PHA
	LDA STIY+2
	BNE MR11A
	INC STIY+2       ;SHOW WE WERE HERE

MR11A	PLA
	JSR NUMA
	DEY
	BNE PRADR2
PRADR3	ASL FORMA
	BCC PRADR4
	LDA CHAR1-1,X
	JSR OUTALL
	LDA CHAR2-1,X
	BEQ PRADR4
	JSR OUTALL
PRADR4	DEX
	BNE PRADR1
	RTS
RELADR	JSR PCADJ3
	TAX
	INX
	BNE PRNTYX
	INY
PRNTYX	TYA
	JMP WRAX         ;PRINT A &X
PRPC	LDA SAVPC+1      ;PRINT PC
	LDX SAVPC
	JSR WRAX
PRBL2	LDA #$20
	JMP OUTALL
	LDA LENGTH
	SEC
PCADJ3	LDY SAVPC+1      ;PRG CNTR HIGH
	TAX
	BPL PCADJ4
	DEY
PCADJ4	ADC SAVPC        ;PROG CNTR LOW
	BCC RTS1
	INY
RTS1	RTS

MODE	.BYT $40,2,$45,3,$D0,8,$40,9
	.BYT $30,$22,$45,$33,$D0,8,$40,9
	.BYT $40,2,$45,$33,$D0,8,$40,9
	.BYT $40,2,$45,$B3,$D0,8,$40,9
	.BYT 0,$22,$44,$33,$D0,$8C,$44,0
	.BYT $11,$22,$44,$33,$D0,$8C,$44,$9A
	.BYT $10,$22,$44,$33
	.BYT $D0,8,$40,9
	.BYT $10,$22,$44,$33,$D0,8,$40,9
	.BYT $62,$13,$78,$A9

MODE2	.BYT 0,$21,1,2,0,$80,$59,$4D
	.BYT $11,$12,6,$4A,5,$1D

CHAR1	.BYT ',',$29,',#(','.'
CHAR2	.BYT 'Y',0,'X',0,0,'A'

MNEML	.BYT $1C,$8A,$1C,$23,$5D,$8B,$1B
	.BYT $A1
	.BYT $9D,$8A,$1D,$23,$9D,$8B,$1D,$A1
	.BYT 0,$29,$19,$AE,$69,$A8,$19,$23
	.BYT $24,$53,$1B,$23,$24,$53,$19,$A1
	.BYT 0,$1A,$5B,$5B,$A5,$69,$24,$24
	.BYT $AE,$AE,$A8,$AD,$29,0,$7C,0
	.BYT $15,$9C,$6D,$9C,$A5,$69,$29,$53
	.BYT $84,$13,$34,$11,$A5,$69,$23,$A0

MNEMR	.BYT $D8,$62,$5A,$48,$26,$62,$94
	.BYT $88
	.BYT $54,$44,$C8,$54,$68,$44,$E8,$94
	.BYT 0,$B4,8,$84,$74,$B4,$28,$6E
	.BYT $74,$F4,$CC,$4A,$72,$F2,$A4,$8A
	.BYT 0,$AA,$A2,$A2,$74,$74,$74,$72
	.BYT $44,$68,$B2,$32,$B2,0,$22,0
	.BYT $1A,$1A,$26,$26,$72,$72,$88,$C8
	.BYT $C4,$CA,$26,$48,$44,$44,$A2,$C8
.PAGE 'TEXT EDITOR'
;*******************************
;***    AIM TEXT EDITOR      ***
;***      05/01/78           ***
;*******************************

; R=READ FROM ANY INPUT DEVICE
; I=INSERT A LINE FORM INPUT DEV
; K=DELETE A LINE
; U=GO UP ONE LINE
; D=O DOWN ONE LINE
; L=LIST LINES TO OUTPUT DEV
; T=GO TO TO OF TEXT
; B=GO TO BOTTOM OF TEXT
; F=FIND STRING
; C=CHANGE STRING TO NEW STRING
; Q=QUIT EDITOR
; (SPACE)=DISPLAY CURRENT LINE

;***** E COMMAND-EDITOR ENTRY (FROM MONITOR) *****
EDIT	JSR CRLOW
	LDY #EMSG1-M1
	JSR KEP          ;START UP MSG
	JSR CRLOW
EDIO	JSR FROM
	BCS EDIO
	LDA CKSUM        ;IS CLR IF ADDR WAS INPUTTED
	BEQ *+5
	JSR WRITAZ       ;OUTPUT DEFAULT ADDR (0200)
	LDX #1
EDI1	LDA ADDR,X
	STA TEXT,X
	STA BOTLN,X
	STA S1,X         ;FOR MEMORY TEST
	DEX
	BPL EDI1
	JSR BLANK2
EDI2	JSR TO           ;END
	BCS EDI2
	JSR TOPNO        ;TRANSF TEXT TO ADDR FRO RAM CHECK
	LDA CKSUM        ;IS CLR IF ADDR WAS INPUTTED
	BEQ EDI4         ;BRNCH IF NOT DEFAULT VALUE
	JSR SAVNOW
EDI3	JSR EDI          ;CARRY IS SET IF NO RAM THERE
	BCC EDI3
	LDA #0           ;SET UPPER LIMIT TO BEGINNING....
	STA ADDR         ;OF PAGE
	JSR WRITAZ       ;OUTPUT DEFAULT VALUE ,UPPER LIMIT
EDI4	LDA ADDR
	STA END
	LDA ADDR+1
	STA END+1
	JSR SAVNOW
;NOW SEE IF MEMORY IS THERE
EDI5	JSR EDI
	BCC EDI5
	LDA END+1        ;CMP WITH END
	CMP ADDR+1
	BEQ EDI7
	BCS EDI8
EDI6	JSR TOPNO        ;RESTORE NOWLN
	LDA #0
	STA (NOWLN)Y     ;END OF TEXT MARKER
	JSR CRLOW
	LDA #'R          ;FORCE READ COMMAND
	JMP ENTRY
EDI7	LDA END          ;IF ZERO MEM IS OK
	BEQ EDI6
EDI8	LDA #0
	STA ADDR
	JMP MEMERR       ;NO MEMORY FOR THOSE LIMITS

EDI	LDY #0           ;CHCK IF MEMORY WRITES
	JSR PATCH6       ;GET BYTE ADDR BY ADDR,ADDR+1
	PHA              ;SAVE IT
	LDA #$AA         ;SET THIS PATTERN
	JSR SADDR        ;CHCK IT
	BNE EDI2B
	PLA
	JSR SADDR        ;RESTORE CHR
	INC ADDR+1       ;NEXT PAG
	CLC              ;IT WROTE
	RTS
EDI2B	SEC              ;DIDNT WRITE
	PLA
	RTS

;***** T COMMAND-REENTRY EDITOR *****
;RE-ENTRY POINT,TEXT ALREADY THERE
REENTR	JSR CRCK         ;(CR) IF PRI ON
TP	JSR TOPNO        ;GO TO TOP
	JMP INO3A        ;DISPLAY LINE

;***** U COMMAND-UP LINE *****
;GO UP ONE LINE BUT....
;DOWN IN ADDRESSING MEMEORY
DNNO	JSR ATTOP        ;THIS RTN DOESNT PRINT
	BCC DOW1         ;NOT TOP
	JSR PLNE         ;ARE AT TOP
	JMP ERRO
DOW1	LDY #0
	JSR SUB          ;DECREMENT NOWLN PAST (CR)
DOW2	JSR SUB
	JSR ATTOP
	BCS UP4
	LDA (NOWLN)Y
	CMP #CR
	BNE DOW2
	JMP AD1

;***** D COMMAND-DOWN LINE *****
;GO DOWN ONE LINE BUT....
;UP IN ADRESSING MEMEORY
UP	JSR UPNO
	JSR PLNE         ;DISPLAY LINE & CHCK BOTTOM
	JSR ATBOT
	BCC UP4
	LDY #EMSG2-M1    ;PRINT 'END'
	JMP KEP
UPNO	LDY #0
	JSR ATBOT
	BCC UP1
	JMP ENDERR
UP1	LDA (NOWLN)Y
	BEQ UP4
	INY
	CMP #CR
	BNE UP1
	TYA
	JSR ADDA         ;ADD LENGTH TO CURRENT LINE
UP4	RTS

;***** B COMMAND-GO TO BOTTOM *****
BT	JSR SETBOT
;START U-COMMAND HERE
DOWN	JSR DNNO         ;U COMMAND

;***** (SPACE) COOMAND-DISPLAY CURRENT LINE *****
PLNE	LDY #0           ;PRINT CURRENT LINE
PO2	LDA (NOWLN)Y
	BEQ PO1          ;PAST END ?
	CMP #CR          ;DONE?
	BEQ      PO1
	JSR OUTALL       ;PUT IT SOMEWHERE
	STA DIBUFF,Y
	INY
	JMP PO2
PO1	STY LENGTH
	STY OLDLEN
PO3	LDY OUTFLG       ;ONE MORE (CR) FOR TAPE
	CPY #CR
	BEQ PO0
	JMP CRLF         ;TO OUTPUT DEV
PO0	JMP CRCK         ;(CR), & DONT CLR DISPL

;***** K COMMAND-KILL LINE *****
;DELETE CURRENT LINE
DLNE	JSR KIFLG        ;CLR K OR I COMM FLG
	NOP
	NOP
	NOP
	JSR PLNE
	JSR ATBOT
	BCS PLNE         ;AT END OF TEXT
	LDY #0
	STY LENGTH
	JSR REPLAC       ;KILL LINE
	JMP PLNE

;***** I COMMAND-INSERT LINE *****
IN	JSR INL
	JSR UP           ;DISPLAY NEXT LINE DOWN
	JMP ERRO         ;IF AT BOTTOM PRINT 'END'
INL	JSR KIFLG        ;CLR K OR I COMM FLG
	LDY #0           ;GET LINE INTO DIBUFF
	STY OLDLEN
	JSR PROMPT
	JSR CLR
INO2	JSR INALL
	JSR PATC12       ;CLR, SO WE CAN OUTPUT TO PRI
	CMP #$7F         ;RUB
	JMP PATC17       ;NO ZEEROS IN CASE OF PAPER TAPE
INO2A	CMP #LF
	BEQ INO2
	CMP #CR
	BEQ INO3
	CPY #60          ;DO NOT INCR Y IF 60
	BCS INO3B
	STA DIBUFF,Y
	INY
	CPY #60
	BNE INO2         ;CONTIN , DISP WONT ALLOW > 60 CHR
INO3B	LDY #60          ;SET Y TO MAX OF 60
	LDA #$01
	ORA PRIFLG       ;DO NOT OUTPUT TO PRI ANY MORE
	STA PRIFLG       ;OTHERWISE CLOBBERS BUFFER
	STY CURPO2
	BNE INO2         ;GO BACK
INO3	STY LENGTH
	CPY #0           ;FIRST CHAR?
	BNE INO5
	LDA COUNT        ;K OR I COMM FLG ?
	BNE INO5         ;BRANCH IF C COMMAND
	JSR CRCK         ;(CR) IF PRI PNTR DIFF FROM 0
	JSR PATC13       ;TURN ON TAPES & SET DEFAULT DEV
INO3A	JSR PLNE         ;DISPLAY NEXT LINE DOWN
	JSR UPNO         ;PRINT 'END' IF BOTTOM
	JSR DNNO
	JMP ERRO
INO5	JSR REPLAC       ;INSERT HE LINE
	JMP CRCK         ;(CR) IF PRI PTR NOT 0

;***** R COMMAND-READ LINE *****
;READ TEXT FROM ANY INPUT DEVICE UNTIL
;TWO CONSECUTIVE (CR) ARE ENCOUNTERED
INPU	JSR WHEREI
	LDY INFLG        ;IF TAPE DO NOT ERRASE BUFFER
	CPY #'T
	BEQ INPU1
	JSR CRLOW
INPU1	JSR INL
	JSR UPNO         ;NEXT LINE
	JMP INPU1

;***** L COMMAND-LIST LINES *****
;PRINT FROM HERE N LINES TO ACTIVE OUTPUT DEV
LST	JSR PSL1         ;PRINT '/'
	JSR GCNT         ;GET LINES COUNT
	JSR CRLOW
	JSR WHEREO       ;WHERE TO
	JMP LSTO2        ;ONE MORE LINE
LSTO1	JSR RCHEK
	JSR DONE
	BEQ LST3
LSTO2	JSR PLNE
	JSR UPNO         ;NEXT LINE
	JSR ATBOT
	BCC LSTO1        ;NO
LST3	JSR PO3          ;ONE MORE CRLF FOR TAPE
	JSR PATC14       ;CLOSE TAPE IF NEEDED
	JMP ENDERR

;***** F COMMAN-FIND STRING *****
;FIND STRING AND PRINT LINE TO TERMINAL
FCHAR	JSR FCH
FCHA1	LDA CURPO2       ;SAVE BUFFER PNTR
	PHA
	JSR CLR          ;CLEAR DISP PNTR
	JSR PLNE
	PLA
	STA CURPO2
	RTS
;FIND A CHARACTER STRING
FCH	LDY #0
	JSR PROMPT
FC1	JSR RDRUB        ;GET THE CHARACTER
	CMP #$D          ;REUSE OLD ARGUMENT??
	BNE FC3
	CPY #0           ;FIRST CHAR?
	BNE FC3
FC2	JSR UPNO         ;NEXT LINE DOWN
	JMP FC5
FC3	CMP #CR          ;DONE
	BEQ FC4
	STA STRING,Y
	INY
	CPY #20          ;MAX LENGTH
	BNE FC1
	JMP ERROR
FC4	JSR CRCK         ;CLEAR DISPLAY
	STY STIY+2       ;COUNT OF CHRACTERS
FC5	LDY #0
	STY CURPO2       ;STRAT AT BEGINNING OF LINENTR IS
FC6	LDY CURPO2       ;CLOBBER
	LDX #0
FC7	LDA (NOWLN)Y     ;GET THE CHARACTER
	BNE FC8          ;NOT AT END
	JMP ENDERR
FC8	CMP #CR          ;END OF LINE
	BEQ FC2
	CMP STRING,X
	BEQ FC9
	INC CURPO2
	JMP FC6
FC9	INY
	INX
	CPX STIY+2       ;DONE?
	BNE FC7
	RTS

;***** Q COMMAND-EXIT EDITOR *****
;EXIT THE TEXT EDITOR NEATLY
STOP	JSR CRLOW
	JMP COMIN

;***** C COMMAND-CHANGE STRING *****
;CHANGE STRING TO ANOTHER STRING IN A LINE
CHNG	JSR CFLG         ;SET C COMMAND FLG
	JSR FCHAR        ;FIND CORRECT LINE
CHN1	JSR READ         ;IS (CR) IF OK
	CMP #CR
	BEQ CHN2
	JSR FC2          ;TRY NEXT ONE
	JSR FCHA1        ; SHOW LINE
	JMP CHN1
CHN2	LDA STIY+2       ;GET CHAR COUNT
	STA OLDLEN       ;GET READY FRO REPLAC
	LDA CURPO2       ;PNTR TO BEGINNING OF STRING
	PHA              ;SAVE IT
	JSR ADDA         ;ADD TO NOWLN (LINE PNTR)
	JSR CLR          ;CLEAR DISP
	LDY #M3-M1       ;PRINT 'TO'
	JSR KEP
	LDY #0
	JSR INO2         ;GET NEW STRING & REPLAC
	PLA
	TAX
	BEQ CHN4
CHN3	JSR SUB          ;RESTORE NOWLN WHERE IT WAS
	DEX
	BNE CHN3
CHN4	JMP PLNE         ;DISPLAY THE CHANGED LINE

;THE FOLLOWING ARE SUBROUTINES USED BY COMMANDS
CFLG	LDA #1           ;SET FLG FOR C COMMAND
	BNE KI2
KIFLG	LDA #0           ;CLR K OR I COMMAND FLG
KI2	STA COUNT
	RTS

TOPNO	LDA TEXT         ;SET CURRENT LINE TO TOP
	LDX TEXT+1
TPO1	STA NOWLN
	STX NOWLN+1
	RTS

SETBOT	LDA BOTLN        ;SET CURRENT LINE TO BOTTOM
	LDX BOTLN+1
	STA SAVE
	STX SAVE+1
	JMP TPO1

RESNOW	LDA ADDR         ;RESTORE CURRENT LINE ADDRESS
	STA NOWLN
	LDA ADDR+1
	STA NOWLN+1
	RTS

;SEE CURRENT LINE AT TOP (C SET IF SO)
ATTOP	LDA NOWLN
	CMP TEXT
	BNE ATO1
	LDA NOWLN+1
	CMP TEXT+1
	BNE ATO1
	SEC
	RTS

;SEE IF CURRENT LINE AT BOTTOM (C SET IF SO)
ATBOT	LDA NOWLN
	LDX NOWLN+1
	CMP BOTLN
	BNE ATO1
	CPX BOTLN+1
	BNE ATO1
ATO2	SEC
	RTS
ATO1	CLC
	RTS

;SEE IF WE RAN PAST END OF BUFFER LIMIT
ATEND	LDA BOTLN
	LDX BOTLN+1
	CPX END+1        ; HIGH BYTE > OR = ?
	BCC ATO1
	BNE ATO2
	CMP END          ;LOW BYTE > OR = ?
	BCC ATO1
	BCS ATO2

;SAVE CURRENT LINE (NOWLN) IN S1
NOWS1	LDA NOWLN
	LDX NOWLN+1
	JMP ADDS1A

;MOVE ADDR INTO S1
ADDRS1	LDA ADDR
	LDX ADDR+1
ADDS1A	STA S1
	STX S1+1
	RTS

;SUBTRACT ONE FROM CURRENT LINE (NOWLN)
SUB	DEC NOWLN
	LDA NOWLN
	CMP #$FF
	BNE SUB1
	DEC NOWLN+1
SUB1	RTS

;ADD ACC TO CURRENT LINE (NOWLN)
AD1	LDA #1
ADDA	CLC
	ADC NOWLN
	STA NOWLN
	BCC ADDA1
	INC NOWLN+1
ADDA1	RTS

SAVNOW	LDA NOWLN        ;SAVE CURRENT LINE INTO ADDR
	STA ADDR
	LDA NOWLN+1
	STA ADDR+1
REP2	RTS
.PAGE 'MAIN MEMORY MOVER'
;MOVE CURRENT TEXT AROUND TO HAVE
;SPACE TO PUT IN THE NEW BUFFER
REPLAC	LDY LENGTH
	CPY OLDLEN       ;COMPARE OLD AND NEW LENGTHS
	BNE R2W          ;BRANCH IF DIFF
	BEQ R87          ;LENGTHS ARE EQUAL.  JUST REPLACE
R8	LDA #CR
	STA (NOWLN)Y
	JSR GOGO

;LENGTH = OLDLEN
R87	DEY
	CPY #$FF
	BEQ REP2
R88	LDA DIBUFF,Y
	STA (NOWLN)Y
	JSR GOGO
	DEY
	BPL R88
	RTS
R2W	BCS R100         ;LENGTH > OLDLEN

;LENGTH < OLDLEN
	JSR SAVNOW       ;PUT NOWLN INTO ADDR
	JSR ADDRS1       ;PUT IT IN S1 ALSO
	LDA OLDLEN
	SEC
	SBC LENGTH       ;GET DIFFERENCE IN LENGTHS
	LDY LENGTH
	BNE RQP
	LDX COUNT        ;C-COMM ?
	BNE RQP          ;YES, JUMP
	ADC #0           ;INCLUDE (CR)
RQP	PHA
	CLC
	ADC S1
	STA S1
	BCC R6
	INC S1+1
R6	LDA #<S1
	JSR LDAY
	STA (NOWLN)Y     ;.... AND MOVE IT UP (DOWN IN ADDR)
	JSR GOGO
	TAX
	LDA S1
	CMP BOTLN        ;DOBE ??
	BNE R5
	LDA S1+1
	CMP BOTLN+1
	BEQ R7
R5	JSR AD1
	INC S1
	BNE R55
	INC S1+1
R55	JMP R6
R7	JSR RESNOW       ;RESTORE NOWLN
	PLA              ;RESTORE DIFFERENCE
	STA CPIY         ;SAVE IT
	LDA BOTLN
	SEC
	SBC CPIY         ;AND SUBTRACT IT FROM BOTTOM
	STA BOTLN
	BCS R9
	DEC BOTLN+1
R9	LDA COUNT        ;C COMM OR K ,I COMM ?
	BNE R10
	LDY LENGTH
	BNE R11
R10	LDY LENGTH
	BNE R87
	RTS
R11	JMP R8

;LENGTH > OLDLEN
R100	LDA LENGTH       ;NEW LINE IS LONGER
	SEC
	SBC OLDLEN
	LDY OLDLEN
	BNE R101         ;ALREADY HAVE ROOM FOR CR
	ADC #0           ;ADD ONE TO DIFFERENCE
R101	PHA
	JSR SAVNOW       ;NOWLN ITNO S1
	JSR SETBOT
	LDY #0
R102	LDA (NOWLN)Y
	CMP #0
	BEQ R108
	JSR AD1
	JMP R102
R108	PLA
	PHA
	CLC
	ADC BOTLN        ;ADD DIFFERENCE TO END
	STA BOTLN        ;STORE NEW END
	BCC R103
	INC BOTLN+1
R103	JSR ATEND
	BCC R107
	LDA SAVE         ;RESTORE OLD BOTTOM
	STA BOTLN
	LDA SAVE+1
	STA BOTLN+1
	JMP ENDERR       ;RAN PAST BUFFER END
R107	JSR NOWS1        ;SAVE CURRENT END
	PLA
	CLC
	ADC NOWLN
	STA NOWLN
	BCC R104
	INC NOWLN+1
R104	LDA #<S1
	JSR LDAY
	STA (NOWLN)Y
	JSR GOGO
	LDA S1
	CMP ADDR
	BNE R105
	LDA S1+1
	CMP ADDR+1       ;BACK WHERE WE STARTED ??
	BEQ R106         ;BRANCH IF DONE
R105	JSR SUB
	DEC S1
	LDA S1
	CMP #$FF
	BNE R1051
	DEC S1+1
R1051	JMP R104
R106	JSR RESNOW
	JMP R9

;SEE IF IT WROTE INTO MEMORY
GOGO	CMP (NOWLN)Y
	BEQ GOGO1
;MOVE ADDRESS
	LDA NOWLN
	STA ADDR
	LDA NOWLN+1
	STA ADDR+1
	JMP MEMERR
GOGO1	RTS              ;OK
.PAGE 'ERROR HANDLERS'
ENDERR	JSR CLR          ;CLEAR PNTR
	LDY #EMSG2-M1    ;PRINT 'END'
	JSR KEP
	JSR DNNO         ;BACK UP TO LAST LINE
	JSR TTYTST       ;IF TTY (CR)
	BNE ENDE2
	JSR CRLOW
ENDE2	JMP ERRO
ERROR	JSR LL
	JSR QM
ERRO	JSR CLR
	LDX #$FF
COM=ERRO
	TXS
	JSR LL           ;I/O TO TERMINAL (KB,D/P OR TTY)
	CLD
	JSR COMM
	JMP COM

; GET EDDITOR COMMANDS & DECODE
COMM	LDX #0
	JSR PATCH8       ;READ A CHAR WITH '=( )'
ENTRY	LDX #COMCN1
CD02	CMP COMTBL,X     ;COMPARE WITH ALL ALLOWABLE COMMANDS
	BEQ CFND1        ;MATCH ,SO PROCESS COMMAND
	DEX
	BPL CD02
	JSR QM           ;NOT IN LIST ,SO NOT LEGAL COMMAND
	JSR CRCK
	JMP ERRO
CFND1	JSR PATC15       ;(CR) & START DECODING COMMAND
	LDA HTBL+1,X
	STA S1+1
	JMP (S1)

COMCN1=11
;COMMAND TABLE
COMTBL	.BYT 'K RIUDLTBFQC'
HTBL	.WOR DLNE,PLNE,INPU,IN,DOWN,UP
	.WOR LST,TP,BT,FCHAR,STOP,CHNG

;READ FROM MEMORY FOR ASSEMBLER
MREAD	TYA
	PHA
	LDY #0
	LDA (NOWLN)Y
	STA CPIY
	JSR AD1
	PLA
	TAY
	LDA CPIY
	RTS
.PAGE 'OP CODE CONVERSION'
;THIS PROGRAM CONVERTS MNEMONIC INSTRUCTIONS INTO MACHINE
;CODE AND STORES IT ON THE DESIGNATED MEMORY AREA

;ROM TABLE LOCATIONS
TYPTR1	.BYT 00,02,00,08,$F2,$FF,$80,01
	.BYT $C0,$E2,$C0,$C0,$FF,00,00
TYPTR2	.BYT 08,00,$10,$80,$40,$C0,00,$C0
	.BYT $00,$40,00,00,$E4,$20,$80
CORR	.BYT 00,$FC,00,08,08,$F8,$FC,$F4
	.BYT $0C,$10,04,$F4,00,$20,$10
SIZEM	.BYT 00,00,$0F,01,01,01,$11,$11
	.BYT 02,02,$11,$11,02,$12,00

STCODE	.BYT $00,$08,$10,$18,$20,$28,$30,$38
	.BYT $40,$48,$50,$58,$60,$68,$70,$78
	.BYT $80,$88,$90,$98,$AC,$A8,$B0,$B8
	.BYT $CC,$C8,$D0,$D8,$EC,$E8,$F0,$F8
	.BYT $0C,$2C,$4C,$4C,$8C,$AC,$CC,$EC
	.BYT $8A,$9A,$AA,$BA,$CA,$DA,$EA,$FA
	.BYT $0E,$2E,$4E,$6E,$8E,$AE,$CE,$EE
	.BYT $0D,$2D,$4D,$6D,$8D,$AD,$CD,$ED
TYPTB	.BYT 13,13,12,13,14,13,12,13
	.BYT 13,13,12,13,13,13,12,13
	.BYT 15,13,12,13,9,13,12,13
	.BYT 8,13,12,13,8,13,12,13
	.BYT 15,6,11,11,4,10,8,8
	.BYT 13,13,13,13,13,15,13,15
	.BYT 7,7,7,7,5,9,3,3
	.BYT 1,1,1,1,2,1,1,1

;PROGRAM STARTS HERE
MNEENT	LDA SAVPC        ;TRANSF PC TO ADDDR
	STA ADDR
	LDA SAVPC+1
	STA ADDR+1
STARTM	JSR CRCK         ;(CR) IF PRI PTR DIFF FROM 0
	LDA #0
	STA CODFLG
	JSR BLANK
	JSR WRITAZ       ;WRITE ADDRESS
	JSR BLANK2
	JSR BLANK2
	JMP MNEM         ;JUMP TO INPUT MNEMONIC OPCODE
MODEM	LDA #00          ;SET UP TO FORM MODE MATCH
	STA TMASK1
	STA TMASK2
	JSR BLANK
	LDY TYPE
	SEC
PNTLUP	ROR TMASK1       ;SHIFT POINTER TO INSTRUCTION TYPE
	ROR TMASK2
	DEY
	BNE PNTLUP

;TEST FRO ONE BYTE INSTRUCTION
	LDY TYPE
	CPY #$0D
	BNE RDADDR
	LDX #00
	JMP OPCOMP

;INPUT ADDRESS FIELD
RDADDR	LDY #06          ;CLEAR ADDRESS FIELD (NON HEX)
	LDA #'Q'
CLRLUP	STA ADFLD-1,Y
	DEY
	BNE CLRLUP       ;(LEAVES Y = 0 FOR NEXT PHASE)
	JSR RDRUB        ;WITHOUT RUBOUT
	CMP #$20         ;IGNORE SPACE CHARCATERS
	BEQ RDADDR
STORCH	STA ADFLD,Y      ;STROE ADDRESS CHARACTER
	INY
	CPY #07
	BCS TRY56
	JSR RDRUB        ;READ REMAINDER OF ADDRESS CHARS
	CMP #$20         ;THRU WHEN (SPACE) OR (CR)
	BNE STOR1
	INC CODFLG       ;SET CODE FLG
	BNE EVAL
STOR1	CMP #$0D         ;CHECK FOR (CR)
	BNE STORCH

;SEPARATE ADDRESSING MODE FROM ADDRESSING FIELD
EVAL	STY TEMPX                ;TEMPX NOW HAS NUMBER OF CHAR
	LDA ADFLD        ;CHECK FRIST CHAR FOR # OR (
	CMP #'#'
	BEQ HATCJ
	CMP #'('
	BEQ PAREN
	LDA TEMPX        ;CHECK FOR ACCUMULATOR MODE
	CMP #01
	BNE TRYZP
ACCUM	LDX #01
	JMP OPCOMP
TRYZP	CMP #$02         ;CHECK FOR ZERO PAGE MODE
	BNE TRY34
	LDA TYPE         ;CHCK FOR BARANCH WITH RELATIVE ADDR
	CMP #$0C
	BNE ZPAGE
	LDX #02
	JMP OPCOMP
ZPAGE	LDX #05
	JMP OPCOMP
HATCJ	JMP HATCH
TRY34	LDA #04          ;CHECK FOR ABSOLUTE OR ZP,X ORZP,
	CMP TEMPX
	BCC ABSIND
	LDX #02
	JSR XORYZ        ;CC = X, CS = Y NE = ABSOLUTE
	BNE ABSOL
	BCC ZPX
ZPY	LDX #03          ;CARRY SET SO ZP,Y MODE
	JMP OPCOMP
ZPX	LDX #04          ;CARRY CLEAR SO ZP,X MODE
	JMP OPCOMP
TRY56	BCS ERRORM
ABSIND	JSR XORY         ;CC=ABS,X   CS=ABS,Y   NE=ERROR
	BNE ERRORM
	BCC ABSX
ABSY	LDA #09
	CMP TYPE
	BNE ABSY1
	LDX #$0E
	BNE OPCOMP
ABSY1	LDX #$08
	BNE OPCOMP
ABSX	LDX #$09         ;CARRY CLEAR SO ABS,X MODE
	BNE OPCOMP
PAREN	LDA ADFLD+3      ;SEE IF (HH,X),(HH)Y OR (HHHH)
	CMP #','         ;(HHX) (HH),Y ARE OK TOO
	BEQ INDX         ;COMMA IN 4TH POSITION = (HH,X)
	CMP #'X'         ;X IN 4TH POSITION = (HHX)
	BNE TRYINY
INDX	LDX #$0B
	BNE OPCOMP
TRYINY	CMP #')'         ;')' IN 4TH POS = (HH)Y OR (HH),Y
	BNE TRYJMP
	JSR XORY         ;CHCK TO SEE IF Y INDEX REG DESIRED
	BNE ERRORM
	BCC ERRORM
	LDX #$0A
	BNE OPCOMP
TRYJMP	LDA ADFLD+5      ;CHECK FOR FINAL PAREN
	CMP #')'
	BNE ERRORM
	LDA TYPE         ;CONFIRM CORRECT ADDRESS TYPE
	CMP #$0B
	BNE ERRORM
	LDX #$0D         ;OK, FORM IS JMP (HHHH)
	BNE OPCOMP
ABSOL	LDA TYPE         ;CHECK FOR BRANCH TO ABSOLUTE LOC
	CMP #$0C
	BNE ABSOL1
	LDX #$02
	JMP OPCOMP
ABSOL1	LDX #$0C
	BNE OPCOMP
;SELECT IMMEDIATE ADDRESSING TYPE
HATCH	LDA TYPE
	CMP #01
	BEQ IMMED1
	LDX #07
	BNE OPCOMP
IMMED1	LDX #06
	BNE OPCOMP
ERRORM	JSR CKERO0       ;OUTPUT ERROR MESSAGE
	JMP STARTM

;COMPUTE FINAL OP CODE FOR DEFINED ADDRESSING MODE
OPCOMP	LDA TYPTR1,X    ;MATCH TYPE MASK VALID MODE
	BEQ OPCMP1      ;PATTERNS & SKIP 1ST WORD TEST IF
	AND TMASK1      ;ALREADY ZERO
	BNE VALID
OPCMP1	LDA TYPTR2,X    ;TEST 2ND PART
	AND TMASK2
	BEQ ERRORM      ;INST DOES NOT HAVE SPECIFIED MODE
VALID	CLC             ;FORM FINAL OP CODE
	LDA CORR,X
	ADC OPCODE
	STA OPCODE

;PROCESS ADDRESSES TO FINAL FORMAT
	LDA SIZEM,X     ;OBTAIN ADDRESS FORMAT FROM TABLE
	CMP #00
	BEQ ONEBYT
	CMP #$0F        ;NEED BRANCH COMPUTATION?
	BEQ BRNCHC
	STA TEMPA       ;SAVE START POINT & CHAR COUNT
	AND #$0F        ;SEPARATE CHARACTER COUNT
	TAY             ;LOAD ADDR BYTES INTO Y (0,1,OR 2)
	STA BYTESM      ;SAVE IN BYTES
	INC BYTESM      ;TO INSTR LENGHT (1,2,OR 3 BYTES)
	LDA TEMPA       ;SEPARATE STARTING POINT
	AND #$F0
	LSR A
	LSR A
	LSR A
	LSR A
	TAX             ;AND PUT IT IN X
	JSR CONVRT      ;CONVERT ASCII ADDRESS TO HEX
	BCS ERRORM      ;SKIP OUT IF ERROR IN INPUT
	BCC STASH
BRNCHC	JMP BRCOMP

;########### SUBROUTE ##########
;CONVERT FORMATTED ADDRESS INTO PROPER HEX ADDRESS
CONVRT	LDA ADFLD,X     ;PICK UP 1ST ADDRES CHARACTER
	JSR HEX         ;CONVERT TO MOST SIG HEX
	BCS ERRFLG
	INX             ;GET NEXT ASCII CHARACTER
	LDA ADFLD,X
	INX             ;POINT TO NEXT CHARACTER, IF ANY
	JSR PACK
	BCS ERRFLG
	STA OPCODE,Y    ;SAVE IN MOST SIG. BYT LOCATION
	DEY             ;SET UP FOR NEXT ADDR BYTE, IF ANY
	BNE CONVRT      ;IF NECESSARY, FORM NEXT ADDR BYTE
	CLC
ERRFLG	RTS             ;NON HEX CLEARED CARRY
;############
STASH	LDY BYTESM      ;SET UP TO STORE COMMAND
	DEY
STSHLP	LDA OPCODE,Y
	JSR SADDR       ;STORE ONE BYTE OFF COMMAND
	CPY #00
	BEQ FORMDS
	DEY
	CLV
	BVC STSHLP      ;REPEAT TILL THRU

ONEBYT	LDA #01         ;SET BYTES = 1
	STA BYTESM
	BNE STASH

;FORMAT FOR SYSTEM 65 DISPLAY (REFORMAT FOR AIM)
FORMDS	JSR CLR
	JSR CGPC1       ;ADDR TO SAVPC FOR DISASSEMBLY
	JSR TTYTST      ;IF TTY DO NOT GO TO DISASS
	BNE FORMD1
	JSR BLANK2
	JSR BLANK2
	BNE FORMD2      ;OUTPUT OPCODE
FORMD1	JSR DISASM
	JSR CRCK        ;<CR> IF PRI PTR DIFF FROM 0
	LDA CODFLG      ;SEE IF HE WANTS CODE ALSO
	BEQ FORM1
	JSR BLANK
	JSR PRPC        ;PROG CNTR
;OUTPUT OPCODE
FORMD2	LDX BYTESM
	LDY #00
DISPLY	LDA #<ADDR      ;DO LDA (ADDR),Y ,WITHOUT PAG 0
	JSR LDAY
	JSR NUMA
	JSR BLANK
	INY
	DEX
	BNE DISPLY

;POINT TO NEXT INSTRUCTION LOCATION
FORM1	LDY BYTESM      ;ADD BYTESM TO ADDR
	JSR NXTADD
	JMP PATC16      ;UPDATE PC

;RELATIVE BRANCH ADDRESS COMPUTATION
BRCOMP	LDA TEMPX
	CMP #02         ;IF REL BRANCH INPUT, USE IT
	BNE COMPBR
	LDX #00
	LDY #01
	JSR CONVRT
	BCS ERRJMP
	LDA #02
	STA BYTESM      ;SET PROPER BYTES
	JMP STASH
;PAGE 92 DWIGHT ELVEY
COMPBR	LDX #00
	LDY #02
	JSR CONVRT
	BCS ERRJMP
	LDA ADDR+1      ;ADD BRANCH OFFSET
	STA MOVAD+1
	LDA ADDR
	CLC
	ADC #02
	STA MOVAD
	BCC CMPBR1
	INC MOVAD+1
CMPBR1	SEC             ;COMPUTE BRANCH RELATIVE ADDRESS
	LDA OPCODE+1
	SBC MOVAD
	STA OPCODE+1
	LDA OPCODE+2
	SBC MOVAD+1
	STA OPCODE+2
	CMP #00
	BEQ FORWRD
	CMP #$FF
	BEQ BACKWD
ERRJMP	JMP ERRORM
BACKWD	LDA OPCODE+1    ;CHECK IN RANGE
	BMI OK
	BPL ERRJMP
FORWRD	LDA OPCODE+1
	BPL OK
	BMI ERRJMP
OK	LDA #02         ;SET UP FOR STASH
	STA BYTESM
	JMP STASH

;######## SUBROUTINE ##########
;SUBROUTINE FOR DETERMINING X OR Y OR NEITHER
XORY	LDX #04
XORYZ	LDA ADFLD,X
	CMP #','
	BNE XORY1
	INX
	LDA ADFLD,X
XORY1	CMP #'X'
	BEQ ISX
	CMP #'Y'
XORYRT
	RTS             ;NOT ZERO IS OT X OR Y
ISX	CLC             ;CARRY SET IS Y
	BCC XORYRT      ;CARRY CLEAR IS X
;######### RND OF SUB ########

;INPUT FOR MNEMONIC CODE
MNEM	LDY #00
	STY OPCODE
	STY OPCODE+1
	STY OPCODE+2    ;CLEARS OPCODE FOR NEW INPUT
	STY MOVAD       ;CLEARS UNUSED BIT IN FINAL FORMAT
RDLUP	JSR RDRUB
	CMP #'*'        ;COMMAND TO LOAD POINTER
	BEQ STLOAD      ;GO TO SET CURRENT ADDRESS POINTER
	CMP #$20        ;IGNORE SPACE BAR INPUT
	BEQ RDLUP
	AND #$1F        ;MASK OFF UPPER 3 BITS
	STA CH,Y
	TYA
	TAX             ;Y----> X
	INC CH,X        ;FORMAT TO MATCH DISASSEMBLER TBL
	INY
	CPY #03         ;REPEAT FOR EACH OF 3 CHARACTERS
	BNE RDLUP

;COMPRESS 3 FORMATTED CHARACTERS TO MOVAD & MOVAD+1
	LDY #03         ;SET UP OUTER LOOP
OUTLUP	LDA CH-1,Y      ;COMPRESS 3 CHARACTERS
	LDX #05         ;SET UP INNER LOOP
INLUP	LSR A           ;SHIFT 5 BITS ACCTO MOVAD,MOVAD+1
	ROR MOVAD
	ROR MOVAD+1
	DEX
	BNE INLUP
	DEY
	BNE OUTLUP

;SEARCH FOR MATCHIN COMPRESSED CODE
	LDX #$40
SRCHLP	LDA MOVAD
SRCHM	CMP MNEML-1,X   ;MATCH LEFT HALF
	BEQ MATCH
	DEX
	BNE SRCHM
	BEQ MATCH1
MATCH	LDA MOVAD+1
	CMP MNEMR-1,X
	BEQ GOTIT
	DEX
	BNE SRCHLP
MATCH1	JMP ERRORM

;GET INSTRUCTION TYPE FROM TYPE TABLE
GOTIT	LDA TYPTB-1,X
	STA TYPE

;GET OPCODE FROM OP CODE UE
	LDA STCODE-1,X
	STA OPCODE
	JMP MODEM

;THIS SECTION SETS THE CURRENT ADDRESS POINTER
STLO	LDA #'*
	JSR OUTPUT
STLOAD	JSR ADDIN       ;GET ADDR
	BCS STLO        ;IN CASE OF ERROR
	JMP PATC16      ;ADDR TO PC THEN TO STARTM

;PATCHES TO CORRECT PROBLEMS WITHOUT
;CHANGING ENTRY POINTS TO THE ROUTINES
	.BYT 'A'
PATCH1	SEC             ;ADJUST BAUD
	SBC #44
	STA CNTL30
	RTS

CUREAD	TXA             ;SAVE X  , OUTPUT CUR
	PHA
	LDX CURPO2
	CPX #20         ;ONLY IF < 20
	BCS PAT2A
	LDA #$DE
	JSR OUTDD1
PAT2A	PLA
	TAX
	JMP READ        ;CONTINUE

RED1	JSR READ        ;READ & ECHO WITHOUT CURSOR
	JMP RED2

PATCH4	LDX CURPO2      ;DONT DO ANYTHING IF '8D'
	CMP #$8D        ;S0 <CR> FOR TV & NOT FOR DISP
	BNE PAT4A
	LDA #$A0        ;CLR CURSOR
	JSR OUTDD1
	JSR CLR         ;CLR PNTRS
	JMP OUTD7       ;EXIT
PAT4A	JMP OUTD1A      ;CONTINUE

PATCH5	STA PRIFLG      ;TURN PRI OFF
	JMP IPO3

PATCH6	LDA #<ADDR      ;SIMULATE LDA (ADDR),Y
	JMP LDAY

PATCH8	JSR READ        ;READ & ECHO WITH CARROTS
	PHA
	JSR EQUAL
	LDA #'<
	JSR OUTPUT
	PLA
	PHA
	CMP #CR
	BEQ PATC8C
	JSR OUTPUT
PATC8C	LDA #'>
	JSR OUTPUT
	PLA
	RTS

PATCH9	CMP #$F7        ;CHCK LOWER TRANSITION OF TIMER
	BCS PAT9A
	CMP TSPEED
	JMP CKF3A
PAT9A	CMP TSPEED
	PLA
	CMP #$FF
PAT9B	RTS

PATC10	JSR CRLF        ;CLR DISP (ONLY 1<CR>)
	JMP STA1

PATC11	BEQ PAT9B       ;GO OUTPUT PROMPT
	CMP #'L         ;NO PROMPT FOR 'T' OR 'L'
	BEQ PAT9B
	JMP PROMP1

PATC12	PHA             ;CLEAR PRIFLG SO WE CAN OUTPUT
	LDA PRIFLG      ;TO PRINTER IF FLG WAS ON (MSB)
	AND #$F0
	STA PRIFLG
	PLA
	RTS

PATC13	LDA INFLG       ;TURN TAPES ON ONLY IF TAPES
	CMP #'T
	BNE PAT9B
	JMP DU14        ;TURN ON TAPES & SET DEF DEV

PATC14	LDA OUTFLG      ;TURN ON TAPES ONLY IF TAPES
	CMP #'T
	BNE PAT9B
	JMP DU11

PATC15	JSR CRLF        ;DECODE COMMAND
	TXA             ;SAVE INDEX
	ASL A
	TAX
	LDA HTBL,X      ;PART OF ENTRY
	STA S1
	RTS

PATC16	JSR CGPC1       ;ADDR TO PC
	JMP STARTM      ;BACK TO MNEMONIC START

PATC17	BEQ PAT17B      ;RUB ,SO READ ANOTHER
	CMP #0
	BEQ PAT17A
	JMP INO2A       ;NEITHER ,CONTINUE
PAT17A	JSR INALL       ;SKIP ON ZEROS
	CMP #$7F        ;UNTIL RUB
	BNE PAT17A
PAT17B	JMP INO2        ;GO BACK

PATC18	JSR PATC12      ;RESET PRIFLG
	PHA
	JSR TTYTST      ;IF TTY JUST RTN
	BNE PAT18A
	PLA
	RTS
PAT18A	JSR LL          ;SET TO LOW SPEED
	JSR IPST        ;PRINT WHAT IS IN BUFFER
	JSR CLR         ;CLR PRINTER BUFFER BY OUTPUTTING
	JSR BLANK       ;AN SPACE
	JSR CLR
	PLA             ;RTN ACC
	RTS

PAT19	CLD
	JSR CRCK
	JMP STA1

PAT20	BEQ VECK4       ;END (DATA BYTES=0)
	CLC
	ADC #4
	TAX
VECK5	JSR INALL       ;SKIP OVER DATA
	DEX
	BNE VECK5
	JMP VECK1       ;PROCESS NEXT RCD
VECK4	JMP DU13

PAT21	LDY #0
PAT12A	LDA POMSG,Y     ;RESET MSG
	BEQ PAT12B
	JSR OUTPUT
	INY
	BNE PAT12A
PAT12B	JSR CRLF
	JSR CRLF
	JMP START

POMSG	.BYT '  ROCKWELL AIM 65'
	.BYT 0

PAT22	INC BLKO
	JMP ADDBK1

PAT23	LDA #$FF        ;START TIMER
	STA DI1024
PAT23A	LDA RINT        ;TIME OUT?
	BMI PAT23B      ;YES
	LDA IFR         ;START SIGNAL?
	AND #MPRST
	BEQ PAT23A      ;NO
	RTS             ;YES
PAT23B	LDA #0           ;TIME OUT RETURN
	RTS

PATC24	JSR CKFREQ       ;READ BIT FROM FOURTH HALF PULSE
	ROR A
	AND #$80
	RTS

PATC25	BIT IFR          ;WAIT TILL TIMES OUT
	BVC PATC25
	LDA T1L          ;CLR INTERRUPT FLG
	RTS

	*=$FFF9
;INTERRUPT VECTORS
	.BYT $FA
	.WOR NMIV1,RSET,IRQV1    ;SET UP VECTORS
.END A0/1
