	.nam DOS/65 DEVELOPMENT (C)1991 CBM
	.subttl *** Copyright (C) 1991	by  Commodore Business Machines, Inc. ***
	.formln 60

;  ***************************************************************************
;  *				   //					     *
;  *		  CCCCCCC	  //	6666666	    555555555		     *
;  *		 CCC   CCC	 //    666   666    555			     *
;  *		CCC		//    666	    555			     *
;  *		CCC	       //     666 6666	    55555555		     *
;  *		CCC	      //      6666   666	  555		     *
;  *		CCC	     //	      666     666	   555		     *
;  *		 CCC   CCC  //	       666   666    555	  555		     *
;  *		  CCCCCCC  //		6666666	     5555555		     *
;  *			  //						     *
;  *									     *
;  *		      DDDDDDDD	     OOOOOOO	 SSSSSSS		     *
;  *		       DDD   DDD    OOO	  OOO	SSS   SSS		     *
;  *		       DDD    DDD  OOO	   OOO	SSS			     *
;  *		       DDD    DDD  OOO	   OOO	 SSSSS			     *
;  *		       DDD    DDD  OOO	   OOO	    SSSS		     *
;  *		       DDD    DDD  OOO	   OOO	      SSS		     *
;  *		       DDD   DDD    OOO	  OOO	SSS   SSS		     *
;  *		      DDDDDDDD	     OOOOOOO	 SSSSSSS		     *
;  *									     *
;  *	    Copyright (C)1991  by   Commodore Business Machines, Inc.	     *
;  *									     *
;  *			     All  Rights  Reserved			     *
;  *									     *
;  ***************************************************************************

;			ROM VERSION 911119  ver 0.9B System

;	******************************************************************
;	*								 *
;	* This listing contains confidential and proprietary information *
;	* of CBM, Inc.	The reproduction, dissemination or disclosure to *
;	* others without express written permission is prohibited.  This *
;	* software is intended for use in  Commodore C/65  systems only. *
;	*								 *
;	*  The	information  in	 this  document	 is  subject  to change	 *
;	*			without notice.				 *
;	*								 *
;	*  No  responsibility  is  assumed  for the reliability of this	 *
;	*			   software.				 *
;	*								 *
;	******************************************************************

	.page
;	This version written and assembled by Fred Bowen and Dennis Jarvis
;	using BSO format.  This assembly consists of the following files:
;
;	.include equate		;DOS constants
;	.include iodef		;I/O defines
;	.include ramvar		;RAM defines
;	.include sect		;Documentation
;	.include kernal
;	.include bankc65
;	.include tst
;	.include tst1
;	.include routines
;	.include commands
;	.include commands1
;	.include routines1
;	.include jobs
;	.include ieee
;	.include lookup
;	.include copy
;	.include block
;	.include add
;	.include bamutl
;	.include openclose
;	.include opchnl
;	.include rel
;	.include routines2
;	.include compress
;	.include tables

	.page
; Note:  This project was terminated prior to this software's completion. The
; following notes should guide you thru correcting one software bug, and one
; change. Both mods were installed then removed because there was not enough
; testing time to verify they worked correctly. The first bug is in the OPEN
; routine. To set up the bug just create any size text file greater than 506
; bytes. Close down the file and ensure there at leaste two sectors allocated
; to the file. Then OPEN the filename up with the APPEND mode set, followed up
; with doing a CLOSE on the file. You will now only have two sectors assigned 
; to the filename. This bug is caused by the MARKTS routine when it fails to
; read in the LAST track, and sector used by the file into the buffer, and the
; failure to update HDRS correctly. To correct this problem just clear the 
; read only T & S flag, then call READSEC to read the sector into the buffer.
; Also MARKTS will need to be changed to correctly detect the WLINDX value as
; not being used by MARKTS. A change is required in the DSKCPY routine to 
; allow you to concantate two BASIC programs together. To make this change 
; just recode the compare to the program type to BCS only if the file type is
; greater than a program type to prevent REL, CBM, RDM file types from being
; concantated. There is a few place in the dos that needs to be looked at 
; closely to see if it is handling the CBM file types correctly. Mainly need
; to make sure that when filetype 7, and REL files are being handled 
; correctly, also need to look at DSKCPY, and the new command structures.
; Estimated time to complete the dos from this point would be less than 200 
; hours.				12/03/91 Dennis Jarvis

	.page
	.subttl	 EQUATE v900622

; C64/C65 System Equates	(ROM version 0.9B, F011D required)

dos_rom		= $8000		;DOS ROM code begins here

dos_safe_place	= $e000-14	;Unused VIC screen attributes (maps to $1FFFx)

a1	= dos_safe_place+0	;save .a here ShiftUp/Down
x1	= dos_safe_place+1	;save .x   "	 "     "
y1	= dos_safe_place+2	;save .y   "	 "     "
z1	= dos_safe_place+3	;save .z   "	 "     "
status	= dos_safe_place+4	;put I/O status here, to be merged with ST
pcl	= dos_safe_place+5	;ShiftUp/Down saves caller's PC here
pch	= dos_safe_place+6	;
pclss	= dos_safe_place+7	;SaveStatus saves caller's PC here
pchss	= dos_safe_place+8	;
sp	= dos_safe_place+9	;save system stack pointer here
config	= dos_safe_place+10	;save system configuration here (4 bytes)	[910116]

; DOS hardware equates

dosversion	= '1'		;CBDOS version
numdrives	= 2		;Number of drives supported by the system
numdefault	= 8		;Unit number of internal drive

steprate	= 96		;62.5us per count (96=6ms)			[900815] FAB
settlerate	= 192		;settle time, same factor as steprate		[900816] FAB
; precomptrk	= 43		;track at which to start data precomp		[900821] FAB
sskew		= 1		;Sector SKEW					[910129] FAB
dskew		= 1		;Directory sector SKEW				[910612] FAB ????

; DOS chip Commands

rds		= $46		;Read sector job (use ADPLL recovery mode)	[910128] FAB
wts		= $80		;Write sector
wtt		= $a0		;Write track [Note: read track does not work]
stin		= $10		;Step head in
stout		= $18		;Step head out
spin		= $20		;Spinup delay (6 index pulses, 1200ms)		[900815] FAB
time		= $14		;Timer (1 STEP delay)				[900815] FAB
; precomp	= $04		;Write data with precompensation		[900821] FAB
reset_bp	= $01		;Reset buffer pointer				[900815] FAB

; DOS chip Control bits

irq		= $80		;IRQ enable (not used on C65)
led		= $40		;			F011C: blink LED
motor		= $20		;			F011C: turns on LED too
head		= $10		;F011A head load, F011B unused, F011C "swap"	[910128] FAB
swap		= $10		;
side		= $08
device		= $01
	.page
lrf		= $80
dyfile		= $40
ovrflo		= $20
nssl		= 6
ssioff		= 4+nssl+nssl
nssp		= 120		;Number of side sectors pointer
mxchns		= 12		;May want to reduce to 10 since BASIC can't
				;handle more than 10 open files at one time

max_entries	= 28		;Created to allow PATH to be greater than 12,	[910528]
				;the limit previously imposed when using mxchns

cmdsa		= 15
errsa		= cmdsa+1	;Error SA
irsa		= errsa+1	;Internal Read Secondary Address
iwsa		= irsa+1	;Internal Write Secondary Address
maxsa		= iwsa
cr		= $0d		;carriage return
bfcnt		= 22		;number of buffers				[900314]
bamjob		= bfcnt
errchn		= mxchns-1
cmdchn		= mxchns-2
lxint		= $7ff		;lindx 0-10 are free				[900314]
lindx_mask	= $0f		;strip all but actual lindx index		[910502] FAB

nmodes		= 4		;Number of MODES
rdmode		= 0		;	ReaD
wtmode		= 1		;	WriTe
apmode		= 2		;	APpend
mdmode		= 3		;	MoDify
free_mode	= 4		;	Free					[900517]
typmsk		= 7		;TYPe MaSK (bits)
deltyp		= 0		;	DELeted TYPe
seqtyp		= 1		;	SEQuential TYPe
prgtyp		= 2		;	PRoGram TYPe
usrtyp		= 3		;	USeR TYPe
reltyp		= 4		;	RELative TYPE
partyp		= 5		;	PaRTition type
dirtyp		= 7		;	DIRect TYPe

	.page
;	      Controller Job Queue Commands
;
;  The following equates do not include the drive number which is bit 0

read		= $80		;read
turn_motor_on	= $84		;Turn on drive's motor
turn_motor_off	= $86		;Turn off drive's motor
write		= $90		;write
disk_inserted	= $92		;Is there a disk inserted in the drive
turn_on_led	= $94		;Turn on activity led
turn_off_led	= $96		;Turn off activity led
turn_on_error	= $98		;Turn on error led
turn_off_error	= $9a		;Turn off error led
detect_wp	= $b6		;Check status of write protect switch
bump_head	= $c0		;Move head to track 0
find_track	= $c2		;Find out what track the head is on
seek		= $b0		;seek

mxfils		= 10		;max # filenames in string			[900622]
cmdind		= 30		;cmd buffer index (*2)
dirlen		= 24		;directory length used
nbsiz		= 27		;nambuf text size
cmdlen		= 176		;command length

dsknam		= 4
sysdirsec	= 3
sysio		= %01000000	;write verify off, CRC on (unused), big rels on	[910429] FAB
systrack	= 40
bindx		= 16

	.page
fmt1030		= $a0		;' ' 1030 disk format method
fmt2040		= $41		;'A' xx40 disk format method
fmt2030		= $42		;'B' 2030 disk format method
fmt8050		= $43		;'C' 8x50 disk format method
fmt1581		= $44		;'D' 1581 disk format method
fmtcmd		= $48		;'H' CMD hard drive format method (3rd party)

				;Command and file buffer errors
badsyn		= $30		; syntax error
badcmd		= $31		; command error
longln		= $32		; command or filename too long error
badfn		= $33		; filename error
nofile		= $34		; missing filename error
; nocfil	= $39		;							[910528]

;		  $4x		;not used by this dos version
		
norec		= $50		;Relative file errors
recovf		= $51
bigfil		= $52

filopn		= $60		;File path/ allocation errors
filnop		= $61
flntfd		= $62
flexst		= $63
mistyp		= $64

noblk		= $65		;System errors
badts		= $66
systs		= $67

nochnl		= $70		;General channel error (sluff-off error)

direrr		= $71		;General disk allocation errors
dskful		= $72
cbmver		= $73		;Dos zznc1 error type
nodriv		= $74
fmterr		= $75
cntrer		= $76		;controller error
illpar		= $77		;illegal partition

bit0		= %00000001
bit1		= %00000010
bit2		= %00000100
bit3		= %00001000
bit4		= %00010000
bit5		= %00100000
bit6		= %01000000
bit7		= %10000000
all		= %11111111

;.end
	.page
	.subttl	 I/ODEF v900906

; DOS chip I/O registers

f011b		= $d080		;Base address of controller IC (internal to C65)
control		= f011b		;Control register
command		= control+1	;Command register
stata		= command+1	;Status register A
statb		= stata+1	;Status register B
track1		= statb+1	;TRACK register
sector1		= track1+1	;Sector register
sider1		= sector1+1	;Side Register
data1		= sider1+1	;Data register
clock		= data1+1	;Clock register
step		= clock+1	;Step (& timer) rate register (62.5us per count)

vic		= $d000		;VIC chip- used to turn on/off CIAs		[900716]

; IEEE I/O definitions

notrdy		= $00		;not ready
talker		= $80		;ieee talker flag
lisner		= $01		;ieee listener flag
eoiout		= $80		;talk with eoi
eoisnd		= $08		;not(eoi) to send
rdytlk		= $88		;talk no eoi
rdylst		= $01		;ready to listen

rndrdy		= rdytlk+rdylst	;random chnrdy
rndeoi		= eoiout+rdylst	;random w/ eoi

;.end
	.page
	.subttl	 RAMVAR v900619
;
; Base page variables
;

	* = $0000

bmpnt		*=*+2		;bit map pointer
track		*=*+1		;current track
sector		*=*+1		;current sector
lindx		*=*+1		;logical index
result		*=*+4
accum		*=*+5
usrjmp		*=*+2		;Vector for the user-definable USER command

	.page
;****************************************************************************
;*				BIT FLAG				    *
;*									    *
;* BIT 7 - This routine is used by the command parser routine to indicate   *
;*	   the status of bit 7 of the byte being tested as a command.	    *
;*	   set by PARSXQ, cleared by PARSXQ.				    *
;*									    *
;* BIT 6 - This bit informs the FDC's READSEC routine to only read in the   *
;*	   1st two bytes off of a sector and place them directly into TRACK *
;*	   and SECTOR variables. (assumed to be the track and sector links  *
;*	   to the next sector. This bit is set by the MARKTS routine and is *
;*	   cleared by the PARSXQ which ensures this flag will be cleared    *
;*	   each time a new command is received by the IP routines and by    *
;*	   the MARKTS routine.						    *
;*									    *
;* BIT 5 - This bit informs the WUSED routine (allocates sectors in the BAM)*
;*	   not to generate an error message when it starts to allocate a    *
;*	   sector and finds out that it is already in use. This bit is set  *
;*	   by the MARKTS routine and is cleared by the MARKTS routine and by*
;*	   the PARSXQ routine to ensure this bit is cleared each time a new *
;*	   command is received by the DOS.				    *
;*									    *
;* BIT 4 - This routine informs the MARKTS routine to call the WUSED routine*
;*	   to allocate sectors when set, and to call FRETS when it is	    *
;*	   cleared. It is set, and cleared by the same method as BIT 5 above*
;*									    *
;* BIT 3 - This bit inform the AUTO INIT. routine not to init the disk that *
;*	   is about to be used by the DOS. This bit is not set by the DOS by*
;*	   any current method.						    *
;*									    *
;* BIT 2 - Used by scratch to denote number of files scratched is > 256	    *
;*									    *
;* BIT 1 - Informs the PARSE routine that it has already found the '/' char.*
;*									    *
;* BIT 0 - This bit informs the PARTITION routine that this is the 1st file-*
;*	   name that it has parsed for. See partition routine for more info.*
;*	   This bit is set, and cleared by the PARTITION routine. It is also*
;*	   Cleared by the PARSXQ routine to prevent problems with other cmds*
;*									    *
;****************************************************************************

bit_flag	*=*+1		;See above comments
	.page
;****************************************************************************
;*				BIT FLAG 1				    *
;*									    *
;* BIT 7 - This bit when set inform the DOS that it is an active talker and *
;*	   is set by the HTALK routine. This bit is used by the error	    *
;*	   message routine, and the HSECOND routine for i/o.		    *
;*									    *
;* BIT 6 - This bit when set informs the dos that it is an active listener &*
;*	   is set by the HLISTEN routine. This bit is used by the error	    *
;*	   message routine, and the HACPTR routine for i/o.		    *
;*									    *
;* BIT 5 - Used to inform various routines that an UNSCRATCH command is in  *
;*	   progress. It is set by the OPEN, and RESTORE routines.	    *
;*									    *
;* BIT 4 - This bit is used by the UNLISTEN communications routines to	    *
;*	   inform the IP routines when it is to perform an EOI operation    *
;*	   with the C65. When set then NO EOI is to be done.		    *
;*									    *
;* BIT 3 - This bit when set informs the PUT routine that there is a	    *
;*	   filename ready to be parsed in the command buffer.		    *
;*									    *
;* BIT 2 - This bit when set informs the various drive number checks to	    *
;*	   allow drive number 1 to be in the command buffer.		    *
;*									    *
;* BIT 1 - This bit when set informs the HCIOUT routine that there is a byte*
;*	   in it's one character buffer. This is the same method used by the*
;*	   Kernel's CIOUT routines label 'BUF_FLAG' (see bit 7)		    *
;*									    *
;* BIT 0 - This bit when set informs the various routines that a DIRECTORY  *
;*	   LISTING is in progress.					    *
;*									    *
;****************************************************************************

bit_flag_1	*=*+1		;See above comments
	.page
;****************************************************************************
;*				BIT FLAG 2				    *
;*									    *
;* BIT 7 - Reserved							    *
;*									    *
;* BIT 6 - Reserved							    *
;*									    *
;* BIT 5 - This bit when set inform the DOS that big relative files are	    *
;*	   allowed to be used. It will also force the DOS to create a BIG   *
;*	   rel file when it is first created. This bit is set from the IOBYT*
;*	   variable stored on the disk's 1st bam sector as well as by a user*
;*	   command.							    *
;*									    *
;* BIT 4 - Reserved							    *
;*									    *
;* BIT 3 - Reserved							    *
;*									    *
;* BIT 2 - Reserved							    *
;*									    *
;* BIT 1 - Reserved							    *
;*									    *
;* BIT 0 - This bit when set informs the FDC routine not to call the error  *
;*	   routines upon an error, but to just place the error number in the*
;*	   the variable JOBS.						    *
;*									    *
;****************************************************************************

bit_flag_2	*=*+1		;See above comments
	.page
nh				;(used by hex/dec)
temp				;temp work space
t0		*=*+1
nfl				;(used by hex/dec)
t1		*=*+1
t2		*=*+1		;temporaries					[910108]
t3		*=*+1
t4		*=*+1
ip		*=*+2		;indirect ptr variable
r0		*=*+1
r1		*=*+1
r2		*=*+1
r3		*=*+1
r4		*=*+1
dirbuf		*=*+2		;directory buffer pointer
buftab		*=*+bfcnt+bfcnt	;buffer byte pointers
cmd_buf_ptr	*=*+2		;cb. command buffer pointer
err_buf_ptr	*=*+2		;er. error buffer pointer

	.page
; Base page array
;

buf0		*=*+mxchns	; BIT 7 Last byte in file reached
				; BIT 6 File is dirty (modified)
				; BIT 5 Record overflow has occured
				; BITs 4 thru 0 Buffer number in use
buf1		*=*+mxchns	; BIT 7 Last byte in file reached
				; BIT 6 File is dirty (modified)
				; BIT 5 Record overflow has occured
				; BITs 4 thru 0 buffer number in use
nbkl
recl		*=*+mxchns
nbkh
rech		*=*+mxchns
next_record	*=*+mxchns	;nr.
record_size	*=*+mxchns	;rs.
side_sector	*=*+mxchns	;ss.
filtyp		*=*+mxchns	;Channel file type from the directory sector if none from user
				;	BIT 7 = Last Record Found (Rel files)
				;	BIT 6 = Record ammended flag
				;	BIT 5 = OVeR FLow flag
				;	BIT 4 = not used currently (reserved)
				;	BIT 3 2 1
				;	    0 0 0 = DEL
				;	    0 0 1 = SEQ
				;	    0 1 0 = PRG
				;	    0 1 1 = USR
				;	    1 0 0 = REL
				;	    1 0 1 = CBM
				;	    1 1 0 = SPARE FILE TYPE
				;	    1 1 1 = DIRECT FILE TYPE (U1/2)
				;	BIT 0 = The drive number

chnrdy		*=*+mxchns	;Channel status byte
				;	BIT 7 set then ready to talk
				;	    3 clear then send EOI
				;	    0 Direct channel access (U1, U2)

lintab		*=*+maxsa+maxsa+2 ;	BIT 7 6
				;	    0 0 then read only chnl
				;	    0 1 then read/write chnl
				;	    1 0 then write only chnl
				;	    1 1 then chnl inactive
				;
				; Bits 5 and 4 are spare
				; Bits 3 thru 0 contain the LINDX value for this channel
				;
				; Lindx is allocated from $00 thru $0A, starting at zero

chndat		*=*+mxchns	;channel data byte
lstchr		*=*+mxchns	;channel last char ptr
drvnum		*=*+1		;current drive #

	.page
; Note: Anything past this point is considered available for user programs ????
;	Leave some base page room.

half		*=*+1		;Block (which half of 512-byte physical sector)
erword		*=*+2		;error word for recovery, each drive		[910313]
prgdrv		*=*+1		;last program drive
prgsec		*=*+1		;last program sector
write_lindx	*=*+1		;write lindx for copy routines
read_lindx	*=*+1		;read lindx
wlindx		*=*+1		;write lindx
nbtemp		*=*+2		;# blocks temp
char		*=*+1		;char under parser
limit		*=*+1		;pointer to end of filename or next comma, =, /
f1cnt		*=*+1		;file stream 1 count
f2cnt		*=*+1		;file stream 2 count
f2ptr		*=*+1		;file stream 2 pointer (maximum = MXFILS)

linuse		*=*+2		;LINUSE is used to keep track of the logical
				;index values that are currently in use.
				;Bits 0 & 1 of linuse+1 are always in use
				;because they're the command and error channels.
				;When another bit is set then it shows that
				;lindx value to be in use and not available.

cmdsiz		*=*+1		;Command string size. If 'I0:1' is in the command
				;buffer then CMDSIZ would contain a 4

prgtrk		*=*+1		;Last PRG file's track number
nodrv		*=*+1		;NO DRiVe ready flag
				;	BIT 7 drive 0 (internal)
				;	BIT 6 drive 1 (external)
curtrk		*=*+2		;Current track under read/write heads
f1ptr		*=*+1		;File stream 1 pointer (indexed by MAXFILS)
cbdosaddress	*=*+2		;Listen address
tos		*=*+1		;Top Of Stack for ERPROC routine
jobnum		*=*+1		;Current job #

	.page
entsec		*=*+mxfils	;sector of directory entry
entind		*=*+mxfils	;index of directory entry

; file_max_trk	*=*+mxfils	;File entry max track # for IP		removed	[910528]
; file_max_sec	*=*+mxfils	;File entry max sector # for IP
; file_dir_trk	*=*+mxfils	;File entry system track # for IP
; file_dir_st	*=*+mxfils	;File entry system sector # for IP


;*****************************************************************************
;*				FILE_DRIVE				     *
;* This variable contains the drive number located in the command buffer for *
;* this file.  If no drive number existed then BIT 7 will be set to indicate *
;* the default drive number is to be used.				     *
;*****************************************************************************

file_drive	*=*+mxfils	;fildrv.

; pattyp	*=*+mxfils	;							[910528]
pattyp		*=*+max_entries	;	BIT 7 Wild cards in the filename
				;	BIT 6 Save with replace flag
				;	BIT 5 File closed correctly
				;	BIT 4 nut currently used (reserved)
				;	BIT 3 2 1
				;	    0 0 0 = DEL
				;	    0 0 1 = SEQ
				;	    0 1 0 = PRG
				;	    0 1 1 = USR
				;	    1 0 0 = REL
				;	    1 0 1 = CBM
				;	    1 1 0 = SPARE FILE TYPE
				;	    1 1 1 = SPARE FILE TYPE
				;	BIT 0 = The drive number

filtbl		*=*+max_entries+1	;Used by various routines to point to the	[910528]
					;DRIVE number in the user given filename
	.page
header
sz		*=*+1		;2=512 byte sectors
sec		*=*+1		;sector
sd		*=*+1		;side
tt1		*=*+1		;track
ttemp		*=*+1		;used by CRC routine
lsec
crc		*=*+21		;CRC, 2 bytes per sector

sa		*=*+1		;secondary address
orgsa		*=*+1		;original secondary address
data		*=*+1		;temp data byte
recptr		*=*+1		;record pointer
ssnum		*=*+1		;side sector number
ssind		*=*+1		;index into side sector
relptr		*=*+1		;pointer into record
type		*=*+1		;active file type
beginame	*=*+1		;new pattern matching				[910716]
beginpat	*=*+1		;

dirtrk		*=*+2		;DIRectory TRacK
dirst		*=*+2		;DIRectory Starting sector
system_track	*=*+2		;SYSTEM TRACK number for disk formating check
dchange		*=*+1		;Disk CHANGEd flag
				;	BIT 7 drive 0 (internal)
				;	BIT 6 drive 1 (external)

maxtrk		*=*+2		;max track
startrk		*=*+2		;Starting TRacK number
grpnum		*=*+1		;group number

sssgrp		*=*+mxchns	;resident group
				;	255 = No SSS or Group resident
				;	254 = 222 is resident in ram
				;	0 thru 91 = N# group is resident
ssssec		*=*+mxchns	;super side sector address
ssstrk		*=*+mxchns	;super side sector track addr
r5		*=*+1		;current group for big rel
secinc		*=*+1		;SECTOR ALLOCATION
lo		*=*+1		;Used by the partition routines
hi		*=*+1		;		"	"
cont				;Used to create a bam
nl
tmp		*=*+1		;Used to parse directory entries vrs cmd buf
dirsecinc	*=*+1		;Directory sector increment value
datasecinc	*=*+1		;Data sector increment value			[910313]
drivenumber	*=*+1		;Physical drive number
dskver		*=*+1		;DiSK dos VERsion
fmttyp		*=*+1		;method disk was formatted under

	.page
;************************************************************************
;*			       IMAGE					*
;*   Is used by the TAGCMD routine to set up the various file stream	*
;*   flags for the command level routines to check for proper syntax.	*
;*									*
;*     BIT 7 - Wild cards present in file stream 1			*
;*     BIT 6 - More than one filename is present in file stream 1	*
;*     BIT 5 - Drive number was specified in file stream 1		*
;*     BIT 4 - A file name exists in file stream 1			*
;*     Bits 3 thru 0 are the same as 7 thru 4 but are for file stream 2 *
;************************************************************************

image		*=*+1		;file stream image
drvcnt		*=*+1		;number of drv searches
drvflg		*=*+1		;drive search flag
control_store	*=*+2		;shadow control register
last_side	*=*+1		;last phys. side read by ReadSec		[910129] FAB
last_track	*=*+1		;last phys. track read by ReadSec		"
last_sector	*=*+1		;last phys. sector read by ReadSec		"
last_drive	*=*+1		;last phys. drive read by ReadSec		"

;
;	WARNING!	THIS LABEL MUST BE THE LAST ONE IN THE STACK AREA
;

found		*=*+1		;found flag in dir searches
	.page
	* = $200		;						[910610]

cmdbuf		*=*+cmdlen+1	;Command input buffer
nambuf		*=*+36		;Directory buffer
errbuf_d0	*=*+43		;Error Message buffer, first drive

;************************************************************************
;*	WARNING:	All buffers must start on a page boundary.	*
;************************************************************************

; I/O buffers
				;			buffer #
dosbuffer0	*=*+256		;			 0
dosbuffer1	*=*+256		;			 1
dosbuffer2	*=*+256		;			 2
dosbuffer3	*=*+256		;			 3
dosbuffer4	*=*+256		;			 4
dosbuffer5	*=*+256		;			 5
dosbuffer6	*=*+256		;			 6
dosbuffer7	*=*+256		;			 7
dosbuffer8	*=*+256		;			 8
dosbuffer9	*=*+256		;			 9
dosbuffer10	*=*+256		;			 A
dosbuffer11	*=*+256		;			 B
dosbuffer12	*=*+256		;			 C
dosbuffer13	*=*+256		;			 D
dosbuffer14	*=*+256		;			 E
dosbuffer15	*=*+256		;			 F
dosbuffer16	*=*+256		;			10
dosbuffer17	*=*+256		;			11
dosbuffer18	*=*+256		;			12
dosbuffer19	*=*+256		;			13
dosbuffer20	*=*+256		;			14
dosbuffer21	*=*+256		;			15

;******************************************************************************
;*  NOTE:  These buffers are NOT available for the U1,U2 commands and if you  *
;*    attempt to access these buffers you will receive a 70,NO CHANNEL,00,00  *
;******************************************************************************

bambuf0d0	*=*+256		;BAM 0 for drive 0
bambuf1d0	*=*+256		;BAM 1 for drive 0
bambuf0d1	*=*+256		;BAM 0 for drive 1
bambuf1d1	*=*+256		;BAM 1 for drive 1

fdcbuffer0
userbuffer0	*=*+256		;FDC 1st. sector buffer  (RESERVED)		[911010]

fdcbuffer1
userbuffer1	*=*+256		;FDC 2nd. sector buffer  (RESERVED)		[911010]

	.page
; Miscellaneous ????
;

cmdnum		*=*+1		;Number of commands in buffer			[910610]
strsiz		*=*+1		;Size of command string
tempsa		*=*+1		;temporary sa
cmd		*=*+1		;temporary job command

errbuf_d1	*=*+43		;Error Message buffer, second drive

	.page
;* -------------------------------------------------------*
;*			BUFUSE+0			  *
;* -------------------------------------------------------*
;* Bits	    7  6  5  4	3  2  1	 0			  *
;*							  *
;* BUFFER#  7  6  5  4	3  2  1	 0			  *
;*	    ^  ^  ^  ^	^  ^  ^	 ^			  *
;*	    :  :  :  :	:  :  :	 :---DOS buffer	 0	  *
;*	    :  :  :  :	:  :  :------DOS buffer	 1	  *
;*	    :  :  :  :	:  :---------DOS buffer	 2	  *
;*	    :  :  :  :	:------------DOS buffer	 3	  *
;*	    :  :  :  :---------------DOS buffer	 4	  *
;*	    :  :  :------------------DOS buffer	 5	  *
;*	    :  :---------------------DOS buffer	 6	  *
;*	    :------------------------DOS buffer	 7	  *
;*							  *
;* -------------------------------------------------------*
;*			BUFUSE+1			  *
;* -------------------------------------------------------*
;* Bits	    7  6  5  4	3  2  1	 0			  *
;*							  *
;* BUFFER#  F  E  D  C	B  A  9	 8			  *
;*	    ^  ^  ^  ^	^  ^  ^	 ^			  *
;*	    :  :  :  :	:  :  :	 :---DOS buffer	 8	  *
;*	    :  :  :  :	:  :  :------DOS buffer	 9	  *
;*	    :  :  :  :	:  :---------DOS buffer 10	  *
;*	    :  :  :  :	:------------DOS buffer 11	  *
;*	    :  :  :  :---------------DOS buffer 12	  *
;*	    :  :  :------------------DOS buffer 13	  *
;*	    :  :---------------------DOS buffer 14	  *
;*	    :------------------------DOS buffer 15	  *
;*							  *
;* -------------------------------------------------------*
;*			BUFUSE+2			  *
;* -------------------------------------------------------*
;* Bits	    7  6  5  4	3  2  1	 0			  *
;*							  *
;* BUFFER# 17 16 15 14 13 12 11 10   (hex)		  *
;*	    ^  ^  ^  ^	^  ^  ^	 ^			  *
;*	    :  :  :  :	:  :  :	 :---DOS buffer 16	  *
;*	    :  :  :  :	:  :  :------DOS buffer 17	  *
;*	    :  :  :  :	:  :---------DOS buffer 18	  *
;*	    :  :  :  :	:------------DOS buffer 19	  *
;*	    :  :  :  :---------------DOS buffer 20	  *
;*	    :  :  :------------------DOS buffer 21	  *
;*	    :  :---------------------NOT USABLE		  *
;*	    :------------------------NOT USABLE		  *
;*							  *
;* -------------------------------------------------------*
	.page
bufuse		*=*+3		;BUFfer USE flags, if bit is zero then buffer is free

dskid		*=*+4		;Current disk ID's
mdirty		*=*+1		;If bit is set then BAM is dirty
				;	BIT 7 drive 0 (internal)
				;	BIT 6 drive 1 (external)

entfnd		*=*+1		;DIR entry found flag

lbused		*=*+1		;last buffer used
rec		*=*+1		;record length
trkss		*=*+1		;side sector track
secss		*=*+1		;side sector sector

	.page
;  RAM array area
;

lstjob		*=*+bfcnt+4	;last job
dsec		*=*+mxchns	;sector of directory entry
dind		*=*+mxchns	;index of directory entry

;
;  Parser tables
;

filtrk		*=*+mxfils	;FILe TRacK number
				;	BIT 7 Pattern match specified

filsec		*=*+mxfils	;FILe SECtor number

patflg		*=*+1		;PATtern presence FLaG
				;	BIT 7 Comma specified in filename
				;	BIT 6-0 used as a counter to show the
				;		number of wildcards in a given
				;		filename (eg. '*' and '?').
				;		If B7 is set then B6 thru B0
				;		are set to zero.

cbm_startrk	*=*+2		;Used by the NEW command to indicate the parent		[910528]
cbm_maxtrk	*=*+2		;maxtrk, startrk, and system_track for CBM file type.
cbm_system_track *=*+2		;They are set by the PARTition and SETDEF routines.

dirsec		*=*+1		;directory sector number
delsec		*=*+1		;sector of 1st avail entry (could be splat DEL type,
				;scratched file, or a new entry.
delind		*=*+1		;index
lstbuf		*=*+1		;= 0 if last block
index		*=*+1		;current index in buffer
filcnt		*=*+1		;counter, file entries
typflg		*=*+1		;match by type flag
mode		*=*+1		;active file mode:	0 = read,   1 = write
				;			2 = append, 3 = modify
				;			4 = free
ndbl		*=*+2		;Number of blocks used by a file on drive 0, 1
ndbh		*=*+2

	.page
jobs	*=*+bfcnt+4		;+4 BAM buffers
hdrs	*=*+bfcnt+bfcnt+8	;job headers

cdrive		*=*+1		;Controller drive number
iobyte		*=*+1		;	BIT 7 set VERIFY on
				;	BIT 6 CRC check on (NOT USED)
				;	BIT 5 Large relative files enabled
file_type	*=*+1		;Currently active file type
partition	*=*+1		;Pointer to last '/' encountered
save_err	*=*+2		;Contains the lsb pointer to the error
				;Channel of the drive that is not active
save_chn_data	*=*+1		;Contains the 1st character to be sent out
				;over the error channel by the inactive drive
save_lstchr_ptr *=*+1		;Contains the pointer to the end of the error message buffer
save_chn_rdy	*=*+1		;Contains error channel status of inactive drive
; patdel	*=*+1		;					removed	[910528]
; beginame	*=*+1		;
; beginpat	*=*+1		;

rc8				;Save RC8 when blamking screen during format	[910815]
acc		*=*+1		;						[910313]
x		*=*+1		;
y		*=*+1		;

; NOTE: The next variable MUST be the last variable used in the page, see ROUNTS2 [DiskInit]

dosver		*=*+1

;.end
	.page
	.subttl	 C65 DOS Documentation
;****************************************************************************************
;*				DIRECTORY HEADER DEFINITION				*
;*--------------------------------------------------------------------------------------*
;* BYTE				      DESCRIPTION					*
;* --- ---------------------------------------------------------------------------------*
;*  0  TRACK number which points to the 1st dir. sector					*
;*  1  SECTOR number which points to the 1st dir. sector				*
;*  2  Disk format version number, which is currently 'D'				*
;*											*
;*			 512 byte sectors 20 per track					*
;*			 20 Sectors per track						*
;*			 40 Tracks per side						*
;*			 2 sides (note they're inverted from normal MFM dsk)		*
;*  3  Must = 0										*
;*  4  Bytes 4 thru 21 contain the volume name (label)					*
;* 22  Bytes 22 and 23 contain the disk id (fake)					*
;* 24  Must contain an $A0								*
;* 25  DOS version number (CBDOS = 1, 1581 = 3						*
;* 26  Format version number (currently = 'D')						*
;* 27  Bytes 27 thru 28 = $A0								*
;* 29  NOT USED AT THIS TIME								*
;* 30  NOT USED AT THIS TIME								*
;* 31  NOT USED AT THIS TIME								*
;* 32  STARTRK variable for the parent directory			[910528]	*
;* 33  MAXTRK variable for  the parent directory					*
;* 34  SYSTEM_TRACK number for the parent directory					*
;* 35  Bytes 35 thru 255 are not used at this time					*
;*											*
;* NOTE: Byte  2 is NOT used by DOS.							*
;*	 Byte 26 is ONLY used by the directory routines to display the format type	*
;*											*
;****************************************************************************************
	.page
;****************************************************************************************
;*				    BAM DEFINITION					*
;*--------------------------------------------------------------------------------------*
;* BYTE				     DESCRIPTION					*
;* ---	     ---------------------------------------------------------------------------*
;*  0	     Track link for next bam sector, if last then end of bams			*
;*  1	     Sector link								*
;*  2	     Format type this disk was formatted under					*
;*  3	     Compliment version number of byte 2 above					*
;*  4 - 5    Disk ID used when this disk was formatted					*
;*  6	     I/O byte used as follows;							*
;*		BIT 7 - When set Verify is performed after each disk write.		*
;*		BIT 6 - Perform CRC check (not used by CBDOS)				*
;*		BIT 1 - Huge relative files disabled					*
;*  7	     Auto loader flag (not used by CBDOS)					*
;*  8 - 15   Not used at this time by any CBM DOS versions				*
;* 16 - 255  BAM image									*
;*--------------------------------------------------------------------------------------*
;*				      BAM IMAGE						*
;*--------------------------------------------------------------------------------------*
;*											*
;*  0 -	     Number of free sectors on this track					*
;*  1 -	     MSB  flag for sector  7, LSB flag for sector  0				*
;*  2 -	     MSB  flag for sector 15, LSB flag for sector  8				*
;*  3 -	     MSB  flag for sector 23, LSB flag for sector 16				*
;*  4 -	     MSB  flag for sector 31, LSB flag for sector 24				*
;*  5 -	     MSB  flag for sector 39, LSB flag for sector 32				*
;*											*
;* NOTE: Byte 2 is the TRUE format type. This one must be correct (D or $00) BAM 0 ONLY!*
;*											*
;****************************************************************************************
	.page
;****************************************************************************************
;*			      DIRECTORY SECTOR DEFINITION				*
;*--------------------------------------------------------------------------------------*
;* BYT BIT			     DESCRIPTION					*
;* --- ---   ---------------------------------------------------------------------------*
;*  0	     TRACK -- Points to the next directory track.				*
;*  1	     SECTOR-- Points to the next directory sector.				*
;*		      [IF TRACK = 0 THEN THIS IS THE LAST DIRECTORY SECTOR ]		*
;*											*
;*--------------------------------------------------------------------------------------*
;*				FILE ENTRY DESCRIPTION					*
;*--------------------------------------------------------------------------------------*
;* BYT BIT			     DESCRIPTION					*
;* --- ---   ---------------------------------------------------------------------------*
;*  0	     File status byte which is used as follows;					*
;*	7    Set indicates properly closed file						*
;*	6    File is locked (read only)							*
;*	5    Save with replace is CURRENTLY in effect.  When file is properly closed	*
;*	     this bit is cleared.  If this bit is set during a directory function,	*
;*	     an error occurred during the replace function.				*
;*	4    NOT USED AT THIS TIME							*
;*	X    Bits 3 thru 0 are used to indicate the filetype				*
;*	     0 = Deleted, 1 = SEQ, 2 = PRG, 3 = USER, 4 = REL, 5 = CBM, 6 = NOT USED,	*
;*	     7 = is used internally by the dos to reqresent DIRECT type of file access	*
;*											*
;*  1	     TRACK  - link to the 1st sector of data for this file.			*
;*  2	     SECTOR - link to the 1st sector of data for this file.			*
;*  3	     Bytes 3 thru 18 contain the actual filename in ASCII, padded with $A0's	*
;* 19	     Side Sector TRACK link for relative files					*
;*		GEOS - Track number of GEOS file header					*
;* 20	     Side Sector SECTOR link for relative files					*
;*		GEOS - Sector number of GEOS file header				*
;* 21	     Record size for relative files						*
;*		GEOS - File structure type 0 = seq, 1 = VLIR				*
;*											*
;* 22	     GEOS - FILE TYPES:								*
;*		13= Swap file temp 12= System boot  11= Disk device   10= Input device	*
;*		09= Printer	   08= Font	    07= Appl. data    06= Applications	*
;*		05= Desk Acc.	   04= System	    03= Basic data    02= Assembly	*
;*		01= Basic	   00= Not GEOS						*
;* 23	     Not used by CBM DOS previous to CBDOS					*
;*		GEOS - DATE: Year last modified (offset from 1990)			*
;*		CBDOS- Bit's 7 thru 4 contain the upper 4 bit's from the file type byte *
;*		    (see byte 0 above) for the UNNEW, UNSRATCH commands used by CBDOS	*
;* 24	     Not used by CBM DOS previous to CBDOS					*
;*		GEOS - DATE: Month last modified ( 1 thru 12)				*
;*		CBDOS- Bit's 7 thru 4 contain the lower 4				*
;*		    bit's from the file type byte (see byte 23 above)			*
;* 25	     GEOS - DATE: Day last modified ( 1 thru 31)				*
;* 26	     TRACK (from 1) for the save with replace file				*
;*		GEOS - DATE: Hour last modified (0 thru 23)				*
;* 27	     SECTOR (from 2) for the save with replace					*
;*		GEOS - DATE: Minute last modified (0 thru 59)				*
;* 28	     LSB of the # of sectors used by this file					*
;* 29	     MSB of the # of sectors used by this file					*
;*											*
;* NOTE: Each sector in the directory contains 8 directory entries of 32 bytes each	*
;****************************************************************************************
	.page
;****************************************************************************************
;*			    SIDE SECTOR FORMAT DEFINITION				*
;*--------------------------------------------------------------------------------------*
;*  BYTE			    DESCRIPTION						*
;* -------   ---------------------------------------------------------------------------*
;*  0	     Next Side Sector TRACK  link ($FF if last)					*
;*  1	     Next Side Sector SECTOR							*
;*  2	     Side Sector number								*
;*	     If this is a SUPER SIDE SECTOR then this location would contain an $FE, if *
;*	     it is then see the description of the SUPER SIDE SECTOR lay out below	*
;*  3	     Record Size								*
;*  4 -	 5 TRACK & SECTOR link of Side Sector number 0					*
;*  6 -	 7 TRACK & SECTOR link of Side Sector number 1					*
;*  8 -	 9 TRACK & SECTOR link of Side Sector number 2					*
;* 10 - 11 TRACK & SECTOR link of Side Sector number 3					*
;* 12 - 13 TRACK & SECTOR link of Side Sector number 4					*
;* 14 - 15 TRACK & SECTOR link of Side Sector number 5					*
;* 16 - 17 TRACK & SECTOR link of the DATA BLOCK #0					*
;* 18 - 19 TRACK & SECTOR link of the DATA BLOCK #1					*
;*    etc...										*
;*											*
;* NOTE: There are 91 groups to the largest file that this DOS can handle.		*
;****************************************************************************************
	.page
;****************************************************************************************
;*			 SUPER SIDE SECTOR FORMAT DEFINITION				*
;*--------------------------------------------------------------------------------------*
;*  BYTE			     DESCRIPTION					*
;* -------   ---------------------------------------------------------------------------*
;*   0	     Next Side Sector TRACK  link ($FF if last)					*
;*   1	     Next Side Sector SECTOR							*
;*   2	     Contains an $FE to indicate this is a SUPER SIDED SECTOR			*
;*   3 -   4 TRACK & SECTOR link of Side Sector number 0				*
;*   5 -   6 TRACK & SECTOR link of Side Sector number 1				*
;*   7 -   8 TRACK & SECTOR link of Side Sector number 2				*
;*   9 -  10 TRACK & SECTOR link of Side Sector number 3				*
;*  11 -  12 TRACK & SECTOR link of Side Sector number 4				*
;*  13 -  14 TRACK & SECTOR link of Side Sector number 5				*
;* 253 - 254 TRACK & SECTOR link of Side Sector number 125				*
;*											*
;* NOTE: There are 91 groups to the largest file that this DOS can handle.		*
;****************************************************************************************
	.page
;****************************************************************************************
;*				  DATA SECTOR DEFINITION				*
;*--------------------------------------------------------------------------------------*
;*  BYTE			      DESCRIPTION					*
;* -------   ---------------------------------------------------------------------------*
;*  0 -	 1   TRACK and SECTOR link to the next data block if track = 0 then sector	*
;*	     contains the number of bytes used in this sector (which will always be	*
;*	     at least 2 on the last block for the T&S link bytes).			*
;*											*
;*  NOTE: Used by DEL, SEQ, PRG, REL (data blocks) and USR				*
;****************************************************************************************

;.end
	.page
	.subttl	 KERNAL INTERFACE  900914


	* = dos_rom		;DOS ROM code begins here

	.word ColdStart		;vector to DOS coldstart/reset routine
	.word WarmStart		;vector to DOS warmstart routine
	.word FastLoad		;vector to DOS fastload routine			[910110] FAB

DOS_vectors
	.word htalk		;vectors to new DOS/IEEE functions
	.word hlisten
	.word hsecond		;htalksa same as hsecond
	.word hsecond
	.word hacptr
	.word hciout
	.word huntalk
	.word hunlisten


;	.byte 'V911021'		;date code of this DOS version		removed	[911021] FAB

	.page
ColdStart
;	ldy #16-1
;10$	lda vectors_c65,y	;install DOS vectors into Kernel's ieee indirects
;	sta $3f0,y
;	dey
;	bpl 10$

;	jsr (ShiftUp)		;(does SEI)
	jsr DiskInit
	jsr BackGround		;						[900709]
;	jsr (ShiftDown)
;	lda #1			;restore CIAs
;	trb vic+48
;	nop			;Release interrupt latch
				; (does NOT do CLI- expects to be called by IOINIT)
	rts


WarmStart			;						[900709]
;	jsr (ShiftUp)
;;	jsr BackGround		;

;	lda control_store	;???? removed for F011C, since LED=motor	[910207] FAB
;	and #%01001000		;turn off internal motor, keep side, led, & device
;	jsr ControlReg
;	lda control_store+1
;	and #%01001001		;turn off external motor, keep side, led, & device
;	jsr ControlReg

	lda #$80		;force a bump (if something wacks t/s/s regs)	[910110] FAB
	tsb curtrk
	tsb curtrk+1
	sta last_drive		;forget last media access			[910129] FAB

;	jsr (ShiftDown)
;	lda #1			;restore CIAs
;	trb vic+48
;	nop			;Release interrupt latch
				; (does NOT do CLI- expects to be called by IOINIT)
	rts

	.page
;ktalk
;	jsr (ShiftUp)
;	jsr htalk
;	jsr SetStatus
;	jmp ($ff39)
;
;klisten
;	jsr (ShiftUp)
;	jsr hlisten
;	jsr SetStatus
;	jmp ($ff3b)
;
;talksa
;	bbs7 $8f,10$		;					[900510]
;	jsr (ShiftUp)
;	jsr hsecond
;	jsr SetStatus
;10$	jmp ($ff3d)
;
;ksecond
;	bbs7 $8f,10$		;					[900510]
;	jsr (ShiftUp)
;	jsr hsecond
;	jsr SetStatus
;10$	jmp ($ff3f)
;
;kacptr
;	bbs7 $8f,10$		;					[900510]
;	jsr (ShiftUp)
;	jsr hacptr
;	jsr SetStatus
;10$	jmp ($ff41)
;
;kciout
;	bbs7 $8f,10$		;					[900510]
;	jsr (ShiftUp)
;	jsr hciout
;	jsr SetStatus
;10$	jmp ($ff43)
;
;kuntalk
;	bbs7 $8f,10$		;					[900510]
;	jsr (ShiftUp)
;	jsr huntalk
;	jsr SetStatus
;10$	jmp ($ff45)
;
;kunlisten
;	bbs7 $8f,10$		;					[900510]
;	jsr (ShiftUp)
;	jsr hunlisten
;	jsr SetStatus
;10$	jmp ($ff47)
;
	.page
;SetStatus
;	pla		;Save return address while we ReMap
;	sta pclss
;	pla
;	sta pchss
;	jsr (ShiftDown)	;Restore system configuration
;	rmb7 $8f	;assume it was for me				[900510]
;
;	tza		;Check status- was it for me?
;	bpl 10$		;   it's me, merge status with OS's & RTS directly to user
;
;	lda #0		;   it's not me, so don't pass status to Kernel,
;	smb7 $8f	;						[900510]
;	ldx pchss	;      restore return addr & JMP() to Kernel serial handler
;	phx
;	ldx pclss
;	phx
;
;10$	tsb serial_bus_st
;	ldx x1
;	ldy y1
;	ldz z1
;	lda a1		;restore .a last to return flags of data in .a (if any)
;	pha
;	lda #1		;restore CIAs
;	trb vic+48
;	pla
;	cli
;	nop		;Release interrupt latch
;	clc		;in case we return directly to Kernel
;	rts

;.end
	.page
	.subttl	 BANKC65  v900507
;	.subttl	 C65 DOS Interface
;
; Copyright (C)1991 by Commodore Business Machines, Inc.
; All Rights Reserved
;
; 6/15/90  F.Bowen
;
;dos_in
;	sei
;	pha
;	lda #165	;put VIC into newVIC mode	<<< C64 OS only >>>
;	sta vic+47
;	lda #150
;	sta vic+47
;	lda #%01000000	;put system into FAST mode
;	tsb vic+49
;	lda #1
;	tsb vic+48	;Turn off CIAs to access "dos_safe_place"
;	pla
;	sta dos_a1	;Save calling routine's registers
;	stx dos_x1
;	sty dos_y1
;	stz dos_z1
;
;	pla		;Save calling routine's return address
;	sta dos_pcl
;	pla
;	sta dos_pch
;	tsx		;Save calling routine's stack pointer
;	stx dos_sp
;
;	lda #%00000000
;	ldx #%00010001	;Map in DOS RAM (8K @ $010000)
;	ldy #%00000000
;	ldz #%00110011	;Map in DOS ROM, I/O at $D000, Map out C64 BASIC
;	aug
;
;	ldx #$ff	;Reset DOS stack pointer
;	txs
;	lda dos_pch	;Move caller's return address to DOS stack
;	pha
;	lda dos_pcl
;	pha
;	lda dos_a1	;Restore registers
;	ldx dos_x1
;	ldy dos_y1
;	ldz dos_status
;	rts		;return to the calling routine
	.page
;
;dos_out
;	pla		;Save calling routine's return address
;	sta dos_pcl
;	pla
;	sta dos_pch
;
;	lda #%00000000
;	ldx #%00000000	;Map in system RAM, stack
;	ldy #%00000000
;	ldz #%00000000	;MAP out DOS, Map in C64 BASIC & I/O at $D000
;	aug		;map
;
;	ldx dos_sp	;Retore caller's (kernel's) stack pointer
;	txs
;	lda dos_pch	;Move caller's return address to stack
;	pha
;	lda dos_pcl
;	pha
;	lda dos_a1	;Restore registers
;	ldx dos_x1
;	ldy dos_y1
;	ldz dos_status	; (note- this returns to DOS, not to Kernel)
;	rts
;
;.end
	.page
	.subttl	 FASTLOAD

FastLoad			;Re-installed for F011C				[910129] FAB
	tax			;Enter with:
	bmi FastBlock		;		.A = 8x to get next block
	bne CheckEr		;		.A = 0x to get DOS error set up
				;		.A = 00 to init FastLoad & get 1st block

; NOTE: When the file was 1st opened the open routine read in the 1st two
; sectors of the file and they're already setting in the dos buffers. I did not
; write the code to extract them, instead I re-read them out of the FDC buffer.

10$	lda prgsec		;Get 1st track and sector setup by previous OPEN
	sta sector
	lda prgtrk
	sta track
	lda jobnum
	asl a
	sta r0

FastBlock
	ldx r0			;Jobnum index
	lda track
	sta hdrs,x
	lda sector
	sta hdrs+1,x		;Read the sector into the F011x buffer
	jsr FastReadSec		; and put the first two bytes into Track & Sector

	ldx sector		;If it's the last sector, this is the number of bytes
	dex			;	well, minus one, actually
	lda track		;Is this the last sector?
	beq 10$			;	Yes
	ldx #254		;	No-  254 bytes is one sector's worth

10$	stx x1			;Return with:	.X = # bytes to read in this sector
	sta a1			;		.A = 0 if last sector
	rts			;	meanwhile, the chip will load rest of sector
				;	and kernel is responsible for error checking
	.page
FastReadSec
	jsr Setup		;Setup controller, find track, reset chip buffer
	  bcs CheckEr		;   can't continue- no drive or disk
	jsr CheckLastTss	;Sector already in chip buffer?			[910129] FAB
	  bcc 40$		;   yes!

1$	lda #rds		;Issue buffered READ command
	sta command
5$	lda stata		;   wait for sector to be found, want RDREQ=1
	and #bit4		;
	bne CheckEr		;	RNF=1, sector not found
	lda statb
	bpl 5$			;	RDREQ=0, still looking for it

	ldy #0			;DOS buffer index
	lda half		;Sector found, start reading from chip buffer to our's
	beq 20$			;   which half of 512-byte chip buffer do we want?
10$	jsr ByteRead		;	want second half, so waste first
	iny			;		(4+1+2+5+12 = 24 cycles)
	bne 10$

20$	jsr ByteRead		;Read & set t&s link bytes only
	sta track
	jsr ByteRead		;		(4+3+5+12 = 24 cycles)
	sta sector
	bra SetLastTSS		;	return, caller must check for errors		[910423]


40$	jsr SetChipBP		;Set buffer pointers to 256-byte block in 512-byte buffer
	jsr ByteReadWithDelay	;Read & set t&s link bytes only (need a slight delay here????)
	sta track
	jsr ByteReadImm		;		(4+3+5+3 = 15 cycles)
	sta sector
	rts

	.page
SetLastTSS
	lda sider1		;Remember last sector accessed			[910129] FAB
	sta last_side
	lda track1
	sta last_track
	lda sector1
	sta last_sector
	lda control
	and #7
	sta last_drive
	rts


CheckLastTSS
	lda sector1		;Check last sector accessed			[910129] FAB
	cmp last_sector
	  bne 10$
	lda sider1
	cmp last_side
	  bne 10$
	lda track1
	cmp last_track
	  bne 10$
	lda control
	and #7
	cmp last_drive
	  beq 20$

10$	lda #$80		;	different
	sta last_drive
	sec
	   .byte $89

20$	clc			;	same
	rts


SetChipBP
;	lda #reset_bp		;Set buffer pointers to 256-byte block in 512-byte buffer
;	sta command		;	reset buffer pointers
;	lsr a			;		.a=0
;	jsr CommandReg		;	"cancel" to reset "nobuf" command bit & busywait

	lda control
	ldy half		;	Which half of 512-byte chip buffer do we want?
	beq 10$
	ora #%00010000		;		second: set F011C's 'swap' flag
	  .byte $2c
10$	and #%11101111		;		first: clear F011C's 'swap' flag	[910417]
	sta control		;	   (but don't affect control_store!)
;	jmp BusyWait		;	   busywait so ByteRead will work
	rts

;.end
	.page
	.subttl	 TST  v910525

;****************************************************************************************
;*   This routine toggles between two buffers, one active and the other inactive, and	*
;*   exits with the number of the active buffer in .A & .X				*
;****************************************************************************************

dblbuf	ldx lindx
	lda buf1,x		;Toggle second active buffer
	eor #$80
	sta buf1,x
	lda buf0,x		;Toggle first active buffer
	eor #$80
	sta buf0,x		;Is the primary buffer in use?
	bpl 10$			;	yes
	lda buf1,x		;Else return the status of the secondary buffer
10$	and #$bf		;Mask 'buffer dirty' flag
	tax			;Above buffers are now active
	rts


;
; Put Internal ByTE		Called only by the Copy routines
;

pibyte	lda file_drive		;(see comments at GetLinTab)			[901002]
	and #1
	tax
	jsr setup_err		;Set up DRVNUM and appropriate error buffer pointers
	ldx #iwsa
	stx sa			;Use internal write SA
	jsr fndwch		;Make it the active channel
	jsr actledon		;	fixes bug in REL type			[900923] DJJ
	jsr typfil		;						[900923] DJJ
	bcc l40			;	branch if not a REL file		[900923] DJJ
	lda #ovrflo		;		show overflow as not occurring	[900923] DJJ
	jsr clrflg_1		;						[901127]
	bra l40

;	lda sa			;Get the current sa		never executed! [900923] DJJ
;	cmp #cmdsa		;Is it the command channel?
;	beq l42			;	Yes
;	bra l40			;	No

	.page
; Main routine to write to channel
;

put	lda orgsa		;Strip all but the OPEN flag and the SA
	and #$8f
	cmp #cmdsa		;Is it the OPEN command or the command channel?
	bcs l42			;	yes

l40	ldx lindx		;Get the logical index
	lda filtyp,x		;Get file type
	lsr a			;Drop the drive #
	and #typmsk		;Drop off garbage
	cmp #reltyp		;Is it a relative type?
	bcs 10$			;	yes

;**********************************************************
;*	 Write to a SEQ, DEL, PRG, or USR file type	  *
;**********************************************************

	lda data	;It's SEQ, PRG, DEL, USR
	bra wrtbyt	;Go place it into the buffer
			;If the buffer is full,	 write it out and get another buffer

10$	bne 20$		;If it's a U1, U2 cmd branch

;**********************************************************
;*		Write to a relative file type		  *
;**********************************************************

	bra write_relative	;Else assume it's a relative file

;**********************************************************
;*	   write a ramdom access file (u1, OR u2)	  *
;**********************************************************

20$	lda data	;Get the byte received
	jsr putbyt_1	;Place it
	ldy lindx	;Go set up for the next byte
	bra rnget2	; to be received

l42	lda #cmdchn	;write to cmd chanl
	sta lindx
	jsr getpnt	;Did the previous byte written fill up the buffer?
	cmp #<cmdbuf+cmdlen+1
	beq 40$		;	Yes- go see if this the last byte to be rec'd.
			;	     If so, execute the cmd. If not, skip the
			;	     rest of the bytes received (drop them).
	lda data	;	Not full-
	jsr putbyt	;	     put the byte into the buffer

40$	bbs4 bit_flag_1,50$	;Branch if an EOI has been received from the C65
	smb3 bit_flag_1		;Set the command awaiting in the buffer flag
50$	rts

	.page
; put .a into active buffer of lindx
;

putbyt	ldx lindx	;Get channel number
putbyt_1
	pha		;Save the byte to be placed
	lda buf0,x	;Is the primary buffer active?
	bpl 10$		;	yes
	lda buf1,x	;	no- return the state of the secondary buffer

10$	and #$bf	;mask buffer dirty flag
	bpl putb1	;	Branch if there's a free buffer
	pla		;Else return no buffer error (file never opened)
	lda #filnop
	bra cmderr
putb1	asl a		;save the byte in buffer
	tax
	pla
	sta (buftab,x)
	inc buftab,x	;adjust the buffer pointer
	rts		;z=1 if this was the last byte in buffer (it's full)

	.page
; Find the active buffer # (lindx)
;
; Initialize drive (command)

intdrv	jsr close_all_channels	;Add a degree of SPLAT file protection		[910528]
				;by closing down all open files on both drives
	jsr simprs		;Extract drive number
	jsr initdr		;Init drive 0
	bra endcmd

;
; Initialize drive (drvnum)
;
; Need to check to see if the bam was marked as being dirty and this routine
; is called (it fills the bam with zero's), will it trash the bam????

initdr	jsr clear_bam	;Fill BAMs for this drive with 0's
	jsr cldchn	;Close down all channels
	jsr actledon	;Set the activity led for this Drive
	jsr rddir	;Read in directory header & BAMS
	lda jobnum	;Get the buffer used by RDDIR
	asl a		;*2 to point to the LSB of the
	tax		;BUFTAB pointer
	lda #1		;Move over to the directory sector link		[900411]
	sta buftab,x
	ldy drvnum
	lda (buftab,x)
	sta dirst,y	;Save 1st directory sector			[900415]
	inc buftab,x	;skip past the sector
	lda (buftab,x)	;Get the DOS version number
	sta dskver	;Save it
	lda #0
	sta buftab,x	;Restore to TRACK link

	.page
; ***************************************************************************************
; * NOTE: Since the previous DOS versions (1.0 to 3.0) did not consider the ID bytes	*
; * in the disk's HEADER to be the official ID bytes, the 1581 used the ID's located	*
; * in BAM 0.  This kept DOS 3.0 partly	compatable with version 10.0.			*
; *											*
; * CHANGES: Now allows no dos version to be okay (not set up defaults- in all past	*
; * dos versions this was allowed).  Because 1581 did not implement this, it CRASHES!!!	*
; ***************************************************************************************

	lda #0
	sta bmpnt
	jsr cleardchange	;Clear write protect flag
	jsr clearnodrv		;Clear drive not ready flag
	txa
	asl a			;X = DRVNUM * 2 so x points to the correct
	tax			;DSKID for this drive number			[900411]
	ldy #2
	lda (bmpnt),y		;Get the DiSK VERsion number from BAM-0
				;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	beq 10$			;Allowed by all previous DOS versions!
				;NO DOS VERSION is okay. (bug in 1581)
				;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	cmp fmttyp		;Is it the same as ours?
	bne default		;	No- set up default parameters
	eor #$ff
	iny
	cmp (bmpnt),y		;2's complement of VERNUM?
	bne default		;	No- set up default parameters

10$	ldy #4			;	in case NO VERSION comes here		[901114] FAB
	lda (bmpnt),y
	sta dskid,x		;Save fake disk id
	iny
	lda (bmpnt),y
	sta dskid+1,x
	iny			;Move to IOBYTE
	rmb5 bit_flag_2 	;Clear current BIG rel flag			[901127]
	lda (bmpnt),y
	and #%01111111		;Strip write/verify, use internal flag		[910429] FAB
	sta iobyte
	and #bit5
	eor #bit5		;						[901115] FAB
	tsb bit_flag_2

	.page
; Calculate free blocks
;

nfcalc	ldx drvnum
	lda #0
	sta ndbl,x
	sta ndbh,x
	lda track		;Save the current track number
	pha
	lda startrk,x		;Start at the starting track #
	sta track
	   .byte $2c

10$	inc track		;Move up to the next track
	lda track
	cmp dirtrk,x		;Is this the directory track?		[900415]
	beq 10$			;	Yes then skip over it
	cmp maxtrk,x		;Are we done?
	bcs 20$			;	Yes
	jsr bamtrk		;Call BAM TRacK to point BMPNT
				;To the bam image for this track
	lda (bmpnt),y		;Get the number of sectors free
	clc			;On this track (Y always = 0)
	ldx drvnum		;Get the currently active drive #
	adc ndbl,x		;Add the # sectors free on this
	sta ndbl,x		;Track to the total so far on
	bcc 10$			;this track
	inc ndbh,x
	bra 10$

20$	pla			;Restore the current track # the head is on
	sta track
	ldx #0			;Restore the index value
	rts

	.page
default	lda #sysio		;Default to VERIFY after WRITE and CRC check
	sta iobyte		; (not possible with F011 FDC)
	smb5 bit_flag_2		;Default to large (big) REL files		[901127]
	jsr cleardchange
	jsr clearnodrv
	lda #0
	sta ndbl,x		;X = DRVNUM from the JSR to CLEARNODRV
	sta ndbh,x
	lda #'D'
	sta dskid,x
	lda #'J'
	sta dskid+1,x
	lda #sysdirsec
	sta dirst,x
strdbl_rts
	rts

	.page
; Start double buffering
; Use track,sector as starting block
;

strdbl	jsr sethdr		;Set up the first sectors T & S
	jsr rdbuf		;Read in the 1st sector
	jsr getbyt		;Get the next sector in the chain
	sta track
	lda (buftab,x)
	inc buftab,x
	sta sector
	lda track		;Is there another sector left?
	beq strdbl_rts		;	No (rts)
	jsr dblbuf		;Switch buffers
	jsr seth		;Set up HDRS for the secondary buffers T & S links
	jsr rdbuf		;Go read in the second sector
	bra dblbuf

	.page
; Read a sector on track,sector
;

rdbuf	lda #read		;Job code for 'read a sector'
	   .byte $2c

;
; Write a sector on track,sector
;

wrtbuf	lda #write		;Job code for 'write a sector'
	sta cmd			;Save the job code in CoMmanD
	ldx lindx		;Get channel number
	lda buf0,x		;Is the primary buffer active?
	bpl 10$			;	yes

	lda buf1,x		;	no- return state of secondary buffer
10$	and #$bf		;Drop off buffer dirty flag
	tax			;Save it in X
	jsr set_last_job	;Go write the sector
	phx			;Save the active buffer number
	txa
	asl a			;Point to the LSB of the buffer's address in BUFTAB
	tax
	lda #0			;Make the LSB=0
	sta buftab,x		; so it points to the T&S links
	ldx lindx		;Get logical index
	lda filtyp,x		;Get file type
	lsr a			;Mask drive number & junk
	and #typmsk
	cmp #reltyp		;Is it a relative file?
	bcs 20$			;	yes

	inc nbkl,x		;else -1 sector in the number of
	bne 20$			;Blocks free on this disk
	inc nbkh,x

20$	plx			;Get the active buffer number
	txa
	rts

	.page
;******************************
;*  fndrch
;******************************

fndrch	lda sa			;Get the current SA
	cmp #maxsa+1		;Is it out of range?
	bcc 10$			;	no

; Falling thru this section of code allows OPEN 2,8,2 to be the same as OPEN 2,8,17

	and #$0f		;	yes, just mask the bad part

; If (SA and $F) = 15 then default to the error channel

10$	cmp #cmdsa		;Is this the command channel?
	bne 20$			;	no
	lda #errsa		;	yes- replace the command channel with
				;	     the pointer to the error channel (SA)
20$	jsr getlintab		;Is this channel a WRITE channel?
	bmi 30$			;	yes- exit with bit 7 set to show BUFFER NOT AVAILABLE
	and #lindx_mask		;	no-  mask buffer dirty & read flag, keep the LINDX value
	sta lindx		;						???? [910322] FAB
	tax			;Move the LINDX value into x
	clc			;OK return
	rts			;Exit

30$	sec
	rts

	.page
;*****************************
;*  fndwch
;*****************************

fndwch	lda sa			;Get the current SA
	cmp #maxsa+1		;Is it within range?
	bcc 10$			;	Yes

; Falling thru this section of code allows OPEN 2,8,2 to be the same as OPEN 2,8,17

	and #$0f		;	No-  strip off junk

10$	jsr getlintab		;Get channel assignment in A
	tay
	asl a			;Shift R/W flags left
	bcc 30$			;	branch for READ channel
	bmi 40$			;	branch if active already & error out

20$	tya			;Move the original LINTAB value into .a
	and #lindx_mask		;Strip all but LINDX
	sta lindx		;Save LINDX value				???? [910322] FAB
	tax			;return in .x
	clc			;No errors flag
	rts

30$	bmi 20$			;it is a READ channel- branch if it's not active
40$	sec			;Flag error and abort
	rts

	.page
typfil	ldx lindx
typfil_1
	lda filtyp,x		;Get the file type
	lsr a			;Drop off the drive number
	and #typmsk		;Drop off flags just keep type
	sta file_type		;Save for other routines uses				[900506]
	cmp #reltyp		;Is it a REL TYPE?
	rts



; GET PREp routine
;
; on exit:	Y = Lindx
;		X = active buffer number
;		A = X

getpre	ldy lindx		;Get channel number
	lda buf0,y		;Is the primary buffer active?
	bpl 10$			;	yes
	lda buf1,y		;	no- return the state of the secondary buffer

10$	and #$bf		;Drop off buffer dirty flag
	asl a
	tax
	rts

	.page
; Read byte from active buffer. Z = 1 if last data byte else z = 0

getbyt	jsr getpre		;Get buffer number and Lindx value
	lda lstchr,y		;Is this the last byte to be sent?
	beq 20$			;	yes
	lda (buftab,x)		;	no- get this byte
	pha			;	    and save it
	lda buftab,x		;Is this now the last byte?
	cmp lstchr,y
	bne 10$			;	no
	lda #$ff		;Set up to rewind back to zero below
	sta buftab,x
10$	pla			;Get byte just fetched back
	inc buftab,x		;Bump to last byte
	rts

20$	lda (buftab,x)
	inc buftab,x
	rts

	.page
; Read a char from file and read next block of file if needed.
; Set chnrdy = eoi if end of file

rdbyt	jsr getbyt		;Get a byte from the buffer
	bne 50$			;	rts if it's not the last one
	sta data		;Save last byte
	lda lstchr,y		;Is this all of the bytes from the last sector?
	beq 10$			;	no
	lda #eoiout		;	yes- send it out with an EOI thing
	sta chnrdy,y
	lda data		;Get the byte we just read & rts
	rts

10$	jsr dblbuf
	lda #0			;Point to the start of the buffer
	jsr setpnt
	jsr getbyt		;Get the Track from the T&S links
	cmp #0			;Is this the last sector?
	beq 60$			;	yes
	sta track		;	no- Make it the target track
	lda (buftab,x)
	inc buftab,x
	sta sector		;	    Make it the target sector
	jsr dblbuf		;Switch to secondary buffer
	jsr setdrn		;Set the correct drive number
	jsr sethdr		;Pass the target T&S to the controller's header
	jsr rdbuf		;Go read in the target sector
	jsr dblbuf		;Switch to primary buffer
	lda data		;Get the last byte from the previous sector back
50$	rts


60$	lda (buftab,x)
	inc buftab,x
	sta lstchr,y
	lda data
	rts

	.page
;**********************************************************
;*		   GET LINdx TABulation			  *
;*							  *
;*  This routine is used to index into the LINTAB array	  *
;*  to obtain the correct LINDX value which is assigned	  *
;*  to the secondary address.  It works as follows:	  *
;*							  *
;*     ACC =  LINTAB (( MAXSA+1 * DRVNUM ) + ACC )	  *
;*							  *
;* ON ENTRY:  ACC = The secondary address to be used	  *
;*		    as an index into LINTAB.		  *
;*	    X,Y,Z = Don't care.				  *
;*							  *
;* ON EXIT:   ACC = LINDEX value			  *
;*		X = (MAXSA+1 * DRVNUM ) + ACC )		  *
;*		Y = Not used or abused			  *
;*		Z =  "	 "   "	   "			  *
;*							  *
;* NOTE: While tracking down a bug in the COPY routines,  *
;*  it was discovered that the jsr to PIBYTE did NOT have *
;*  the proper drive number in place at the time of the	  *
;*  jsr and could not correct this using the normal dos	  *
;*  method because the normal way to switch the drives at *
;*  the buffer level is to call SETDRN which uses the	  *
;*  currently active LINDX value. Since DRVNUM contained  *
;*  the wrong drive number, when PIBYTE called FNDWCH to  *
;*  get the current write LINDX value it would obtain the *
;*  wrong value because when FNDWCH called GETLINTAB the  *
;*  DRVNUM value was for the SOURCE drive!!!		  *
;*  I added a LDX file_drive, JSR SETUP_ER to correct the *
;*  problem.						  *
;**********************************************************

getlintab
	clc
	ldx drvnum		;Get the drive number
	beq 10$			;	if drive 0 branch
	adc #maxsa+1		;Else add MAXSA to SA				[900414]
10$	tax			;Use as an index
	lda lintab,x		;Get LINdx from the table
	rts

;.end
	.page
	.subttl	 TST-1	v910525

; Write a byte to a channel and write out the buffer if it's full

wrtbyt
	jsr putbyt		;Place a byte in the buffer
	bne incpnt_rts		;branch if the buffer is not full yet		[900622]


;*********************************************************
;*  This routine will allocate another track and sector	 *
;* in the bam then place the track and sector links in	 *
;* the current sector in ram then write it out to disk.	 *
;*********************************************************

wrt0	jsr setdrn		;Set the active drive number
	jsr nxtts		;Get the NeXT Track and Sector to write to
	lda #0			;Set the buffer pointer to zero to point to T&S link
	jsr setpnt
	lda track		;Put the next T&S values into the current sector
	jsr putbyt		;   these are the link bytes
	lda sector
	jsr putbyt
	jsr wrtbuf		;Write out the current (full) buffer

; Switch to the new buffer just set up by NXTTS

	ldx lindx
	lda buf1,x		;Toggle second active buffer
	eor #$80
	sta buf1,x
	lda buf0,x		;Toggle first active buffer
	eor #$80
	sta buf0,x		;Is the primary buffer in use?
;	bpl 10$			;	yes					removed	[910117] DJJ
;	lda buf1,x		;	no- return the status of secondary buffer
;
;10$	and #$bf		;Drop off buffer dirty flag
;	tax			;Above buffers are now active
	jsr sethdr		;Setup new T&S for the active buffer
	lda #2			;Position buffer pointer past T&S link
	bra setpnt		; & rts

	.page
; INC PoiNTer of active buffer by .a
;

incpnt	sta temp
	jsr getpnt
	clc
	adc temp
	sta buftab,x
	sta dirbuf
incpnt_rts
	rts


; Set drvnum to the last accessed drive number

setdrn	ldx lindx		;Get channel number
	lda buf0,x		;Is the primary buffer active?
	bpl 10$			;	yes
	lda buf1,x		;	no- return the state of the secondary buffer

10$	and #$bf		;Drop off buffer dirty flag
	tax

setdrn_1			;Enter with X = the job number (buffer #)
	lda lstjob,x		;Get the last job executed
	and #1			;Get the drive number
;	sta drvnum		;Make it the current drive
	phx
	tax
	jsr setup_err		;						[910805] FAB
	txa
	plx
	rts

	.page
; .a = # of buffers needed (max of 2)
; sets up buffer # and allocates lindx

getwch
	sec			;Wanting to allocate a WRITE buffer
	   .byte $89

getrch	clc			;Wanting to allocate a READ buffer

	php			;Save the R/W flag (carry)
	sta temp		;Save the number of buffers needed
	jsr frechn		;Free all channels
	jsr fndlnx		;Get the next available LINDX
	sta lindx		;Make it current

;	ldx sa			;Get current Secondary Address			[910328] DJJ
	plp			;Is this a Write channel?
	bcc 10$			;	no
	ora #bit7		;	yes- set flag for WRITE ONLY to this channel
10$	pha			;Save LINDX value in A
;	txa			;Move SA into ACC				[910328] DJJ
	lda sa
	jsr getlintab		;Place X at correct location in LINTAB for this drive
	pla			;Get LINDX + write only flag back
	sta lintab,x		;Put status in LINTAB to make channel active
	and #lindx_mask		;Keep LINDX value only				[910325] FAB
	tay			;Use LINDX value as an index
	lda #$ff		;Clear the Side Sector value for REL file
	sta side_sector,y
	sta buf0,y		;Show the primary and
	sta buf1,y		;Secondary buffers as now being free
	dec temp		;Was one or two buffers needed?
	bmi getr4		;	one (rts)
	jsr getbuf		;Get the PRIMARY buffer (#1)
	bpl getr5		;	branch if available

gberr	jsr relbuf		;No buffer available- Release all active buffers
	lda #nochnl		;And generate a NO CHANNEL error message
	bra cmderr

getr5	sta buf0,y		;Save the PRIMARY buffer number
	dec temp		;Was a second buffer required?
	bmi getr4		;	no (rts)
	jsr getbuf		;Get the SECONDARY buffer (#2)
	bmi gberr		;	branch if not available
	sta buf1,y		;Save the SECONDARY buffer number
getr4	rts

	.page
; Free channel associated with SA
; (free read and write channels only, don't free command channel 15)

frechn	lda sa			;Get SA for current drive
	cmp #15			;Command channel?
	beq frechn_rts		;	yes (rts)

	jsr getlintab		;lda LINTAB [DRVNUM*MAXSA],X
	cmp #$ff		;Is this file inactive?
	beq frechn_rts		;	yes (rts)

	and #lindx_mask		;Keep only the LINDX value			[910325] FAB
	sta lindx

	lda #$ff		;Free the channel
	sta lintab,x
	inc a
	ldx lindx
	sta chnrdy,x
	jsr relbuf


freelindx			;						[910204] DJJ
	ldx lindx
	lda #1			;start at channel 0
	cpx #8			;is channel >8?					[900314]
	bcs relio		;	yes
10$	dex
	bmi 20$
	asl a
	bne 10$

20$	ora linuse		; 1=free, 0=used
	sta linuse

frechn_rts
	rts

	.page
relio	lda lindx		;Move LINDX into A				[900314]
	sbc #8			;Normilize LINDX value
	tax
	lda #1
10$	dex			;Support for chnl >8
	bmi 20$			;br if done shifting
	asl a			;shift another one
	bne 10$			;Always

20$	ora linuse+1		;release it
	sta linuse+1
	rts

; Given SA, free its read channel & release its buffers (lindx)

relbuf	ldx lindx		;Get the index
	lda buf0,x		;Is the primary buffer active?
	cmp #$ff
	beq 10$			;	no
	pha			;	yes- save the buffer #
	lda #$ff		;	     mark it as inactive
	sta buf0,x
	pla			;	     release the buffer
	jsr frebuf

	ldx lindx		;Get the index
10$	lda buf1,x		;Is the secondary buffer active?
	cmp #$ff
	beq 20$			;	no
	pha			;	yes- save the buffer #
	lda #$ff		;	     mark it as inactive
	sta buf1,x
	pla			;	     release the buffer
	jsr frebuf

	ldx lindx		;Get the index
20$	lda side_sector,x	;Is the Side Sector buffer active?
	cmp #$ff
	beq 30$			;	no
	pha			;	yes- save the buffer #
	lda #$ff		;	     mark it as inactive
	sta side_sector,x
	pla
	bra frebuf		;	     release the buffer

30$	rts

	.page
;**********************************************************
;*		    GET a free BUFfer			  *
;*							  *
;* ENTry:  A = Not used					  *
;*	   Y = Not used					  *
;*	   X = Not used					  *
;*	   Z = Not used					  *
;*							  *
;* EXIT : A = Buffer number to be used, if bit 7 is set	  *
;*	      then there is no free buffer available.	  *
;*	  X = ????					  *
;*	  Y = Unchanged					  *
;*	  Z = Unchanged					  *
;**********************************************************

getbuf	lda #$ff		;Find a free buffer
	sta temp+1
	ldx #24-1		;The number of total bits added together for BUFUSE-1

10$	rol bufuse
	rol bufuse+1
	rol bufuse+2		;						[900314]
	bcs 20$			;Is this one free?
	stx temp+1
	sec
	bcs 50$
20$	dex
	bpl 10$
	rol bufuse
	rol bufuse+1
	rol bufuse+2		;						[900314]
30$	ldx temp+1		;Is there a buffer availabe?
	bmi 40$			;	no
	lda #0			;Start this buffer
	sta jobs,x
	lda drvnum
	sta lstjob,x
40$	txa
	rts

50$	rol bufuse
	rol bufuse+1
	rol bufuse+2		;						[900314]
	dex
	bpl 50$
	bra 30$

	.page
; FREe a BUFfer
;

frebuf	and #$1f		;Allow only allowable buffer range		[900414]
	tay
	iny
	ldx #24			;Total number of bits added together for BUFUSE
10$	ror bufuse+2
	ror bufuse+1
	ror bufuse
	dey
	bne 20$
	clc
20$	dex
	bpl 10$
	rts


; FREe a CHaNnel
;

clrchn	lda #14
	sta sa
10$	jsr frechn
	dec sa
	bne 10$
	rts

	.page
cldchn	lda #14			;Close all channels with the exception of the
	sta sa			;command, err$, and internal read/write channels

10$	lda sa			;Get the channel to be shut down
	jsr getlintab		;Is it currently active?
	cmp #$ff
	beq 30$			;	no

	and #lindx_mask		;Save the the LINDX value assigned to it	[910325] FAB
	sta lindx		;Make it the currently active channel
	tax			;Use LINDX as an index

	lda buf0,x		;Get the active buffer number (GETACT inline)
	bpl 20$			;	primary buffer is active
	lda buf1,x		;	must be secondary buffer
20$	and #all-bit6		;Drop off buffer dirty flag

	tax			;Buffer number		????   what if no buffer (bmi 30$)  ???? FAB
	lda lstjob,x		;Get the drive number from the last job executed
	and #1
	cmp drvnum		;Is it the same as the current drive?
	bne 30$			;	no, it's not the right drive so skip it
	jsr frechn		;	yes, free it

30$	dec sa
	bpl 10$
	rts

	.page
; Find a free LINDX to use.  Mark as used in LINUSE

fndlnx	ldy #0
	lda #1
10$	bit linuse		; 1=free, 0=used
	bne 20$			;	found a free one
	iny
	asl a
	bne 10$			;	loop for 8 bits

	lda #1			;						[900314]
15$	bit linuse+1		;1=free, 0=used					[900415]
	bne 25$			;	found a free one
	iny
	asl a
	bne 15$			;	loop for 8 bits

	lda #nochnl		;no free lindx available, NO CHANNEL error
	bra cmderr


20$	eor #$ff		;toggle bit mask
	and linuse		;mark bit used
	sta linuse
	tya			;return lindx in .a
	rts

25$	eor #$ff		;toggle bit mask				[900314]
	and linuse+1		;mark bit used
	sta linuse+1
	tya			;return lindx in .a
	rts

	.page
; Get next char from a channel
;

gbyte	jsr fndrch		;Set up read channel
	jsr actledon		;Turn on the activity led
	jsr get
	lda chndat,x
	rts



get	jsr typfil		;File type?
	beq rdrel		;	Relative file
	lda sa
	cmp #15			;Command channel?
	beq geterc		;	yes
	lda chnrdy,x		;Was last byte sent with EOI thing?
	and #eoisnd
	bne 20$			;	no
	lda file_type
	cmp #dirtyp
	bne 10$			;	not direct type
	lda #rndrdy		;direct file remains active
	sta chnrdy,x		;talker listener noeoi
	bra rndget		;prepare the next char

10$	lda #notrdy		;lst char sent, not ready
	sta chnrdy,x
	rts

20$	lda sa			;Load?
	beq get6		;	yes
	jsr typfil		;test for rel file
	bcc seqget		;seq file char get

	.page
rndget	jsr getpre		;direct file get
	lda buftab,x
	cmp lstchr,y		;up to lst char yet
	bne rnget1		;not yet
	lda #0			;read the whole thing
	sta buftab,x		;wrap pntr to 0

rnget1	inc buftab,x		;get the next char

rnget2	lda (buftab,x)
	sta chndat,y		;save char in
	lda buftab,x
	cmp lstchr,y
	bne 10$
	lda #rndeoi
	sta chnrdy,y		;this is last char
10$	rts			;send eoi with it

	.page
seqget	jsr rdbyt		;read the next byte
get3	ldx lindx
	sta chndat,x		;store in chndat
	rts

get6	bbr0 bit_flag_1,seqget	;Branch if not a Directory channel		[900622]
	jsr getdir		;Handle a directory read- get dir char
	bra get3

geterc	lda drvnum		;						[900703]
	asl a			;DRVNUM*2, a pointer into errbuftbl
	pha			;Point DIRBUF to the error message buffer,
	jsr getpnt		;  contained in the variable ER
	plx
	inc a			;+1 to be the same as the old CMP #ERRBUF-1
	cmp errbuftbl,x
	bne 10$
	lda dirbuf+1
	cmp errbuftbl+1,x
	bne 10$
	lda #cr
	sta data
	jsr erroff		;Turn off error led, show no errors in ERWORD
	lda #0
	jsr errts0
	dec err_buf_ptr
;	asl a			;????						[910417]
;	asl a
;	asl a
	lda #eoiout
	bra ge30

10$	jsr getbyt		;Get a byte from the error msg
	sta data		;Save it for CIOUT, was this the
	bne ge20		;Branch if not last byte of the message

ge15	lda drvnum
	asl a
	phy			;Save y
	tay			;Get drvnum * 2
	lda errbuftbl,y		;Reset the buffer back to the
	dec a			;-1
	jsr setpnt		;Start of the buffer
	lda errbuftbl+1,y
	ply			;Restore Y
	sta buftab+1,x
ge20	lda #rdytlk
ge30	sta chnrdy+errchn
	lda data
	sta chndat+errchn
nxtb1	rts

	.page
; Read next buffer of a file, following links in first two bytes.
; End of file if 1st byte = 0, 2nd char length

nxtbuf	ldx lindx		;Get channel number
	lda buf0,x		;Is the primary buffer active?
	bpl 10$			;	yes
	lda buf1,x		;	no- return the state of the secondary buffer

10$	and #$bf		;Drop off buffer dirty flag
	asl a
	tax
	lda #0
	sta buftab,x
	lda (buftab,x)
	beq nxtb1
	dec buftab,x
	bra rdbyt

	.page
; DiRecT ReaD			Direct Block Read
;

drtrd	lda #read
	   .byte $2c

;
; DiRecT WRiTe			Direct Block Write
;

drtwrt	lda #write
	ora drvnum		;Include current drive number
	sta cmd			;Save the command for DOIT2
	lda jobnum		;Get the job number for this command
	jsr seth		;Set up its header
	ldx jobnum		;Get the job number (buffer)
	bra doit2		;Go do the read/write

	.page
; Open internal read channel (make SA = IRSA, 16)
;

opnird	lda #seqtyp		;Set up as SEQ file

opntyp	sta type		;Save file type
	lda #irsa		;Set SA for Internal Read Secondary Address
	sta sa
	jsr opnrch		;Open the channel
	lda #2			;Skip past track and sector links
	bra setpnt		;Go read in 1st 1 or 2 sectors


;
; Open internal write channel (make SA = IWSA, 17)
;

opniwr	lda #iwsa		;Set SA for Internal Write Secondary Address
	sta sa
	bra opnwch		;Open the channel

	.page
; Allocate next directory block and mark it used in bam
;

nxdrbk	jsr curblk		;Get the current T&S for the current directory sector
	lda #1			;Init temp counter
	sta temp
;	lda secinc		;Save the current sector increment		removed [910313]
;	pha
;	lda dirsecinc
;	sta secinc
	jsr nxtds		;Get next directory sector
;	pla			;Restore SECtor INCrement
;	sta secinc
	lda #0			;Point to the T&S links
	jsr setpnt
	lda track		;Place the links into the buffer
	jsr putbyt
	lda sector
	jsr putbyt
	jsr wrtbuf		;Write out this buffer
	lda #0			;Point back to the T&S links
	jsr setpnt

10$	jsr putbyt		;Fill the new directory sector with zeros
	bne 10$

; Change to close_directory type of padding the buffer <<<<<<<<<

	jsr putbyt		;Move past track link	   ($00)
	lda #$ff		;Put end of directory flag ($FF)
	bra putbyt		; & rts

	.page
; SET PoiNTer
; Set DIRBUF to point to the byte in A for the currently active channel.

setpnt	sta temp
	ldx lindx		;Get channel number
	lda buf0,x		;Is the primary buffer active?
	bpl 10$			;	yes
	lda buf1,x		;	no- return the state of the secondary buffer

10$	and #$bf		;Drop off buffer dirty flag
	asl a
	tax
	lda buftab+1,x
	sta dirbuf+1
	lda temp
	sta buftab,x
	sta dirbuf
	rts

	.page
; Free the internal read and write channels
;

freich	lda #irsa
	sta sa
	jsr frechn
	inc sa			;lda #iwsa
;	sta sa			;						[901213]
	bra frechn

;
; Read the active buffer pointer
;

getpnt
	ldx lindx		;Get channel number
getpnt_1
	lda buf0,x		;Is the primary buffer active?
	bpl 10$			;	yes
	lda buf1,x		;	no- return the state of the secondary buffer
10$	and #$bf		;Drop off buffer dirty flag

setdir				;SET DIRbuf directly (buffer number in A)
gp1	asl a
	tax
	lda buftab+1,x
	sta dirbuf+1
	lda buftab,x
	sta dirbuf
	rts

;
; Direct read byte, .a = byte # to read
;

drdbyt	sta temp+2		;Save the LSB of the byte to fetch
	ldx lindx		;Get channel number
	lda buf0,x		;Is the primary buffer active?
	bpl 10$			;	yes
	lda buf1,x		;	no- return the state of the secondary buffer

10$	and #$bf		;Drop off buffer dirty flag
	tax
	lda bufind,x		;get the MSB of the active chnl
	sta temp+3		;Save it
	ldy #0			;Index of zero
	lda (temp+2),y		;Now get the byte
	rts

	.page
; Table containing high bytes of buffer addresses
;

bufind	.byte >dosbuffer0
	.byte >dosbuffer1
	.byte >dosbuffer2
	.byte >dosbuffer3
	.byte >dosbuffer4
	.byte >dosbuffer5
	.byte >dosbuffer6
	.byte >dosbuffer7
	.byte >dosbuffer8
	.byte >dosbuffer9
	.byte >dosbuffer10	;				[900314]
	.byte >dosbuffer11
	.byte >dosbuffer12
	.byte >dosbuffer13
	.byte >dosbuffer14
	.byte >dosbuffer15
	.byte >dosbuffer16
	.byte >dosbuffer17
	.byte >dosbuffer18
	.byte >dosbuffer19
	.byte >dosbuffer20
	.byte >dosbuffer21
	.byte >bambuf0d0	;Drive 0 BAM 0 buffer
	.byte >bambuf1d0	;Drive 0 BAM 1 buffer
	.byte >bambuf0d1	;Drive 1 BAM 0 buffer
	.byte >bambuf1d1	;Drive 1 BAM 1 buffer
	.byte >fdcbuffer0	;1st. half buffer for fdc chip
	.byte >fdcbuffer1	;2nd. half buffer for fdc chip


;.end
	.page
	.subttl	 ROUTINES  v910530

;		  TRansfer fileNAME
;
; Transfer filename from cmd to buffer
;
; ON ENTRY:	a    string size
;		x    starting index in cmdbuf
;		y    buffer #

trname	pha			;Find out where the ',' or '=' is in the buffer
	jsr fndlmt		;(the end of this string)
	jsr trcmbf
	pla
	sec
	sbc strsiz
	tax
	beq 20$
	bcc 20$

	lda #$a0
10$	sta (dirbuf),y
	iny
	dex
	bne 10$

20$	rts

	.page
toggle_drive_number		;togdrv.
	bbr2 bit_flag_1,10$	;exit if internal dual drive disabled	[900919] DJJ
	lda drvnum		;otherwise toggle to the other drive
	and #1
	eor #1
;	sta drvnum
	phx
	tax
	jsr setup_err		;					[910805] FAB
	txa
	plx
10$	rts



; Transfer cmd buffer to other buffer
; uses current buffer ptr limit ending index+1 in cmd buf
;	x    starting index in cmd buf
;	y    buffer #

trcmbf	tya
	asl a			;*2 to point to LSB of the buffer number
	tay
	lda buftab,y
	sta dirbuf
	lda buftab+1,y
	sta dirbuf+1

	ldy #0
10$	lda cmdbuf,x
	sta (dirbuf),y
	iny
	beq 20$
	inx
	cpx limit
	bcc 10$

20$	rts

	.page
;****************************************************************************************
;*					FNDLMT						*
;*  Find the length of the string in command buffer starting where 'X' marks the spot.	*
;*											*
;*	ENTRY:		X = Where in the COMMAND BUFFER to start			*
;*											*
;*	EXIT:		X = Same value you entered with					*
;*											*
;*	LIMIT = Pointer to the ',' or '=' in the filename.  If they don't exist it	*
;*		will point to the end of the string+1.					*
;*											*
;*	STRSIZ= If LIMIT found one of [ ,=/ ].	If BIT_FLAG is setup then STRSIZ	*
;*		will point one character before these two characters.  If they were	*
;*		not found then it will contain a 15 or point to the end of the		*
;*		command buffer, which ever comes first.					*
;****************************************************************************************

fndlmt	lda #0
	sta strsiz
	phx			;Save index
5$	lda cmdbuf,x
	cmp #','		;Statement seperator?
	beq 10$			;	Yes, then we're done
	cmp #'='		;Name sperator?
	beq 10$			;	Yes, then branch
	bbr0 bit_flag,6$
	cmp #'/'
	beq 10$
6$	inc strsiz		;Bump the length of the string
	inx			;Bump the index pointer
	lda #15
	cmp strsiz		;Check string length
	bcc 10$			;	branch if exceeded allowable size
	cpx cmdsiz		;Check for end of buffer
	bcc 5$			;	branch if not end of buffer

10$	stx limit
	plx			;Restore X
	rts

	.page
; Get file entry from directory.  Called by STDIR, GETDIR

getnam	lda sa			;save variables
	pha
	lda lindx
	pha
	jsr gnsub
	pla			;restore variables
	sta lindx
	pla
	sta sa
	rts

	.page
;* Get Name SUBroutine
;*

gnsub	lda #irsa		;Use internal read SA
	sta sa
	jsr fndrch		;Get a read channel
	jsr getpnt		;Get the pointer to the channel
	lda entfnd		;More files?
	bpl 5$			;	yes
	lda drvflg		;Is this the last drive in the system?
	bne 6$			;	no
4$	jsr msgfre		;Place blocks free in the buffer
	clc
	rts

5$	lda drvflg		;(drvflg=0)
	beq 10$			; send file name

6$ ;	dec drvflg		;(drvflg=-1)
	bra 4$

	lda #0
	sta nbtemp+1
	sta drvflg		;reset flag
	jsr newdir
	sec
	rts

10$	ldx #dirlen		;set number blocks
	ldy #29			; & adjust spacing
	lda (dirbuf),y
	sta nbtemp+1
	beq 11$

; *******************************************************************************
; *   Changed the way the number of BLOCKS USED by each file is displayed so	*
; *   that files using >999 blocks line up with files using <1000 blocks.	*
; *******************************************************************************

	cmp #>1000		;Is it greater than 999 blocks?
	bcc 12$			;	<1000
	bne 13$			;	>1000
	dey			;	=1000?  Check LSB
	lda (dirbuf),y
	iny
	cmp #<1000		;Is it <1000 blocks?
	bcc 12$			;	yes
13$	dex
12$	dex
	dex
11$	dey
	lda (dirbuf),y
	sta nbtemp
	cpx #dirlen
	bcc 14$
	cmp #10
	bcc 14$
	dex
	cmp #100
	bcc 14$
	dex
14$	jsr blknb		;clear name buffer
	lda (dirbuf),y		;set type chars
	taz			;						[910610]
;	pha
	asl a			;(used in bcs 20$ below)
	bpl 15$			;is the file locked?
	lda #'<'		;	yes, show the locked file
	sta nambuf+1,x

15$	tza			;get the file status byte back			[910610]
;	pla
	and #bit5		;If it was not a save with replace branch
	beq 16$

; Previous DOS versions would not indicate a problem with the save with		[910610]
; replace operations, such as when you save a BASIC program and get a write
; error.  The previous DOS versions would never inform you that a save with
; replace error had occurred.  Since the TRACK and SECTOR pointers for this file
; name reflect the previous data contents prior to the save with replace you
; not be able to retreive ANY of this info.  At this point in 'TIME' the save
; with replace TRACK and SECTOR pointers are in the SAVE with REPLACE locations
; in the filename.

	lda #'@'		;Show previous save with replace operation as incomplete
	sta nambuf+3,x
16$	tza
	asl a			;(for the BCS below)
	tza
	and #typmsk		;mask all but true file types
	tay			;use it as an index
	lda tp2lst,y		;place the extension into the buffer
	sta nambuf,x
	dex
	lda tp1lst,y
	sta nambuf,x
	dex
	lda typlst,y
	sta nambuf,x
	dex
	dex
	bbs5 bit_flag_1,17$	;Branch if in UNSCRATCH mode			[900815]
	bcs 20$			;(from the ASL above)
	lda #'*'
	sta nambuf+1,x		;Show a splat file
	bra 20$

17$
;	lda #$0f		;						[900815]
;	sta nambuf+1,x		;then show it
	lda #'-'
	sta nambuf+6,x		;(was +5)					[910610]
20$	lda #$a0		;terminate with a shifted space
	sta nambuf,x
	dex
	ldy #18
22$	lda (dirbuf),y
	sta nambuf,x
	dex
	dey
	cpy #3
	bcs 22$

	lda #34			;send name in quotes
	sta nambuf,x
30$	inx
	cpx #$20
	bcs 35$
	lda nambuf,x
	cmp #34
	beq 35$
	cmp #$a0
	bne 30$

35$	lda #34
	sta nambuf,x
37$	inx
	cpx #32
	bcs 40$
	lda #$7f
	and nambuf,x
	sta nambuf,x
	bpl 37$
40$	bbr5 bit_flag_1,50$	;If not UNSCRATCH directory branch
	lda #0			;Show no sectors as being found as of yet
	sta delsec		;						[900821]
	inc a			;Set flag for finding 1st. available spot in the
	sta delind		;Directory					[900821]
50$	jsr fndfil		;Go lookup the file
	sec
	rts


blknb	ldy #nbsiz		;blank nambuf
	lda #32
10$	sta nambuf-1,y
	dey
	bne 10$
	rts

	.page
; New directory in listing
;

newdir	jsr autoi		;Init the drive
	jsr rddir		;Write dirty bam if needed & get the directory header
	jsr blknb		;BLanK the Name Buffer
	lda #$ff
	sta temp
	lda #0
	sta nbtemp+1
	sta nbtemp
	ldx jobnum		;Get the buffer number that the
	lda bufind,x		;Directory header was read into
	sta dirbuf+1		;And save its address in DIRBUF
	lda #dsknam		;Skip over to the disk's name
	sta dirbuf

	ldy #22
	lda (dirbuf),y		;Get the DOS version number
	beq 12$			;	no version is okay!
	cmp fmttyp
	beq 20$			;	okay

	lda #'?'		;	unknown dos
	   .byte $2c
12$	lda #fmt1581
	   .byte $2c

15$	lda (dirbuf),y
	cmp #$a0		;Copy the disk's name to the
	bne 20$			;Name buffer, and replace the
	lda #' '		;Shifted space with non-shifted
	sta nambuf+19		;End with a space
20$	sta nambuf+2,y		;Place the name after the 1st
	dey			;Quote mark, and after the RVSON character
	bpl 15$

	lda #$12
	sta nambuf
	lda #34
	sta nambuf+1		;Start name with a quote
	sta nambuf+18		;And end with a quote
	rts

	.page
msgfre	jsr blknb		;Fill the name buffer with zeros

	ldy #msgend-fremsg-1
10$	lda fremsg,y		;Place the message in the buffer
	sta nambuf,y
	dey
	bpl 10$
	bra numfre		;get number of bytes & rts



fremsg	.byte 'BLOCKS FREE'
msgend

	.page
;*	ONE DRiVe
;*
;* This routine will check the filename in the command buffer for a drive number.
;* Note that this routine restricts the file stream to one filename.  If more than
;* one filename is in the buffer, it will be ignored by this and all future calls
;* to DOS routines, since F1CNT and F2PTR are set to one filename.

onedrv	lda f2cnt
	sta f1cnt
	lda #1
	sta f2cnt		;One filename to find drive number for
	sta f2ptr


;*	ALL DRiveS
;*
;* This routine checks all the filenames in the command buffer for drive numbers
;* and places them in file_drive.  The number of filenames to be checked is in
;* F2CNT.  FILTBL contains the pointer to the filename.

alldrs	ldy drivenumber
	ldx #0			;...into file entry table...
10$	stx f1ptr		;Save where to start checking for the drive # in the cmd buf
	lda filtbl,x		;Get the pointer to the char before the ':'
	jsr setdrv		;Get the drive #
	ldx f1ptr		;Get the File stream pointer
	sta filtbl,x		;Move past ':'
	tya			;Save drive #
	sta file_drive,x
	inx			;Move past the ':'
	cpx f2cnt		;Any more filenames to search for drive numbers?
	bcc 10$			;	branch if yes
	rts

	.page
;****************************************************************************
;*				SET DRiVe				    *
;*									    *
;* ENTRY:  A = Index into the command buffer (normally points at the ':')   *
;*	   Y = Last drive number					    *
;*	   X = DESTROYED						    *
;*	   Z = Not used							    *
;*									    *
;* EXIT:   A = New index into the command buffer			    *
;*	   Y = New drive number						    *
;*	   X = New index into the command buffer			    *
;*									    *
;* NOTE: I discovered this routine NEVER performed its task since the 1st   *
;*  DOS was coded. This routine was to check to see if there was a drive #  *
;*  prefixing the ':', and if there was NOT it was to set BIT 7 in the ACC. *
;*  to denote that the DEFAULT drive was being used. We double checked this *
;*  on the 2030, 2040, 4040, 8050, 8250 and found it never worked, so I	    *
;*  recoded it.								    *
;****************************************************************************

setdrv	tax			;Move pointer into X
	lda #':'		;Search for the colon (since FILTBL points at the colon,
	cmp cmdbuf+1,x		;this passes because we're now indexing 0 thru xx)
	beq sd40		;And FILTBL starts at 1
	cmp cmdbuf,x		;And normally fails
	bne sd50
	inx			;							[910314]
sd20	tya			;Use physical drive number
sd22	and #bit0		;Stip off not specified flag
sd24	tay			;Move drive number back into Y as the default drive
	txa			;Reflect new cmd buffer index
	rts

sd40	lda cmdbuf,x		;Check before the colon
	inx			;Then move just past the colon
	inx
	cmp #'0'
	beq sd55
	cmp #'1'		;IF NOT DRIVE NUMBER 1
	bne sd50		;   BRANCH

	bbs2 bit_flag_1,sd22	;IF drive one then branch (use requested drive number)
	beq no_drive_present	;	ELSE generate a no drive number error

sd50	tya			;Move default drive number into A
	ora #bit7		;Set show no drive specified flag			[900614]

sd51	and #bit7+bit0		;Keep default and the drive number
	bra sd24		;	return it in Y

sd55	bbs2 bit_flag_1,sd22	;Uses drive number 0
	bra sd20		;Use the device address (0 or 1)

	.page
simprs	jsr close_all_channels	;SPLAT protection (eg., 'I0' with files open)		[910528]
simprs_1
	ldx cmdsiz		;SIMple PaRSer
	cpx #4			;Say 4 to account for possible <cr>
;	cpx #3			;Prevent the user from being able to use command lines longer
	bcs syntax_error	;than expected.	 This affects initdr, validate, and opening the
				;directory as a SEQ file.  This blocks syntaxes such as V0:JUNK99.
	ldx #0
	stx filtbl
	jsr look_4_colon
	beq 3$
	dey
	dey
	sty filtbl
3$	lda #0
	sta image
	ldy filtbl		;Get the pointer to the drive number
5$	lda (cmd_buf_ptr),y	;Was the drivenumber specified?
	jsr tst0v1
	bpl 20$			;	Yes then branch
	iny			;	No keep on looking
	cpy cmdsiz		;We done yet?
	bcs 10$			;	yes, use the default drive
	ldy cmdsiz		;	no, then scan back one
	dey
	bne 5$

10$	dec image		;Set IMAGE to $FF to denote DEFAULT drive used
	lda drivenumber 	;Get the logical drive number
20$
;	sta drvnum
	phx
	tax
	jsr setup_err		;						[910805] FAB
	txa
	plx
	bra actledon

	.page
; Set ptrs to one file stream & chk type

fs1set	ldy #0			;Default to DEL file type
	lda f1cnt		;Get the pointer to the end of filename 1
	cmp f2cnt		;Same as the end of filename 2?
	beq fs1set_rts		;	branch if same
	dec f2cnt
	ldy f2cnt		;Move to the file type
	lda filtbl,y
	tay
	lda (cmd_buf_ptr),y

;		MR BUG RESIDES IN THIS SECTION OF CODE ????			[910610] DJJ

fs1set_1			;Entered here by COPY routine			[910430]
	ldy #ntypes-1
10$	cmp typlst,y		;Is it a valid file type?
	beq fs1set_rts		;	yes
	dey			;	no- continue searching
	bne 10$			;If we're not done branch else default to DEL

fs1set_rts
	tya			;Place file type in Acc. for other folks use
	sty typflg
	rts

	.page
; IF ACC = '0'
;     THEN IF BIT 2 set in BIT_FLAG_1
;	     THEN ACC = $00
;	      ELSE ACC = '0' ora DRIVENUMBER
;	ELSE IF ACC = '1'
;	      THEN IF BIT 2 set in BIT_FLAG_1
;		    THEN ACC = $01
;		     ELSE NO_DRIVE_ERROR
;		ELSE ACC = ACC ora $80	[no drive specified flag]

tst0v1	cmp #'0'
	beq t0v1
	cmp #'1'
	bne 10$			;If not drive one branch		[900904]
	bbs2 bit_flag_1,t0v2	;					[900911]
	bra no_drive_present	;					[900904]
10$	ora #bit7		;Set drive number not specified flag
t0v1	bbs2 bit_flag_1,t0v2	;					[900911]
	ora drivenumber
t0v2	and #bit7+bit0		;Strip off not specified flag and a possible drive #
	rts

	.page
;************************************************************************
;*  GET the ACTive buffer number for the current logical index.		*
;*  Exits with bit7 set if there are no buffers active for this Lindx.	*
;************************************************************************

getact	ldx lindx		;Get channel number
	lda buf0,x		;Is the primary buffer active?
	bpl 10$			;	Yes, then branch
	lda buf1,x		;	No, return the state of the Secondary buffer
10$	and #all-bit6		;Strip off buffer dirty flag & ignore
	rts



;************************************************************************
;*  GAFLGS	Get active buffer's flags, set LBUSED & uP flags.	*
;*		regs out:	.a= act buffer #			*
;*				.x= lindx				*
;*		flags:		.n=1  no act-buf			*
;*				.v=1  dirty buf				*
;************************************************************************

gaflgs	ldx lindx		;Get channel number
	stx lbused		;Show it as Last Buffer USED
	lda buf0,x		;Is the primary buffer being used?
	bpl 10$			;	Yes
	txa			;Bump point up to the secondary buffer
	clc
	adc #mxchns
	sta lbused		;Show secondary as being last one used
	lda buf1,x
10$	sta t1			;Save LINDX value from BUF0,BUF1
	and #$1f		;Strip off ACTIVITY and DIRTY flags
	bit t1			;Restore flags
	rts

	.page
;************************************************************************
;* NULBUF								*
;*	set null records in active_buffer for extention			*
;* VARS USED:								*
;*	next_record, record_size, lx, active_buffer			*
;* VARS IN:								*
;*	next_record = last record position in previous buffer		*
;* VARS OUT:								*
;*	next_record = last record position in buffer for next nulbuf	*
;*		      or to set lstchr					*
;************************************************************************

nulbuf	jsr set00		;Set indirect ptr

	ldy #2			;Skip past track and sector links
	lda #0
10$	sta (dirbuf),y		;Fill the buffer with zero's
	iny
	bne 10$

	jsr addnr		;advance next_record
20$	sta next_record,x
	tay
	lda #$ff
	sta (dirbuf),y		;	Pad record with the fill byte
	jsr addnr
	bcc 20$			;	loop until done
	bne 30$

	lda #0
	sta next_record,x
30$	rts

	.page
; ACC = Record Size & Number Record
; c=1 if record sought is across sectors

addnr	ldx lindx		;Advance Next Record
	lda next_record,x
	sec
	beq 5$			;	not this sector, exit with .c=1 & .a=2
	clc
	adc record_size,x
	bcc 10$			;	in this sector, exit with .c=0 & .a=where
	bne 5$			;
	lda #2
	bit er00		;sets z flag, c=1
	rts

5$	adc #1			;adjust for link
	sec
10$	rts


setflg	ldx lindx
	ora filtyp,x
	bne clrf10

clrflg	ldx lindx
clrflg_1
	eor #$ff
	and filtyp,x

clrf10	sta filtyp,x
	rts


tstflg	ldx lindx
tstflg_1
	and filtyp,x
	rts


test_write_mode			;tstwrt.				???? getact inline ????
	ldx lindx		;Get channel number
	lda buf0,x		;Is the primary buffer active?
	bpl 10$			;	Yes then branch
	lda buf1,x		;	No, return the state of the Secondary buffer
10$	and #$bf		;Strip off buffer dirty flag
	tax
	lda lstjob,x
	and #$f0
	cmp #$90		;Exit with N flag set if it is write mode
	rts

	.page
; TeST CHaNnel			Test for active files from lindx table
;
;	c=1 file not active x=18,y=?,a=?
;	c=0 file active x=entfnd,y=lindx,a=?


tstchn	ldx #0			;Start search at top
20$	stx temp+2		;	save SA to test
	txa			;SA into acc
;	pha			;	save it for later	[901127] removed [910327] FAB
	jsr getlintab		;Get lindx
	cmp #$ff		;Channel active?
	bne 40$			;	yes
;	pla			;	no, cleanup stack	[901127] removed [910327] FAB

30$	ldx temp+2		;Next SA
	inx
	cpx #maxsa-2		;Searched all?
	bcc 20$			;	no
	rts			;	yes- exit with no active channels


40$
;	plx			;SA of the active channel	[901127] removed [910327] FAB
;	stx temp+2		;	save it
	and #lindx_mask		;						[910325] FAB
	tay			;LINDX of the active channel
	lda filtyp,y		;Right drive # ?
	and #1
	sta temp+1
	ldx entfnd		;	Index entry found
	lda file_drive,x
	and #1
	cmp temp+1		;	Same drive # ?
	bne 30$			;	       no
	lda dsec,y
	cmp entsec,x		;	Same directory entry ?
	bne 30$			;	       no
	lda dind,y
	cmp entind,x		;	Same directory index?
	bne 30$			;	       no

	clc			;Set 'active' flag
	rts

	.page
lda_erword
	phx			;						[910313]
	ldx drvnum
	lda erword,x
	plx
;	cmp #0			;Reset processor flags
	and #$ff		;						[910315] FAB
	rts



sta_erword
	phx			;						[910313]
	ldx drvnum
	sta erword,x
	plx
	rts

;.end
	.page
	.subttl	 COMMANDS  v910525

derror	lda #direrr
	bra cmderr

unnew	jsr CheckProt		;Disk must not be write protected		[910328]
	jsr rdbam		;Get the bam
	ldx drvnum		;Get the number of blocks free on this diskette
	lda ndbl,x		;						[900721]
	ldy ndbh,x		;And if less than 3160				[900721]
	cmp #<3160
	bne derror
	cpy #>3160		;Error out
	bne derror
;	lda #1			;						[910108]
	sta temp
	jsr getbuf		;Get one buffer to use
	bmi no_channel		;	none available				[901127]
	sta jobnum		;Save job (buffer #)
	jsr set00_1		;Point DIRBUF at the T & S links
	lda jobnum
	jsr frebuf		;Free this buffer as it's no longer needed
	ldx drvnum		;						[900415]
	lda dirst,x
	jsr settrk		;						[900415]
	jsr drtrd		;Go read in the 1st. directory sector
	lda #0
	sta dirbuf
	ldz #1			;Points to the SECTOR link
	ldy #33
10$	lda (dirbuf),y		;Copy the T and S links which point
	sta (dirbuf),z		;to the 2nd directory sector to bytes
	dey			;32 and 33 in the directory sector
	dez
	bpl 10$

	lda #0			;Clear sector links to the directory sector
	sta (dirbuf),y
	iny
	sta (dirbuf),y
	smb1 dirbuf		;Byte for the 1st. file in the directory sector	[900723]

	ldx #7			;8 directory entries
20$	jsr restore_file_status	;Move status byte to a safe place		[900723]
	dex
	bpl 20$
	rmb1 dirbuf		;						[900723]
	ldx drvnum		;						[900415]
	lda dirst,x
	jsr settrk		;						[900415]
	jsr drtwrt

	.page
; Validate files with BAM.  Create a new BAM according to contents of files entered in dir.
;
; NOTE:		If the V was shifted (bit 7 set) then the blocks used by each file
;		will be updated to the correct sectors used.

validate_bam			;verdir.
	jsr CheckProt		;Check for a write protect error		[900517]
	jsr cmdset		;Find the length of the command string
	jsr simprs		;Extract drive #
	jsr initdr		;Extract required info from the BAM, such as IOBYTE etc.
	lda #0
	ldx drvnum
	sta ndbl,x		;.a = 0
	sta ndbh,x		;Clear for new map
	jsr create_bam		;Create a new bam
	lda #0			;Not searching for deleted
	sta delind
	jsr srchst		;Find 1st file name
	bne 25$			;	Found one so branch

10$	ldy drvnum		;						[900415]
	lda dirtrk,y		;Set the directory starting track
	sta track
	lda #0			;Start with the directory header
	sta sector
	jsr markts		;Mark directory header thru to last directory sector
	ldy drvnum		;						[900415]
	lda dirtrk,y
	sta track
	lda #1			;Now do the bams
	sta sector
	jsr markts
	jsr mapout		;Write out the bam				[900918]
	bra endsav		;Show bam as being clean then we're done	[900517]

15$	iny
	jsr validate_bam_2	;						[910610]
	bbr7 bit_flag,18$	;branch if not long verdir command		[910204] DJJ
	lda #0
	sta lo
	sta hi			;Clear temp block count
	lda dirbuf		;						[900505]
	sta r3
	lda dirbuf+1
	sta r3+1
18$	jsr markts		;Mark links in bam
	bbr7 bit_flag,20$	;						[910204] DJJ
	ldy #28			;Save blocks used by this file
	lda lo
	cmp (r3),y		;Time saver: Don't update the directory sector if no change
	bne 19$			;						[910313]
	iny			;  Idea: Use a 'directory sector dirty' flag, and update
	lda hi			;  only when this flag was set.	 The check would occur in
	cmp (r3),y		;  the SEARCH routine.
	beq 20$			;						[910313]
	dey
19$	lda lo			;Update the number of blocks used in the file	[910313]
	sta (r3),y
	iny
	lda hi
	sta (r3),y
	jsr wrtout

;20$	jsr srre		;Search for the next directory entry
;
; The following change reduces the collect time on a disk with 296 one
; sector files from 1min. 51sec. to 1min. 3sec. and greatly reduces the
; wear and tear on the stepper motor.  The previous call to SRRE caused
; the DOS to reread the directory sector each time a new filename was
; sought from the diskette.

20$	jsr search		;Look for the next filename in the directory	[900913]
	beq 10$			;	branch if none found

25$	ldy #0
	lda (dirbuf),y		;Is this a splat file?
	bpl 28$			;Yep then scratch it

;; Need to add a check here to see if this was a save-with-replace file.  If	[910117] DJJ
;; it was, restore the original t&s links because the only way you can see the
;; save-with-replace bit at this point is if an error occurred during the replace
;; procedure... you cannot have a splat file occur during a save with replace!!!!!
;
;	pha			;						[910528]
;	and #bit5		;					removed	[910610]
;	cmp #bit5
;	pla
;	bcs 102$
;	pha
;	jsr restore_file_status
;	pla
;102$
	and #typmsk		;Drop off completed and locked
	cmp #partyp		;Part file?
	bne 15$			;Nope then branch
	jsr validate_partition
	bra 20$

28$	beq 20$			;If the file was already scratched, don't waste time
				; rewriting the directory sector!
	jsr delete_dir_entry	;Set file status byte to 0 and write the directory sector
	bra 20$			; always

	.page
validate_bam_2			;Made into a subroutine				[910610]
	lda (dirbuf),y
	pha			;save track
	iny
	lda (dirbuf),y
	pha			;save sector
	ldy #19			;get side_sector track
	lda (dirbuf),y		;is this relative?
	beq 17$			;no
	sta track		;yes, save track
	iny
	lda (dirbuf),y		;get side_sector sector
	sta sector
	jsr markts		;validate side sector by links

17$	pla
	sta sector		;now do data blocks
	pla
	sta track
	rts

	.page
;**********************************************************
;*		MARK Track and Sector			  *
;*							  *
;* The routine will follow a set of track and sector links*
;* marking them as being used in the BAMs as required.	  *
;*							  *
;* ENTRY: TRACK	 = Track number the 1st sector is on	  *
;*	  SECTOR = Sector number the 1st sector is on	  *
;*							  *
;* EXIT: Bam for the active drive is updated TRACK, SECTOR*
;*	 points to the last sector marked.		  *
;*							  *
;* ERROR: Bad track and sector, NO CHANNEL if no buffers  *
;*	  are available to be used by this subroutine.	  *
;**********************************************************

markts	smb4 bit_flag		;Set flag to call WUSED
	   .byte $2c

delfil	rmb4 bit_flag		;Set flag to call FRETS
	smb6 bit_flag		;Signal FDC to place T & S links in TRACK AND SECTOR
	bbs4 bit_flag,5$	;						[910502] DJJ
	lda lindx
	pha
	jsr fndlnx		;Get a new Lindx				[910204] DJJ
	sta lindx
5$	jsr getbuf		;Get a buffer to use
	bmi no_channel		;	error if none free
	sta jobnum		;	else save buffer number for later
	jsr set00_1		;Point DIRBUF at the T&S links for the active buffer
	lda jobnum
	jsr frebuf		;Free up this buffer as it's no longer needed

;	bbr4 bit_flag,1$	;Branch if called by the append command		[910117] DJJ
;;	jsr getbuf		;Get a buffer to use				" removed DJJ
;;	bpl 5$			;	ok
;;	bra no_channel		;	none available				[901127]
;1$
;;	jsr set00		;Get the active buffer number then point	[900418]
;;	bra 6$			;DIRBUF at the T & S links for the active buffer
;;
;;5$	sta jobnum		;Save job buffer #				[900502]
;;	jsr set00_1		;Point DIRBUF at the T & S links for the active buffer
;;	lda jobnum		;Free up this buffer as it's
;;	jsr frebuf		;No longer needed

6$	jsr tschk		;Check for a BAD T&S
	bbs4 bit_flag,10$	;Branch if it's Validate_BAM calling us
	jsr frets		;Free up this track and sector
	bra 20$			;Always

10$	bbr7 bit_flag,15$	;						[910204] DJJ
	inc lo			;Add one more block to the number used by this file
	bne 15$
	inc hi
15$	jsr wused		;Mark it as being used

20$	lda jobnum
	jsr seth		;Place TRACK, SECTOR in HDRS
	jsr ReadSector		;Read in this sector and extract its links	[900517]
	lda track		;Are we at the last sector?
	bne 6$			;	No,  continue
	bbs4 bit_flag,25$	;						[910502] DJJ
	jsr freelindx		;	Yes, discard the temp lindx value	[910204] DJJ
	pla
	sta lindx
25$	rmb6 bit_flag		;Clear FDC 'only two bytes' flag
	rmb5 bit_flag		;Clear flag to prevent NO BLOCK in WUSED
	rmb4 bit_flag		;Clear allocate/deallocate sectors flag
	rts

	.page
; Called by VALIDATE_BAM and FILE_RESTORE
;

validate_partition
	jsr setparts
	bra allocpart


scratch				;scrtch.						[901127]
	jsr setup_one_stream	;Check state of wp switch and if okay set up a file stream
	jsr optsch
	lda #0			;Use R0 to accumulate the total number of scratched files
	sta r0
	jsr ffst		;Find the first filename
	bmi 30$			;	branch if none

	ldy #0			;Prevent user from scratching splat file		[910117]
	lda (dirbuf),y
	bpl 25$			;	branch if splat file (don't scratch it) ????

15$	jsr tstchn		;Is this file name opened for R/W?
	bcc 25$			;	branch if file currently open (don't scratch it)

	ldy #0
	lda (dirbuf),y		;Get the file type and save it
	sta lo
	and #$40		;Is it a LOCKED file?
	bne 25$			;	yes- branch to keep from scratching it
	jsr delete_dir_entry	;	no-  delete file from the directory and write it out

	lda lo			;Is it a partition?
	and #typmsk
	cmp #partyp
	bne 16$			;	branch if not
	iny			;	else get the starting track & sector of partition
	lda (dirbuf),y
	sta track		;		save it in TRACK and SECTOR
	iny
	lda (dirbuf),y
	sta sector
	ldy #28			;	and get the number of blocks (sectors) used
	lda (dirbuf),y
	sta lo			;		save it in LO and HI for CALCPAR
	iny
	lda (dirbuf),y
	sta hi

;  Start with the starting track and sector for this partition, and loop through each
;  each Track and Sector for each max sector allowed

1$	jsr tschk		;Check for sector out of range
	jsr frets		;Free it
	jsr calcpar		;Move up to the next T and S
	bne 1$			;loop until at the end of the partitioned area
;	jsr mapout		;Write out the BAM(s)				    [not needed]
	bra 20$

16$	cmp #reltyp		;Is it a RELative file?					[910328]
	bne 17$			;	no, not REL filetype
	ldy #19
	lda (dirbuf),y		;	See if it has any side sectors
	beq 17$			;		branch if not

	sta track		;	Save the track and sector number of side sector
	iny
	lda (dirbuf),y
	sta sector
	jsr delfil		;	Delete the side sector by its links

17$	ldx entfnd		;Get the index into the tables
	lda #$20		;Was this file closed properly?
	and pattyp,x
	bne 20$			;	branch if not
	lda filtrk,x		;Delete the data block by its links
	sta track
	lda filsec,x
	sta sector
	jsr delfil

20$	jsr increment_r0	;Increment the number of files scratched

;25$	jsr ffre		;Another file to be scratched?				[901213]
25$	jsr continue_search	;Look for another filename				[910205] DJJ
	bpl 15$			;	loop until there are no more

30$	jsr mapout
	lda r0			;Place the total number of files scratched
	sta track		;in TRACK for the error message routine to report

;	ldy #0			;							[901127]
	lda #1			;FILE SCRATCHED error message
	bra scratch_end		;we're done


delete_dir_entry		;deldir.
	ldx #0
	jsr save_file_status
	bra wrtout		;Write out the directory sector

	.page
;  This routine moves a file's current status byte to a storage area
;  which could be used by the UNNEW or UNSCRACH routines.  This routine
;  ASSUMES that upon entry that you have DIRBUF pointing to the file's
;  file_status_byte.  For example, for the first file in the sector DIRBUF
;  would have its LSB pointer pointing at $02.		900723 DJJ

save_file_status		;					[900723]
	ldz tfiletype,x
	ldy filetype,x
	lda (dirbuf),z		;Clear out possible existing
	and #$0f
	sta (dirbuf),z
	inz
	lda (dirbuf),z
	and #$0f
	sta (dirbuf),z
	dez
	lda (dirbuf),y
	beq 10$			;Already blown away so go to the next name
	pha
	and #$f0
	ora (dirbuf),z
	sta (dirbuf),z
	inz
	pla
	and #$0f
	asl a
	asl a
	asl a
	asl a
	ora (dirbuf),z
	sta (dirbuf),z
	lda #0			;Blow away this file
	sta (dirbuf),y
10$	rts

	.page
restore_file_status		;						[900723]
	clc			;Flag to clear temp storage area
	   .byte $89

restore_file_status_1		;Entered by Lookup
	sec
	php			;Save flag
	ldz tfiletype,x
	ldy filetype,x
	lda (dirbuf),y		;Is it currently scratched?
	bmi 10$			;No then bug out (have to get php off stack)
	lda (dirbuf),z
	and #$f0
	sta (dirbuf),y		;Save upper 4 bits
	inz
	lda (dirbuf),z
	and #$f0
	clc
	ror a
	ror a
	ror a
	ror a
	ora (dirbuf),y
	sta (dirbuf),y
	dez			;Move back to upper 4 bits
	plp			;Get status back
	bcs 20$			;If called by LOOKUP then branch
	lda (dirbuf),z		;Wipe upper 4 bits
	and #$0f
	sta (dirbuf),z
	inz
	lda (dirbuf),z		;Also lower
	and #$0f
	sta (dirbuf),z
	   .byte $89		;					[901127]

10$	plp			;cleanup
20$	rts

	.page
;************************************************************************
;*	NEW		Initialize (format) a diskette.			*
;*  soft-sectors, bit avail. map, dir, & 1st block are all inited	*
;************************************************************************

new	jsr onedrv		;Get the 1st drive number found
	lda file_drive		;Must be specified, can't use default
	bmi syntax_error	;	error if none specified			[901127]
	and #1
;	sta drvnum		;Save drive number
	phx
	tax
	jsr setup_err		;						[910805] FAB
	txa
	plx
	jsr actledon		;Turn on activity led				[910814] FAB
	jsr clearnodrv		;Clear no drive available flag
	jsr cleardchange	;Clear disk changed flag
	lda drvnum
	asl a
	tax
	ldy filtbl+1		;get disk id
	cpy cmdsiz		;is this full new or short new?
	beq 20$			;	branch if short new
	lda cmdbuf,y		;prepare to format disk
	sta dskid,x		;store in proper drive
	lda cmdbuf+1,y		;(y=0)
	sta dskid+1,x
	jsr clrchn		;clear all channels
	jsr intdsk		;init disk
	ldy drvnum		;						[900415]
	lda dirtrk,y		;Get the current directory track		[900305]
;	cmp system_track,y	;						[910528]
	cmp #40			;Was CMP SYSTEM_TRACK,y	????			[910610]
	bne 15$			;no- (partition) skip Format and just clear the BAM

	jsr format		;format disk
15$	jsr clear_bam		;Clear bam
	bra 30$

20$	jsr intdsk		;init disk
	jsr initdr		;clear directory only
	lda dskver		;Get the disk's format type
	beq 30$			;No version is okay
	cmp fmttyp		;Is it our disk formating method?
	bne vnerr		;wrong version #

30$	lda jobnum
	tay
	asl a
	tax
	lda #dsknam		;set ptr to disk name
	sta buftab,x
	ldx filtbl
	lda #27
	jsr trname		;transfer cmd buf to bam
	ldy #0
	sty dirbuf		;reset lsb
	ldx drvnum		;						[900415]
	lda dirtrk,x
	sta (dirbuf),y		;directory track
	iny
	lda #sysdirsec
	sta dirst,x		;						[900415]
	sta (dirbuf),y		;link to first dir blk
	iny
	lda fmttyp		;Get our formating method
	sta dskver		;Make it the current one
	sta (dirbuf),y		;And this disk's format method
	iny
	lda #0			;null
	sta (dirbuf),y
	ldy #22			;skip name
	txa			;						[900415]
	asl a
	tax
	lda dskid,x		;Just in case it was never formatted
	bne 40$
	lda #'D'
40$	sta (dirbuf),y
	iny
	lda dskid+1,x
	bne 45$
	lda #'J'
45$	sta (dirbuf),y
	iny
	lda #160		;shifted space
	sta (dirbuf),y
	iny
	lda dosver		;Send out this dos's version number
	sta (dirbuf),y
	iny
	lda dskver		;Get the current disk's formatting
	bne 31$			;Method, if no number then okay

	lda fmttyp		;Else use our version instead
31$	sta (dirbuf),y
	iny
	lda #160		;shifted space
	sta (dirbuf),y
	iny
	sta (dirbuf),y
	iny
	lda #0			;Pad remainder of the directory
32$	sta (dirbuf),y		;Sector with zeros
	iny
	bne 32$
;	lda pattyp		;Get the previous file type		removed [910528]
;	and #typmsk
;	cmp #partyp		;Is this directory in a partition?
;	bne 33$			;	No then branch
;	ldy #32
;	ldx drvnum
;	lda dirtrk,x
;	sta (dirbuf),y
;	iny
;	lda entsec
;	sta (dirbuf),y
;	iny
;	lda entind
;	sta (dirbuf),y

	ldx drvnum
	ldy #34			;Added for the new PERIOD command		[910525] DJJ
	lda cbm_system_track,x
	sta (dirbuf),y
	dey
	lda cbm_maxtrk,x
	sta (dirbuf),y		;Place DIRECTORY track number of where the CBM filename is
	dey			;That this header belongs too.
	lda cbm_startrk,x
	sta (dirbuf),y

33$	lda #0			;Start with sector 0
;	ldx drvnum		;Get the current drive number			[900416]
	jsr settrk		;Set up Track & Sector for DIRTRK		[900415]
	jsr drtwrt		;Header
	ldx drvnum		;						[900415]
	lda dirst,x		;						[900415]
	sta sector
	jsr drtrd		;Read in the 1st directory sector
	lda #0
	sta dirbuf		;LSB RESET
	ldz #1			;Points to the SECTOR link
	ldy #33
34$	lda (dirbuf),z		;Copy the T and S links
	sta (dirbuf),y		;Which points to the 2nd
	dey			;Directory sector to bytes
	dez			;32, and 33 in the directory
	bpl 34$			;Sector
	smb1 dirbuf		;						[900723]

	ldx #7			;8 directory entries
89$	jsr save_file_status	;						[900723]
200$	dex
	bpl 89$
	rmb1 dirbuf		;						[900723]
	ldy #1
	lda #$ff
	sta (dirbuf),y
	dey
	tya
	sta (dirbuf),y
	jsr drtwrt
	jsr create_bam		;build new bam1
	jsr allocsyssec		;Allocate system sectors
	bra endcmd

	.page
;*  Set up track and sector links for the directory track
;

settrk	sta sector	;					[900415]
	lda dirtrk,x	;					[900415]
	sta track
initdsk_rts		;					[910528]
	rts

	.page
;********************************************************************
;*			    INIT DiSK				    *
;*								    *
;*   This routine checks to see if the user has changed the disk.   *
;*   If they have then we revert back to the ROOT directory.	    *
;*								    *
;*   DANGER:  If the user selects a partition, then attempts to	    *
;*   write to the disk and gets a write protect error, when  he	    *
;*   removes the disk to unprotect the disk this routine will	    *
;*   revert back to the root directory.	 Normally this would not    *
;*   be problem UNLESS he was attempting a SCRATCH or NEW command,  *
;*   in which case the wrong file(s) would be deleted or the	    *
;*   entire disk would be re-formatted.	 No solution for this.	    *
;*								    *
;*   NOTE:  This routine is called only by the NEW command.	    *
;********************************************************************

intdsk	jsr testdchange		;Poll drive for a disk change
	beq initdsk_rts		;	branch if it was changed
	jsr cleardchange	;Show it's no longer changed			[900710] FAB
	jsr setdef		;Reset system to the root Directory		[910610]
	lda #6			;Warn user
	bra cmderr	


;********************************************************************
;*    lsb pointers to the file type bytes for each filename	    *
;********************************************************************

filetype	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0

;********************************************************************
;*    lsb pointers to the temp storage for the file type byte	    *
;********************************************************************

tfiletype	.byte $16,$36,$56,$76,$96,$b6,$d6,$f6


;.end
	.page
	.subttl	 COMMANDS-1  v910525

;*****************************************************************************
;*			      RECORD <COMMAND>				     *
;*									     *
;*	This routine has two functions:					     *
;*		1) Set up the standard record pointer as in normal dos	     *
;*		2) Return the record length for an active relative file	     *
;*									     *
;*	To use the new function (2), use the following syntax:		     *
;*			PRINT#15, "P"+CHR$(SA+96);			     *
;*									     *
;*    Notes:	Use ';' at the end to suppress the carriage return	     *
;*		The +96 is optional, but allowed to keep with the	     *
;*		older syntax of the pointer command.			     *
;*									     *
;*****************************************************************************

record	ldz cmdsiz		;????						[901127] DJJ
	jsr cmdset		;Init tables, ptrs
	lda cmdbuf+1
	ora #96			;Now make 96 in SA + 96 optional
	sta sa
	jsr fndrch
	bcs no_channel
	cpz #3			;If z<3 then read the record length		[901211] FAB
	bcs 20$			;else branch to set the record pointer

	lda record_size,x	;Get the record size
	sta chndat,x		;Get ready to send it
	lda #1			;Only one character to send
	sta lstchr,x
	lda #eoiout
	sta chnrdy,x		;Send with an EOI please
	bra endsav		;Exit without clearing bam dirty flag

20$	lda #lrf+ovrflo
	jsr clrflg_1		;X contains LINDX  value from the JSR FNDRCH above
	jsr typfil_1		;Get file type
	bne file_type_mismatch	;If not REL, then wrong type

	lda filtyp,x
	and #1			;Extract the drive number
;	sta drvnum		;And make it the new drive
	phx
	tax
	jsr setup_err		;						[910805] FAB
	txa
	plx
	lda cmdbuf+2
	sta recl,x		;get record #
	lda cmdbuf+3
	sta rech,x
	ldx lindx		;clear chnrdy to rndrdy
	lda #rndrdy
	sta chnrdy,x
	lda cmdbuf+4		;get offset
	beq 30$
	dec a			;   -1
	beq 30$
	cmp record_size,x
	bcc 30$
	lda #recovf
	jsr sta_erword		;						[910313]
	lda #0
30$	sta recptr		;set offset
	jsr fndrel		;calc side_sector stuff
	jsr sspos		;set side_sector ptrs
	bvc 40$
	lda #lrf		;beyond the end
	jsr setflg		;set last rec flag
	bra rd05

40$	jsr positn		;position to record
	lda #lrf
	jsr tstflg		;Is this the last record?
	beq endcmd		;	yes
	bra rd05		;	no

	.page
;************************************************************************
;*   POSITN	position relative data block into active buffer		*
;*		& next block into inactive buffer.			*
;************************************************************************

positn	jsr posbuf		;position buffers
	lda relptr
	jsr setpnt		;set ptr from fndrel
	ldx lindx
	lda record_size,x
	sec			;calc the offset
	sbc recptr
	bcc break		;branch if big relative files are disabled
	clc
	adc relptr
	bcc 10$
	adc #1			;crossed into next buffer, add 2
	sec
10$	jsr nxout		;set next_record
	bra rd15

	.page
;************************************************************************
;*   POSBUF	Position proper data blocks into buffers		*
;************************************************************************

posbuf	lda dirbuf
	sta r3
	lda dirbuf+1
	sta r4
	jsr bhere		;is buffer in?
	beq 20$			;	yes! (rts)
	jsr scrub		;clean buffer
	jsr getlnk
	lda track
	beq 10$
	jsr dblbuf		;try inactive buffer
	jsr bhere		;is it this buffer?
	bne 10$			;	no!
	jsr getlnk
	lda track
	beq 20$			;(rts)
	jsr dblbuf
	jsr rdab		;read in next buffer
	bra dblbuf

10$	ldy #0			;get proper block
	lda (r3),y
	sta track
	iny
	lda (r3),y
	sta sector
	jsr dblbuf
	bra strdbl		;get next block, too.

20$	rts

	.page
; Check to see if buffer is in memory
;

bhere	jsr gethdr		;get the header
	ldy #0
	lda (r3),y
	cmp track
	bne 10$			;test sector, too.
	iny
	lda (r3),y
	cmp sector		;set .z
10$	rts


	.page
;  Format the drive indicated in DRVNUM
;

format	ldx #0			;Job zero
	stx hdrs+1
	ldy drvnum		;						[910528]
	lda system_track,y	;#40
	sta hdrs
	lda #$f0
	ora drvnum
	jsr setjob
	lda jobs		;Will only be an error if the calling routine flags
	cmp #2			;JOBS to return the error to the calling routine
	bcs 10$			;(i.e., the routine that called this one)
	rts

10$	ldx #0			; job # 0
	bra error

	.page
; MEMORY READ/WRITE/EXECUTE Commands
;
; Memory access commands.  '-' must be 2nd char


mem	lda cmdbuf+1
	cmp #'-'
	bne bad_command	;						[901127]
	lda cmdbuf+3	; set address in temp
	sta temp
	lda cmdbuf+4
	sta temp+1
	ldy #0
	lda cmdbuf+2
	cmp #'R'
	beq memrd	; read
	cmp #'W'
	beq memwrt	; write
	cmp #'E'	;						[910117]
	bne bad_command




;
; MEMORY EXECUTE
;
	jmp (temp)	;????

	.page
;
; MEMORY READ
;

memrd	lda temp	;Kludge to test for M-R used by
	cmp #$c6	;Compute's partition basic program
	bne 1$
	lda temp+1
	cmp #$e5
	bne 3$
	bra 2$
1$	cmp #$fe	;Check for someone sniffing the irq vector		[910801]
	bcc 3$
	lda temp+1
	cmp #$ff
	bne 3$
2$	lda #$ff
	   .byte $2c
3$	lda (temp),y
	sta data
	lda cmdsiz
	cmp #6
	bcc 10$
	lda cmdbuf+5
	dec a
	beq 10$
	clc
	adc temp
	inc temp
	sta lstchr+errchn
	lda temp
	sta err_buf_ptr
	lda temp+1
	sta err_buf_ptr+1
	bra ge20

10$	jsr fndrch
	bra ge15

;
; MEMORY WRITE
;

memwrt	lda temp	;Kludge to test for M-W used by				[910129] FAB
	cmp #119	;everybody to renumber serial disk drives
	bne 10$		;	no
	lda temp+1
	cmp #0
	bne 10$		;	no
	ldx drvnum
	lda cmdbuf+6	;	yes- install new unit# for current drive
	and #$1f	;		strip talk/listen garbage
	sta cbdosaddress,x
	rts

10$	lda cmdbuf+6,y
	sta (temp),y	; transfer from cmdbuf
	iny
	cpy cmdbuf+5	; # of bytes to write
	bcc 10$
	rts

	.page
period	lda cmdbuf+1		;						[910528]
	cmp #'.'
	bne syntax_error
	jsr close_all_channels	;Prevent splat files
	jsr rddir		;Write out bam if dirty and read in partition's header
	lda jobnum
	asl a
	tax
	ldy drvnum
	lda #32
	sta buftab,x
	lda (buftab,x)
	beq 10$			;exit if not a c65 disk (1581?)			[910731] DJJ
	sta startrk,y
;	sta dirtrk,y		;					move	[911030] DJJ
	inc buftab,x
	lda (buftab,x)
	sta maxtrk,y
	inc buftab,x
	lda (buftab,x)
	sta system_track,y
	sta dirtrk,y		;					to here	[911030] DJJ
10$	lda #0
	sta buftab,x
	bra change_partition

	.page
;************************************************************************
;*			PARTITION ROUTINES				*
;*									*
;* Create Partition:							*
;*	"/0:PAR_NAME,"+(START-TRK)+(START-SECTOR)+(LO-BLKS)+(HI-BLKS)	*
;*									*
;* Select Partition:							*
;*	"/0:PAR_NAME"  will select given filname as subdirectory	*
;*	"/0"	       will select root directory			*
;************************************************************************

part	jsr autoi	;Init drive
	lda cmdsiz	;If it's "/"+CHR$(13) or
	cmp #2		;"/" then select the 'ROOT'
	bcc 70$		;directory
	lda #1		;Nope then parse ONE file name
	sta filtbl
	jsr onedrv	;Select the drive number
			;^^^^^^^^^^^^^^^^^^^^^^^
			;can't set default except on the last accessed drive due to this!!

	jsr lookup	;Does it exist?
	lda filtrk	;If not branch to see if they
	beq 40$		;  wish to create one
	jsr testlimit	;If the file does not already
	bcc 50$		; exist then branch

	lda #flexst	; FILE EXISTS
	   .byte $2c
10$	lda #flntfd	; FILE NOT FOUND
	   .byte $2c
20$	lda #badsyn	; BAD SYNTAX
	bra cmderr

40$	jsr testlimit	;Check for proper number of parameters
	bcc 10$		; branch if it's not right
	ldx limit	;Do they have the ',c' after the parameters?
	lda cmdbuf+6,x
	cmp #'C'
	bne 20$		;	No then syntax error
	beq creatpart	;	Yes then create the file

50$	lda pattyp	;If the filename they requested
	and #typmsk	;Is not a partition file type
	cmp #partyp
	bne 10$		;Then branch for 'FILE NOT FOUND'
	jsr setup_partition
	bra 80$

70$	jsr setdef	; set default
80$	jsr clrchn	; clear all channels

change_partition	;Entered by PERIOD command				[910528]
	jsr initdr	; init directory
	ldy drvnum	;							[900416]
	lda startrk,y
	sta track	; exit with starting track in track position of OK...
	lda maxtrk,y	; & last track in sector position
	dec a
	sta sector
	lda #2		; ok partition
	ldy #0
	bra partition_end

	.page
setup_partition			;Added soly to reduce rom size			[900725]
	ldy drvnum
	lda startrk,y		;Add CBM labels for the new PERIOD cmd		[910525]
	sta cbm_startrk,y
	lda maxtrk,y
	sta cbm_maxtrk,y
	lda system_track,y
	sta cbm_system_track,y
	jsr setparts		;Set partition T & S and #blocks used by this partition

10$	jsr tschk		; check t&s
	jsr calcpar		; calc maxtrk, etc...  (see the comments at CALCPAR)
	bne 10$			;If we're not at the end of the partitioned area, loop
	bcc 20$			;Opps can't do this one sorry

	ldy #2
	lda (dirbuf),y		; get sector
	bne 20$			; must be zero
	dey
	lda track		; get maxtrk
	tax			; save
	sbc (dirbuf),y		; sub starting track
	cmp #2
	beq 20$			; illegal
	bcc 20$			; illegal
	lda (dirbuf),y
	ldy drvnum		;						[900415]
	stx maxtrk,y		; set maxtrk					   "
	sta dirtrk,y		; set system track				   "
	sta startrk,y		; set starting track				   "
	sta system_track,y	;						[910528]
	rts

20$	lda #illpar		; ILLEGAL PARTITION
	bra cmderr

	.page
;************************************************************************
;* SCAN a PARTition looking for any sectors that may already be in use	*
;* by another file.  If one is found, return a NO BLOCK error message.	*
;************************************************************************

scanpart
;	lda mdirty		;Save existing bam dirty flag		removed	[910610]
;	pha
;	lda ndbl		;Save number of blocks free
;	pha
;	lda ndbh
;	pha
	jsr settslim		;set t&s limits

10$	jsr tschk		;Check for bad track & Sector
	ldy drvnum		;						[910528]
	lda track		;Are they attempting to allocate
	cmp system_track,y	;the system track and sector?
	beq 20$			;	error if so
	jsr setbam		;Check for nodrive, and set BAMPNT to this track
	jsr bambit		;Move to the specific sector
	beq 20$			;	error if already used!
	jsr calcpar		;see the comments at CALCPAR
	bne 10$			;Loop if we're not at the end of the partitioned area

;	pla			;						[910610]
;	sta ndbh
;	pla
;	sta ndbl
;	pla
;	sta mdirty
	rts

20$
;	pla			;restore					[910610]
;	sta ndbh
;	pla
;	sta ndbl
;	pla
;	sta mdirty

; ************************************************************************
; * If the user attempts to create a partition and one of the sectors is *
; * already allocated,  a NO BLOCK error message is generated with the	*
; * the problem TRACK and SECTOR number in it.				*
; ************************************************************************

	lda #noblk
	bra cmder2		;error

	.page
testlimit
	ldx #1			;Move past the '/' character
	jsr fndlmt		;Search for '=' or ','
	lda cmdsiz		;See if it's 3 characters or less
	sec
	sbc limit
	cmp #4
	rts

settslim
	ldy limit		;Get the location of the comma
	iny			;After the filename then +1 to
				;Point us at the TRACK parameter
	lda cmdbuf,y
	sta track		;Save the starting track
	iny
	lda cmdbuf,y
	sta sector		;  "   "     "	   sector
	iny
	lda cmdbuf,y
	sta lo			;  "   "  number of blocks LOW
	iny
	lda cmdbuf,y
	sta hi			;  "   "  number of blocks HIGH
;	clc			;						[910624] FAB
	ora lo
;	adc hi
	bne tschk		;Go check for a bad T & S
;	beq badpart		;error if zero blocks requested

badpart lda #illpar
	bra cmderr		;illegal partition

	.page
creatpart
	jsr scanpart		;test range given
	lda #partyp		;open partition
	sta type
	lda #iwsa		;internal write channel
	sta sa
	jsr settslim		;set starting T&S and #blocks to be used for a bad track or sector
	jsr opnwch1		;open internal write channel
	jsr addfil		;addfil to directory
	jsr settslim		;set t&s limits

10$	jsr tschk		;check limits
	lda track
	jsr wused		;allocate it, then generate a DIR error
	jsr calcpar		;next (see the comments at CALCPAR)
	bne 10$			;If we're not at the end of the partitioned area, loop

	jsr settslim		;set t&s limits
	ldx lindx
	lda lo
	sta nbkl,x		;low blks
	lda hi
	sta nbkh,x		;high blks
	lda #0
	jsr putbyt		;write one byte, nil
	lda #iwsa
	sta sa
	jsr close_one_channel	;close channel
	bra endcmd

	.page
;***********************************************************
;*    This routine is used to move up one sector each time *
;* it is called, if we pass the max sectors per track then *
;* it moves up to the next track and restarts us back over *
;* at sector 0. This routine is used for several things &  *
;* is called to move up one sector at a time so that the   *
;* range of sectors used by the partition can be allocated *
;* by the parent's BAM, also called by the SCRATCH routine *
;* to deallocate the parent's BAM, also it used by the	   *
;* PARTition routine to ensure no ILLEGAL T & S errors	   *
;* occur and to ensure the user does not try to overwrite  *
;* the SYSTEM track and sector which is known as the ROOT  *
;* directory and BAM.					   *
;***********************************************************

calcpar
	lda lo			;If the number of sectors
	bne 10$			;Used by the partition ='s 0
	lda hi			;Then we're done so branch
	beq 20$			;else subtract one from the #
	dec hi			;of sectors used
10$	dec lo
	inc sector		;Move up one sector
	lda #40			;Are we at the last sector on
	cmp sector		;This track (numsec)
	bne 20$			;If not we're done so branch
	lda #0			;Yes then move up one track
	sta sector		;And start over with sector 0
	lda track		;IF we're on the directory track
	ldy drvnum		;						[900415]
	cmp dirtrk,y		;Then SYSTEM TRACK AND SECTOR
	beq 30$			;Error
	inc track

	sec			;Set a flag showing we're not done
	   .byte $89
20$	clc			;Set a flag showing we're done
	lda hi			;Show the summation for a BNE
	ora lo			;Branch
	rts

30$	lda #systs		;Illegal partition t and s
	bra cmder2

	.page
setparts
	ldy #1
	lda (dirbuf),y		;Get starting track number,
	sta track
	iny
	lda (dirbuf),y		;sector,
	sta sector
	ldy #$1c
	lda (dirbuf),y		;and number of sectors (blocks) used by this partition
	sta lo
	iny
	lda (dirbuf),y
	sta hi
	rts

allocpart
	jsr tschk		;Check track and sector
	jsr wused		;Allocate this sector error out if already used
	jsr calcpar		; (see the comments at CALCPAR)
	bne allocpart		;If we're not at the end of the partitioned area branch
	rts

	.page
; Rename file name in directory
;

rename
	smb2 bit_flag_1		;????allow use of either drive #		[911010] DJJ
	jsr alldrs		;set both drive #'s
	lda file_drive+1
;	and #1
;	sta file_drive+1
	cmp file_drive
	bne bad_filename	;actually using multiple drive's is a bad thing	[911028] FAB
;	beq 10$			;same drive #'s
;	ora #$80		;check both drives for name
;10$	sta file_drive
	jsr lookup		;look up both names
	jsr chkio		;check for existence
	ldx file_drive+1
;	and #1
;	sta drvnum
	jsr setup_err		;????						[910805] FAB
	lda entsec+1
	sta sector
	jsr rdab		;read directory sector
	lda entind+1
	clc			;set sector index
	adc #3			;...+3
	jsr setpnt
	jsr getact
	tay
	ldx filtbl
	lda #16
	jsr trname		;transfer name
	jsr wrtout		;write sector out
	bra endcmd

	.page
; Check input drive (source drive) to make sure the file exists

chkin
	lda pattyp+1		;1st file bears type
	and #typmsk
	sta type
	ldx f2cnt
10$	dex
	cpx f1cnt
	bcc chkinrts
	lda filtrk,x
	bne 10$
	lda #flntfd		;input file not found
	bra cmderr



; Check output drive (destination drive) to make sure the file does not exist

chkio
	jsr chkin
10$	lda filtrk,x
	beq 20$
	lda #flexst
	bra cmderr
20$	dex
	bpl 10$
chkinrts
	rts

	.page
; BAM_COPY	Accessed via command channel using a SHIFTED 'B'
;
;	CALL MAPOUT to write out the bam if needed on the source drive
;		    (this will also verify the BLOCKS FREE)
;
;	FOR TRACK = 1 TO 80
;	    FOR SECTOR = 0 TO 39
;	????	SETBAM			  set up BAMPNT to bam image
;	????	BAMBIT			  see if SECTOR is in use
;	????	 IF SECTOR_USED
;		    THEN DOREAD		  read in the track and sector
;			 DOWRITE	  write out the track and sector
;	     NEXT SECTOR
;	NEXT TRACK
;
; BACKUP from one drive to another (both drives must be F011-type drives, obviously).


backup	smb2 bit_flag_1		;Allow drive number 1 to be used
	jsr prseq		;Extract both drive numbers
;	rmb2 bit_flag_1		;Disable drive number 1 flag			[910207] FAB

	lda drvnum		;Drive to which command was issued
	sta tmp			;	remember it
	bit file_drive+1	;Source
	  bmi syntax_error	;	no default allowed
	lda file_drive		;Destination
	  bmi syntax_error	;	no default allowed
	cmp file_drive+1
	  beq syntax_error	;	source must differ from destination

	tax			;Set up DS$ for destination drive
	jsr setup_err
	jsr MotorON		;Select destination drive			[910502] FAB

	smb0 bit_flag_2		;Want all errors returned to me			[911008] FAB
	jsr autoi_1		;Does destination drive need to be formatted?
	beq 1$			;	no
	jsr format		;	yes, format disk (*NO* verify????)
	  bcs 99$		;       something is wrong

1$	jsr CheckProt		;Disk must not be write protected		[910425] FAB
	lda #$ff		;Seek track zero on both drives
	sta curtrk
	sta curtrk+1
	inc a
	sta cdrive
	lda #bit7+bit6		;						[910801]
	trb dchange		;Clear disk change flags
	jsr InitCtlr		;Init drive 0
	inc cdrive
	jsr InitCtlr		;Init drive 1
	smb0 bit_flag_2		;Want all errors returned to me			[911008] FAB
;	ldx tmp
	ldx file_drive+1	;	Select source drive			[910424] FAB
	jsr setup_err		;		error buffer

	.page
; FOR track = 1 to 80 .........................

	lda #0			;Start at track 0
5$	sta track1


; FOR side = 0 TO 1 ...........................

	ldx #0			;Start on side 0
10$	stx sider1
	lda sidemask,x		;	flip it for 1581 compatibility
	ora #motor		;	add motor
	sta sd


; FOR sector = 10 TO 1 ........................

	lda #10			;Start on sector 10				[910129] F011C
20$	sta sector1

	ldx file_drive+1	;	Select source drive			[910424] FAB
	jsr setup_err		;		error buffer
	lda drvnum		;		drive
	ora sd			;		side
	jsr ControlReg
	bit dchange		;		Abort if disk ejected
	  bmi 50$
	lda #rds		;	READ a sector from SOURCE drive
	sta command
	jsr CheckEr		;		busywait, then check FDC read status
	  bcs 60$

	ldx file_drive		;	Select destination drive		[910424] FAB
	jsr setup_err		;		error buffer
	lda drvnum		;		drive
	ora sd			;		side
	jsr ControlReg
	bit dchange		;		Abort if disk ejected
	  bvs 50$
	lda #wts		;	WRITE a sector to DESTINATION drive
;	ldx track1
;	cpx #precomptrk		;		use precompensation?
;	bcc 25$			;			no
;	ora #precomp		;			yes
25$	sta command
	jsr CheckEr		;		busywait, then check for error ???? verify ????
	  bcs 60$		;			abort if error

	.page
	lda sector1		;NEXT sector .............................
	dec a
	bne 20$

	ldx sider1		;NEXT side ...............................
	inx
	cpx #1+1
	bcc 10$

	lda track1		;NEXT track ..............................
	inc a
	cmp #80			;	done?
	bcs 40$			;		yes

	pha
	lda #stout
	jsr CommandReg		;Step out destination drive
	ldx file_drive+1	;	Select source drive			[910424] FAB
	jsr setup_err		;		error buffer
	lda drvnum		;		drive
	ora #motor	
	jsr ControlReg		;Step out source drive
	lda #stout
	sta command
	jsr SettleHead		;Delay 24ms
	pla
	bra 5$			;Continue until done

; Done

40$	rmb0 bit_flag_2		;Don't want errors returned to me any more	[901127]
	ldx tmp			;Restore command drive
;	stx drvnum		;						[910801] FAB
	jsr setup_err
	jsr Background		;turn off motors & leds as necessary		[910214] FAB
;	jsr initdr		;why???						[910207] FAB
	lda #bit7+bit6		;						[910801]
	tsb dchange		;fake disk change on both drives to force a future init
;	lda #$ff
	sta curtrk		;						[911008] FAB
	sta curtrk+1
	sta last_drive		;Reset last t/s/s flag				[910129] FAB
	bra endcmd		;Exit

	.page
; BACKUP error handlers
;
;   Disk was ejected, caught by us

50$	lda #15			;error # for drive not ready


;   FDC error on either source or destination drive, caught by CheckER

60$	sta jobs		;Force error on JOB 0
99$	lda #bit7+bit6		;						[910801]
	tsb dchange		;Fake disk change on both drives to force a future init
	trb nodrv
;	lda #$ff		;Seek track zero on both drives
	sta curtrk
	sta curtrk+1
	sta last_drive		;Reset last t/s/s flag				[910129] FAB

	rmb0 bit_flag_2		;No longer want errors returned to me		[901127]
	lda track1		;Grab current track & sector for DS$
	sta track
	lda sector1
	sta sector
;	ldx drvnum		;Drive error occurred on
;	stx cdrive
;	jsr setup_err		;Set up error buffer for this drive		[910801] FAB
	lda jobs		;Get back the error #
	bra error_1		;Go report error & exit with drvnum=drive causing error


;.end
	.page
	.subttl	 ROUTINES-1  v901029

;****************************************************************
;*	SCRUB		write out buffer if dirty		*
;****************************************************************

scrub	jsr gaflgs		;Is this buffer dirty?
	bvs wrtout		;	Yes write it out
	rts


;****************************************************************
;*	SETLNK		put TRACK, SECTOR into buffer		*
;****************************************************************

setlnk	jsr set00		;Move point to T and S link
	lda track		;Place next T & S in the buffer
	sta (dirbuf),y
	iny
	lda sector
	sta (dirbuf),y
	bra sdirty


;****************************************************************
;*	GETLNK		get link from buffer into TRACK, SECTOR *
;****************************************************************

getlnk	jsr set00		;Point DIRBUF to T and S links
getlink	lda (dirbuf),y
	sta track
	iny
	lda (dirbuf),y
	sta sector
getlnk1	rts


;****************************************************************
;*	NULLNK		set track  link = 0	and		*
;*			    sector link = last non-zero char	*
;****************************************************************

nullnk	jsr set00		;Point DIRBUF to track and sector links
	lda #0
	sta (dirbuf),y		;Make track link = 0
	iny
	ldx lindx		;Get the active channel number
	lda next_record,x	;Get the number of bytes used in this sector
	dec a			;and save it as the sector length-1
	sta (dirbuf),y
	rts


;****************************************************************
;*	SET00		set DIRBUF pointer to the active buffer *
;****************************************************************

set00	jsr getact		;Get the active buffer number
set00_1 asl a			;*2 to point to MSB of the buffer's address
	tax
	lda buftab+1,x		;Leave with DIRBUF pointing to
	sta dirbuf+1		;The track number in the T & S link
	lda #0
	sta dirbuf
	tay			;						[900421]
	rts

;****************************************************************
;*	GETHDR		read TRACK, SECTOR from header		*
;****************************************************************

curblk	jsr fndrch		;Find the active read channel

gethdr	jsr getact		;Get the active buffer number
	sta jobnum		;Make it the active job
	asl a			;*2 to point to track and sector
	tay
	lda hdrs,y
	sta track		;Save track and sector
	lda hdrs+1,y
	sta sector
	rts

	.page
wrtab	lda #write		;WRiTe out A and B sectors (REL data sectors)
	   .byte $2c

rdab	lda #read		;ReaD  in  A and B sectors (REL data sectors)
	sta cmd
	bra sj10

wrtout	lda #write		;Write out active buffer
;	   .byte $2c
;
;rdin	lda #read		;					unused	[910610]
	sta cmd
	bra sj20

wrtss	lda #write		;write SideSector
	   .byte $2c

rdss	lda #read		;read SideSector
	sta cmd
	ldx lindx
	lda side_sector,x	;	get the side sector number
	tax
	bpl sj30

sj10	jsr sethdr		;set T&S for headers of the active buffer
	jsr getact		;get the active buffer number
	tax			; (could replace 'getact' with .X=.Y/2)
	lda drvnum
	sta lstjob,x		;show the last drive used for this job (buffer)

sj20	jsr cdirty		;clear dirty flag since we R/W this buffer
	jsr getact		;get active buffer number again
	tax

sj30	bra set_last_job	;pass command to FDC

	.page
;****************************************************************
;*	RDLNK							*
;****************************************************************

rdlnk	lda #0			;Set DIRBUF to point to the T and S links
	jsr setpnt
	jsr getbyt		;Get the T and S links and place in TRACK/SECTOR
	sta track
	jsr getbyt
	sta sector		;EXIT with DIRBUF = 1st byte PAST T and S link
	rts



;****************************************************************
;*	NeXT Track & Sector					*
;* returns next available T & S given current T & S		*
;* allocation is from dirtrk towards 1 & maxtrk, by full tracks *
;****************************************************************

nxtts	jsr gethdr
	lda #3			;Two boundries, 1-40 and 41-80
	sta temp
	lda datasecinc		;Get interleave value for data sector		[910313]
	bra nxtds_2

	.page
;****************************************************************
;*	NeXT Directory Sector					*
;****************************************************************

nxtds	lda dirsecinc		;Get interleave for directory sectors		[910313]

nxtds_2	sta secinc		;						[910313]
	lda track
	sta tmp			;Save which track we're starting at

nxtds_1	jsr setbam		;Set BMPNT to correct bam image
	lda (bmpnt),y		;Is there a free sector on this track?
	bne fndnxt		;	Yes then branch
	ldy drvnum		;						[900415]
	lda track		;Are we on the directory track?
	cmp dirtrk,y
	bne nxtts1		;	No then branch
	lda tmp
	cmp dirtrk,y		;Did we start on the system track?		[900731]
	bne nxterr		;	No then disk full

	lda #$78		;Generate a DIRECTORY FULL error		[900731]
	   .byte $2c
nxterr	lda #dskful		;Generate a DISK FULL error
	bra cmderr

nxtts1	bcc 10$			;Branch if below the directory track
	inc track		;Move up one track number
	lda track		;Out of tracks?
	cmp maxtrk,y
	bne nxtds_1		;	branch if not
	lda dirtrk,y		;Restart below the directory and scan downwards	[900415]
	dec a
	sta track
	cmp startrk,y
	bcc 20$
	lda #0
	sta sector
	dec temp
	bne nxtds_1

10$	lda track		;At the bottom track value?
	cmp startrk,y
	bcc 20$			;	Yes then branch
	dec track		;	No then move down one track
	bne nxtds_1		;	always (unless some joker makes STARTRK=0)

20$	ldx dirtrk,y		;Start with one track past the dir track	[900415]
	inx
	stx track
	lda #0			;Start with sector zero
	sta sector
	dec temp		;Done yet?
	bne nxtds_1		;	No
	bra nxterr		;	Yes- then DISK FULL

	.page
;  Find the next optimum sector
;	next sector = current sector+secinc

fndnxt
;	lda secinc		;						[910204] FAB
;	cmp dirsecinc
;	beq 1$			;If not a directory track, we want the next sector
;	lda sector		;to be in the same physical 512-byte sector if
;	lsr a			;possible, (i.e., if sector is even, just add one)
;	bcs 1$			;Else, add the normal skew.
;	inc sector
;	bra 2$

1$	clc
	lda sector		;Get the current sector number
	adc secinc		;Add in the SECtor INCrement
	sta sector		;Save it back
2$	lda #40			;Get the number of sectors per track
	sta cmd
	cmp sector		;Above the max sector number?
	bcs 10$			;	If not branch
	sec
	lda sector		;Take the current + interleave
	sbc #40			;Subtract it from the
	sta sector		;max # sectors on this track (numsec)
	beq 10$			;	branch if at sector 0
	dec sector		;	else - 1

10$	jsr getsec		;Is this sector free in the bam?
	bne wused		;	yes, mark it as being used
	lda #0			;Start at sector 0
	sta sector		;And continue searching from the start to the sector
				;you first requested when you entered above.

	jsr getsec		;Is it free?
	bne wused		;	yes, mark it used
	beq direrror		;	no, error out

	.page
;  Returns optimum initial track, sector
;

intts	lda r0
	pha			;save temp var
	lda #1
	sta r0
its1	ldy drvnum		;					[900415]
	lda dirtrk,y		;Get the Director TRacK			[900415]
	sec
	sbc r0			;-1
	sta track		;Save the
	php
	cmp startrk,y
	bcs 10$
	plp
	bra 20$

10$	plp
	bcc 20$
	beq 20$
	jsr setbam		;Set BMPNT to correct bam image
	lda (bmpnt),y
	bne fndsec
20$	ldy drvnum		;					[900415]
	lda dirtrk,y		;					[900415]
	clc
	adc r0
	sta track
	inc r0
	cmp maxtrk,y
	bcs badt_s
	jsr setbam		;Set BMPNT to correct bam image
	lda (bmpnt),y
	beq its1

fndsec	pla
	sta r0			;restore r0
	lda #0
	sta sector
	jsr getsec		;Is there a used sector really?
	bne wused		;	Yes then branch

direrror
	lda #direrr
	   .byte $2c

badt_s	lda #systs		;SYSem Track and Sector error
	bra cmder2

	.page
;  This routines points BAMPNT at the BAM IMAGE for the T & S number held
;   in TRACK, and SECTOR. It then calls AVCK to make sure the number of
;   sectors shown free in the sector count equals the sum of all the bits
;   shown free in the sector image, and if it not then generate a BAM
;   CORRUPTED ERROR.

; Z = 1 then used

getsec	jsr setbam		;Set BMPNT to BAM image for this track
	jsr avck		;Check bits & count

;  At this point you KNOW that the bam image is correct for this track. Now you
;  have to scan the BAM IMAGE for each sector one at a time to find out if
;  there is a free sector available. By calling BAMBIT which pointes you to
;  correct bit in the IMAGE for the sector in SECTOR. BAMBIT also test the
;  bit to see if the sector is free for use, and if it is we exit with the
;  Z flag set to reflect this.

10$	lda sector		;Get the current sector
	cmp #40			;Out of range?
	bcs 20$			;	Yes.  Exit with Z = 1 because all of the
				;	sectors from the one requested to the max
				;	number of sectors allowed are filled up.

	tax			;						[910402]
	jsr bambit_1		;Set up the point in the bam
	bne 30$			;Exit showing this sector is free

;  NOTE:  If the requested sector in TRACK & SECTOR is not free this routine just moves
;  up one sector without using the sector interleave (skew) during this proccess.  You
;  should see an increase in speed if this was recoded.

	inc sector		;Move up to the next sector
	bpl 10$			;bne 10$	; Always

20$	lda #0			;Show that all the sectors are used that are equal to
				;or greater than the sector you requested.  If carry is
				;set at this point you have run out of sectors.
30$	rts

	.page
;********************************************************
;*	B0TOB0						*
;*  Transfer bytes from one buffer to another.		*
;*  reg in:						*
;*		.a = # bytes				*
;*		.y = source buf #			*
;*		.x = destin buf #			*
;********************************************************

b0tob0	pha			;[left as a subroutine (it's used only one place)
	lda #0			; so that a user could use it.]
	sta temp
	sta temp+2
	lda bufind,y
	sta temp+1
	lda bufind,x
	sta temp+3
	ply
	dey

10$	lda (temp),y
	sta (temp+2),y
	dey
	bpl 10$
	rts

	.page
;*********************************
;* clrbuf			 *
;*    clear buffer given	 *
;*     reg in			 *
;*	.a = buffer #		 *
;*	   out			 *
;*	.y, .a = 0		 *
;*********************************

clrbuf	tay
	lda bufind,y
	sta temp+1
	lda #0
	sta temp
	tay
10$	sta (temp),y
	iny
	bne 10$
	rts


;*********************************
;* side sector set		 *
;*    set side_sector pntr to 0	 *
;*    reg  out			 *
;*     .a = side_sector number	 *
;*********************************

ssset	lda #0
	jsr ssdir
	ldy #2			;move past links
	lda (dirbuf),y		;get the side sector number
	rts


;*********************************
;* ssdir			 *
;*    set dirbuf with current	 *
;*    side_sector pointer.	 *
;*  reg	 in			 *
;*   .a = low byte		 *
;*********************************

ssdir	sta dirbuf
	ldx lindx
	lda side_sector,x
	tax
	lda bufind,x
	sta dirbuf+1
	rts

	.page
;*********************************
;* setssp			 *
;*  set dirbuf & buftab		 *
;*  with current side_sector ptr *
;*   regs  in			 *
;*    .a = low byte		 *
;*********************************

setssp	pha
	jsr ssdir
	pha
	txa
	asl a
	tax
	pla
	sta buftab+1,x
	pla
	sta buftab,x
	rts


;*****************************************
;* sspos				 *
;*  position side_sector & buftab to	 *
;*  ssnum ssind.			 *
;*  flags:				 *
;*	     .v = 0, ok			 *
;*	     .v = 1, out of range	 *
;*****************************************

sspos	jsr sstest
	bmi 10$			;	out of range
	bvc 20$			;	er0, ok, in range
	ldx lindx		;	er1, possibly in range
	lda side_sector,x
	jsr ibrd		;read side_sector in
	jsr sstest		;test again
	bpl 20$

10$	jsr ssend		;not in range,set end
	bit er1
	rts

20$	lda ssind		;ok, set ptr w/index
	jsr setssp
	bit er0
	rts

	.page
;*********************************
;* ibrd	  indirect block read	 *
;*				 *
;* input: .a = buf # for r/w	 *
;*	  .x = lindx		 *
;* (dirbuf),y ptr t&s to be r/w. *
;*********************************

ibrd	sta jobnum		;Save job number
	lda filtyp,x		;Get the drive number
	and #1			;Make it active
	sta drvnum
	ora #read		;Include READ job queue command
	sta cmd			;Save the command
	lda (dirbuf),y		;Set up the track and sector requested
	sta track
	iny
	lda (dirbuf),y
	sta sector
	lda jobnum		;Set up the HEADER for this job number
	jsr seth
	ldx jobnum		;Go do this job for this job number
	bra doit2

gsspnt	ldx lindx
	lda side_sector,x
	bra gp1

scal1	lda #nssp
	jsr addt12		;add (#ss needed)*120

;
; calculate # of side sectors needed (small relative files only)
;

sscalc	dex
	bpl scal1
	lda t3			;add (# side_sector indices needed)
	lsr a
	jsr addt12
	lda t4			;add (# side_sector blocks needed)

addt12	clc			;add .a to t1,t2
	adc t1
	sta t1
	bcc addrts
	inc t2
addrts	rts

	.page
; Calculate # of side sectors needed for super relative files
;

ssscal	jsr zerres
	jsr zeracc
	ldy r3

10$	dey
	bmi 20$
	ldx #>726
	lda #<726
	jsr addlit
	bra 10$

20$	ldy t4
30$	dey
	bmi 40$
	ldx #0
	lda #nssp+1
	jsr addlit
	bra 30$

40$	lda t3
	lsr a
	ldx #0
;	beq addlit		;	fall into addlit			[901114] FAB

addlit	stx accum+2
	sta accum+1
	bra addres


zeracc	ldx #0
	stx accum+1
	stx accum+2
	stx accum+3
	rts

	.page
;****************************************************************
;* SSEND   Position SIDE_SECTOR & BUFTAB to end of last record	*
;****************************************************************

ssend	bbr5 bit_flag_2,ssend1	;Branch if not a big relative file		[901127]
	jsr rdlg		;else read last group

ssend1	jsr ssset
	sta ssnum
	lda #4
	sta dirbuf
	ldy #ssioff-6
	bra 20$

10$	dey
	dey
	bmi break		;branch if big relative files disabled

20$	lda (dirbuf),y		;look for last side_sector #
	beq 10$			;t = 0, not yet
	tya
	lsr a
	cmp ssnum		;check side_sector #
	beq 30$			;this is last side_sector
	sta ssnum
	ldx lindx
	lda side_sector,x
	jsr ibrd		;read last side_sector

30$	ldy #0			;set ssind
	sty dirbuf
	lda (dirbuf),y
	bne break		;branch if this is a big relative file
	iny
	lda (dirbuf),y
	tay			;back up to track
	dey
	sty ssind
	tya
	bra setssp


; You will only see this if the user attempts to read/write to a super relative
; file, and the super relative file capabilities of the dos have been turned off!!!

break	lda #$53		;Big relative files disabled			[900731]
	bra cmder2

	.page
;************************************************************************
;* NEWSS  generate new side sector & fix old side sector to reflect it	*
;************************************************************************

newss	jsr nxtts		;Get t&s based on hdr
;	 ldx lindx		;						[901114] FAB
;	 lda buf1,x		;Toggle second active buffer
;	 eor #$80
;	 sta buf1,x
;	 lda buf0,x		;Toggle first active buffer
;	 eor #$80
;	 sta buf0,x		;Is the primary buffer is in use?
;	 bpl 10$		;	yes
;	 lda buf1,x		;	else return the status of the secondary buffer
;
;10$	 and #$bf		;Drop off buffer dirty flag
;	 tax			;Above buffers are now active
	jsr dblbuf		;_fab						[910108] FAB
	jsr scrub
	jsr getact
	pha
	jsr clrbuf
	lda side_sector,x	;set regs for transfer
	tay
	pla
	tax
	bbr5 bit_flag_2,newss1	;Branch if not a big relative file	[901127]
	bra newss3		;it is big

	.page
newss1	lda #ssioff		;# of chars
	jsr b0tob0		;transfer at buf(0)
	lda #0
	jsr ssdir
	ldy #2
	lda (dirbuf),y		;get side_sector #
	pha
	lda #0
	jsr setpnt
	pla
	clc
	adc #1
	sta (dirbuf),y		;put side_sector # in new side_sector
	asl a
	adc #4
	sta r3			;save position
	tay
	sec
	sbc #2
	sta r4

newss2	lda track
	sta r1			;save for side_sector update
	sta (dirbuf),y		;put track in side_sector
	iny
	lda sector
	sta r2			;save for side_sector update
	sta (dirbuf),y		;put sector in side_sector
	ldy #0
	tya
	sta (dirbuf),y		;null link
	iny
	lda #ssioff+1		;ptr to last byte
	sta (dirbuf),y
	lda #ssioff
	jsr setpnt
	jsr wrtab
	ldx lindx
	lda side_sector,x	;get side_sector buffer #
	pha
	jsr gaflgs
	ldx lindx
	sta side_sector,x	;swap act-buf & side_sector
	pla
	ldx lbused
	sta buf0,x
	lda #0
	jsr setpnt		;set link to new side_sector
	ldy #0
	lda track
	sta (dirbuf),y
	iny
	lda sector
	sta (dirbuf),y

	bbr5 bit_flag_2,ns50	;Branch if not a big relative file		[901127]
	lda r0
	cmp #255
	bne ns50
	lda sector
	pha
	lda track
	pha
	jsr wrtout		; write old side_sector
;	 ldx lindx		;						[901114] FAB
;	 lda buf1,x		;Toggle second active buffer
;	 eor #$80
;	 sta buf1,x
;	 lda buf0,x		;Toggle first active buffer
;	 eor #$80
;	 sta buf0,x		;Is the primary buffer is in use?
;	 bpl 40$		;	yes
;	 lda buf1,x		;Else return the status of the secondary buffer
;40$	and #$bf		;Drop off buffer dirty flag
;	 tax			;Above buffers are now active
	jsr dblbuf		;_fab						[910108] FAB
	jsr rdsssa		;read super side sector
	inc r5			;next group #
	lda r5
	asl a			;* 2
	clc
	adc #3			;index into sss
	jsr setssp		;point to it
	pla
	jsr putss		;set the track
	pla
	jsr putss		;set the sector
	jsr wrtsss		;write the sss
	lda r5
	pha
	bra rdss1d		;read the new side_sector back in

ns40	jsr getact
	jsr ibrd		;read next side_sector
	lda #0
	jsr setpnt		;ptr = 0

ns50	dec r4
	dec r4
	ldy r3			;get new side_sector link ptr
	lda r1
	sta (dirbuf),y		;put track in
	iny
	lda r2
	sta (dirbuf),y		;put sector in
	jsr wrtout		;write it back...
	ldy r4
	cpy #3
	bcs ns40		;more side_sector to update!
	bra dblbuf		;						[910108] FAB

;dblbuf_fab			;????same as dblbuf but no sta active_buffer	[901114] FAB
;	ldx lindx
;	lda buf1,x		;Toggle second active buffer
;	eor #$80
;	sta buf1,x
;	lda buf0,x		;Toggle first active buffer
;	eor #$80
;	sta buf0,x		;Is the primary buffer is in use?
;	bpl 70$			;	yes
;	lda buf1,x		;Else return the status of the secondary buffer
;
;70$	and #$bf		;Drop off buffer dirty flag
;	tax			;Above buffers are now active
;	rts

	.page
newss3	lda r0
	cmp #nssl-1
	bcc newss1

newss4	lda #255
	sta r0
	lda #0
	jsr setpnt
	ldy #2
	sta (dirbuf),y		;side sector 0
	ldx lindx
	lda record_size,x
	iny
	sta (dirbuf),y		;record size
	iny
	bne newss2
	beq newss1

	.page
;*********************************
;* sstest			 *
;*     test ssnum & ssind for	 *
;*     residence & range.	 *
;* vars:			 *
;*     ssnum,ssind,dirbuf	 *
;*				 *
;* flags:			 *
;*     .n rng  .v res  er	 *
;*	  0  ok	  0 yes	 er0	 *
;*	  0 maybe 1 no	 er1	 *
;*	  1 no	  0 yes	 er2	 *
;*	  1 no	  1 no	 er3	 *
;*********************************

sstest
	bbr5 bit_flag_2,10$	;Branch if not big relative file		[901127]
	lda grpnum
	jsr rdss1
	beq 10$
	bit er3
	rts

10$	jsr ssset		;set pointer & side_sector #
	cmp ssnum
	bne 30$			;not this side_sector
	ldy ssind
	lda (dirbuf),y
	beq 20$
	bit er0			;ok, resident
	rts

20$	bit er2			;out of range, res
	rts

30$	lda ssnum
	cmp #nssl
	bcs 40$
	asl a
	tay
	lda #4
	sta dirbuf
	lda (dirbuf),y
	bne 50$

40$	bit er3			;way out of range
	rts

50$	bit er1			;not res, range???
	rts

	.page
; LIST DIRECTORY
; Start the directory loading function.	 Get the buffer and get it started.
;

stdir	lda #0			;Set SA for LOAD
	sta sa
	lda #1			;Get one buffer so we have a place to put it
	jsr getrch
	lda #0			;Start at line links
	jsr setpnt
	ldx lindx
	lda #0			;Read all of the buffer
	sta lstchr,x
	lda buf0,x		;Is the primary buffer active?
	bpl 10$			;	Yes
	lda buf1,x		;No then return the state of the secondary buffer
10$	and #$bf		;Drop off buffer dirty flag
	tax
	lda drvnum		;Save drive number
	sta lstjob,x
	lda #'F'		;For FRED BOWEN
	jsr putbyt
	lda #'R'
	jsr putbyt
	lda #'E'
	jsr putbyt
	lda #'D'
	jsr putbyt
	lda nbtemp		;Place the drive number in the
	jsr putbyt		;Buffer as the LINE NUMBER
	lda #0			;Set the MSB of the drive number
	jsr putbyt		;To zero
	jsr movbuf		;Place this disk's name and ID into the buffer
	ldx lindx		;Get channel number
	lda buf0,x		;Is the primary buffer active?
	bpl 20$			;	Yes
	lda buf1,x		;No then return the state of the secondary buffer
20$	and #$bf		;Drop off buffer dirty flag
	asl a
	tax
	dec buftab,x
	dec buftab,x
	lda #0			;end of this line
	jsr putbyt
dir1	lda #68
	jsr putbyt
	lda #74
	jsr putbyt
	jsr getnam		;Get blocks used and filename
	bcc dir3		;If this is the last filename in the directory branch
	lda nbtemp		;Get the number of blocks used
	jsr putbyt		;By this file and place it into
	lda nbtemp+1		;The buffer
	jsr putbyt
	jsr movbuf		;Move the file name into the Buffer
	lda #0			;Place the end of this line
	jsr putbyt		;Flag into the buffer
	bne dir1		;If the buffers NOT full branch

dir10	ldx lindx		;Get channel number
	lda buf0,x		;Is the primary buffer active?
	bpl dir11		;Yes then branch
	lda buf1,x		;No then return the state of the secondary buffer
dir11	and #$bf		;Drop off buffer dirty flag
	asl a
	tax
	lda #0
	sta buftab,x		;Go from start
	ldy lindx		;Get active channel number
	lda #rdytlk		;Get ready to talk flag
	sta chnrdy,y		;Say we're ready to talk NOW
	lda data
	rts

dir3	lda nbtemp		;Get the blocks free on the
	jsr putbyt
	lda nbtemp+1		;Disk and place it into the buffer
	jsr putbyt
	jsr movbuf
	ldx lindx		;Get channel number
	lda buf0,x		;Is the primary buffer active?
	bpl 80$			;	Yes
	lda buf1,x		;No then return the state of the secondary buffer

80$	and #$bf		;Drop off buffer dirty flag
	asl a
	tax
	dec buftab,x
	dec buftab,x
	lda #0
	jsr putbyt		;Put end of line flag in buffer
	jsr putbyt		;Followed by the end of this program flag
	jsr putbyt		; (in case it was loaded into BASIC's memory)
	ldx lindx		;Get channel number
	lda buf0,x		;Is the primary buffer active?
	bpl 90$			;	Yes
	lda buf1,x		;No then return the state of the secondary buffer

90$	and #$bf		;Drop off buffer dirty flag
	asl a			;*2
	tay
	lda buftab,y		;Get the MSB of this buffers address
	ldx lindx		;Get the active channel number
	sta lstchr,x		;Force DOS to send all of the buffer
	dec lstchr,x		;To the controller (computer)
	bra dir10		;Always

	.page
;  Transfer file name to listing buffer
;

movbuf	ldy #0
10$	lda nambuf,y
	jsr putbyt
	iny
	cpy #27
	bne 10$
	rts

;
;  Get char for directory loading
;

getdir	jsr getbyt		;Get a byte from the buffer
	beq 10$			;	last byte in the buffer
	rts

10$	sta data		;Save the byte we just got
	ldy lindx		;get index
	lda lstchr,y		;Are we to read to the end?
	beq 20$			;	Yes
	lda #eoiout		;	No, send with EOI
	sta chnrdy,y
	lda data		;Retrive last byte read
	rts

20$	pha			;Save byte just received
	jsr dir1		;Go get another entry
	pla			;Get byte back
	rts


;.end
	.page
	.subttl	 JOBS: FLOPPY DISK CONTROLLER ROUTINES	v910610

;*************************************************************
;* JOBS	 C65 Controller Code	02/02/90 F.Bowen
;*				02/10/90 D.Jarvis
;*************************************************************
;
;	LSTJOB	= drive #
;	CMD	= job command

set_last_job			;.setljb
	lda lstjob,x		;Get last job number
	and #1			;Keep drive number
	ora cmd			;Save it as the current command


	; Set job up and check T & S
	;   .a = command for jobs
	;   .x = job number

setjob
	jsr busywait		;wait for previous job				[900409]
	pha			;current command
	stx jobnum		;current job number
	txa
	asl a
	tax
	lda hdrs+1,x		;check sector
	cmp #40			;   (numsec)
	bcs tserr		;   sector too large (>39)
	lda hdrs,x		;check track
	beq tserr		;   track too small (<1)
	ldy drvnum		;Get the drive number				[900416]
	cmp maxtrk,y		;Are we crossing partition boundries or		[900416]
	bcs tserr		;   track too large (>80)

20$	pla			;check disk format
	pha
	and #$f0
	cmp #write
	bne 40$			;    not a write cmd, so skip check
	pla
	pha
	lsr a
	lda bambuf0d0+2 	;    assume drive 0
	bcc 30$			;	yes					[910610]
	lda bambuf0d1+2 	;	no-  drive 1
30$	beq 40$			;	No number is okay too
	cmp fmttyp		;    same as our formatting method?
	beq 40$
	pla			;	no- fix stack
	bra vnerr		;	report version number error

40$	ldx jobnum		;passes checks, so setup command
	pla
	sta cmd
	sta jobs,x
	sta lstjob,x
	and #device
	sta cdrive		;save controller drive select

	lda cmd			;						[910429]
	and #$f0		;strip drive & dispatch per command:
	cmp #read
	beq ReadSector		;    read sector
	cmp #write
	beq WriteSector 	;    write sector
	cmp #$f0
	beq FormatDisk		;    format disk
	sec
	rts			;    unknown command

	.page
ReadSector
	jsr Setup		;Setup controller, find track, reset chip buffer
	  bcs wtabort		;   can't continue- no drive or disk
	jsr CheckLastTss	;Sector already in chip buffer?			[910129] FAB
	  bcc ReadSectorImm	;   yes!

1$	lda #rds		;Issue buffered READ command
	sta command
5$	lda stata		;   wait for sector to be found, want RDREQ=1	[900815] FAB
	and #bit4
	bne 40$			;	RNF=1, sector not found
	lda statb
	bpl 5$			;	RDREQ=0, still looking for it

	ldy #0			;DOS buffer index
	lda half		;Sector found, start reading from chip buffer to our's
	beq 20$			;   which half of 512-byte chip buffer do we want?

10$	jsr ByteRead		;	want second half, so waste first
	iny			;		(4+1+2+5+12 = 24 cycles)	[900815] FAB
	bne 10$

20$	bbr6 bit_flag,30$	;	want whole block?
	jsr ByteRead		;		no- read & set t&s link bytes only
	sta track
	jsr ByteRead		;		(4+3+5+12 = 24 cycles)		[900815] FAB
	sta sector
	bra 40$

30$	jsr ByteRead		;Xfer block from chip to ram buffer
	sta (ip),y		;		(4+5+1+2+5+12 = 29 cycles)	[900815] FAB
	iny
	bne 30$

40$	jsr CheckEr		;BusyWait & check for errors			[900815] FAB
	  bcs wtabort		;	error occurred, and control to return to caller

	jsr SetLastTSS		;Remember last sector access			[910129] FAB
	bra done		;Normal exit

	.page
ReadSectorImm			;Sector is already in chip buffer		[910129] FAB
	jsr SetChipBP		;Set cpu & fdc buffer pointers
	bbr6 bit_flag,30$	;Want whole block?
	jsr ByteReadWithDelay	;	no- read & set t&s link bytes only	[910624] FAB
	sta track
	jsr ByteReadImm		;		(4+4+3+5+3 = 19 cycles)
	sta sector
	bra done

30$	ldy #0			;Our buffer index
35$	jsr ByteReadImm		;Xfer block from chip to ram buffer
	sta (ip),y		;		(4+5+1+2+5+3 = 20 cycles)
	iny
	bne 35$
	bra done		;Normal exit (errors were caught when sector was 1st read)

	.page
WriteSector
	jsr Setup		;Setup controller, find track, reset chip buffer
	  bcs wtabort		;	can't continue- no drive or disk
	jsr CheckProt		;Check write protect status
	  bcs wtabort		;	can't continue- wp error (or no disk present)
	jsr CheckLastTSS	;;Sector already in chip buffer?		[910129] FAB
	  bcc 10$		;;	yes!

1$	lda #rds		;Read sector we're going to update into chip buffer
	sta command
	jsr CheckEr		;	busywait & check for errors
	  bcs wtabort		;		can't continue- crc or rnf error

10$	jsr SetChipBP		;;Set cpu & fdc buffer pointers
	jsr BusyWait		;;
	ldy #0			;;
20$	lda (ip),y		;;Xfer ram buffer to chip buffer
	jsr ByteWrite		;;
	iny			;;
	bne 20$			;;

;5$	ldy #0
;	lda half		;Which half of chip buffer is our sector in?
;	beq 20$			;	branch if first
;
;10$	jsr ByteReadImm		;want second half, so skip first		[900815] FAB
;	iny			;	(4+1+2+5 = 12 cycles)			[900815] FAB
;	bne 10$
;
;20$	lda (ip),y		;Xfer ram buffer to chip buffer
;	jsr ByteWrite
;	iny
;	bne 20$
;
;30$	lda stata		;Make sure chip buffer pointer EQ  (????)	[910129] FAB
;	and #bit5
;	bne 40$			;	yes- now write sector
;	jsr ByteReadImm		;	no-  strobe DATA to bump pointer
;	bra 30$			;		loop (4+2+4+2+2+5 = 19 cycles)	[900815] FAB

	lda #swap		;;Reset chip buffer pointers
	trb control		;;
	lda #reset_bp		;;
	sta command		;;

40$	lda #wts		;Prepare WriteSector command			[900821] FAB
;	ldx track1
;	cpx #precomptrk		;	use precompensation?
;	bcc 50$			;		no
;	ora #precomp		;		yes- track >=43

50$	sta command		;Issue buffered write command			[900821] FAB
	jsr CheckEr		;	busywait & check for errors		[910429] FAB
	  bcs wtabort		;		can't continue- crc or rnf error

;* NOTE: This is NOT a normal write verify check as it is done in normal dos disk drives,
;* this routine just reads the sector back into the chip buffer and checks for any errors.
;* It DOES NOT compare the dos buffer with the data in the chip buffer because it is assumed
;* that the only way to get a non-detectable error using this method is for the user to have
;* bad RAM in his C65 since this chip computes its own checksum value.

	bit iobyte		;Verify sector?					[910429] FAB
	bpl 60$			;	no
	smb0 bit_flag_2		;	yes- want errors returned to me		[901127]
	lda #rds		;   	   issue read command
	sta command
	jsr CheckEr		;	   busywait & check for errors
	rmb0 bit_flag_2		;	   clear error return flag		[901127]
	bcs wverify		;	   	report write verify error

60$	jsr SetLastTSS		;Remember last sector access			[910129] FAB
	bra done		;Normal exit

	.page
FormatDisk
	jsr cleardchange
	lda #2
	sta sz			;sector size = 512
	ldx cdrive		;drive number
	lda #$80		;force INIT to bump
	sta curtrk,x
	sta last_drive		;forget previous accesses			[910129] FAB
	jsr InitCtlr		;init controller
	jsr CheckProt		;check write protect status
	bcs wtabort		;   can't continue- protected

	lda $d011		;Disable VIC					[910815] FAB
	sta rc8			;	to be restored later
	and #%01101111
	sta $d011		;	blank to suspend VIC DMA's

	lda #0			;Set starting track (0-79, initially zero)
	sta tt1

fmttrk	lda #0			;Set starting side (0-1, initially zero)
	sta sd
	lda #side
	tsb control		;  (1581 has physical/logical swapped)

fmtside	jsr BusyWait
	lda #1			;Set starting sector (1-10, initially one)
	jsr docrc		;CRC track
	jsr wttrk		;Format track
	lda sd
	bne 10$
	inc sd			;Flip to second side
	lda #side
	trb control		;  (1581 has physical/logical swapped)
	bra fmtside

10$	lda tt1
	cmp #79			;Check max track
	bcs fmtdone		;  yes- Done
	inc tt1			;  no-	Move to the next track

20$	jsr CheckDC		;Check for disk change
	beq 30$			;  no-	Continue
	jsr setnodrv		;  yes- set no drive flag		[900822] FAB
;	lda #0
;	sta command		;???? to get rid of "nobuf"		[910203]
	jsr hed2ts
	lda rc8			;Reenable VIC				[910815] FAB
	and #%01111111		;	must keep RC8 low
	sta $d011
	ldx #12			;DOS error #75 format error		[910420]
	bra nderror

30$	lda #stout		;Step head out to next track
	sta command
	jsr SettleHead		;Delay 24ms
	bra fmttrk		;  continue


fmtdone
	lda rc8			;Reenable VIC				[910815] FAB
	and #%01111111		;	must keep RC8 low
	sta $d011
;	lda #0
;	sta command		;???? to get rid of "nobuf"		[910203]
	ldx cdrive
	lda #bit7		;????force a bump
	sta curtrk,x		;(have to- head is now at track 80, DOS thinks it's at 1)

	bit iobyte		;Verify?				[911008] FAB
	bpl done		;	no
	jsr VerifyDisk		;	yes


done	ldx jobnum		;Flag job complete
	lda #0			;					[901127]
	sta jobs,x
	clc
wtabort	rts

	.page
;*--------------------------------------------------------*
;* Format a track					  *
;* 10 sectors per track numbered 1-10, 512 byte sectors	  *
;*--------------------------------------------------------*
;*  12 Sync marks			     00		  *
;*   3 Header ID marks w/missing clock	     A1		  *
;*   1 Header ID			     FE		  *
;*   4 Header bytes			     Track	  *
;*					     Side	  *
;*					     Sector	  *
;*					     Sector size  *
;*   2 Header CRC bytes			     xx,xx	  *
;*  22 Data gap bytes			     4E		  *
;*  12 Sync marks			     00		  *
;*   3 Data block ID marks w/missing clock   A1		  *
;*   1 Data block ID			     FB		  *
;* 512 Data block fill bytes		     00		  *
;*   2 Data block CRC bytes		     xx,xx	  *
;*  24 Sector gap bytes			     4E		  *
;*--------------------------------------------------------*

wttrk	jsr BusyWait		;Wait for previous job to finish
	lda #$4e
	ldx #$ff
	sta data1
	stx clock

;	lda #wtt+1		;Build command					[900821] FAB
;	ldx track1
;	cpx #precomptrk 	;	use precompensation?
;	bcc 10$			;		no
;	ora #precomp		;		yes
;10$
	lda #wtt+1		;Erase track (fill with $4E gap bytes)		[900821] FAB
	jsr CommandReg		;	necessary due to simulated index pulse!
;	lda #wtt+1		;Write track unbuffered				[900821] FAB
	sta command		;Begin formatting

	.page
fmtsec	ldy #16			;write post index gap 12 sync
10$	lda secdat-1,y
	ldx secclk-1,y
20$	bit stata
	bpl wtabort		;   oops
	bvc 20$
	sta data1		;Always write data before clock
	stx clock
	dey
	bne 10$

	ldy #4			;Write 4 header bytes
	ldx #$ff
30$	lda header-1,y
40$	bit stata
	bpl wtabort		;   oops
	bvc 40$
	sta data1
	stx clock
	dey
	bne 30$

	lda sec			;Convert sector number into a
	asl a			; CRC pointer
	tay
	lda crc,y
	ldx #$ff
50$	bit stata		;Write 2 byte header CRC
	bpl wtabort		;   oops
	bvc 50$
	sta data1
	stx clock
	lda crc-1,y
60$	bit stata
	bpl wtabort		;   oops
	bvc 60$
	sta data1
	stx clock

	ldy #42			;Write post ID gap
70$	lda gap1-1,y
	ldx gap1clk-1,y
80$	bit stata
	bpl 130$		;   oops
	bvc 80$
	sta data1
	stx clock
	dey
	bne 70$

	ldy #0			;Write data field 512 bytes of 0
	ldx #$ff
	lda #0
90$	bit stata
	bpl 130$		;   oops
	bvc 90$
	sta data1		; block 0
	stx clock
91$	bit stata
	bpl 130$		;   oops
	bvc 91$
	sta data1		; block 1
	stx clock
	dey
	bne 90$

	lda #$da		;Write pre-calculated data CRC
	ldx #$ff		;512 byte sectors $da6e
100$	bit stata		;256 byte sectors $e122
	bpl 130$		;   oops
	bvc 100$
	sta data1
	stx clock
	lda #$6e
	ldx #$ff
110$	bit stata
	bpl 130$		;   oops
	bvc 110$
	sta data1
	stx clock

	ldy #24			;Write sector gap
	lda #$4e
	ldx #$ff
120$	bit stata
	bpl 130$		;   oops
	bvc 120$
	sta data1
	stx clock
	dey
	bne 120$

	inc lsec		;						[910423] FAB
	ldx lsec
	cpx #10+1		;Do until 10 sectors are done
	bcs BusyWait
	lda sector_interleave_table-1,x
	sta sec			;Move to the next sector
	bra fmtsec
130$	bra BusyWait

	.page
;*----------------------------------------------------------------------*
;* Calculate the 2 byte CRC for each sector header of an entire track	*
;* of 10 sectors.   AXYZ are trashed.					*
;*									*
;*  This routine is based on the Cyclical Redundancy Check on the	*
;*  polynomial:	 A^16+A^12+A^5+1.					*
;*									*
;*	HEADER contains TRACK,SIDE,SECTOR,2 [sector size]		*
;*									*
;*	DO WHILE ne = 0							*
;*	  DO FOR each bit in the data byte (.a) [from lsb to msb]	*
;*	    IF (LSB of crc) EOR (LSB of data)				*
;*	      THEN CRC = (CRC/2) EOR polynomial				*
;*	      ELSE CRC = (CRC/2)					*
;*	      ENDIF							*
;*	    LOOP							*
;*	  LOOP								*
;*----------------------------------------------------------------------*

docrc	pha			;Save the starting sector number
	tax
	stx sec
10$	lda #$30		;Initialize the CRC word to the
	sta crc,x		; precomputed CRC for A1,A1,A1,FE
	lda #$b2
	sta crc+1,x

	ldy #4
20$	lda header-1,y		;CRC the 4 variable header bytes
	jsr crcalc
	dey
	bne 20$

	inc sec			;Move to the next sector
	inx			;Move to the next CRC in buffer
	inx
	cpx #20			;CRC 10 sectors, 2 bytes each
	bcc 10$
	pla
	sta sec
	sta lsec		;						[910423] FAB
	rts

	.page
;*--------------------------------------------------------*
;* Add to the running CRC pointed to by X the byte in A	  *
;*--------------------------------------------------------*

crcalc	phy			;Save Y
	ldy #8			;CRC 8 bits in A
	sta ttemp		;Save byte to CRC in TTEMP
10$	asl ttemp
	ror a			;Calculate CRC/2
	eor crc+1,x
	php
	asl crc,x
	rol crc+1,x
	plp
	bpl 20$
	lda crc,x
	eor #%00100001
	sta crc,x
	lda crc+1,x
	eor #%00010000		;A^16
	sta crc+1,x
20$	dey
	bne 10$
	ply			;Restore Y
	rts

	.page
;*--------------------------------------------------------*
;* SECDAT - 12 syncs, header ID marks			  *
;* GAP1	  - 26 gap bytes, 12 syncs, data block ID marks	  *
;*							  *
;* Data is backwards in memory!				  *
;*--------------------------------------------------------*

secdat	.byte $FE,$A1,$A1,$A1
	.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00

secclk	.byte $FF,$FB,$FB,$FB
	.byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF

gap1	.byte $FB,$A1,$A1,$A1
	.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
	.byte $4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E
	.byte $4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E

gap1clk .byte $FF,$FB,$FB,$FB
	.byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
	.byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
	.byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF

sidemask
	.byte $08,$00

sector_interleave_table			;					[910205] FAB
	.byte 1,8,5,2,9,6,3,10,7,4	;(skew=7)

	.page
; CONTROLLER SUBROUTINES

;*			SETUP controller for R/W command
;*
;* Performs LOGICAL -> PHYSICAL sector translation based upon the following pseudo code
;* (CBM1581 compatible):
;*
;*		SIDE		= (LogicalSector >= 20) AND 1
;*		TRACK		= LogicalTrack -1
;*		StartingSector	= SIDE * 20
;*		SECTOR		= (LogicalSector - StartingSector) /2 +1
;*		HALF		= (LogicalSector - StartingSector) AND 1
;*
;* Initializes control, seeks indicated track, and selects side.  Initializes chip and
;* RAM buffer pointers.  Called exclusively by RaedSector, WriteSector, and FastLoad.


Setup	jsr BusyWait		;'SETUP' controller for R/W command
	lda jobnum
	asl a			;JOBNUMber * 2 to point to the correct header
	tax
	lda hdrs,x		;Get track  (logical,  1-80)
	dec a
	sta track1		;Set track  (physical, 0-79)

	lda hdrs+1,x		;Get sector (logical,  0-39)
	cmp #20			; (0-19, side 0) or (20-39, side 1)
	lda #0
	rol a
	sta sider1		;Set side   (0-1)
	beq 10$
	lda #20			;Get starting sector (0 or 20)
10$	neg a
	clc
	adc hdrs+1,x		; calculate physical 512-byte sector
	lsr a
	inc a
	sta sector1		;Set sector (physical, 1-10)
	lda #0
	ror a
	sta half		;Set block

	jsr InitCtlr		;Init controller, reset chip buffer
	bcs 20$			;    boogie if error
	jsr fndtrk		;Seek track
	ldx jobnum		;Setup address of RAM buffer
	lda bufind,x
	sta ip+1
	lda #0
	sta ip
	clc
	rts


20$	plz			;Error:
	plz			;	pop return address
	bra goerror		;	and exit with err# in .A,  job# in .X

	.page
ControlReg			;Issue FDC control parameter			[900821] FAB
	pha			;	save FDC control byte
	jsr CheckDC		;	update disk change status before we lose it
	lda #2
	tsb control		;	decouple (chip bug)			[900821] FAB
	jsr BusyWait		;	(expensive!!!)				????
	pla


ControlRegImm
	sta control		;	install new control value & busywait
;	ldx #0
;	bit #device		;		determine device # from the	[900823] FAB
;	beq 10$			;		actual control byte we're
;	inx			;		writing.  this executes during busy.
	ldx drvnum
	sta control_store,x
	bra BusyWait



CommandReg			;Issue FDC Command				[900820] FAB
	sta command



BusyWait
	bit stata		;Wait for controller chip BUSY to clear
	bmi BusyWait
	rts

	.page
ByteRead			;Read byte immediately from chip buffer		[910129] FAB
	lda stata		;Has FDC put a byte into chip buffer?
	and #bit5		;	want EQ=0, chip <> cpu buffer pointer
	bne ByteRead		;	no- stick around & wait for it



ByteReadImm			;Allow 13 cycles (4MHz) between calls!		[900815] FAB
	lda data1		;Read it (clears DRQ)
	rts			;		(min 8 cycles)



ByteReadWithDelay	
	jsr ByteReadImm		;to add a few cycles of delay between calls	[910624] FAB
	rts



ByteWrite			;allow 13 cycles (4MHz) between calls!
	sta data1
	rts

	.page
;	**********************************************************
;	*		  CHECK Disk Change			 *
;	*							 *
;	* This routine will test & update the disk change status *
;	* of the active drive.	It *must* be called before the	 *
;	* active drive is changed to preserve the DSKCHG status. *
;	* It may be called at any other time to test the status. *
;	* Caller must call ClearDChange beforehand to obtain the *
;	* current status, otherwise DCHANGE will indicate the	 *
;	* change status accumulated over time.			 *
;	*							 *
;	* If a change is detected, DCHANGE is set as follows:	 *
;	*	       B7      internal drive			 *
;	*	       B6      external drive			 *
;	*							 *
;	* Upon return, <> means disk changed, = means no change	 *
;	**********************************************************


CheckDC				;Rewrote & merged checkdc & update_dc		[900821] FAB
;	jsr BusyWait		;why????					[910207] FAB
	lsr statb		;Get the current drive's DSKCHG status in .c
	lda control		;Get the active drive # from the chip
	and #device		;	0 or 1
	tax			;	save it for later
	bcc 20$			;If no disk swap, save time & skip ahead	[910207] F011C
;				; (can't until ext_dc is fixed- chip bug) ????
	beq 10$			;Put the dc status in proper place, per drive#:
	ror a			;  External drive (1), put dc status into bit6
;	eor #bit7		;    and invert sense (chip bug)		[910207] F011C
	clc			;    zap drive# shifted into .c
10$	ror a			;  Internal drive (0), put dc status into bit7
	tsb dchange		;Update the disk change flag

;	lda #2			;DeSelect current drive to clear the latched status
;	tsb control		; (unnecessary????  ControlReg does this)
;	trb control

20$	lda drivemask,x		;.x has active drive # from up above
	and dchange		;Return <> if change, = if no change
	beq 30$
	pha			;shit!
	lda #$80
	sta last_drive		;???? necessary ????				[910129] FAB
	pla
	and dchange
30$	rts

	.page
;* 'CheckProt'	Check the Write Protect status of the currently selected drive
;*
;* If diskette is protected the error handler is JuMPed to.

;* THIS ROUTINE NEEDS TO BE RECODED TO CHECK REAL TIME.	 SEE SCRATCH, VALIDATE_BAM

CheckProt
	jsr BusyWait
	lda stata
	and #bit1
	bne wperror	;go report error
	clc
	rts

	.page
;* 'CheckEr'   Check for CRC/RNF status following read of currently selected drive
;*
;* If an error is detected the error handler is JuMPed to.  Preserve Z register.

CheckEr
	jsr BusyWait		;Busywait for op to complete
	lda stata
	and #bit4+bit3		;Check RECORD NOT FOUND and CRC
	beq noerror		;    branch if no errors
	cmp #bit4		;    what is the error?
	beq 10$
	bcs 20$

	ldx #5			;	DOS error # 23 (data CRC)
		.byte $2c
10$	ldx #9			;	DOS error # 27 (header CRC)
		.byte $2c

20$	ldx #2			;	DOS error # 20 (read error DNR)
		.byte $2c

wverify ldx #7			;	DOS error # 25 (write verify)
		.byte $2c
wperror ldx #8			;	DOS error # 26 (write prot on)

nderror txa			;    return error message #


goerror ldx jobnum		;    return job #				[9004xx]
	sta jobs,x
	sec			;shit!
	ror last_drive		;force re-read of sector
	bbs0 bit_flag_2,10$	;branch if caller wants control back
	bra error		;else go directly to error handler

10$	sec
	rts


noerror clc			;A clean exit
	rts

	.page
tschk	ldx drvnum		;						[900418]
	lda track		;If track = 0 then error
	beq tser1
	cmp maxtrk,x		;If >  max. track then error
	bcs tser1
	cmp startrk,x		;If < starting track then error
	bcc tser1
	lda #40			;If <> max sectors (numsec) then error
	cmp sector
	bcc tser1
	beq tser1
	rts

;*
;*  'TSERR'  reports illegal T/S errors
;*

tserr	jsr hed2ts
tser1	lda #badts
	bra cmder2


hed2ts	lda jobnum		;Get job number * 2
	asl a
	tax
	lda hdrs,x		;Place FDC track and sector into Track and Sector
	sta track
	lda hdrs+1,x
	sta sector
	rts

	.page
;*
;* Ctlr ERROR Handlers.		JuMP to these routines, do not call them.
;*

;*
;*  'VersioN ERRor'  		reports diskette/format version error
;*

vnerr
	jsr hed2ts		;Get track & sector error occurred on
	lda #cbmver
	bra cmder2


;*
;*  'DNRERR'			reports Drive Not Ready error (no drive or no disk)
;*

dnrerr	jsr hed2ts
	jsr setnodrv		;						[9004xx]
	ldx #15			;DOS error # 21 (drive not ready)
	bra nderror

	.page
;**********************************************************
;*  Seek TRACK ZERO on current drive			  *
;*							  *
;* called by: initdr, DiskInit				  *
;**********************************************************
;*  KNOWN BUGS - Since this routine is NOT called via the *
;*   job queue CDRIVE is not set up so it is reset in line*
;*   Since motoron is not called via the job queue or does*
;*   not use DRVNUM either it will bomb the drive	  *
;*   do not set up CONTROL at this time for the correct	  *
;*							  *
;*   Since this section of code in the dos need recoded I *
;*     did not take the time to do all of the kludges	  *
;*     required so this code may hang if you do a directory
;*     before you do a dclear when you first call the dos *
;**********************************************************
;
;dobump				;not used					[900815] DJJ
;	ldx drvnum		;Get active drive number
;	stx cdrive		; KLUDGE<------------------------------------	[900414]
;	lda #bit7		;Force a bump to track 0
;	sta curtrk,x
;	lda jobrtn		;Save error return flag
;	pha
;	ora #bit7		;Set flag to prevent errors from being generated
;	sta jobrtn
;	jsr initf011_1		;Do the bump					[900414]
;	pla			;Restore the job return flag
;	sta jobrtn
;	rts			;(.c=1 if error reported by initf)

	.page
;* 'InitCtlr'  Initialize F011x controller chip
;*
;* Called by SETUP  for sector READ/WRITE
;* Called by FORMAT
;*
;* Does not return if drive not ready

InitCtlr
	ldx cdrive		;Current drive					[900820] FAB
	lda control_store,x
	and #motor		;	is motor on?
	tay			;	save in y for later. (y=0 if motor was off)

	ldx sider1		;Side number
	lda sidemask,x		;	flip it for 1581 compatibility		[900822] FAB
	ora #motor		;Turn on motor & LED, BackGround will turn off	[910129] F011C
	ora cdrive
	jsr ControlReg		;   Decouple ctlr & set new control value	[900710]
	tya			;						[900820] FAB
	bne 10$			;	skip ahead if motor was already on	[900820] FAB
	jsr MotorDelay		;   Motor spinup delay

10$	lda #reset_bp		;Reset chip's buffer pointers			[900820] FAB
	sta command
	dec command		;	make sure "nobuf" bit is reset		[910204] FAB
	lda #steprate
	sta step		;Set step rate
	lda #$ff
	sta clock		;Set clock

	lda statb		;Got a disk?
	and #bit3
	beq dnrerr		;	no disk error

	ldx cdrive		;Current drive (ControlReg destroys .x)		[900820] FAB
	lda curtrk,x		;Seek track 0 ?
	bpl 40$			;	no- branch if bump already done

	lda #stin
20$	lsr stata		;On track 0 ?					[900822] FAB
	bcs 30$			;	yes
	jsr CommandReg		;	no- step in 1 track
	bra 20$			;	    loop until track zero found

30$	jsr SettleHead		;	delay 24ms				[910425] FAB
	lda #0			;	flag bump completion
	sta curtrk,x

40$	clc
	rts

	.page
;* 'FNDTRK'   seek given track


fndtrk	phy			;   ???? necessary ????
	ldy #0			;Step flag
	ldx cdrive		;Current drive					[900816] FAB
	lda track1		;Track we want					[900821] FAB

5$	jsr BusyWait		;Wait for previous op to finish
	cmp curtrk,x		;Current track
	beq 30$			;   exit if current track = track we want
	bcc 10$			;   else determine direction to step to get there

	inc curtrk,x		;	step out				[900816] FAB
	ldy #stout
	bra 20$

10$	dec curtrk,x		;	step in					[900816] FAB
	ldy #stin

20$	sty command		;						[900820] FAB
	bra 5$			;Loop until track we seek is the current track


30$	tya			;Wait for head to settle			[900816] FAB
	beq 40$			;	no need- head not moved
	jsr SettleHead		;	Delay 24ms

40$	ply			;???? necessary ????
	rts

	.page
; Do job in .a, set up error count and lstjob.
; Return when job done ok,  Jmp to error if error returns.

doread	lda #read
	   .byte $2c


dowrit	lda #write


dojob	ora drvnum
	ldx jobnum


doit	sta cmd


doit2	lda cmd
	jsr setjob
	clc			;c = 0 finished ok or quit
	rts

	.page
;	SET HeaDeR		Set up T&S for active buffer pointed to by LINDX
;

sethdr	jsr getact		;Get the active BUFFER number




;	SET Header		Set up T&S for the buffer pointed to by .A
;

seth	asl a			;buffer number *2 to point at the LSB of HDRS
	tay
	lda track
	sta hdrs,y		; set track
	lda sector
	sta hdrs+1,y		; set sector
	lda #0
	tax
	rts

	.page
; The LED is blinked automatically by F011D controller.				[910417] F011D



erron				;Turn error    LED on
	inc $d020		; (FLASH BORDER COLOR?????) leave in until ext. error led works
	lda #'D'		;						[900911] FAB
	   .byte $2c


erroff				;Turn error    LED off
	lda #0
	jsr sta_erword		;						[910313]

	tax			;						[910417] F011D
	beq 10$
	lda #led		;set led blink accordingly
10$	ora drvnum
	sta cdrive
	ldx drvnum
	ora control_store,x
	and #motor+side+swap	;keep these bits!		added motor????	[911021] FAB
	ora cdrive		;add drive
	stx cdrive
	bra ControlReg		;install new control byte
				;???? check activity ????			[911021] FAB	
	.page
; [900710] FAB	Rewrote the following routines for BackGround & decoupling
; [900821] FAB	Rewrote them again!  Something expects them to set cdrive????

;setlds				;Turn activity LED on			removed-[910129] F011C
;actledon
;	lda drvnum
;	and #device
;	sta cdrive
;	tax
;	lda control_store,x
;	and #motor+side		;keep motor, side			[900609]
;	ora #led		;add LED				[900609]
;	ora cdrive		;add drive
;	bra ControlReg		;install new value			[900710] FAB



;actledoff			;Turn activity LED off
;	lda drvnum
;	and #device
;	sta cdrive
;	tax
;	lda control_store,x
;	and #motor+side		;keep motor, side			[900409]
;	ora cdrive		;add drive
;	bra ControlReg		;install new value			[900710] FAB

	.page
setlds				;					[910129] F011C
actledon			;					"
motoron				;Turn motor on
	ldx drvnum
	stx cdrive
	lda control_store,x	;					"
	and #led+side+swap	;keep led, side, swap bits		[900822] F011C
	ora #motor		;add motor				[900814]
	ora cdrive		;add drive
	cmp control_store,x	;already got all that?!?		[910208] FAB
	beq motor_rts		;	yes- just exit
	jsr ControlReg		;install new control byte		[900710] FAB
				;	problem with dual drives requires
				;	spinup delay here????

MotorDelay			;					[910207] FAB
;	phx			;Provide motor spinup delay
	ldx #0			;	(700ms delay, Chinon spec .7sec)
10$	inx
	stx step		;	set timer (62.5us per count, 16=1ms)
	lda #time
	jsr CommandReg		;	start & wait on timer
	cpx #steprate
	bcc 10$			;exit with proper step parameter installed!
;	plx
motor_rts
	rts

;	lda #spin
;	bra CommandReg		;busy will be set for 6 index pulses	[900815] FAB
				; (too long!)


actledoff			;					[910129] F011C
motoroff			;Turn motor off
	ldx drvnum
	stx cdrive
	lda control_store,x	;					"
	and #led+side+swap	;keep led, side, swap bits		[910207] F011C
	ora cdrive		;add drive
	cmp control_store,x	;already got all that?!?		[910208] FAB
	beq motor_rts		;	yes- just exit
	bra ControlReg		;install new control byte		[900710] FAB

	.page
SettleHead			;Settle time					[910425] FAB
	jsr BusyWait
	lda #settlerate
	sta step		;	set timer (62.5us per count, 16=1ms)
	lda #time		;		  (Chinon specs 21ms, so do twice...)
	jsr CommandReg		;	start & wait on timer (12ms)
	jsr CommandReg		;	start & wait on timer (12ms)
	lda #steprate		;	restore step rate
	sta step
	rts


;is_drv_here			;Check for drive present			[910313]
;	clc
;	rts
;	jsr busywait		;Wait for previous op to finish (just in case)
;	txa
;	ora #motor
;	jsr ControlReg
;	lda #stout		;Set away from track 0
;	jsr CommandReg		;Do the command
;	lsr stata		;On track 0 ?
;	rts

;.end
	.page
	.subttl	 IEEE  v910525

; NOTE: How about saving the index (X) for PARSEX so that the preprocessor only has
;	to 'or' X with $30 to obtain the drive number?


hlisten jsr resetmode
	ldx #0			;number of drives (0 & 1)			[900803]
10$	cmp cbdosaddress,x	;  check internal drive first, in case		[900803]
	beq 20$			;  user renumbered it same as the		[900803]
	inx			;  external drive...				[900803]
	cpx #2
	bcc 10$			;trynext
	bra notpres

20$	lda #bit6		;myaddress


present
;	taz			;						[910313]
;	jsr is_drv_here
;	bcs notpres
;	tza
	tsb bit_flag_1
	stx drivenumber		;Save index as drive number (0 or 1)
;	rts

	.page
; Since we are taking a DUAL DRIVE and having it emulate two single drives
; we must have seperate ERROR MESSAGE BUFFERS.  Since we are emulating a
; SERIAL bus device, we know that in order for the user to swap channels he
; has to do an unlisten or untalk then send a TALK, or LISTEN command out to
; a normal SERIAL bus device.  I've taken that in to consideration and used it
; to save ram.  So if the actual drive number changes we swap pointers in ER
; with SAVE_er which contains ERR_BUF_PTR for the inactive drive which is
; about to become active.  Just remember that ERR_BUF_PTR contains the pointer
; to the NEXT byte to be sent from the DOS (IP) to the C65 (Kernel).

setup_err			;Entered by the RESET routine
	cpx drvnum		;Is this drive the current drive?
	beq 10$			;	yes
	stx drvnum		;	no, make it the current drive
	lda err_buf_ptr
	pha			;Could not use PHW here (does not work on PC version)
	lda err_buf_ptr+1
	pha
	lda chndat+errchn
	pha			;Swap 1st. char to be sent over error channel
	lda lstchr+errchn
	pha
	lda chnrdy+errchn
	pha
	lda save_chn_rdy
	sta chnrdy+errchn
	lda save_lstchr_ptr
	sta lstchr+errchn
	lda save_chn_data
	sta chndat+errchn
	lda save_err		;Swap the drives' err pointers
	sta err_buf_ptr
	lda save_err+1
	sta err_buf_ptr+1
	pla
	sta save_chn_rdy
	pla
	sta save_lstchr_ptr
	pla
	sta save_chn_data
	pla
	sta save_err+1
	pla
	sta save_err
10$	rts

	.page
htalk	jsr resetmode
	ldx #0			;number of drives (0 & 1)			[900803]
10$	cmp cbdosaddress,x	;  check internal drive first, in case		[900803]
	beq 20$			;  user renumbered it same as the		[900803]
	inx			;  external drive...				[900803]
	cpx #2
	bcc 10$			;trynext
	bra notpres

20$	lda #bit7		;myaddress
	bra present

	.page
;*
;* need to make sure we're an active talker/listener
;*

hsecond	bit bit_flag_1		;Active talker/listener?
	bmi 10$			;	yes
	bvc notpres		;	no- error out

10$	pha
	and #$60		;Make sure the SA is really an SA
	cmp #$60
	pla
	bcc notpres		;	it's not- DEVICE NOT PRESENT error
	pha
	sta orgsa		;Save the original SA
	and #$0f		;Mask command flags
	sta sa			;Save it as the current SA
	pla
	and #$f0		;Mask device, keep command
	cmp #$e0		;Is it is a close command?
	bne Background		;	no- Update led and motor		[900630]

20$	tsx			;	yes- close & fall into Background
	stx tos
	jsr close

	.page
;********************************************************************************
;*     This routine emulates the Background job called IDLE in the normal	*
;*   CBM DOS.  Its main job is to scan the LINTAB table looking for currently	*
;*   active R/W channels, turning on or off the drive's motor and activity	*
;*   LED appropriately.								*
;********************************************************************************
; NOTE: for disk swap check to work, Background MUST toggle drives		[900823] FAB

Background			;Rewrote to make mystery problem go away	[900822] FAB
	pha			;Save registers
	phx
	phy
	lda drvnum
	tay
	eor #1
	sta drvnum
	jsr CheckActivity
10$	sty drvnum		;check current drive last (restores drvnum)
	jsr CheckActivity
	ply			;Restore registers & exit
	plx
	pla
	rts

CheckActivity
;	ldx drvnum		;If drive is not "on" don't need to check it	[900901]
;	lda control_store,x
;	and #motor+led
;	beq 20$			;	motor & led already off

	lda #cmdsa-1		;Start with the max user sa allowed, except cmd sa
	sta temp
10$	lda temp		;Get the current SA we're checking
	jsr getlintab		;Get the status + LINDX value for this channel
	inc a			;	Is this channel active (.a<$ff)?
	bne 20$			;	  yes, therefor drive is active
	dec temp		;Next SA
	bpl 10$			;	loop until all channels checked

;	jsr actledoff		;No active channels found, therefor drive is inactive
	bra motoroff		;so turn off motor & led			[910128] F011c

20$ ;	jsr actledon		;Turn on the motor on the active drive		[910128] F011c
	bra motoron		;Also the led

	.page
;*
;* Send a byte from the DOS to the computer
;*

hacptr	jsr CheckDC		;Check for disk change, update DCHANGE
	bbr7 bit_flag_1,notpres	;Are we an active TALKER?

	tsx			;Save pointer to return
	stx tos			;Address on the stack
	jsr fndrch		;See if this SA (that's in SA) is active
	bcs notpres		;	no

	lda chnrdy,x		;Is the channel status OK?
	bpl notpres		;	no- error
	and #eoisnd		;Do we need to do an EOI operation?
	bne 10$			;	no
	lda #bit6		;	yes- set the EOI bit
	tsb status
10$	lda chndat,x		;Get the data byte
	sta a1			;Save it so when SHIFTDOWN restores its registers
				;it will return the byte received
	bra get			;Go get the next byte

	.page
;*
;* Get a byte from the computer and give it to the DOS
;*

hciout	jsr CheckDC		;Check for disk change, update DCHANGE
	tsx
	stx tos
	lda #bit1		;Is there a character in the buffer?
	bit bit_flag_1
	bvc notpres		;no matter, not a listener: DEVICE NOT PRESENT
	beq 10$			; no character waiting
	jsr listen		; yes- send out the buffered byte and buffer current one
10$	smb1 bit_flag_1		;Show there's a byte in the buffer now
	lda a1			;Buffer the byte just received
	sta data
	rts

	.page
;***********************************************************
;*  This routine will check to see if this SA's channel	  *
;* is currently set up as an input channel and is active  *
;* (is already OPENed) and if it is then it checks to see *
;* if the CHaNnel is ReaDY to receive a byte, if it is	  *
;* the it jumps to PUT to place the byte into the buffer  *
;* and possibly write out this sector. If the channel is  *
;* not already opened or the channel is not ready (CHNRDY)*
;* has bit 7 set, then this routine checks to see if the  *
;* original SA was ORed with $F0 to see if this is an OPEN*
;* request from the controller and if it is it will call  *
;* PUT, else ERROR.					  *
;**********************************************************

listen	jsr fndwch		;Is this SA an active WRITE channel?
	bcs 10$			;	no- go see if we're opening one now
	lda chnrdy,x		;Is it ready to receive a byte?
	ror a
	bcs put			;	yes- go give it one

10$	lda orgsa		;Get the original SA command
	and #$f0		;Mask out all but OPEN, CLOSE commands
	cmp #$f0		;Is it an open request?
	beq put			;	yes- put(data,eoiflg,sa)
				;	no- fall into 'ilerr' error


ilerr	lda #bit0		;Time out write				(was bit1)	[911119] FAB
	   .byte $2c

notpres lda #bit7		;Device not present or file not found flag
;	   .byte $2c
;
;frmerr	lda #bit1		;Time out read 		(unused????)	(was bit0)	[911119] FAB

	tsb status
	clc
	rts

	.page
hunlisten
	bbr6 bit_flag_1,notpres	;Are we an active LISTENER? No then branch
;	 bvc notpres		;	no- DEVICE NOT PRESENT
	jsr resetmode
	bbr1 bit_flag_1,10$
	lda #bit4+bit1		;Clear byte waiting in buffer flag, and set DO EOI
	trb bit_flag_1		;						[900622]
	jsr listen		;Send byte with an EOI-thing
10$	lda #bit3		;Clear the command waiting in the command buffer
	trb bit_flag_1		;Flag, and test to see if there was one waiting to
	beq nocmd		;Executed and if this is not branch
	bra parsxq		;	     and Execute the command


huntalk				;    (Compatable with 15xx, 20xx)
	bbr7 bit_flag_1,notpres	;Are we an active TALKER? No branch
;	 bpl notpres		;	no- DEVICE NOT PRESENT


resetmode
	pha
	lda #bit7+bit6		;Clear active talker/listener bits
	trb bit_flag_1
	smb4 bit_flag_1 	;Clear do eoi thing with c65
	lda #0			;Clear I/O status returned to kernel
	sta status
	pla

nocmd	clc			;All okay, no errors have occurred
	rts


;.end
	.page
	.subttl	 LOOKUP/PARSE  v910122

setup_one_stream		;Added to make some rom space available		[900725]
	jsr CheckProt		;Check for w/p error (error out if so)

setup_one_stream_1		;				<<<< Entry by SELECT_PARTITION
	jsr fs1set		;Set up for one file stream
	bra alldrs		;Extract all drive numbers

;
; OPTimal SearCH routine for Lookup and Fndfil
;

optsch	lda #0			;determine optimal search
	sta temp		;init drive mask
	sta drvflg		;clear drive search flag
	sta drvcnt		;only one drive at this time
	pha
	ldx f2cnt
10$	pla
	ora temp
	pha
	lda #1
	sta temp
	dex
	bmi 30$
	lda file_drive,x
	bpl 20$
	asl temp
	asl temp

20$	lsr a
	bcc 10$
	asl temp
	bra 10$			;4040 has bne here ????

30$	plx
	lda schtbl-1,x
	pha
	and #3
	sta drvcnt
	pla
	asl a
	bpl 80$

	ldx f2cnt		;Added to correct LINTAB operation of DRVNUM*2	[910501] DJJ
	lda file_drive,x	;						[910401] DJJ
35$	and #1
;	sta drvnum
	phx
	tax
	jsr setup_err		;						[910805] FAB
	plx
	lda drvcnt
	beq 60$			;only 1 drive addressed
	jsr autoi		;check for auto init
	beq 50$			;drive is active
	jsr toggle_drive_number	;try other drive
	lda #0			;set 1 drive addressed
	sta drvcnt
	jsr autoi		;check for auto init
	beq 70$			;drive is active
40$	bra no_drive_present

50$	jsr toggle_drive_number
	jsr autoi
	php
	jsr toggle_drive_number
	plp
	beq 70$
	lda #0
	sta drvcnt		;set 1 drive addressed
	beq 70$

60$	jsr autoi
	bne 40$			;drive not active

70$	bra actledon		;Turn on this drive's activity LED & rts

80$	rol a
	bra 35$


schtbl	.byte $00,$80,$41,$01
	.byte $01,$01,$01,$81
	.byte $81,$81,$81,$42
	.byte $42,$42,$42,$42
	.page
;  LOOKUP
;
;  Look up all files in stream and fill tables w/ info
;
; *******************************************************************************
; * NOTE:  Currently this routine will toggle between both drives.   To prevent	*
; * this, we'll need a flag to test in toggle_drive_number.  If more than two	*
; * drives are used, we'll need to 'walk' thru them in toggle_drive_number.	*
; *******************************************************************************

lookup	jsr optsch		;Set up optimum search pattern
5$	lda #0			;Set flag for NOT looking for a DELeted entry
	sta delind
;	sta delsec		;Show no entries found so far				[910402] removed
	jsr srchst		;Search the 1st and possibly 2nd directory sectors
	bne 30$			;	Branch if a file was found

10$	dec drvcnt		;Search all drives
	bmi 50$			;	Have searched all drives, rts			[911008] FAB
	lda #1			;Toggle drive #
	sta drvflg
	jsr toggle_drive_number
	jsr actledon		;Turn on activity led
	bra 5$

20$	jsr search		;Find a valid file name
	beq 40$			;	done looking on this drive
30$	jsr compare		;Compare filenames in stream with directory buffer
	lda found		;Have all the files been found?
	bne 50$			;	yes, rts					[911008] FAB
	bra 20$			;	no, keep searching				[911008] FAB
;	lda entfnd		;Was there a match?
;	bmi 20$			;	no, continue search
;	bpl 30$			;	yes, check for a match

40$	lda found		;Have all the files been found?
	beq 10$			;	no, go try next drive
50$	rts

	.page
;	Find next File REentry
;
; Routine will re-read the directory sector and point the index pointer contained
; in INDEX into DIRBUF so that the system can continue searching where it left off
; since the LAST filename was found.  This routine will also match any file in the
; stream & return with the entry found stuffed into tables.

ffre	jsr srre		;Read in the next directory sector
ffre_1	beq ff10		;No more sectors left then branch
	bra ff25		;GOT ONE


continue_search
	jsr search		;Search for a matching filename
	bra ffre_1		;Always

ff15	lda #1			;Two drives to check
	sta drvflg
	jsr toggle_drive_number	;Move to the other drive
	jsr actledon		;turn on activity led for the new drive

;
;	Find FirST entry

ffst	lda #0			;Show not looking for deleted entry
	bbr5 bit_flag_1,10$	;Branch if not Unscratch command (or dir unscratch)
	inc a			;Show looking for deleted entry
10$	sta delind
	jsr srchst		;Start the search process
	bne ff25		;	branch if no files found
	sta found		;Save the number
ff10	lda found		;					<<<< entry by FNDFIL
	bne 20$			;Branch if any files found
	dec drvcnt		;Any other drives to check?
	bpl ff15		;	yes
20$	rts


fndfil	jsr search		;Find the next directory entry on a sector
	beq ff10		;... re-entry, no channel activity
ff25	jsr compare		;Compare sector entry with file stream
	ldx entfnd		;Was there a match?
	bpl 10$			;	Yes- branch to check file types
	lda found		;Have all files been found?
	beq fndfil		;	No- branch to check next name in stream
	rts			;We're done

10$	lda typflg		;Get the file type requested by the user
	beq 20$			;If no file type specified then branch
	lda pattyp,x		;Get the filetype of the directory entry
	and #typmsk
	cmp typflg		;Are they the same?
	bne fndfil		;	No- go find the next file match
20$	rts

	.page
;	COMPARE
; Compare all filenames in stream table with each valid entry in the directory.
; Matches are tabulated.  Called by LOOKUP & FNDFIL.

compare ldx #$ff
	stx entfnd	;Show no entries found so far
	inx		;x=0
	stx patflg	;Clear wildcard flag
	jsr cmpchk	;Check for unfound files
	beq 10$		;	branch if entry remains in 'unfound' table
2$	rts		;	else all are found

5$	jsr cc10	;Move F2PTR to next entry in unfound file table
	bne 2$		;	branch if there are no more files on this drive

10$	lda drvnum	;Get the current drive & drive requested in the file stream
	eor file_drive,x
	lsr a		;Are they the same drive?
	bcc 20$		;	yes
	and #$40	;Are we allowed to use the default drive?
	beq 5$		;	no- they specified the wrong drive number so branch
	lda #2
	cmp drvcnt	;Do both drives need to be searched?
	beq 5$		;	yes

20$	lda filtbl,x	;good drive match
	tax		;Find the end of the file name in the cmd buffer
	jsr fndlmt	;Place the pointer in LIMIT
	ldy #3		;Skip over the drive number and colon
;	jsr match	;							[910528] new
;	bcs 5$		;							[911007] inline

	.page
;----------------------------------------------------------------------------
;  Pattern Matching Routine							[910716] new
; * - any number of characters including 0   a*.src   a*   *src			[911007] moved
;     sliding match			     *abc*  must contain "abc"
; ? - must have this char (may be anything)  ?a* 2nd char must be "a"
; # - must be a number			     *#.src all src files w/ a number	< not implemented
; $ - must be a letter			     *$.src all src files w/ a letter	< not implemented
;----------------------------------------------------------------------------
;
; output:	carry clear on match
;		carry set on no match

	stx beginpat		;.match
	dec limit

30$	lda cmdbuf,x		;.patcont
	cmp #'*'
	bne 35$			;.patsing	handle single character

				;.asterik	Handle obscure uses of the asterik
	cpx limit		;char after * is end of pattern?
	bcs 40$			;.satisfy	this is a hit.
	inx			;		otherwise, point to next character
				;.slidemat
	jsr slide		;use sliding match to locate specific pattern
	bcs 5$			;.unsatis	if pattern not found in slide, no-go on this name
 
	cpx limit		;if satisfied, so far, see if there's more to check
	bcc 30$			;.patcont	if so, continue to check
	beq 30$			;.patcont	if so, continue to check
	bcs 40$			;.satisfy	fail search if pattern's index is out of range

35$				;.patsing
	jsr looksngl		;look for special char (#, $, ?, or exact match)
	bcs 5$			;.unsatis	not found
	iny
	jsr endcheck
	inx
	bcs 30$			;.patcont
	jsr entcheck		;is file entry ptr at end of name?
	bcs 30$			;.patcont	no  next
;	bra 40$			;.satisfy	yes exit

	.page
;	bra 33$		;						removed	[910528]
;
;30$	lda cmdbuf,x	;Get a character from the file name in the cmd buffer
;	cmp (dirbuf),y
;	beq 32$		;chars are =
;	cmp #'?'
;	bne 5$		;no single pattern
;	lda (dirbuf),y
;	cmp #$a0	;If we're at the end of the file name,
;	beq 5$		;Branch
;
;32$	inx		;Move to the next char. in the cmd buffer
;	iny		;and in the directory sector
;33$	cpx limit	;At the end of the name in the cmd buffer?
;	bcs 38$		;end of pattern
;	lda cmdbuf,x	;Check to see if the char. in the cmd buffer
;	cmp #'*'	;is this the metacharacter?
;	bne 30$		;  no, keep checking
;	stx tmp		;If it is then save its location in the cmd buffer
;	ldx limit	;Get top end
;	dex
;	cpx tmp		;End of name?
;	beq 40$		;Yes then branch
;	ldy #19
;35$	dey
;	lda (dirbuf),y
;	cmp #$a0
;	beq 35$
;36$	lda cmdbuf,x	;Get char
;	cmp (dirbuf),y
;	beq 37$
;	cmp #'?'
;	bne 5$
;37$	dey
;	dex
;	cpx tmp		;Done?
;	bne 36$
;	beq 40$
;
;38$	cpy #19
;	bcs 40$		;end of filename
;	lda (dirbuf),y
;	cmp #$a0
;	bne 5$

	.page
40$	ldx f2ptr	;filenames match
	stx entfnd
	lda pattyp,x	;store info in tables
	and #bit7
	sta patflg
	lda index	;Save index into the directory sector
	sta entind,x
	lda sector	;Save the directory sector number
	sta entsec,x

	ldy #0		;Get the file type
	lda (dirbuf),y
	iny		;Move over to the track number
	pha		;Save it
	and #$40	;Save scratch protect flag
	sta temp
	pla		;Get the filetype back
	and #$ff-$20	;Drop the save with replace flag
	bmi 42$		;If the file was not closed properly
	ora #$20	;show file as being SPLAT
42$	and #$27
	sta temp	;							[910528]
	lda #bit7
	and pattyp,x
	ora temp
	sta pattyp,x

	lda file_drive,x
	and #bit7
	ora drvnum
	sta file_drive,x

	lda (dirbuf),y	;Setup track & sector table
	sta filtrk,x
	iny
	lda (dirbuf),y
	sta filsec,x

	lda rec		;Do we have the record length?
	bne cmpchk	;	yes
	ldy #21
	lda (dirbuf),y	;	no- get it
	sta rec

	.page
; Check table for unfound files

cmpchk	lda #$ff	;Say files found
	sta found
	lda f2cnt	;Get number of files to search for
	sta f2ptr	;Use as an index

cc10	dec f2ptr	;entry from compare <<<<<<<<<<<<
	bmi 30$		;	table exhausted
	ldx f2ptr
	lda pattyp,x	;File already found?
	bmi 20$		;	Yes then branch
	lda filtrk,x	;Does it really exist?
	bne cc10	;	Yes then branch
20$	lda #0		;Show all files as not being found
	sta found
30$	rts

	.page
;	       Search STart
;
; Search directory - returns with valid entry with DELIND = 0 or returns with
; 1st deleted entry with DELIND > 0.   Note that DELSEC & DELIND will always
; contain the first available directory entry even if you are not looking for one.
;
;		SRCHST    will initiate a search
;		SEARCH    will continue a search

srchst	jsr autoi		;Init the drive if necessary
	ldy #0			;Show no sectors found
	sty delsec
	dey			;$ff
	sty entfnd

	ldy drvnum		;						[900415]
	lda dirtrk,y		;start search at beginning
	sta track
	lda dirst,y		;Get starting directory sector
	sta sector
	lda #bit0		;Show last buffer not encountered yet		[900821]
	sta lstbuf		; (Added because it prevented DIRST from being 0)
				;Added to correct DRVNUM*2 in getlintab		[910501]
	ldx f2cnt		;   In normal dos, at this point the DOS has no idea as 
	lda file_drive,x	;   to what the filename has specified as the drive #
	jsr opnird		;open internal read chnl

sr10	lda lstbuf		;last buffer if 0		<<<<<<<entry from search
	beq sr25		;	yes- exit with z=1
	lda #7
	sta filcnt
	lda #0			;read track #
	jsr drdbyt
	sta lstbuf		;update end flag

sr20	jsr getpnt		;				<<<<<<<entry from search
	dec filcnt
	ldy #0
	lda (dirbuf),y		;read file status byte
;	bne sr30		;	branch if SPLAT or PROPERLY CLOSED	[900820]
;	bbr5 bit_flag_1,20$	;	branch if not unscratch mode		[900815]
	bmi sr30		;	branch if properly closed		[910328]
	beq 10$			;	branch if scratched file		[910328]

	.page
; The following change was made to allow users to copy all the files on the source disk
; to the destination disk with out attempting to copy SPLAT files.		[910328] DJJ

	bbs2 bit_flag_1,search	;If processing a COPY command, skip over splat files
	bra sr30		;If SPLAT or PROPERLY CLOSED branch		[900820]

; Now we know the file type is SCRATCHED or a SPLAT DELETED!! 
; Check to see if we're in unscratch mode getting a directory of scratched files.

10$	bbr5 bit_flag_1,20$	;Not in unscratch mode branch			[900815] 
	ldx #0
	ldy tfiletype,x		;Find out if this file was closed correctly
	lda (dirbuf),y		;Because they would not want to unscratch a splat file
	bpl search		;branch if not closed correctly

;  The next jsr DOES NOT actually write the directory sector back to the
;  disk to restore the file, it simply fakes out the GNSUB routine into
;  thinking this file actually exits on the disk as a good filename.

	bbr0 bit_flag_1,sr50	;If we're not in the DIRECTORY command branch
	jsr restore_file_status_1	;Temporarily restore the file status byte

20$	lda delsec		;deleted entry found
	bne search		;deleted entry already found
	jsr curblk		;get current sector
;	lda sector		;Free directory entry is on			[910528]
	sta delsec		;And save them
	lda dirbuf		;Get the index to the entry
	ldx delind		;If > 0 then return deleted entry (will be 0 or bit 5)
	sta delind
	beq search		;need valid entry, else rts with z=0
sr25	rts

sr30	ldx #bit0		;Looking for the 1st empty slot in the directory sector?
	cpx delind
	bne sr50		;	No
	beq search		;	Yes, keep on looking



srre	ldy drvnum		;						[900415]
	lda dirtrk,y		;Added to allow different partitions of different drives
	sta track
	lda dirsec
	sta sector
	jsr opnird
	lda index
	jsr setpnt

	.page
;* SEARCH
;*
;* This routine will search the directory sectors until the next entry is found.
;* If DELIND is set up for deleted files, this routine stops at the next available slot.


search	lda #$ff
	sta entfnd
	lda filcnt	;adjust file count
	bmi sr40
	lda #32		;incr by 32
	jsr incpnt
	bra sr20


;* This routine reads the next directory sector into a buffer.	If the
;* currently active directory sector is dirty, it is written out before the
;* next one is read in.

sr40	jsr nxtbuf	;new buffer
	bra sr10

sr50	lda dirbuf	;found valid entry
	sta index	;save pointer to filetype
	jsr curblk	;get Track and Sector # of directory sector (in ram)
;	lda sector	;get the sector number					[910528]
	sta dirsec	;save it as the file's directory sector number
	rts		; (.z = 0)

	.page
;**********************************************************
;*     AUTOI	checks to see if the auto init		  *
;* is allowed and if so it will check for a disk swap	  *
;* condition, and if it has not then it exits. If the	  *
;* disk was swapped then it will reset the system back	  *
;* to default, then it will re-read the directory header  *
;* to perform a FAKE SEEK to see if there's a formatted	  *
;* diskette in the drive.  If there's a diskette in the	  *
;* drive it will do an 'I0:' to obtain its BAM and ID.	  *
;* If there is no diskette in the drive it will set the	  *
;* no drive flag for this drive.			  *
;**********************************************************


autoi	bbs3 bit_flag,autoi_rts	;Exit if auto-init is disabled
	jsr testdchange		;Exit if the drive doesn't require init (i.e., disk swap)
	beq autoi_rts

				;						[900912]
autoi_1				;					<<<< Entry by BACKUP
	jsr setdef		;Start init by setting T&S defaults
	smb0 bit_flag_2 	;	(want errors returned to me)		[901127]
	jsr rddir		;Fake one with software...
	rmb0 bit_flag_2 	;	(clear error return flag)
	ldx jobnum		;						[900414]
	lda jobs,x		;Get the error from the RDDIR/RDBAM routines
	ldy #$ff		;Default to NO-DRIVE
	cmp #2			;Did we get a CRC/RNF error?		(CRC/data error)
	beq 10$			;   yes- branch (NO-DRIVE)
	cmp #9			;					(RNF/header error)
	beq 10$
	cmp #15			;   no-	 diskette then error		(DNR error)
	beq 10$
	jsr clearnodrv		;Show drive as being present
	bra 20$

10$	jsr setnodrv		;Set NO DRiVe condition for this drive
	bra autoi_rts		;Always

20$	smb0 bit_flag_2 	;return on error
	jsr initdr		;Init this drive
	rmb0 bit_flag_2

autoi_rts
	bra testnodrv		;Return no drive state for this drive

	.page
; Parse & execute string in CMDBUF

parsxq	jsr okerr		;set error channel to 00,OK,00,00
	jsr bamclean		;show this drive as having a clean BAM

;	lda bit_flag		;Keep only AUTO INIT flag			[901127]
;	and #bit3		;						[900429]
;	sta bit_flag
	lda #$ff-bit3		;						[911010] FAB
	trb bit_flag

;	lda bit_flag_1		;Turn off UNSCRATCH, ALLOW D1, & DIR IN PROGRESS flags
;	and #$ff-bit5-bit2-bit0
;	sta bit_flag_1
	lda #bit5+bit2+bit0	;						[911010] FAB
	trb bit_flag_1

	lda orgsa
	bpl 5$
	and #$0f
	cmp #$0f
	bne open

5$	jsr cmdset		;Set variables, regs	returns with Y = 0
	lda (cmd_buf_ptr),y
	tax			;						[910204] DJJ
	and #$7f
	sta char
	txa
	and #bit7
	tsb bit_flag

	ldx #ncmds-1
10$	lda cmdtbl,x		;Is this a good command?
	cmp char
	beq 20$			;	yes
	dex			;All commands checked?
	bpl 10$			;	no
	bra bad_command

20$	stx cmdnum		;.x = cmd #
	cpx #parsed_commands	;commands not parsed
	bcc 30$
	jsr tagcmd		;Set tables, pointers & patterns

30$	ldx cmdnum
	lda cjumpl,x
	sta temp
	lda cjumph,x
	sta temp+1
	jmp (temp)		;Jump to the command

	.page
; Command termination
;

endcmd	jsr bamclean	;Show this BAM as being clean


; Entry point for routines which do not want to force the BAM as being clean.

endsav			;   entry point for save
	jsr lda_erword	; was there an error?						[910313]
	bne cmderr	;   yes, last command had an error
;	tay		;   no,	 set track and sector to zero & error msg to "OK"	[901127]
	sta track	;		(sector reset below)


; Scratch termination
;
; On entry A = number of files scratched

scratch_end		;scrend.
	ldy #0		;								[901127]
	sty sector	;					scratch entry


partition_end		;partend.				partition entry
	sty cmd_buf_ptr	;set the command buffer ptr to beginning
	jsr errmsg	;put the error msg into the buffer
	jsr erroff	;turn off the error led


; Entered here by the CLOSE routine ONLY if a fatal IP error occurs

scren1	jsr clearnodrv	; default to drive 'OK'
;	jsr clrcb	; fill the command buffer with zeros				[901127]
	jsr freich	; free internal channels
	bra background	;								[900610]


; Clear the command buffer						removed		[901127]
;
;clrcb	ldy #cmdlen-1
;	lda #0
;10$	sta cmdbuf,y
;	dey
;	bpl 10$
;	rts

	.page
syntax_error
	lda #badsyn
	   .byte $2c
no_drive_present
	lda #nodriv
	   .byte $2c
bad_command
	lda #badcmd
	   .byte $2c
bad_filename			;						[911017] FAB
	lda #badfn		;Bad filename error
	   .byte $2c
missing_filename_error
	lda #nofile
	   .byte $2c
no_channel
	lda #nochnl
	   .byte $2c
record_not_found		;no_record.
	lda #norec
	   .byte $2c
no_block
	lda #noblk
	   .byte $2c
file_open_error			;				[901204] DJJ
	lda #filopn
	   .byte $2c
file_not_found
	lda #flntfd
	   .byte $2c
file_type_mismatch
	lda #mistyp

;
; command level error processing
;

cmderr	ldy #0
	sty track
	sty sector
	bra cmder2

	.page
; TAG COMmanD
; Set up cmd structure IMAGE & file stream ptrs

tagcmd	jsr prscln		;Look for required ':'
	beq missing_filename_error


; Entered here by DSKCPY.......................

tc30	dey			;Point to ':'
	dey			;Point to drive number
	sty filtbl		;Mark start of FS1
	txa
;	bne missing_filename_error
	bne bad_filename	;						[911017] FAB


; Entered here by LOAD_DIRECTORY...............

tc35	jsr look_4_equal	;Look for '='
	txa			;found?
	beq 40$			;	no
	lda #%01000000		;	yes- Set G1 bit flag for 'more files'
40$	ora #%00100001		;Set E1 & E2 to force drive number to be used and
	sta image		;to show there's a 2nd file name (filestream 2)
	inx
	stx f1cnt		;filestream 1 count
	stx f2cnt		;filestream 2 count defaults to filestream 1 count

	lda patflg		;Were any wildcards found by PARSE?
	beq 50$			;	no
	lda #%10000000		;	yes, set P1 flag
	sta image
	lda #0
	sta patflg		;	and clear pattern flag

50$	tya			;Are there more filenames?
	beq 75$			;	no
	sta filtbl,x		;	yes, mark position
	lda f1cnt		;	     fs2 is here now,...
	sta f2ptr		;		...now set f2 ptr
	lda #$8d		;find shifted-cr (should not exist)
	jsr parse		;parse rest of cmd string
	inx			;advance filtbl ptr to end
	stx f2cnt		;save it
	dex			;restore for test
	lda patflg		;save last pattern
	beq 60$			;any patterns?
	lda #%1000		;yes, p2-bit
60$	cpx f1cnt		;f2cnt = f1cnt+1?
	beq 70$
	ora #%0100		;g2-bit
70$	ora #%0011		;e2-bit,~e2-bit
	eor image		;eor clears ~e2-bit
	sta image

75$	lda image
	ldx cmdnum
	and struct,x		;match cmd template
	beq 80$
	ldx drvnum		;						[910313]
	sta erword,x		;Place any non-zero value here to prevent the CLOSE
	bra syntax_error	;routine from writing out the BAMs even if they're dirty

80$	rts

	.page
;look_4_path			;						[910610]
;	ldy #0			;				unused, removed	[910801]
;	ldx #0
;	lda #'/'
;	bra parse

prscln
	ldy #0			;Start at the beginning of command buffer
	ldx #0
look_4_colon
	lda #':'		;search for a colon
	   .byte $2c
look_4_equal
	lda #'='		;search for an equal sign

;********************************************************************************
;*				    PARSE					*
;*  Looks for special characters, and returns when the character is found or	*
;*  the end of the string is reached.						*
;*										*
;*	On ENTRY	A: Character sought					*
;*			X: Channel or index into the variable tables		*
;*			Y: Index into the COMMAND BUFFER			*
;*			Z: Not used or abused					*
;*										*
;*	On EXIT		A: Varies depending on what you're looking for		*
;*			X: If not equal to the entry value then a comma		*
;*			   was located before the character sought (usually	*
;*			   an error).						*
;*			Y: Points one character past the character sought	*
;*			   or one character past the end of the command.	*
;*										*
;*		>>>>>	Returns <> if found, = if not found   <<<<<		*
;*										*
;* Note: Corrected bug that was found in the 1540, 1541, 1581, 2031, 2040,	*
;*	 4040, 8050 8250 disk drives that prevented the user from actually	*
;*	 filling the command buffer to MXFILS.	For example, if you created	*
;*	 a disk with the filenames 1 thru 60 and sent a scratch command		*
;*	 "S0:1?,2?,3?,4?,5?" the  dos would only scratch filenames 1 thru 49.	*
;*							6/22/90 D. Jarvis	*
;********************************************************************************

parse	sta char		;Save the character sought
10$	cpy cmdsiz		;At the end of the string?
	bcs 30$			;	Yes, we're done
	lda (cmd_buf_ptr),y	;Get a character from buffer
	iny			;Increment character pointer
	cmp char		;Is it the character we're searching for?
	beq 35$			;	Yes

	bbr0 bit_flag,11$	;Branch if not called from new partition routine
	cmp #'/'		;Treat partition seperator the same as a comma
	bne 11$			;  (see OPENCLOSE.SRC for more info)		[900620]
	sty partition		;REMEMBER
	bbs1 bit_flag,26$	;Branch if not the 1st time we've seen this critter
	smb1 bit_flag		;Else set 'not-first-time' flag and...
	bra 10$			;Skip over it /0:fname/fname
				;	      ^ we're skipping over this one

11$	cmp #'*'		;Wildcard META character?
	beq 20$			;	yes
	cmp #'?'		;Wildcard skip single character?
	bne 25$			;	no
20$	inc patflg		;set wildcard flag

25$	cmp #','		;Filename (or type) separator?
	bne 10$			;	no
26$	sty filtbl+1,x		;Save the pointer to the character past the '/' or ','
	lda patflg
	and #$7f		;Mask 'comma exists in previous filename' flag
	beq 28$			;Branch if no wildcards used
	lda #bit7		;Else set bit 7 showing a comma was found
	sta pattyp,x
	sta patflg
28$	inx			;Move up to the next index into the file entries
	bbs0 bit_flag,29$ 	;Branch if we were called from new partition routine
	cpx #mxfils		;Done, or out of entries?			[900623]
	   .byte $2c
29$	cpx #max_entries+1	;Out of entries?				[910528]
	bcc 10$			;	no, continue
30$	ldy #0			;	yes, show buffer overrun or max files exceeded
				;	     (sets '=' status for return)

35$	lda cmdsiz		;Mark where the end of the command is
	sta filtbl+1,x
	lda patflg		;Any wild cards found?
	and #$7f		;	mask comma flag
	beq 40$			;	no wildcards found
	lda #bit7
	sta pattyp,x		;	yes, set flag

40$	tya			;Return current position (& '=' flag set appropriately)
	rts

	.page
; Initialize command tables, ptrs, etc.
;

cmdset	lda #0			;						[910717] DJJ
	ldy cmd_buf_ptr		;Any characters in the buffer?
	sta cmdbuf,y		;delimit buffer for pattern match routine	"
	beq 20$			;	no
	dey			;Is there only one character in the buffer?
	beq 10$			;	yes
	lda cmdbuf,y
	cmp #cr
	beq 20$
	dey
	lda cmdbuf,y
	cmp #cr
	beq 20$
	iny
10$	iny
20$	sty cmdsiz		;set cmd string size
	cpy #cmdlen+1
	ldy #$ff
	bcc cmdrst
	sty cmdnum		;Prevent error routine from writing out the BAM
	lda #longln		;Report line too long error
	bra cmderr

	.page
; Clear variables & tables
;

cmdrst	ldy #0
	tya
	sta cmd_buf_ptr		;Rewind cmd buffer pointer
	sta rec			;RECord back to zero
	sta type
	sta typflg
	sta f1ptr
	sta f2ptr
	sta f1cnt
	sta f2cnt
	sta patflg
	ldx drvnum		;						[910313]
	sta erword,x		;

; The next store allows the user to read only part of an error msg without confusing the DOS.

;	lda drvnum
	txa			;						[910313]
	asl a
	tax
	lda errbuftbl,x
	inc a
	sta err_buf_ptr		;reset err msg buffer back to beginning		[900820]
	tya			; ACC = 0
	ldx #mxfils
10$	sta filtbl-1,x
	sta entsec-1,x
	sta entind-1,x
	sta file_drive-1,x
	sta pattyp-1,x
	sta filtrk-1,x
	sta filsec-1,x
	dex
	bne 10$
	rts

	.page
;match			;							[910528]
;10$	jsr 120$
;	cmp #"?"
;	beq 20$		; if ? in cmdbuf then skip a dirbuf char
;	cmp #"*"
;	beq 40$		; do tests for *
;	cmp (dirbuf),y
;	bne 100$
;20$	inx		; next character of cmdbuf and dirbuf
;	iny
;	cpy #17
;	bcs 30$
;	jsr 110$
;	bne 10$		; no, so loop
;30$	jsr 120$
;	beq 90$		; succeed if at end of cmdbuf and dirbuf
;	cmp #"*"
;	bne 100$	; also allow cmdbuf ending in *(s)
;	inx
;	bne 30$
;
;; handle *<cmdbuf>
;
;40$	inx
;	jsr 120$
;	beq 90$
;	cmp #"*"	; **
;	beq 40$		; loop on extra *'s
;	cmp #"?"	; *?
;	bne 60$
;	iny		; skip one dirbuf character
;	cpy #17
;	bcs 50$
;	jsr 110$
;	bne 40$		; no then loop for next character of cmdbuf
;50$	inx
;	jsr 120$
;	beq 90$		; succeed if at end of cmdbuf
;	cmp #"*"	; *?*
;	beq 50$		; loop if *
;	bne 100$	; otherwise fail
;
;60$	sta tmp		; store away char we want to search for
;	dey		; set up y properly for loop
;70$	iny
;	cpy #17
;	bcs 100$
;	jsr 110$
;	beq 100$	; fail if we reach end of dirbuf
;	cmp tmp		; is it the one we're looking for?
;	bne 70$		; no, so loop
;	pha
;	phx
;	phy		; push current state on stack
;	jsr 20$		; recursion call through 20$ to continue test
;	bcc 80$		; we succeeded
;	ply
;	plx
;	pla
;	sta tmp		; occurence, so restore state and
;	bne 70$		; try searching for *<char> some more
;
;80$	ply
;	ply
;	ply		; clean up stack
;
;90$	clc		; carry clear = success
;	rts
;
;100$	sec		; carry set = failure
;	rts 
;
;110$	lda (dirbuf),y
;	cmp #$a0
;	rts
;120$	lda cmdbuf,x
;	cpx limit
;	rts

	.page
;----------------------------------------------------------------------------
; Pattern Matching Routine							[910716] new
; * - any number of characters including 0   a*.src   a*   *src
;     sliding match			     *abc*  must contain "abc"
; ? - must have this char (may be anything)  ?a* 2nd char must be "a"
; # - must be an ascii digit		     *#.src all src files w/ a number
; $ - must be a letter			     *$.src all src files w/ a letter
;----------------------------------------------------------------------------
;
;output: carry clear on match
;	 carry set on no match
;
;match	stx beginpat
;	dec limit
;patcont
;	lda cmdbuf,x
;	cmp #'*'
;	bne patsing	;handle single character
;
;; handle obscure uses of the asterik
;
;asterik
;	cpx limit	;char after * is end of pattern?
;	bcs satisfy	;	this is a hit.
;	inx		;	otherwise, point to next character
;
;slidemat
;	jsr slide	;use sliding match to locate specific pattern
;	bcs unsatis	;	if pattern not found in slide, no-go on this name
; 
;	cpx limit	;if satisfied, so far, see if there's more to check
;	bcc patcont	;	if so, continue to check
;	beq patcont	;	if so, continue to check
;	bcs satisfy	;	fail search if pattern's index is out of range
;
;patsing
;	jsr looksngl	;look for special char (#, $, ?, and exact match)
;	bcs unsatis
;	iny
;	jsr endcheck
;	php
;	inx
;	plp
;	bcs patcont
;	jsr entcheck	;is file entry ptr at end of name?
;	bcs patcont	;	no next
;
;	.page
;satisfy clc
;	rts
;
;unsatis sec
;	rts
 
	.page
;----------------------------------------------
; check end of filename in cmdbuf indexed by .x

endcheck
	lda cmdbuf,x
	cmp #'*'
	beq 20$ 
	cpx limit
	bcs 20$
	sec
	rts
20$	clc
	rts


;----------------------------------------------
; check end of file name in line indexed by .y

entcheck
	cpy #2+16+1		;skip over '0:'+filename
	bcs 10$
	lda (dirbuf),y
	cmp #$a0		;end of filename padding
	beq 10$
	sec
	rts
10$	clc
	rts

	.page
;------------------------------
; do an instr in m/l code
 
slide	stx beginpat		;save index to beginning of pattern
	sty beginame		;save index to beginning of name
 
			;Start slide here...
5$	ldx beginpat		;.recheck	point to beginning of the pattern
10$	lda cmdbuf,x		;if there's an asterik
	cmp #'*'
	beq 30$			;	I think we're home!
 
	jsr looksngl		;compare w/ single character criteria
	bcs 20$			;	no match, skip to next char & retry
	iny			;point to next char in name
	cpx limit		;compare here for end check
	inx			;point to next char in pattern
	bcc 10$			;	if that was not the last character, move to next char
 
 	jsr entcheck		;we are at the limit in pattern!
	bcc 30$			;	branch if at the last char in the name
 
			;Restart search at next entry name char...
20$	inc beginame		;.slnext	next entry name char
	ldy beginame
	jsr entcheck		;did we run out of entry name?
	bcs 5$			;	if not, go for it!
	sec
	rts
 
30$	clc		;.slhit
	rts
 
	.page
;---------------------------------------
; check single char or special data types
;---------------------------------------
; carry clear if data type is found

looksngl
	lda cmdbuf,x		;check for single char
	cmp #'?'
	bne 10$
 
	jsr entcheck
	bcc 30$			;	fail
	bcs 20$			;	pass
 
10$	cmp (dirbuf),y		;an exact match
	bne 30$
 
20$	clc			;.lpass
	rts

30$	sec			;.lpfail
	rts

;.end
	.page
	.subttl	 COPY	v910424

;				DiSK Copy
; USAGE:
;	COPY [SD] "SOURCE_FILENAME" TO [DD] "DESTINATION_FILENAME"
;		copy source filename to the destination filename.
;		or,
;	OPEN 15,dv,15, "C[DD]:DESTINATION_FILENAME=C[SD]:SOURCE_FILENAME"
;
;	COPY SD TO DD
;	COPY SD,"*.SRC" TO DD,"*"
;	COPY SD,"*=SEQ" TO DD,"*"
;		copy all files on source drive to destination drive.
;		note that drive numbers are required.  Pattern matching legal.
;	
;	CONCAT [SD] "FIRST_FILENAME" TO [DD] "SECOND_FILENAME"
;		the contents of the first filename on the source drive is concatenated
;		to the end of the second filename on the destination drive
;
;			WHERE: SD = Source Drive number
;			       DD = Destination Drive number
;
;			OR:    "1:RESULT=1:FIRST_FILE,0:SECOND_FILE"
;
;		This would concatenate a file on drive 1 called "first_file", and
;		a file on drive 0 called "second_file". The concatenated file is
;		"RESULT" and is created on drive 1.


dskcpy	smb2 bit_flag_1		;Allow '1:' syntax in command buffer
	jsr prscln		;find   ':'
	bne 10$			;	branch if found


; Parse C(DRV)=(DRV), which will copy ALL files from one drive to another.
;
; This routine will take each filename in the source file's directory sector
; and append it after the second drive number above (DRV).  This routine will
; now skip over open or splat files, correcting a bug in DOS 2.7			[910328]

	jsr prseq		;Find '=' and get both drive numbers
	lda #'*'		;copy all files
	ldx #40-1		;put at buffer end			(was cmdlen-1)	[911010] DJJ
	stx filtbl+1
	sta cmdbuf,x
	inx
	stx cmdsiz
	ldx #1			;set up cnt's
	stx f1cnt
	inx
	stx f2cnt
	bra 40$			;enter routine to find optimum search of files in the table

	.page
; At this point we have found a colon (at .y-1) in the buffer, but it does not follow a comma.

10$	phy			;COPY source TO D:"*"					[910418]
	stx tmp			;							[911028] DJJ
	jsr look_4_equal
	beq 20$			;	not found
	phy			;COPY source=type TO dest:"*"				[910430]
	jsr look_4_equal
	beq 15$			;	not found
;	lda cmdbuf,y
;	jsr fs1set_1
;	ply			; temporary patch to allow *=SEQ, etc.			[910917] DJJ
;	sty tmp
;	sec
;	lda cmdsiz
;	sbc tmp
;	sta cmdsiz
;	inc cmdsiz
;	   .byte $89
	phy			;save pointer to filetype				[911010] FAB
	lda cmdbuf,y
	jsr fs1set_1		;set filetype
	ply
	dey			;point to =sign
	sty cmdsiz		;kludge: make this the end of the command

15$	ply			;pointer to 1st =sign +1
	dey			;point to =sign
	dey			;point to filename
	lda cmdbuf,y
	cmp #'*'
	bne 20$
	iny
	lda #','
	sta cmdbuf,y
20$	ply
	ldx tmp			;							[911028] DJJ
	jsr tc30		;Check the command for syntax errors
	jsr alldrs		;Locate and place drive numbers in file_drive [F1CNT]
	lda image		;Get parse image
	and #%01010101		;Normal copy or concat?
	bne dx0020		;	yes

	ldx filtbl		;Check for C1:FNAME=0:* or C0:FNAME=1:*
	lda cmdbuf,x		;If this is the case then error out
	cmp #'*'
	bne dx0020

; Copy Drive to Drive with wildcards

	ldx #1			;Set cnt's
	stx f1cnt
	lda file_drive		;Get destination drive number
	cmp file_drive+1	;Compare with source drive number
	beq dx0010		;	same: C?:*=* is an error
	inx
	stx f2cnt
	lda filtbl+1		;Save pointer to source file in cmd buf
	sta temp
	ldx cmdsiz		;prep to move
	ldy #40			;Shift all of the buffer down		(was cmdlen-1)	[911010] DJJ
	sty cmdsiz		;end of filename2

30$	dey
	dex
	lda cmdbuf,x		;mov fn lifo
	sta cmdbuf,y
	cpx temp		;actual f2 val
	bne 30$
	sty filtbl+1		;pointer to f2

40$	jsr optsch		;Set optimum search pattern
	jsr pups1		;setup first pass
	jsr ffst		;first match
	bpl fixit		;entry found?
	bra endcmd		;	no

exlp0	pla			;Restore values for next filename
	sta dirsec
	pla
	sta filtbl+1
	pla
	sta lstbuf
	pla
	sta filcnt
	pla
	sta index
	pla
	sta found
	pla
	sta delind
	pla
	sta drvflg

exlp1	jsr pups1		;set up vars
	jsr ffre		;next match
	bmi endcmd		;If none, branch

fixit	jsr tstchn		;Is this file already open?			[901127]
;	bcc file_open_error	;error if so
	bcc exlp1		;Yes then skip over it				[910501]
	ldy #0			;(fixes bug in DOS1.4 thru 2.7 excluding DOS2.6, and TED 488)
	lda (dirbuf),y		;Skip over CBM file types
	and #typmsk
	cmp #partyp
	beq exlp1

	lda drvflg		;push needed vars
	pha
	lda delind
	pha
	lda found
	pha
	lda index
	pha
	lda filcnt
	pha
	lda lstbuf
	pha
	lda filtbl+1
	pha
	lda dirsec
	pha

;	jsr trfnme		;transfer name from the directory sector to CMDBUF	[911010] DJJ
;				; C [dest drive #] = 'filename',  padded with $A0 just	(moved inline)
;				;like it sits in the directory sector!

	ldy #3			;Skip past "C?=",  where ? = target drive number
	sty filtbl		;Set beginning of filename 1
10$	lda (dirbuf),y		;Move it
	sta cmdbuf,y
	iny
	cpy #19			;all 16 chars passed?
	bne 10$

	lda #1			;fake out lookup with only one filename to search for
	sta f1cnt
	sta f2cnt
	lda file_drive+1	;Switch to the source drive
	and #1
	tax
	jsr setup_err
	jsr lookup		;Lookup the filename we just placed in the CMDBUF
;	jsr chkin
	lda #1
	sta f1cnt
	inc a
	sta f2cnt
	jsr cy			;copy it
	bra exlp0		;next one

;
; set up subroutine
;

pups1	lda #0
	sta rec
	sta drvcnt
	sta filtrk		;Show no files on either drive as being found yet
	sta filtrk+1
	lda file_drive+1	;get source drive number
	and #1
	tax
	jsr setup_err		;Prep error message buffer for source drive
	lda #1
	sta delsec		;nonzero
	lda filtbl+1		;fn1=fn2
	sta filtbl
	rts

	.page
; Copy file(s) to one file
;

copy	jsr lookup		;Look up all files in the file stream
	lda f2cnt		;If less then 3 files named then it's
	cmp #3			;a standard copy request and not a CONCAT request
	bcc 30$			;	branch if less than 3 (standard copy)

	lda file_drive		;Branch if they're not...
	cmp file_drive+1	;		... same drive
	bne 30$
	lda entind		;		.... same file entry
	cmp entind+1
	bne 30$
	lda entsec		;		.... same directory sector
	cmp entsec+1
	bne 30$

;  Perform a CONCAT		DRV:FILENAME=DRV:FILENAME

	jsr chkin		;Check the source drive to insure the file is found
	lda #1
	sta f2ptr
	jsr opirfl		;Get a read channel
	jsr typfil
	bcc 20$			;Allow SEQ, PRG, and USR files			[911028] FAB
;	bcs 10$			;Can't concat REL or CBM file types
;	cmp #prgtyp		;Can't concat PRG file types
;	bne 20$
10$	lda #mistyp		;Error- bad file type
	bra cmderr

20$	ldx file_drive		;Set up source drive & error buffer pointers	[910328] FAB
	jsr setup_err
	lda #irsa		;Set up internal read channel
	sta sa
	jsr getlintab		;Get its lindx value
;	sta lintab+1,x		;Move LINTAB+IRSA into LINTAB+IWSA		[900416]
;	lda #$ff		;Mark LINTAB+IRSA as being inactive
;	sta lintab,x
;	inc sa			;Make IWSA the currently active SA
	pha			;						[910325] FAB
	lda #$ff
	sta lintab,x		;Make IRSA inactive
	lda file_drive+2
	sta drvnum
	inc sa			;Make IWSA active
	lda sa
	jsr getlintab
	pla
	sta lintab,x		;Move LINTAB+IRSA into LINTAB+IWSA
	lda file_drive
	sta drvnum		;Error buffer pointers already set for destination drv
	jsr append		;Move to the end of the destination file
	ldx #2			;Point to the source file now
	jsr cy10		;Copy it
	bra endcmd		;We're done 'OK'

30$	lda pattyp+1		;Skip partitions				[910501]
	cmp #partyp
	beq 35$
	jsr cy			;Go copy the file now
	lda file_drive+1	;????						[910801] DJJ
	and #1
	tax
	jsr setup_err
35$	bra endcmd

	.page
cy	jsr chkio		;Check files for existence
	lda file_drive		;Make the destination drive active
	and #1
	tax
	jsr setup_err		;Set DRVNUM & error buffer pointers
	jsr opniwr		;Open internal write channel
;	lda file_drive+1	;						[910408] DJJ
;	and #1
;	tax
;	jsr setup_err
	jsr addfil		;Add filename to directory
	ldx f1cnt

cy10	stx f2ptr		;Set up read file
	jsr opirfl		;Open an internal read file on the source drive
	lda #irsa
	sta sa
	jsr fndrch
	jsr typfil_1		;Is it a relative file?				[901127]
	bne 10$			;	no
	jsr copy_relative_file

10$	smb4 bit_flag_1		;Set No EOI flag
	bra 20$

15$	jsr pibyte		;Place the byte into the dest file
20$	jsr gibyte		;Get a byte from the source file
	lda #lrf		;Was the character we got before the last JSR PIBYTE
	jsr tstflg		; the last one?
	beq 15$			;	no
	jsr typfil		;Was this a rel file type?
	beq 30$			;	Yes then branch
	jsr pibyte		;	No then place last byte into the file
30$	ldx f2ptr
	inx
	cpx f2cnt
	bcc cy10		;Branch if more files to copy
	lda #iwsa
	sta sa
	bra close_one_channel	;close copy channel, file

	.page
opirfl	ldx f2ptr		;Get the file number we're on
	lda file_drive,x	;Get the drive number
	and #1			;	want only the drive number
	tax
	jsr setup_err		;	set DRVNUM & appropriate error buffer

	ldy drvnum
	lda dirtrk,y		;Get the directory track for this file		[900415]
	sta track
	ldx f2ptr
	lda entsec,x		;Get the directory sector for this file
	sta sector

	jsr opnird		;Open internal read channel
	ldy f2ptr		;						[910502]
	lda entind,y		;Setup index into file
	jsr setpnt
;	ldx f2ptr
	lda pattyp,y		;Setup the file type
	and #typmsk
	sta type
	lda #0
	sta rec			;Set record size to zero

	jsr opread		;Open file for reading

	ldy #1			;Point to the sector in the T&S links
	jsr typfil
	beq 10$			;	branch if relative file
	iny			;if it's a relative file then move past the record length????
10$	tya			;move pointer into A
	bra setpnt		;Set DIRBUF to point at the first data byte

	.page
gibyte	ldx f2ptr		;Set input device				[910325] FAB
	lda file_drive,x	;(see comments at GetLinTab)			[901003] DJJ
	and #1
	tax
	jsr setup_err
	lda #irsa		;Set internal read SA
	sta sa
	jsr gbyte		;Go get one byte
	sta data		;	Save it for now
	ldx lindx		;Get index number				[910117]
	lda chnrdy,x		;Is this the last byte to be sent?
	and #eoisnd
	bne 10$			;	branch if not

	rmb4 bit_flag_1		;Set EOI received flag
	jsr typfil		;Is this a relative file?
	beq 10$			;	yes
	lda #lrf		;	no- set the last record flag too
	bra setflg

10$	rts

	.page
; COPY RELATIVE FILES	(Dennis, you need to correct the file existence bug????)

copy_relative_file
	jsr setdrn		;Set up the drive number for this file
	jsr ssend		;Get the side sector index value

	bbr5 bit_flag_2,10$	;Branch if this isn't a big relative file
	lda grpnum		;Save group #
	pha
10$	lda ssind		;Save the index number
	pha
	lda ssnum		;And the side sector number
	pha
	lda #iwsa
	sta sa
	jsr fndwch		;Get the active write channel (lindx)
	jsr adrels		;Add the relative file to the directory of the target drive
	sta relptr
	pla
	sta ssnum
	pla
	sta ssind
	bbr5 bit_flag_2,20$	;Branch if this isn't a big relative file
	pla
	sta grpnum		;else restore group #
20$	bra addr1

	.page
; Transfer filename from dirbuf to cmdbuf			moved to inline	[911010] DJJ
;
;trfnme	ldy #3			;Skip past "C?=",  where ? = target drive number
;	sty filtbl		;Set beginning of filename 1
;
;10$	lda (dirbuf),y		;Move it
;	sta cmdbuf,y
;	iny
;	cpy #19			;all 16 chars passed?
;	bne 10$
;	rts




prseq	jsr look_4_equal	;Find the '=' sign
	bne x0020		;	branch if found
dx0010	bra syntax_error	;	else error


dx0020	lda image		;Check for normal copy command
	and #%11011001		;Wild cards are NOT allowed
	bne dx0010		;	error- they used wildcard
	bra copy		;Go copy files


x0020	lda cmdbuf,y		;Get source drive
	jsr tst0v1
	bmi dx0010		;	none specified, error
	sta file_drive+1	;	save the source drive
	dey
	dey
	lda cmdbuf,y		;Get destination drive
	jsr tst0v1
	bmi dx0010		;	none specified, error
	cmp file_drive+1	;Compare source & destination drive numbers
	beq dx0010		;	if same, error
	sta file_drive		;	save the destination drive
	rts

;.end
	.page
	.subttl	 BLOCK	v910601

; 910601	Corrected bugs in:
;		File-Restore that would write directory sector back before it
;		completed the restoreation process. If a bam corrupted error
;		occured this would set the user up to trash his disk.
;		File command parser that used -1 to define the commands
;		address. When the jsr (fcmdadd,x) was added I forgot to
;		remove this.

;**************************************************************************
;*			    FILE_COMMANDS				  *
;*									  *
;* The following set of command channel routines were added to allow the  *
;* user a graceful way of manupilating files.  These commands are setup	  *
;* as follows:								  *
;*									  *
;*	"F-L"  Lock a file to prevent it from being scratched		  *
;*	"F-U"  Unlock a file and allow it to be scratched		  *
;*	"F-R"  Restore a file after it has been scratched		  *
;*									  *
;* Following each command above is the drive number, followed by a colon  *
;* then followed by the filename(s).  For example, to lock all the files  *
;* on drive 0 you would send the following file command:		  *
;*									  *
;*	       OPENXX,xX,15,"F-L0:*"					  *
;*				OR					  *
;*	       OPENXX,XX,15,"F-L0:FNAME,FNAME1,FNAME2, ... etc		  *
;*							      7,25,90 DJJ *
;**************************************************************************

fcmdtbl
	.byte 'LUR'		;Lock, Unlock, Restore
fcmdtbl1

fcmdadd .word lock_file		;							[910610]
	.word unlock_file
	.word restore_file


file_commands			;							[900814]
	iny
	lda #'-'
	cmp cmdbuf,y
	bne bad_command
	iny
	ldx #fcmdtbl1-fcmdtbl-1
10$	lda cmdbuf,y
	cmp fcmdtbl,x		;Search for the command they want
	beq 20$			;Found it so branch
	dex
	bpl 10$
	bmi bad_command		;Bad command error

20$	sta cmdnum		;Store any non zero value to show ERROR routine that	[910528]
	txa			;this error did NOT occur during a validate command!
	asl a			;*2
;	tax
;	lda fcmdadd+1,x
;	pha			;Save routine to be called onto the stack
;	sta cmdnum		;Store any non zero value to show ERROR routine that
;				;this error did NOT occur during a validate command!
;	lda fcmdadd,x
	pha
	smb2 bit_flag_1		;							[910801] DJJ
	jsr alldrs		;Set up for 1 file stream ONLY				"
	jsr optsch		;Setup drive search pattern
	lda #0
	sta r0			;Clear possible number of files unscratched
	plx			;							[910528]
	jsr (fcmdadd,x)
	rts

lock_file
	jsr ffst		;Search for the 1st. file in the stream
	bmi 30$			;Done, no files in the stream matched
10$	ldy #0
	lda (dirbuf),y
	bpl 20$
	taz
	and #bit6		;Already locked?
	bne 20$			;Then go try the next one
	tza
	ora #bit6		;Set lock bit
	sta (dirbuf),y
	jsr increment_r0	;Show one more file being locked
15$	jsr wrtout

20$	jsr continue_search	;Go find the next file
	bpl 10$			;Found one then branch
30$	lda r0
	sta track
;	ldy #0			;Reset cmd buffer to the begining			[901127]
	lda #3
	bra scratch_end

restore_file
	jsr mapout		;Write out the bam if dirty				[910601]
	lda #0			;Force error routine NOT to write out the bam if
	sta cmdnum		;an error occurs or we will trash the disk

	smb5 bit_flag_1 	;Show UNSCRATCH in progress
;	lda #0			;							[901127]
;	sta delsec
	jsr ffst		;Search for the file they want to restore
	bmi 30$			;None found then bug out

10$	ldx #0			;Start with file entry 0
	jsr restore_file_status
;	jsr wrtout		;Go write out the directory sector			[910601]
	ldy #0
	lda (dirbuf),y
	and #7
	cmp #partyp
	bne 15$
	jsr validate_partition
	bra 17$

;15$	ldy #1			;							[910601]
;	lda (dirbuf),y
;	sta track
;	iny
;	lda (dirbuf),y
;	sta sector
;	jsr markts		;Mark file in use in bam, don't write out bam yet
;17$	jsr increment_r0

15$	ldy #1			;Move over to the file's starting TRACK			[910601]
	jsr validate_bam_2	;Set up T & S, and handle side sectors
	jsr markts		;Mark file in use in bam, don't write out bam yet
17$	jsr wrtout		;Write out the directory sector
	jsr increment_r0

20$	lda #0			;Deleted sector not found
	sta delsec
	inc a			;Show we're looking for a deleted entry now
	sta delind
	jsr fndfil
	bpl 10$			;Found one that matched so branch
30$	jsr mapout		;Write out bam now! (if at least one file restored)
	lda r0
	sta track
	rmb5 bit_flag_1
	lda #0
	sta delind		;No longer looking for a deleted entry
	sta delsec		;	and deleted sector not found
	lda #5
	bra scratch_end

unlock_file
	jsr ffst		;Search for the 1st. file in the stream
	bmi 30$			;Done, no files in the stream matched
10$	ldy #0
	lda (dirbuf),y
	bpl 20$
	taz			;Save file status byte
	and #bit6		;Save lock flag
	cmp #bit6		;Was the file previously locked?
	tza
	bcc 20$			;No then branch
	and #$ff-bit6		;Clear locked bit
	sta (dirbuf),y
	jsr increment_r0
15$	jsr wrtout		;Write out this sector

20$	jsr continue_search	;Go find the next file
	bpl 10$			;Found one then branch
30$	lda r0
	sta track
;	ldy #0			;							[901127]
	lda #4			;Scratch for debugging
	bra scratch_end

increment_r0
	inc r0			;Increment # of files restored, locked ,or unlocked
	bne 10$
	smb2 bit_flag		;Set flag for value >256 characters
10$	rts

	.page
; User commands

user	ldy cmdbuf+1
	cpy #'0'
	bne us10		;0 resets pntr
	ldy cmdbuf+2
	cpy #'>'
	beq chgutl


;*  NOTE: I've now made it possible for the user to change the USER vector
;* without requiring a memory write.  The method is as follows:
;*	"U0"+NEW_VECTOR_LSB+NEW_VECTOR_MSB	  			6/30/90 D. Jarvis
;*	 12		3	   4

usrint	ldy cmdsiz		;Set vector to new address?
	cpy #2			;Is this the simple U0 command?
	beq usrint_1		;	Yes then restore the vector
	cpy #4			;	No then use default
	bne usrint_rts

	ldy cmdbuf+2
	lda cmdbuf+3
	bra usrint_2


usrint_1
	ldy #<ublock		;set default block add
	lda #>ublock
usrint_2
	sty usrjmp
	sta usrjmp+1
usrint_rts
	rts


us10	dey			;entry is (((index-1)and$f)*2)
	tya
	and #$0f
	asl a
	tay
	lda (usrjmp),y
	sta ip

	iny
	lda (usrjmp),y
	sta ip+1
	jsr (ip)
	tax			;						[910528]
	bra endcmd

	.page
; Block commands
;
; Open direct access buffer from open '#'
;

opnblk	lda sa			;Save the secondary address
	pha
	jsr autoi
	pla
	sta sa
	ldx cmdsiz		;Did they specify a specific buffer to use?
	dex
	bne 10$			;	Yes then branch
	lda #1			;	No then get any ONE buffer
	jsr getrch
	bra 30$			;Always

5$	bra no_channel		;Done this way to save 1 byte

10$	ldy #1			;Skip past the '#' character
	jsr bp05		;Convert from ASCII to DEC
	ldx filsec		;Get the buffer # they requsted
	cpx #bamjob		;If it's a BAM, CMD, or ERROR buffer then generate an error
	bcs 5$

	lda #0
	sta temp		;Set the bit in TEMP to represent
	sta temp+1		;which buffer they've requested (see BUFUSE)
	sta temp+2
	sec

15$	rol temp
	rol temp+1
	rol temp+2		;						[900314]
	dex
	bpl 15$
	lda temp		;If the buffer is currently in use
	and bufuse
	bne 5$			;	generate an error
	lda temp+1
	and bufuse+1
	bne 5$			;	same here
	lda temp+2
	and bufuse+2
	bne 5$			;	same here				[900314]

	lda temp		;Show the buffer as being in use now
	tsb bufuse
	lda temp+1
	tsb bufuse+1
	lda temp+2		;						[900314]
	tsb bufuse+2
	lda #0			;Show no buffer needs allocated
	jsr getrch		;But set up the LINDX #
	jsr actledon
	ldx lindx
	lda filsec		;Show the requested buffer as the Primary buffer
	sta buf0,x
	tax			;Use the buffer # as an index
	lda drvnum		;Save the current drive # as the last job drive #
	sta lstjob,x

30$	lda sa			;Show this buffer as being both a read and a write buffer
	jsr getlintab
	ora #bit6
	sta lintab,x
	ldy lindx		;Get the index back
	lda #$ff		;Read/write all 256 bytes in the buffer
	sta lstchr,y
	lda #rndrdy		;Show us ready to talk or listen
	sta chnrdy,y
	lda buf0,y		;Return the buffer number that was allocated
	sta chndat,y		;(as the 1st char)
	asl a			;X = BUFFER # USED * 2
	tax
	lda #1			;Skip past the 1st byte of the buffer
	sta buftab,x
	lda #dirtyp+dirtyp	;Set up Direct TYPe of file
	sta filtyp,y		;file
	bra endcmd		;We're done

	.page
; Block commands
;

block				;parse_neg.					[910117]
	ldy #0
	ldx #0			;starting at the B, look for the extension
	lda #'-'
	jsr parse
	beq bad_command		;	not found
	txa			;Was there a comma before the '-'?
	bne syntax_error	;	yes- error
;	rts			;	no-  exit with Y pointing 1 char past '-'

;block	jsr parse_neg		;Search for '-'					[910117]
	ldx #bctab2-bctab-1
	lda cmdbuf,y
10$	cmp bctab,x		;Find command
	beq 20$			;	found it
	dex
	bpl 10$
	bra bad_command		;	no found- bad command error

20$	txa
	ora #bit7
	sta cmdnum
	jsr blkpar		;Parse parms
	lda cmdnum
	asl a
	tax
;	lda bcjmp+1,x		;					[910528]
;	sta temp+1
;	lda bcjmp,x
;	sta temp
;	jmp (temp)		;Goto command
	jsr (bcjmp,x)
	rts


bctab	.byte 'AFRWEP',$d2,$d7,'S'	;					[910117]
bctab2
bcjmp	.word blkalc		;block-allocate
	.word blkfre		;block-free
	.word blkrd		;block-read
	.word blkwt		;block-write
	.word blkexc		;block-execute					[910117]
	.word blkptr		;block-pointer
	.word xublkrd		;User read  with to tschk, new LSTCHR
	.word xublkwt		;User write with no tschk, new LSTCHR
	.word blkstat		;block-status					[900602]

	.page
;*  This routine, first added to the 1581 (NEW DOS 3.0, not normal dos 3.0),
;*  was installed because the users did not know HOW the thru B-R/W routines
;*  worked. This routine will allow them to read all of a sector.

xublkrd jsr xbkotst
	jsr drtrd
	jsr blkrd4
	bra ublkrd1

;*
;* This routine is the same as XUBLKRD except for writing
;*

xublkwt jsr xbkotst
	bra ublkwt1

;  BLocK PARser
; This subroutine is used to parse the parameters for the block commands.
; Note that each parameter MUST be seperated by a space, comma, or cursor right.
; Failure by the user to observe this could corrupt his diskette as there are
; NO saftey checks built in to guard against this error!

blkpar	jsr prscln		;Start at the 1st char in the command buffer and look for a colon
	bne bp05		;	branch if found
	ldy #3			;Else ASSUME the parameters start at the 2nd byte in the buffer and
				;the command was sent as 'B Xxxx'.  If not...

bp05	lda cmdbuf,y		;Start at the 1st char past ':' or '#' if called by open_block routine
	cmp #' '		;	Is it a space?
	beq bp10		;	       yes- skip over it
	cmp #29			;	Is it a cursor right?
	beq bp10		;	       yes- skip over it
	cmp #','		;	Is it a parameter seperator?
	bne bp20		;	       no-  use it as a parameter

bp10	iny			;Move over one char in the cmd buffer
	cpy cmdsiz
	bcc bp05		;Loop until we're at the end of the command
	rts			;We're done

bp20	jsr aschex		;Convert the ACC from ASCII to HEX
	inc f1cnt		;Bump the number of parameters received by one
	ldy f2ptr
	cpx #4			;Did we get more parameters than are allowed?
	bcc bp10		;	no
	bra syntax_error

	.page
;**********************************************************
;* Convert ASCII to binary and store the results in	  *
;* FILESEC  on entry Y = Index into the command buffer	  *
;*							  *
;* On exit FILESEC will contain the all the parameters.	  *
;* for example 'U1:2 0 40 3'				  *
;*							  *
;*		      filesec	=  2   [1st parameter]	  *
;*		      filesec+1 =  0   [2nd parameter]	  *
;*		      filesec+2 = 40   [3rd parameter]	  *
;*		      filesec+3 =  3   [4th parameter]	  *
;**********************************************************

aschex	ldz #0			;Set flag for CHGUTL call			[910205] DJJ
	   .byte $2c
aschex_1
	ldz #1
	lda #0
	sta temp
	sta temp+1
	sta temp+3
	ldx #$ff
10$	lda cmdbuf,y		;Test for dec #

; Note: this is testing the wrong value, but don't change it to #$41 or it will
; cause problems with existing software which relies on this "mistake".

	cmp #$40
	bcs 20$			;non-numeric terminates
	cmp #'0'
	bcc 50$			;non-numeric					[910205] DJJ
	and #$f
	pha
	lda temp+1		;shift digits (*10)
	sta temp+2
	lda temp
	sta temp+1
	pla
	sta temp
	iny
	cpy cmdsiz
	bcc 10$			;Loop until end of string

20$	sty f2ptr		;Save where we left off in the command buffer
	clc
	lda #0
30$	inx
	cpx #3
	bcs 40$
	ldy temp,x
35$	dey
	bmi 30$
	adc dectab,x
	bcc 35$
	clc
	inc temp+3
	bne 35$

40$	pha
	ldx f1cnt
	lda temp+3
	sta filtrk,x		;store result in table
	pla
	sta filsec,x
	rts

50$	cpz #1			;						[910205] DJJ
	bcc 20$
	rts


dectab	.byte 1,10,100		;decimal table

	.page
; BLOCK-FREE
;

blkfre	jsr blktst
	jsr frets

; The following used to be JMP ENDCMD.	It was changed to allow the BAM dirty flag
; to remain intact (normally it is reset by ENDCMD).  This allows the diskette to
; maintain a real-time BAM.

	bra endsav		;endcmd



; BLOCK-ALLOCATE
;
; NOTE: Since the this routine does not support a channel #, the command channel on
; one drive CAN allocate a sector on the other drive.....!!

blkalc	jsr blktst		;Parse the command
	lda sector		;Save the sector number they want to allocate
	pha
	jsr getsec		;See if there's a free sector on this track
	beq 15$			;	none free
	pla
	cmp sector		;Is there currently a free sector on this track?
	bne 30$			;	no- then none available

; The following bit set solves the problem where the WUSED generated an error message
; when the sector was already in use.

	smb5 bit_flag		;Set flag to prevent WUSED from generating a DIR ERROR message.
	jsr wused		;Mark this track and sector as used

; The following used to be JMP ENDCMD.	It was changed to allow the BAM dirty flag
; to remain intact (normally it is reset by ENDCMD).  This allows the diskette to
; maintain a real-time BAM.

	bra endsav

	.page
15$	pla			;pop stack

;*--------------------------------------------------------*
;* Scan thru all the tracks and sectors on this disk with *
;* the exception of the directory track to see if there's *
;* a free sector somewhere.  If there is, return them as  *
;* 65,NO BLOCK, TRACK,SECTOR where TRACK, SECTOR is the	  *
;* next available track and sector starting from track 1. *
;*--------------------------------------------------------*

20$	lda #0
	sta sector
21$	inc track
	ldy drvnum		;						[900415]
	lda track		;Can't allocate a sector on the Directory track
	cmp dirtrk,y
	beq 21$
	cmp maxtrk,y
	bcs no_block		;gone all the way
	jsr getsec
	beq 20$

30$	lda #noblk
	bra cmder2

	.page
; BLOCK READ SUBS
;

blkrd2	jsr bkotst		;Set up channel, drive, track , and sector
	bra drtrd		;Go read in the sector


;
; BLOCK-READ
;

blkrd3	jsr blkrd2		;Go read in the sector
blkrd4	lda #0			;Move back to track link pointer
	jsr setpnt
	jsr getpre		;get byte w/o inc to BUFTAB Y = LINDX, X = Y * 2
	lda (buftab,x)		;Get the number of bytes to send
	sta lstchr,y		;Save it
	lda #rndrdy
	sta chnrdy,y		;Mark buffer as ready for R/W
	rts


blkrd	jsr blkrd3
	jsr rnget1
	bra endcmd

;
; User direct read, lstchr = $ff to send all of the sector
;

ublkrd	jsr blkpar		;Parse the parameters
	jsr blkrd3

;*  Entered at this point by XUBLKRD command

ublkrd1	lda lstchr,y		;1st char. returned is the # of bytes to send
	sta chndat,y
	lda #$ff
	sta lstchr,y
	rmb0 bit_flag_2		;Release return errors to me flag		[901127]
	bra endcmd

	.page
;
; BLOCK-WRITE
;

blkwt	jsr bkotst		;Set up the parameters
	jsr getpnt		;Get the number of bytes to
	tay			;Write
	dey			;-1
	cmp #2			;Past the
	bcs 10$
	ldy #1
10$	lda #0			;set record size
	jsr setpnt
	tya
	jsr putbyt
	phx
	jsr drtwrt		;write block
	plx
	ldy lindx
	jsr rnget2
	bra endcmd


;
; User direct write, no lstchr	 (U2 command)
;

ublkwt	jsr blkpar		;Get paramters
	jsr bkotst		;Set up the parameters
ublkwt1 jsr drtwrt		;Go write out the sector
	bra endcmd

blkexc	jsr blkrd2		;Read in the sector into ram			[910117]
	lda #0
	sta temp		;Always at the first byte in the sector
	ldx jobnum
	lda bufind,x		;Get the msb of the buffer to be used
	sta temp+1
	jsr (temp)
	bra endcmd

	.page
;
; BUFFER-POINTER, set buffer pointer
;

blkptr	jsr buftst		;Check 1st parameter (buffer #) to see if it's okay.
				;If so,	 make it the currently active buffer number.
	lda jobnum		;Get this buffer's job number
	asl a			;* 2 as a pointer
	tax
	lda filsec+1		;get the second parameter (lsb pointer)
	sta buftab,x		;and make it the lsb pointer for this buffer
	jsr getpre		;get the 1st byte to send from the buffer
	jsr rnget2		;place it in the 1 char buffer and flag it as ready to xmit
	bra endcmd		;we're done

;
; Test for allocated buffer related to sa
;

buftst	ldx f1ptr
	inc f1ptr
	lda filsec,x		;Get the channel number number parameter
	tay
	dey
	dey
	cpy #bamjob
	bcs 10$
	sta sa
	jsr fndrch
	bcs 10$
	jsr getact
	sta jobnum
	rts

10$	bra no_channel		;Done this way to save 1 byte

	.page
;  TEST BLOCK OPERATION PARAMETERS
;

bkotst	jsr buftst		;Set up the channel number

;
; Test for legal block & set up drv, trk, sec
;

blktst	ldx f1ptr
	lda filsec,x		;						[900709]
	bne no_drive_present

;**********************************************************
;* NOTE: There's a bug in all CBM DOS versions that allows*
;* you to request a drive number 0 thru 255.		  *
;*			     1/12/1990 Dennis J. Jarvis	  *
;**********************************************************

;	lda drivenumber		;Get the phys. drive number			[900423]
;	sta drvnum
	phx
	ldx drivenumber		;Get the phys. drive number			[900423]
	jsr setup_err		;						[910805] FAB
	plx
	lda filsec+2,x
	sta sector
	lda filsec+1,x
	sta track
	jsr tschk		;Check for a bad track or sector
	bra actledon		;Turn on drive's activity LED & rts

xbkotst	jsr buftst		;Test parameters
	ldx f1ptr		;Set up track and sector
	lda filsec+2,x
	sta sector
	lda filsec+1,x
	sta track
	jsr actledon
	smb0 bit_flag_2		;set 'return to me on error' flag		[901127]
	rts

	.page
;*******************************************************************
;*			   BLOCK STATUS				   *
;*								   *
;*  SYNTAX:  "B-S:CHANNEL NUMBER, DRIVE NUMBER, TRACK, SECTOR	   *
;*								   *
;*  Check error channel for normal errors, then get one byte from  *
;*  the channel number.  If it is a 0, then the sector is free. A  *
;*   1 indicates the sector is in use.				   *
;*								   *
;*  This command was added as an easy method of determining if a   *
;*  given track or sector is currently marked as being used.       *
;*								   *
;*					6/30/90 Dennis J. Jarvis   *
;*******************************************************************

blkstat	jsr bkotst		;Set up the channel, drive, track, and sector
	phy			;Save the channel number
	jsr setbam		;Move BAMPNT to the bit rep for this T & S
	jsr bambit		;See if it's used or free
	beq 10$
	lda #0
	   .byte $2c
10$	lda #1
	ply			;Get the channel number back
	sta chndat,y		;Save the free used flag
	lda #1			;Only one character to send
	sta lstchr,y		;Only one character to send
	lda #eoiout		;Send it with an EOI
	sta chnrdy,y
	rts			;Exit with out saving the bam back to disk

	.page
;*******************************************************************
;*			   CBDOS CHGUTIL			   *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*   COMMAND	       COMMENTS			  DRIVES USED ON   *
;* ----------------    ------------------------   ---------------- *
;* "U0>B"+chr$(n) b  = set fast/slow serial bus	  1581		   *
;* "U0>C"+chr$(n) c  = set system_track		  CBDOS		   *	[910528]
;* "U0>D"+chr$(n) d  = set dirsecinc		  CBDOS		   *
;* "U0>H"+chr$(n) h  = set head selection 0, 1	  1571		   *
;* "U0>M"+chr$(n) m  = set dos mode		  1571		   *
;* "U0>R"+chr$(n) r  = set dos retries on errors  1571, 1581	   *
;* "U0>S"+chr$(n) s  = set datasecinc		  1571,1581,CBDOS  *
;* "U0>V"+chr$(n) v  = set verify oN/oFF	  1581,CBDOS	   *
;* "U0>?"+chr$(n) ?  = set device number	  1571,1581,CBDOS  *
;* "U0>L"+chr$(n)    = set large rel files on/off CBDOS		   *
;* "U0>MR"+ xx	     = perform memory read	  1581		   *
;* "U0>MW"+ xx	     = perform memory write	  1581		   *
;*  12345							   *
;*	^_______________ CMDSIZ points to end of string starting @1*
;*******************************************************************

chgutl	ldz cmdsiz		;Got to have at least 3 characters
	cpz #4
	bcc utlbad		;	error, missing parameters
	cpz #5			;If it's just a device number then branch
;	bcc 25$			;						[910123] FAB
	bcc 30$
	ldy #4			;		"U0>?x"
				;Move to ------------^
	jsr aschex_1		;Convert it					[910205] DJJ
	ldy cmdbuf+3		;Check here --------^  for special case 0x thru 9x
	cpy #'0'
	bcc utlbad		;	not in range 0-9
	cpy #'9'+1
	bcc 30$

	cpy #'V'		;Verify?
	beq 50$			;	yes
	cpy #'L'		;Big relative files?				[901127]
	beq 60$			;	yes

	cmp #0			;Must be interleave				[900702]
	beq utlbad		;	error if interleave value = 0
	cpy #'S'		;Data sector interleave?
	beq 40$			;	yes
	cpy #'C'		;Change system_track?				[910528]
	beq 99$			;Yes then branch
	cpy #'D'		;Directory sector interleave?
	bne utlbad		;	no, bad utility command

	.page
;     CHANGE DIRECTORY SECTOR INCREMENT VALUE

	sta dirsecinc
	rts

;     CHANGE SYSTEM TRACK, DIRECTORY TRACK, AND MAX TRACK

99$	cmp #82			;						[910528]
	bcs utlbad
	cmp #0
	beq utlbad
	ldx drivenumber
	jsr setdef_1
	bra initdr

;     CHANGE DEVICE ADDRESS							[910123] FAB

;25$	ldy #3			;only have one number, maybe hex, maybe binary (1581 style)
;	lda cmdbuf,y		; test for binary number
;	cmp #4
;	bcc utlbad		;	range 4...30
;	cmp #31
;	bcc 35$			;	it's binary

30$	ldy #3
	jsr aschex_1		;Convert it					[910205] DJJ
	cmp #31			;Only device numbers 0 thru 30 are allowed by the dos,
	bcs utlbad		;But only 4 thru 30 are allowed by BASIC
35$	ldx drivenumber
	sta cbdosaddress,x
	rts

;      CHANGE FILE SECTOR INCREMENT VALUE

40$	sta datasecinc		;						[910326] FAB
;	sta secinc
	rts

;	TURN VERIFY AFTER WRITE ON/OFF

50$	cmp #2			;Only 0(off), or 1(on) is allowed
	bcs utlbad
	ror a			;move 0/1 into bit7
	ror a
	eor #bit7
	trb iobyte		;clear if 0
	eor #bit7
	tsb iobyte		;set accordingly
	rts

;	TURN SUPER SIDE SECTORS ON/OFF

60$	cmp #2			;Only 0(off), or 1(on) is allowed
	bcs utlbad
;	eor #1			;??? invert because DOS uses inverse logic from disk
	ror a			;Move 0/1 into bit5
	ror a
	ror a
	ror a
;	eor #bit5
	trb iobyte		;clear if 0
	eor #bit5
	tsb iobyte		;set accordingly  ???? (this needs work: change IOBYTE
	rmb5 bit_flag_2		;			only when going to BIG files)
	tsb  bit_flag_2
	rts

utlbad	bra bad_command

;.end
	.page
	.subttl	 ADD  v900815

addrel	jsr adrels
	jsr fndrel		;calc side_sector ptrs

addr1	jsr numfre		;calc available...
	ldy lindx		;record span?
	ldx record_size,y	;A. = (Record Size -1) + Relative Pointer
	dex
	txa
	clc
	adc relptr		;Is there a span to the next block (sector)?
	bcc 10$			;	No then branch
	inc ssind		;Add 2 to the side sector pointer to point to the next block
	inc ssind
	bne 10$			;	branch if we're not out of this side sector
	inc ssnum		;	else, move to the next side sector
	lda #ssioff		;	and reset the side sector offset to the start
	sta ssind
10$	lda r1			;Move the index pointer to the next record
	inc a
	inc a
	jsr setssp		;Set up DIRBUF, and BUFTAB
	lda ssnum		;Get the side sector number and if it is in
	cmp #nssl		;Range of the max side sectors for non big files
	bcc ar25		;   Branch if in range
	bbr5 bit_flag_2,ar20	;   Branch if not big & we're out of range of small	[901127]
	lda #0			;Reset Side Sector NUMber to zero
	sta ssnum
	inc grpnum		;Move to the next group number
	bne ar25		;WAS BNE AR25 (I think it should be BNE to err out if grpnum overflows)

ar20	lda #bigfil
	bra cmderr		;too many side_sectors

	.page
ar25	lda ssind		;calc # blocks needed...
	sec			;...& check against avail.
	sbc r1
	bcs 30$
	sbc #ssioff-1
	clc

30$	sta t3			;# side sector indices
	bbs5 bit_flag_2,addbig	;branch if big relative file			FAB	[901127]
	lda ssnum		;current side sector #
	sbc r0
	sta t4			;# side sectors needed
	ldx #0			;clear accum.
	stx t1
	stx t2
	tax			;.x = #  side_sectors
	jsr sscalc		;calc # of blocks needed
	lda t2
	bne ar35
	ldx t1
	dex
	bne ar35
	bra ar34		;jump

	.page
; added for big relative file
;

addbig
;	pla			;get .a
;	sta t3			;Save the number of side sector indices
	lda ssnum
	sbc r0
	bcs 10$
	inc r3
	adc #6

10$	sta t4
	lda grpnum
	sec
	sbc r3
	sta r3
	jsr ssscal
	lda result+1
	bne ar35
	ldx result
	bne 20$
	rts

20$	dex
	bne ar35
ar34	inc r2
ar35	cmp nbtemp+1
	bcc 40$			;ok!!
	bne ar20
	lda nbtemp
	cmp t1
	bcc ar20		;not enough blocks

40$	lda #1
	jsr drdbyt		;look at sector link
;	clc
;	adc #1			;+1 is next_record
	inc a			;????						[900815]
	ldx lindx
	sta next_record,x
	jsr nxtts		;get next block...
	jsr setlnk		;...& set link.
	lda r2
	bne 50$			;add one block
	jsr wrtout		;write current last rec

45$	jsr dblbuf		;switch bufs
	jsr sethdr		;set hdr from t & s
	jsr nxtts		;get another
	jsr setlnk		;set up link
	jsr nulbuf		;clean it out
	bra 55$

50$	jsr dblbuf		;switch bufs
	jsr sethdr		;set hdr from t & s
	jsr nulbuf		;clean buffer
	jsr nullnk		;last block = 0, lstchr

55$	jsr wrtout		;write buffer
	jsr getlnk		;get t&s from link
	lda track
	pha			;save 'em
	lda sector
	pha
	jsr gethdr		;now get hdr t&s
	lda sector
	pha			;save 'em
	lda track
	pha
	jsr gsspnt		;check side_sector ptr
	tax
	bne 60$
	jsr newss		;need another side_sector
	lda #ssioff
	jsr setssp		;.a = bt val
	inc r0			;advance side_sector count

60$	pla
	jsr putss		;record t&s...
	pla
	jsr putss		;...in side_sector.
	pla			;get t&s from link
	sta sector
	pla
	sta track
	beq 65$			;t = 0, that's all!!
	bbr5 bit_flag_2,61$	;branch if not a big relative file
	lda r5
	cmp grpnum
	bcc 45$

61$	lda r0
	cmp ssnum
	bne 45$			;not done yet
	jsr gsspnt
	cmp ssind
	bcc 45$			;almost done
	beq 50$			;one more block left

65$	jsr gsspnt
	pha
	lda #0
	jsr ssdir
	lda #0
	tay
	sta (dirbuf),y
	iny
	pla
	dec a
	sta (dirbuf),y
	jsr wrtss		;write side_sector
	jsr mapout		;Write out the bam
	jsr fndrel
	jsr dblbuf		;get back to leading buffer
	jsr sspos
	bvs 70$
	bra positn

70$	lda #lrf
	jsr setflg
	lda #norec
	bra cmderr

	.page
adrels	jsr setdrn
	jsr ssend		;set up end of file
	jsr posbuf
	bbr5 bit_flag_2,10$	;branch if not big relative file
	lda grpnum
	sta r5
	sta r3

10$	lda ssind
	sta r1			;save side_sector index
	lda ssnum
	sta r0			;save side_sector number
	lda #0
	sta r2			;clear flag for one block
;	sta recptr		;to 1st byte in record				[911025] FAB
	rts

	.page
;	ADD FILe to directory
;

addfil	lda sa		;Save DATA file variables
	pha
	lda lindx
	pha
	lda sector	;Save the track and sector of the DATA block for this file
	pha
	lda track
	pha

	lda #irsa	;Use internal read SA
	sta sa
	jsr curblk	;Get the current directory sector we're on
	lda type	;Save file type						[901008] DJJ
	pha
	lda file_drive	;Make file's drive the active drive
	and #1
	sta drvnum	;	(it should be active at this time already)
	ldx jobnum
	eor lstjob,x	;Check to see if the LAST accessed drive is the
	lsr a		;Drive number the user requested
	bcc 8$		;same drive then branch

; Since last drive is not the current drive, search the current drive's
; directory for a deleted spot we can use or append one to the directory

	ldx #bit0	;Added for UNSCRATCH command				[900815]
	stx delind	;look for deleted entry
	jsr srchst
	beq 15$		;all full, new sector
	bra 20$		;found one

8$	lda delsec	;Get the sector number of the deleted entry
	beq 10$		;	None located so continue the search
	cmp sector	;Is it the current sector in memory?
	beq 20$		;	If so branch
	sta sector	;	Else, read it in
	jsr drtrd
	bra 20$

; Continue searching remaining directory sectors for an available slot

10$	lda #bit0	;find deleted entry					[900815]
	sta delind
	jsr search
	bne 20$		;If one was found branch

; All current directory sectors are full so create another one

15$
;	lda secinc	;Save data sector increment value		removed [910313]
;	pha
;	lda dirsecinc	;Change it to the directory inc. value
;	sta secinc
	jsr nxdrbk	;Go find a free sector on the SYSTEM track
;	pla
;	sta secinc	;Restore data increment value
	lda sector	;Save the next directory sector
	sta delsec
	lda #2		;Show the 1st entry as being the one free
	sta delind	;(skip past directory T and S links)

20$	lda delind	;Point DIRBUF to the directory entry that is free to use
	jsr setpnt
	pla		;Restore file type
	sta type
	cmp #reltyp	;Is it relative?
	bne 25$		;	no
	ora #bit7	;	yes, show it as already being a CLOSED file

25$	jsr putbyt	;Place the file status byte into the buffer
	pla
	sta filtrk
	jsr putbyt	;Place the track # of the 1st. data block
	pla
	sta filsec	;and the sector number
	jsr putbyt
	jsr getact	;Get the active buffer number
	tay
	ldx filtbl	;Get the pointer to the 1st. char of the filename
	lda #16		;Move filename into the directory sector
	jsr trname

	ldy #16
	lda #0
30$	sta (dirbuf),y	;Clear # of blocks & replace links
	iny
	cpy #27
	bcc 30$

	lda type
	cmp #reltyp	;RELative file?
	bne 50$		;	no
	ldy #16		;	yes
	lda trkss	;		get side_sector track
	sta (dirbuf),y	;		put in directory
	iny
	lda secss	;		get side_sector sector
	sta (dirbuf),y	;		put in
	iny
	lda rec		;		get record size
	sta (dirbuf),y

50$	jsr drtwrt	;Write the directory sector back
	plx
	stx lindx
	pla
	sta sa
	lda delsec
	sta entsec
	sta dsec,x
	lda delind
	sta entind
	sta dind,x
	lda type	;Make current file type
	sta pattyp
	lda drvnum	;Make current drive number the one for the new file creation
	sta file_drive	;(this should already be true)
	rts


;.end
	.page
	.subttl	 BAMUTL	 v900627

;**********************************************************
;*		      ReaD DIR				  *
;*							  *
;* Read the active drive's BAMs and place the DIRECTORY	  *
;* HEADER into the buffer pointed to by JOBNUM.		  *
;*							  *
;* On Entry: JOBNUM = Buffer number where to place the	  *
;*		      DIRECTORY HEADER			  *
;* On Exit : JOBNUM = Buffer number where the DIRECTORY	  *
;*		      HEADER lives			  *
;*	   : BAMPNT = Preserved				  *
;*							  *
;* CAUTIONS: This routine calls GETBUF to obtain a temp	  *
;* buffer to place the DIR. HEADER into.  If one is not	  *
;* available then a NO CHANNEL error message will be	  *
;* generated.  Also, this buffer is discarded after this  *
;* routine is done with it.  JOBNUM will contain the	  *
;* pointer to where I placed the DIRECTORY HEADER.	  *
;*							  *
;* For the DIRECTORY HEADER to remain active, you MUST	  *
;* reallocate the buffer thru GETBUF!!!			  *
;**********************************************************

rddir	jsr mapout	;Write out the bam if dirty
			; (preserves JOBNUM before doing so)
;	lda #1		;						[910108]
;	sta temp
	jsr getbuf	;Get one temp buffer for the directory header
	bpl 10$		;						[910313]
;	bmi no_channel	;	none available				[901127]
	lda #nochnl
	bra cmder2

10$	pha		;Save the buffer number
	jsr frebuf	;Free (discard) the buffer
	pla
	ldx #0
	jsr prep_bam_job
	jsr doread	;Read the directory header

	.page
;**********************************************************
;*		     ReaD BAM				  *
;*							  *
;* Read the active drive's BAMs (both 0 and 1) and place  *
;* them into their respective BAM locations.		  *
;**********************************************************

rdbam	lda jobnum	;Save the current job number
	pha
	lda bmpnt+1	;Save the current BaM PoiNTers
	pha
	lda bmpnt
	pha
	jsr setbamjob	;Get job number for bam 0 for this drive
	pha		;Save it for later

	lda bufind,x	;Get the MSB of the buffer's address
	sta bmpnt+1
	ldy #0		;LSB must be zero!
	sty bmpnt

	lda (bmpnt),y	;Is this drive's BAM in RAM?			[900305]
	beq 10$		;						[900314]
	ldy drvnum
	cmp dirtrk,y	;
	beq bamend	;	Yes, so exit
			;	Else not in or wrong BAM (i.e., subdir), so load it

10$	pla		;Load in the BAMs for current drive
	pha		;	Re-get & re-save the job number
	ldx #1		;	Read BAM-0
	jsr prep_bam_job
	jsr doread
	inc bmpnt+1	;	Read BAM-1
	pla
	inc a		;Bump the job number
	inc bmpnt+1
	ldx #2
	jsr prep_bam_job
	jsr doread
	bra bamend_1

	.page
;**********************************************************
;* SET Track and Sector. This routine will set up HDRS to *
;* point to a sector on the DIRectory TRacK (DIRTRK) then *
;* call SETH to make it the track and sector for the job  *
;* number in HDRS.					  *
;*							  *
;* Entry: ACC = JOB NUMBER (which buffer to be used)	  *
;*	   X  = target SECTOR				  *
;*	   Y  = not used				  *
;* Exit:  ACC = 0					  *
;*	   X  = 0					  *
;*	   Y  = points to HDRS for this job number	  *
;**********************************************************

prep_bam_job		;setts.
	sta jobnum	;save the job number
prep_bam_job_1
	stx sector	;Save the sector
	ldx drvnum
	ldy dirtrk,x	;Get the directory track
	sty track
	bra seth	;Place TRACK, and SECTOR in hdrs+acc*2


;**********************************************************
;* Get the current number of free blocks for this drive	  *
;**********************************************************

numfre	ldx drvnum
	lda ndbl,x
	sta nbtemp
	lda ndbh,x
	sta nbtemp+1
	rts

	.page
create_bam		;newmap.
	jsr clear_bam	;Fill the BAM with zeros
	jsr setbmp	;Set up pntrs to BAM-0 for this drive
	ldy drvnum	;							[900506]
	lda dirtrk,y
	sta track	;Set links to BAM-1
	ldy #1
	sty sector
	iny		;Save link to next bam
	sty temp	;in TEMP
	jsr setupbam	;Place bytes 2 thru 7 in bam
	inc bmpnt+1	;Move to BAM 1
	ldy #$ff
	sty temp	;Ending bam flag
	jsr setupbam	;Do BAM 1
	dec bmpnt+1	;Move back to bam 0

10$	ldy #$ff
20$	ldx #5
30$	lda bamimage,x
	sta (bmpnt),y
	dey
	cpy #16
	bcc 40$		;branch when done
	dex
	bpl 30$
	bmi 20$

40$	jsr setbamjob	;Get the job number for this drv
	lda bufind,x	;Get the MSB of the pointer to
	tay
	iny
	cpy bmpnt+1	;Completed both bams yet?
	beq 50$		;Yes then we're done
	inc bmpnt+1	;No then do BAM 1
	bne 10$		;Always
50$	rts

allocsyssec		;  Allocate system sectors
	ldy drvnum
	lda dirtrk,y
	sta track
	lda dirst,y
	sta  sector
10$	jsr wused	;Allocate DIR sector, bam 0,
	dec sector	;BAM 1, and dir header
	bpl 10$		;When done fall thru to write out the bam

	.page
bamout	jsr verify_bam_blocks_free
	lda jobnum		;Save it
	pha
	lda bmpnt+1
	pha
	lda bmpnt
	pha
	jsr setbamjob
	pha
	lda bufind,x		;Make a pointer to the BAM buffer
	sta bmpnt+1
	ldy #0
	sty bmpnt
	pla			;Place the job number in A
	pha			;Save it for BAM 1 call to PREP_BAM_JOB
	ldx #1			;Sector 1
	jsr prep_bam_job	;Setup pointers
	jsr dowrit		;Write out BAM 0
	inc bmpnt+1		;Move the pointer up to BAM 1
	pla			;Get the index into the correct drive's BAM 0 buffer back
	inc a			;Job number (which buffer is to be used)
	ldx #2			;Select sector number 2 (BAM 1)
	jsr prep_bam_job	;Setup the controller's pointers
	jsr dowrit		;write out BAM 1
	   .byte $89

bamend	pla			;Trash BUFIND value
bamend_1
	pla
	sta bmpnt
	pla
	sta bmpnt+1
	pla
	sta jobnum		;restore it
	jsr nfcalc		;Calculate the number of blocks free on this disk

bamclean
	ldx drvnum		;Clear the BAM's dirty flag for this drive
	lda drivemask,x
	trb mdirty
	rts


setbamdirty
	ldx drvnum		;Set the BAM's dirty flag for this drive
	lda drivemask,x
	tsb mdirty
	rts

	.page
mapout	ldx drvnum
	lda mdirty		;Get the bam flags
	and drivemask,x 	;Is this drive's BAM dirty?
	bne bamout		;	Yes, write it out
	rts

;*****************************************************************************
;* This subroutine will start at the MAXimum TRacK number for this partition *
;*  and verify that the total number of free sectors shown in the BAM IMAGE  *
;*  matches the true number of free sectors on this track.		     *
;*  CALLED BY: MAPOUT, BAM_COPY						     *
;*****************************************************************************

verify_bam_blocks_free
	lda maxtrk		;verify bam first
	sta cont		;set trk counter
	jsr setbmp		;Set base address to BAM 0
10$	lda #bindx		;bam offset
20$	sta bmpnt		;lsb
	jsr avck		;check this trk
	dec cont		;do next trk
	beq 25$			;verify done
	clc			;update bam pointer
	lda bmpnt		;
	adc #6			;6 byte per trk
	bcc 20$			;same bam
	jsr setbamjob
	lda bufind,x		;Get the MSB of the pointer to
	tax
	inx
	cpx bmpnt+1		;Completed both bams yet?
	bne 30$
25$	rts

30$	inc bmpnt+1		;do next bam
	bra 10$			;Always

	.page
setupbam
	lda drvnum		;X = DRVNUM * 2 which is used
	tay
	asl a			;To point to the correct DiSK ID
	tax			;Bytes for the correct drive #
	lda #0
	bit temp		;Is this the last bam sector?
	bmi 10$			;Yes then DIRTRK = 0 branch
	ldy drvnum
	lda dirtrk,y		;This is for BAM 0
10$	ldy #0
	sta (bmpnt),y		; set trk links
	iny
	lda temp		; Set link to the next BAM
	sta (bmpnt),y
	iny
	lda fmttyp		;Disk format version
	sta (bmpnt),y
	iny
	eor #$ff		;Complement format version
	sta (bmpnt),y
	iny
	lda dskid,x		;id1
	sta (bmpnt),y
	iny
	lda dskid+1,x		;id2
	sta (bmpnt),y
	iny
	lda iobyte
	sta (bmpnt),y
	iny
	lda #0
	sta (bmpnt),y		;Turn off auto loader
	rts

	.page
;**********************************************************
;*		   FREe Track and Sector		  *
;*							  *
;*  This routine will mark a track and sector FREE in the *
;*  current drive's BAM.				  *
;*							  *
;* ON ENTRY: DRVNUM  contains active drive number	  *
;*	     TRACK   contains track  to be free'd up	  *
;*	     SECTOR	      sector to be free'd up	  *
;**********************************************************

frets	jsr setbam		;Set up BMPNT to point to BAM 0 for this drive
	jsr bambit		;Test bit representing this track and sector in the image
	bne fre10		;	it's free already
	lda (bmpnt),y		;	it's not free, so free it
	ora bmask,x
	sta (bmpnt),y
	jsr setbamdirty 	;		mark it dirty
	ldy #0			;		point to blocks free
	lda (bmpnt),y
	inc a			;Set up BAM-1
	sta (bmpnt),y
	lda track
	ldx drvnum		;If we're on the system track bypass showing
	cmp dirtrk,x		;one more free sector on this disk
	beq use10
	inc ndbl,x
	bne fre10
	inc ndbh,x
	rts


fre11	bbs5 bit_flag,fre10	;Generate error on conflict? no then branch
	lda #direrr
	bra cmder2


fre10	lda #0
	rts

	.page
;**********************************************************
;*	     Write USED Track and Sector		  *
;*							  *
;*  This routine will mark a track and sector USED in the *
;* current drives BAM.					  *
;*							  *
;* ON ENTRY: DRVNUM  contains active drive number	  *
;*	     TRACK   contains track to be free'd up	  *
;*	     SECTOR	      sector to be free'd up	  *
;*							  *
;* NOTE: If a sector is already in use this routine will  *
;*  check bit 5 in BIT_FLAG, and if it is NOT set, this	  *
;*  this routine will generate a DIRECTORY ERROR message  *
;*  indicating two or more files are MANGLED together.	  *
;**********************************************************

wused	jsr setbam		;Get index into the correct bam
	jsr bambit		;Move to the correct bit for this sector
				;and test to see if it's in use.
	beq fre11		;Already used, there may be an error
	lda (bmpnt),y		; get bits
	eor bmask,x		; mark sec used
	sta (bmpnt),y
	jsr setbamdirty 	; set it dirty
	ldy #0
	lda (bmpnt),y		; count -1
	dec a
	sta (bmpnt),y		; save it
	lda track		;Skip over the directory track
	cmp dirtrk,x
	beq use20
	lda ndbl,x		;DRVNUM in X see SETBAMDIRTY
	bne use10		;-1 on blocks free in RAM
	dec ndbh,x
use10	dec ndbl,x
use20	lda ndbh,x
	bne use30
	lda ndbl,x		;Check to see if two sectors
	cmp #3			;Remain on the disk because
	bcs use25		;Of the DOUBLE BUFFERING used
	lda #dskful		;By this dos, If there's NOT
	bra errmsg		;Two sectors left then ERROR

use25	lda #1
use30	rts

	.page
clearnodrv
	ldx drvnum		;Clear this drive's drive not ready flag
	lda drivemask,x
clearnodrv1
	trb nodrv
	rts



setnodrv
	lda #$80		;						[910129] FAB
	sta last_drive
	ldx drvnum		;Set this drive's NOT READY flag
	lda drivemask,x
	tsb nodrv
	tsb dchange
	rts

testnodrv			;Test this drive's not ready flag
	ldx drvnum
	lda drivemask,x
	and nodrv
	rts

testdchange			;Test this drive's disk swap flag
	jsr CheckDC
	ldx drvnum
	lda drivemask,x
	and dchange
	rts

cleardchange			;Clear this drive's disk swap flag
	ldx drvnum
	lda drivemask,x
	trb dchange
	rts

	.page
;**********************************************************
;*		 BIT MAP VALIDITY CHECK			  *
;*							  *
;*   This subroutine verifies that the number of free	  *
;* sectors indicated for this track is valid by adding the*
;* number of sectors free for this track and checking it  *
;* with the blocks free for this track.			  *
;*							  *
;* ENTRY:  BMPNT points to the address of the number of	  *
;*	    sectors free on the track you want to check	  *
;*	    in the BAM.					  *
;*							  *
;* EXIT:   If no errors occured then the routine returns  *
;*	    to the caller.  Otherwise, a BAM CORRUPTED	  *
;*	    error is generated.				  *
;**********************************************************

avck	lda temp
	pha
	lda #0
	sta temp
	ldy #6
	dey
10$	ldx #8			;Number of bits in a byte
	lda (bmpnt),y		;Get the image for this sector
20$	asl a			;Is it used?
	bcc 30$			;No then branch
	inc temp
30$	dex
	bne 20$
	dey
	bne 10$
	lda (bmpnt),y
	cmp temp
	bne 40$			;counts do not match
	pla
	sta temp		;restore temp
	rts

40$	pla			;direrror
	sta temp		;Clean up stack
	lda #direrr
	bra cmder2

	.page
;*********************************************************
;*		      Clear BAM				 *
;*							 *
;*   This routine will fill both BAMS for the currently	 *
;* active drive with zeros.				 *
;*							 *
;* ENTRY: DRVNUM = Currently active drive number	 *
;*	  A,X,Y	 = Don't care				 *
;*							 *
;* EXIT : BMPNT	 = Pointer to this drive's BAM 0 address *
;*	  X & Y	 = 0					 *
;*	  A	 = MSB pointer to this drives BAM 0	 *
;*********************************************************

clear_bam			;clrbam.
	jsr setbmp		;Point to BAM 0 for this drive (Y=0 on exit from SETBMP)
	pha			;Save MSB of bam pointer
	lda #0			;Fill with zeros
	ldx #1			;Two bam's per drive
10$	sta (bmpnt),y
	iny
	bne 10$
	inc bmpnt+1
	dex
	bne 10$
	dec bmpnt+1		;Reset back to BAM 0
	pla			;Restore MSB pointer to BAM 0
	rts

setbam	jsr testnodrv		;Is the drive ready?
	beq bamtrk		;Yes then branch
	lda #nodriv
	bra cmder2		; no drive present

;*************************************************************
;* Used to position BMPNT to the correct BAM TRACK image     *
;* in the bam for the current track number located in TRACK. *
;*************************************************************

bamtrk	lda track		;						[901213]
	pha			;						"
	jsr setbmp		;Set BMPNT to point to BAM 0			[900602]
	pla			;						[901213]
				;.bamtrk_1					"
;	lda track		;Which side are we on?				"
	cmp #41			;Are we on side 0?
	bcc 10$			;Yes then branch (bam 0)
	sbc #40			;No then normalize track number
	inc bmpnt+1		;Move pointer to BAM 1
10$	tay			;Normalize track number
	dey			;By subtracting one
	lda blkfreeindex,y	;Get the index to the blks
	sta bmpnt		;Free for this track
	ldy #0			;Reset index pointer
	rts

setbp	jsr rdbam		;Read in the bam if not in memory

;**********************************************************
;* Used to set up BMPNT to point to BAM 0 for the current *
;* active drive number in DRVNUM.			  *
;**********************************************************

setbmp	ldy drvnum		;Get the current drive number
	lda bam0ptr,y		;get the msb address of BAM 0
	sta bmpnt+1		;For this drive
	ldy #0
	sty bmpnt
	rts

;**********************************************************
;*	 Set up the job number for this drive's BAM 0	  *
;**********************************************************

setbamjob
	ldx drvnum
	lda bamjobs,x
	tax
	rts

;**********************************************************
;* Move over to the correct sector number in this track's *
;* image which pointed to by BMPNT. Return with the Y reg *
;* containing the bit field value and N flag indicating	  *
;* if this sector is already in use.			  *
;**********************************************************

bambit	ldx sector		;Get the current sector we're on
bambit_1			;						[910402]
	ldy sectorindex,x	;Get the index value to point
				;to the byte for this Sector
	txa			;Get the index value to point
	and #7			;to the correct bit in this byte
	tax
	lda (bmpnt),y		;Test to see if this sector is already in use
	and bmask,x
	rts			;If Z=0 then it's used

;**********************************************************
;* Index pointer to the byte which contains this sector	  *
;**********************************************************

sectorindex					;Index starts at 1st byte past blocks free
	.byte 1,1,1,1,1,1,1,1			;Sectors  0 thru  7
	.byte 2,2,2,2,2,2,2,2			;Sectors  8 thru 15
	.byte 3,3,3,3,3,3,3,3			;Sectors 16 thru 23
	.byte 4,4,4,4,4,4,4,4			;Sectors 24 thru 31
	.byte 5,5,5,5,5,5,5,5			;Sectors 32 thru 39

;**********************************************************
;* Index pointer to the BLOCKS FREE byte for each track	  *
;**********************************************************

blkfreeindex
	.byte $10,$16,$1c,$22,$28,$2e,$34,$3a	;Track	1 thru	8
	.byte $40,$46,$4c,$52,$58,$5e,$64,$6a	;Track	9 thru 16
	.byte $70,$76,$7c,$82,$88,$8e,$94,$9a	;Track 17 thru 24
	.byte $a0,$a6,$ac,$b2,$b8,$be,$c4,$ca	;Track 25 thru 32
	.byte $d0,$d6,$dc,$e2,$e8,$ee,$f4,$fa	;Track 33 thru 40

;**********************************************************
;*	  MSB pointers to both drives BAM 0 buffers	  *
;**********************************************************

bam0ptr	.byte >bambuf0d0,>bambuf0d1		;Drive 0, drive 1

;**********************************************************
;*	     JOB numbers for BAM0, both drives		  *
;**********************************************************

bamjobs .byte bamjob,bamjob+2			;Drive 0, drive 1

bmask	.byte bit0,bit1,bit2,bit3,bit4,bit5,bit6,bit7

drivemask
	.byte bit7,bit6				;Drive 0 and 1 flags

bamimage
	.byte $28,$ff,$ff,$ff,$ff,$ff		;For one track with no sectors in use


;.end
	.page
	.subttl	 OPEN/CLOSE  v901029

;			   OPEN CHANNEL
;
; Parses the input string that is sent as an Open data channel,
; Load, or Save.  Channels are allocated and the directory is
; searched for the filename contained in the string.

open	lda sa
	sta tempsa
	jsr cmdset		;initiate cmd ptrs
	stx cmdnum
	ldx cmdbuf
	lda tempsa
	cmp #cmdsa
	beq 20$			;Not cmdsa then branch
	cpx #'/'
	beq select_partition
	cmp #0			;Is it the load sa
	bne 20$			; No then branch				[900624]
	cpx #'*'		;load last file accessed on this drive?
	bne 20$			;No then branch
	lda prgtrk		;Was the file found?
	beq 40$			;No then branch

;***********************************************
;* Load last program from last drive accessed. *
;***********************************************

	sta track		;Save track number for the file
	lda prgdrv		;	     .....and the drive
;	sta drvnum
	sta file_drive		;	     .....and make it the current drive
	phx
	tax
	jsr setup_err		;						[910805] FAB
	txa
	plx
	lda prgsec		;	     .....and now the sector
	sta sector
	lda #prgtyp
	sta pattyp		;Default to PRG filetype
	jsr opnrch		;Go get a read channel and 2 buffers		[900624]

;*--------------------------------------------------------*
;*   The following JSR was added to force the drive's	  *
;* activity led to be turned on.  If the file was one	  *
;* sector or less and was already in the dos buffer the	  *
;* DOS would not normally turn on the led since it didn't *
;* have to access the diskette.	 This change was just to  *
;* make people happy.	  02/5/1990 Dennis Jarvis	  *
;*--------------------------------------------------------*

	jsr actledon
	lda #prgtyp+prgtyp
	ora drvnum

10$	ldy lindx
	sta filtyp,y
	bra endcmd

20$	cpx #95			;Unscratch directory request?		[900815]
	bne 25$			;No then branch
	smb5 bit_flag_1
	smb0 bit_flag_1
	ldx #'$'
	stx cmdbuf		;					[901127]
25$	cpx #'$'
	bne 30$
	lda tempsa		;Read or load in the directory?
	beq load_directory	;	Load it

; Set up to read directory as a SEQ file, do not allow user to
; specify a file type.

	jsr simprs_1		;	Read it- open dir as seq file	[910528]
	ldy drvnum		;					[900415]
	lda dirtrk,y
	sta track
	lda #0
	sta sector
	jsr opnrch
	lda drvnum
	ora #seqtyp+seqtyp
	bra 10$

30$	cpx #'#'		;'#' is direct access
	bne 50$
	beq opnblk

40$	lda #prgtyp		;program type
	sta typflg

	lda #0			;Start with default drive
;	sta drvnum
	phx
	tax
	jsr setup_err		;						[910805] FAB
	txa
	plx
	jsr initdr

50$	jsr prscln		;look for ':'
	bne 60$			;Drive is specified so branch
	ldx #0
	beq 80$

60$	txa
	bne syntax_error	;bad syntax- comma came before colon		[901127]
	dey			;back up to ':'
	beq 80$			;1st char is ':'
	dey
80$	sty filtbl		;Point to the first character of the filename
	lda #$8d		;look for cr-shifted (skip to the end of the filename)
	jsr parse
	inx
	stx f2cnt
	jsr onedrv		;Use only the first drive number
	jsr optsch		;Get the search pattern

;   The following changes marked with "<" were done to prevent:
;
;   1) Opening the same file for writing (creating) and reading at the same time.
;   2) Opening the same file for writing (creating) more than once at a time.
;
;   NOTE:  This also prevents someone from opening a DEL file by opening two write
;   channels (with same 'filename,s,w' but different SA's) then closing them both.
;   This would have created two files, the first of type DEL and the second type SEQ.

	jsr ffst		;look for file entry
	bmi 90$			;	no file found				< [901204] DJJ
	jsr tstchn		;	which SA is file assigned to?		<
	bcs 90$			;		not currently active		<
	lda temp+2		;		get sa# (from tstchn)		< [910328]
	jsr getlintab		;		get lindx#			<
	bpl 90$			;			not write channel	<
	lda mode		;		get current mode		<
	cmp #wtmode		;						<
	beq file_open_error	;			error- file already open for write

90$	ldx #0			;Set up default parameters
	stx rec			;	record length zero
	stx mode		;	read mode
	stx type		;	SEQ filetype
	inx
	cpx f1cnt
	bcs 100$		;no parameters given

;  NOTE: The method in which the next section of code is coded. You can have
;  a legal file suffix such as ,S,W or ,W,S.  However this prevents you from
;  being able to have a file mode name (,A,R,W,M) which is also used as a type
;  (,P,S,C,D,U) since they would become mangled.

	jsr set_type_and_mode	;check for type or mode, place in TYPE and MODE
	inx
	cpx f1cnt
	bcs 100$		;only one parameter

	cpy #reltyp
	beq 130$		;set record size

	jsr set_type_and_mode	;Check for type or mode
100$	ldx tempsa
	stx sa			;set sa back
	cpx #2
	bcs 110$		;not load or save
	stx mode		;mode=sa (0=read/load 1=write/save)
	jsr bamclean		;Show the bam as being clean			[900611]
	lda type		;Did the user request a file type?
	bne 120$		;	yes
	lda #prgtyp		;	no- default to PRG type
	sta type

110$	lda type		;Branch if user specified a file type
	bne 120$
	lda pattyp		;else use the file status byte to obtain the file type
	and #typmsk
	sta type		;type from file
	lda filtrk		;If the file exists branch
	bne 120$
	lda #seqtyp		;else default to SEQ as the file type obtained above
	sta type		;from 'pattyp' was DEL

120$	lda mode
	cmp #wtmode
	beq 140$		;go write
	bra 200$		;go read

;
;  Handle relative file type
;

130$	ldy filtbl,x		;Get the index into the cmd buffer that points
	lda cmdbuf,y		;To the record length, and get it
	sta rec			;Save the record length
	lda filtrk		;Does it already exits?
	bne 100$		;	Yes then branch
	lda #wtmode		;Prep to create it by setting mode to write
	sta mode
	bra 100$

;
;  Prep write mode
;

140$	lda pattyp		;Save wild card flag
	and #bit7
	tax			;Were wild cards used?
	bne 160$		;	Yes
	lda #$20		;Open write
	bit pattyp
	beq 150$
	jsr delete_dir_entry	;Set the file status byte to 0
	bra create_file_entry

150$	lda filtrk		;Does the file exist?
	beq create_file_entry	;	No- go create it now

160$	lda cmdbuf		;Save with replace?
	cmp #'@'
	beq 180$		;	yes
	txa			;Were wild cards used?
	bne 170$		;	yes- error

	lda #flexst		;File exists error
	   .byte $2c
170$	lda #badfn		;Bad filename error
	bra cmderr

;
;  Perform save with replace
;

180$	lda pattyp		;Is new file same filetype as existing one?
	and #typmsk
	cmp type
	bne 220$		;	no- MISMATCH error
	cmp #reltyp		;Is it a RELative file?
	beq 220$		;	yes- error, you can't replace it

	lda lindx		;							[910108]
	sta read_lindx
	jsr opnwch		;Get a write channel
	lda lindx		;Save it as the current Write Logical Index (WLINDX)	[901127]
	sta wlindx
	lda #irsa		;Open an internal read channel
	sta sa
;	jsr fndrch		;							[901127]
	lda read_lindx
	sta lindx
	lda index		;Get the index to this file's status byte
	jsr setpnt
	lda delsec		;If this file never existed then it
	bne 190$		;logically can't be replaced, so branch

	ldy #0
	lda (dirbuf),y
	ora #$20		;Mark save with replace in progress
	sta (dirbuf),y

	ldy #26
	lda track		;Move the current track and sector links of the first data
	sta (dirbuf),y		;Sector for the NEW LINKS into the save with replace location
	iny
	lda sector
	sta (dirbuf),y
	ldx wlindx
	stx lindx		;							[901127]
	lda entsec		;		   sector #
	sta dsec,x

	lda entind		;Get the index to the entry
	sta dind,x

190$	lda #0
	ldy #25			;Clear unnew restore flag
	sta (dirbuf),y

	jsr curblk		;Get our current dir. T and S
	jsr drtwrt		;Write it back
	bra open_finished

220$	bra file_type_mismatch	;						[901127]

200$	lda filtrk		;open read (& load)
	bmi file_not_found	;						[901127]
	beq file_not_found

	lda mode		;Modify mode?
	cmp #mdmode
	beq 245$		;	yes
	lda #$20		;Is the file currently open?
	bit pattyp
	bne file_open_error	;	yes					[901127]

245$	lda pattyp
	and #typmsk		;type is in index table
	cmp type
	bne 220$		;	error

	ldy #0			;everything is ok!
	sty f2ptr
	ldx mode
	cpx #apmode		;Append mode?
	bne 250$		;	yes
	cmp #reltyp		;Relative file?
	beq 220$		;	yes- error
	lda (dirbuf),y
	and #$4f		;Drop off FILE CLOSE IMPROPERLY and SAVE WITH REPLACE bits
	sta (dirbuf),y
	lda sa			;Save SA for later (we're getting ready to trash it!)
	pha
	lda #irsa		;Use our own internal SA
	sta sa
	jsr curblk		;Get the current T&S number that's in the buffer
	jsr drtwrt		;Write it to disk
	pla			;Restore the SA
	sta sa

250$	jsr opread		;open the internal read channel
	lda mode
	cmp #apmode		;Append mode?
	bne open_finished	;	no
	jsr append		;	yes- move to end of file
	bra endcmd


	.page
opread	ldy #19
	lda (dirbuf),y		;Get the side sector track number
	sta trkss
	iny
	lda (dirbuf),y
	sta secss		;	and sector number
	iny
	lda (dirbuf),y
	ldx rec			;	and record size
	sta rec
	txa
	beq 10$			;		branch if size=0
	cmp rec
	bne record_not_found	;		branch if record not found	[901127]

10$	ldx f2ptr
	lda filtrk,x		;Get the track number of the first data block
	sta track
	lda filsec,x		;	and the sector
	sta sector
	jsr opnrch		;Read the first two sectors
	ldy lindx		;Get the index over to the logical file index
	ldx f2ptr		;Get the stream pointer
	lda entsec,x		;Get the directory sector number this entry is in
	sta dsec,y
	lda entind,x		;Get the index over to the entry
	sta dind,y
	rts

	.page
create_file_entry		;opwrit.
	lda file_drive
	and #1
;	sta drvnum		;Make the write drive currently active
	phx
	tax
	jsr setup_err		;						[910805] FAB
	txa
	plx
	jsr opnwch		;Open write channel
	jsr addfil		;Add this filename to the directory


open_finished			;opfin.
	lda sa			;Is this for a LOAD or SAVE?
	cmp #2
	bcs 10$			;	no
	jsr gethdr		;Get the track & sector number
;	lda sector		;						[910528]
	sta prgsec		;	and sector
	lda track		;Save as the current program track
	sta prgtrk
	lda drvnum
	sta prgdrv		;	and drive
;	lda sector
;	sta prgsec		;	and sector


; The following jump was changed to prevent the BAM
; from being marked free when it really wasn't (was endcmd).

10$	bra endsav

	.page
;*  Set Type and Mode
;*
;*	Note that the type and mode can be in any order in the command buffer,
;*	such as	 FILENAME,S,W  or  FILENAME,W,S

set_type_and_mode		;cktm.
	ldy filtbl,x		;get ptr
	lda cmdbuf,y		;get char
	ldy #nmodes
10$	dey
	bmi 20$			;no valid mode
	cmp modlst,y
	bne 10$
	sty mode		;mode found

20$	ldy #ntypes
30$	dey
	bmi 40$			;no valid type
	cmp tplst,y
	bne 30$
	sty type		;type found
40$	rts

	.page
;*************************************************************************
;*     Recoded this routine so that it calls the MARKTS routine, using	 *
;* this method it will greatly reduce the time it takes to reach the	 *
;* end of a file. This is because instead of having to read in each and	 *
;* EVERY byte of the file, the MARKTS routine just reads in the 1st two	 *
;* bytes of a file to obtain the Track and Sector links of the file and	 *
;* moves on to the next sector.						 *
;*************************************************************************

append	lda track		;Valid track number?				[910228] DJJ
	beq 5$			;	no- must be one block file		"

				;Flag WUSED routine NOT to generate an error	[900429]
	smb5 bit_flag		;(since we're calling MARKTS and the sector is already allocated
				;the WUSED routine will attempt to generate an error message)

	jsr markts		;Go do it the FAST WAY
	rmb5 bit_flag		;Clear the APPEND calling MARKTS routine flag	[900429]
	jsr rdlnk		;Get the T and S link so we can

  ;********************************************************************************
  ;* I don't think this code can EVER be executed.  This is because when you have *
  ;* a sector that was not used at all it is discarded by the CLOSE routine when  *
  ;* the file is closed, and if it was the ONLY sector in use a CHR$(13) is put   *
  ;* into the sector by the DOS so the smallest a file can be is one character.	  *
  ;********************************************************************************

5$	ldx sector		;Get the number of bytes used in
	inx			;This last sector + 1
	txa
	bne 10$			;branch if not all of the sector is used
	jsr wrt0		;Get another sector
	lda #2			;Move past the track and sector links
10$	jsr setpnt
	ldx lindx		;Get the channel #
	lda #rdylst		;we're ready to listen now
	sta chnrdy,x
	lda sa
	jsr getlintab
	lda #bit7		;Show channel as WRITE ONLY
	ora lindx
	sta lintab,x
	rts

	.page
; LOAD dIRectory
;

load_directory			;loadir.
	lda #ldcmd		;Used to fake out the jsr below to Tag Command 35
	sta cmdnum
	smb0 bit_flag_1
	lda drivenumber
	ldx cmdsiz		;Drive # or filename specified?
	dex			;	If only one char in the buffer
	beq 10$			;	it must be '$', therefore no drive specified.
	dex			;Is it '$x'?
	bne 30$			;	No, there are extra characters

	lda cmdbuf+1		;Check if the 1st char is a drive number
	jsr tst0v1
	bmi 20$			;	No, use the default drive
10$	sta file_drive		;	Yes
	inc f1cnt
	inc f2cnt
	inc filtbl
	lda #$80
	sta pattyp
	lda #'*'
	sta cmdbuf+1
	bra 50$

; THIS NEXT SECTION OF CODE ONLY GETS EXECUTED ON LOAD"$:"
; because there was a colon but NO drive number specified.

20$
;	inc $d020

30$	jsr prscln		;Look for a colon
	bne 40$			;Found one so branch
	jsr cmdrst		;Reset the variables
	ldy #3			;
40$	dey
	dey
	sty filtbl		;Point to
	jsr tc35		;parse & set tables
	jsr setup_one_stream_1	;Setup one file stream no write protect check [900725]

50$	jsr optsch		;new directory
	jsr newdir		;Do an Ix: on this drive to Read the directory header
				;and BAMs, then place the disk's Name into NAMBUF along
				;with the other junk such as RVS on etc.
;	lda #0			;						FFST does this????
;	sta delind		;Clear looking for deleted flag			[900822]
	jsr ffst		;Go get the 1st file name in the directory
	jsr stdir		;STart the DIRectory listing
	jsr getbyt		;Get the 1st byte from the Directory listing (drive #)
	ldx lindx
	sta chndat,x		;Place 1st byte for ciout routine
	lda #prgtyp+prgtyp
	sta filtyp,x		;Make the file type PRG
	lda #0			;Reset the command buffer pointer
	sta cmd_buf_ptr		;Back to the start
	rts

	.page
;		CLOSE
; Close the file associated with sa

close	lda sa			;Are we closing a LOAD, or
	bne 10$			;DIRECTORY file? No then branch
	rmb0 bit_flag_1 	;Reset DIRECTORY LISTING IN PROGRESS flag	[900622]
	jsr frechn
5$	bra freich		;Free the internal read chnl

10$	cmp #15			;Closing the command channel?
	beq close_all_channels	;	yes- close everything

	smb0 bit_flag_2		;Return errors to me				[911021] FAB
	jsr close_one_channel	;Close down the requested channel	solves error blink ????
	rmb0 bit_flag_2		;Release return errors to me flag	(want to exit via scren1)
	lda sa			;Is this close for SAVE?
	cmp #2
	bcc 5$			;	yes- branch

cls14	jsr lda_erword		;If the last operation had an			[910313] FAB
	bne scren1		;error then do not write out the BAM.		         DJJ
	jsr mapout		;Write out the bam
	bra endcmd		;We're done


	;
	; Close all secondary channels
	;

close_all_channels		;clsall.
	lda #14			;Close down all but the cmd channel
	sta sa
10$	jsr close_one_channel	;Close down the chnl in SA
	dec sa			;Next one please
	bpl 10$			;	loop until done
	bra cls14		;See if ANY error occurred


	;
	; Close secondary address (sa)
	;

close_one_channel
	lda sa			;Get the current SA
	jsr getlintab		;Is this channel active?
	cmp #$ff
	bne 10$			;	yes
	rts			;	no, therefore channel is already closed

10$	and #lindx_mask		;					???? [910322] FAB
	sta lindx		;Make the current SA the active LINDX channel
	jsr typfil		;Get this file's type
	beq 40$			;	relative file
	cmp #dirtyp		;Is it a BLOCK R/W access?
	beq 20$			;	yes
	jsr fndwch		;Get the active write channel
	bcs 30$			;	there is none
	jsr close_write_file	;Close the file
	jsr close_directory	;Write the directory sector back
20$	jsr mapout		;Write out the bam
30$	bra frechn		;Done


	;
	; Close relative file
	;

40$	jsr scrub		;clsrel.  Write out the buffer if it's dirty
	ldx lindx
	lda buf1,x		;Toggle second active buffer
	eor #$80
	sta buf1,x
	lda buf0,x		;Toggle first active buffer
	eor #$80
	sta buf0,x		;Is the primary buffer in use?
	jsr ssend
	ldx ssnum
	stx t4

	bbs5 bit_flag_2,80$	;Branch if big relative file		[901114] FAB
	inc t4
	lda #0
	sta t1
	sta t2
	lda ssind
	sec
	sbc #ssioff-2
	sta t3
	jsr sscalc
	ldx lindx
	lda t1
	sta nbkl,x
	lda t2
	sta nbkh,x
60$	lda #dyfile
	jsr tstflg		;Test if file written to
	beq 70$			;	no
	jsr close_directory
70$	bra frechn


80$	lda ssind		;clsbig.
	sec
	sbc #ssioff-2
	sta t3
	lda grpnum
	sta r3
	jsr ssscal
	ldx #0
	lda #2
	jsr addlit
	ldx lindx
	lda result
	sta nbkl,x
	lda result+1
	sta nbkh,x
	bra 60$

	.page
;************************************************************************
;*			    CLOSE A WRITE CHANNEL			*
;*									*
;*  Close down a write channel.	 When the write channel was opened, two *
;*  sectors were assigned to it, presenting the following scenarios:	*
;*									*
;*   1) The file never had any bytes sent to it, so there are 2		*
;*	sectors allocated that aren't needed.				*
;*									*
;*   2) One sector was used, one was not.				*
;*									*
;*   3) Both sectors are used.						*
;*									*
;*  For the 1st condition this routine will place a CR into the 1st.	*
;*  sector, then deallocate the second one in the BAM and update the	*
;*  number of blocks free on disk and in DOS memory.			*
;*									*
;*  For the second condition it will just free the second sector in	*
;*  the BAM, and increment the blocks free count.			*
;*									*
;*  For the third condition it will just update the number of bytes	*
;*  used by the second sector.						*
;*									*
;*  NOTE:  If a one block file is appended, the directory will always	*
;*  show 2 blocks in use.  This is caused by the JSR to WRTBUF, which	*
;*  automatically increments NBKL (from BUTTERFIELD Transactor V3, I4).	*
;************************************************************************

close_write_file	;clswrt.
	ldx lindx	;Get the index
	lda nbkl,x	;Was at least one sector written?
	ora nbkh,x
	bne 10$		;	yes
	jsr getpnt_1	;Was at least one byte written to 1st sector?	[910328]
	cmp #2
	bne 10$		;	yes
	lda #cr		;	no:
	jsr putbyt	;Put a <cr> into the buffer as a fill byte

10$	jsr getpnt	;Get the number of bytes in the buffer
	cmp #2		;Was at least one byte written to 1st sector?
	bne 20$		;	yes

	jsr dblbuf	;							[910117]
	ldx lindx
;	lda buf1,x	;Toggle second active buffer
;	eor #$80
;	sta buf1,x
;	lda buf0,x	;Toggle first active buffer
;	eor #$80
;	sta buf0,x	;If the primary buffer is in use

	lda nbkl,x
	bne 15$
	dec nbkh,x
15$	dec nbkl,x
	jsr getlnk
	jsr frets	;Free up the unused SECTOR
	lda #0
20$	dec a
	pha
	lda #0
	jsr setpnt
	jsr putbyt
	pla
	pha
	jsr putbyt
	pla
	cmp #$e0
	bcs 40$
	inc a
	jsr setpnt
	lda #0
30$	sta (buftab,x)
	inc buftab,x
	bne 30$

40$	jsr wrtbuf	; write out last buffer
	bra dblbuf	;

	.page
;****************************************************************
;*			CLOSE DIRECTORY				*
;*  This routine is used to update the FILE_STATUS_BYTE for a	*
;*  file in the directory sector.  It will set the 'file	*
;*  closed properly' bit.					*
;*								*
;*  NOTE:  Added a JSR NUMFRE so that the correct # of free	*
;*  blocks (sectors) was shown on the next DIRECTORY or		*
;*  whenever another save with replace is done.			*
;*				1/12/89 Dennis J. Jarvis	*
;****************************************************************

close_directory		;clsdir.
	ldx lindx	;save lindx
	stx wlindx
	lda sa		;Save the SA since we will trash it with the internal SA
	pha
	lda dsec,x	;Get the directory sector
	sta sector
	lda dind,x	;Get the pointer to the filename
	sta index	;(file status byte)
	lda filtyp,x	;Get the drive number
	and #1
;	sta drvnum	;Make it the active drive
	phx
	tax
	jsr setup_err		;						[910805] FAB
	txa
	plx
	tay		;					[900415]
	lda dirtrk,y
	sta track
	jsr getact	;Get the active buffer for the directory sector
	pha		;Save it so we can use it to write back the directory sector
	sta jobnum	;Make it the active buffer for the FDC
	jsr drtrd	;Read in this directory sector
	ldy #0
	lda bufind,x	;Get the address of the buffer
	sta r0+1
	lda index	;Get the index to the file status
	sta r0		;Byte for this filename
	lda (r0),y	;Is this a save with replace?
	and #bit5	;'@'
	beq 20$		;No then branch

	jsr typfil	;Is this a RELATIVE file?
	beq 30$		;No then branch, it can't be a save with replace file

	lda (r0),y	;Clear the save with replace
	and #$ff-bit5	;Flag from the file status byte
	sta (r0),y	;This was a $8F but it cleared too many file types
			;as well as the file_locked bit
	iny
	lda (r0),y	;Get the track # for the first
	sta track	;Track and sector used by this file and save it
	sty temp+2	;Save the index to the track Link
	ldy #27		;Move to the save with replace
	lda (r0),y	; Track and sector replacement link
	pha		;Get the sector # and save it
	dey		;Now get the track number
	lda (r0),y	;If there's not a track # then
	bne 10$		;It's a bad T and S error
	sta track
	pla
	sta sector	;___ move up see below
	lda #systs
	bra cmder2

10$	pha		;Save the track # of the @ trk
	lda #0		;Erase the track and sector
	sta (r0),y	;For the replace links (bytes 26 & 27)
	iny
	sta (r0),y
	pla		;Get the track number back to the @ links
	ldy temp+2
;*	^^^ ^^^^^^	;Dumb will always = 2!
	sta (r0),y	;Move the save with replace links
	iny		;Back into the main T & S links
	lda (r0),y	;
	sta sector
;*	^^^^^^^^^^	;Why not just place the sector just above CLSD4 (10$)
	pla
	sta (r0),y

	jsr delfil	;Free up the Track and Sectors that were used by the
			;file that was to 'REPLACE' the current file on the disk

	jsr numfre	;Update the number of blocks free so that on the next
			;DIRECTORY Command they get the true # blocks free and
			;not the '0' blocks free

	bra 30$		; set close bit


20$	lda (r0),y
	and #typmsk	;WAS #$0F  (Allowed improper file types to be found by the DIR CMD)
	ora #bit7	;Include closed bit in the file
	sta (r0),y	;Status byte

30$	ldx wlindx
	ldy #28		;set # of blocks
	lda nbkl,x
	sta (r0),y
	iny
	lda nbkh,x
	sta (r0),y
	plx		;Get the job # back for the directory sector			[910108]
	lda #write	;write the directory sector back to the disk
	ora drvnum
	jsr doit
	pla		;Restore sa
	sta sa
	bra fndwch	;Restore lindx

	.page
;*		SELECT PARTITION
;*
;*  This routine will allow the user to quickly select partition paths using
;* the normal SA values other than 15. To use this new method the user opens
;* the file using a normal SA and the filename MUST be structured as follows:
;*
;*  "/[drive]:PATH_1/PATH_2/PATH_3..... ETC"
;*
;*  If the DOS does not find one of the filenames in the file path stream it
;*  will check to see if the file exists in the current directory and if it
;*  does it will open the file in the normal method as it does now.
;*
;*  If the drive number is specified then the search starts from track 40
;*  else the search continues from the current directory track.

select_partition
	jsr autoi
	lda #<new_partition_open
	sta cmdnum
	smb0 bit_flag		;Set a flag to show TAGCMD we're calling it
	rmb1 bit_flag		;Reset '/' encountered
	jsr tagcmd		;Parse the command string
	jsr setup_one_stream_1	;Set up one filestream no wp check [900725]
	lda file_drive		;Did the user specify a drive number?
	bmi 4$			;	no
	jsr setdef		;	yes- start search from the ROOT (Track 40) directory
	jsr initdr
4$	jsr optsch		;Find best search pattern
5$	jsr ffst		;Find 1st file name
	bmi 51$			;	branch if one not found

;*******************************************************************************
;*  The filename in the command buffer was found on a directory sector now     *
;* check to ensure it is a partition file type. If it is NOT then, starting    *
;* with the 1st character past the '/' character, shift it to the start of the *
;* command buffer. For example /:PARTITION_1/JUNK,S,W would be shifted	       *
;* backward in the command buffer to be JUNK,S,W. This will setup the OPEN     *
;* routine to parse this command with the DEFAULT drive number, and to create  *
;* JUNK in the LAST DIRECTORY chain located. From this point on it will be     *
;* processed in the same manor as always. (FILE EXITS, WRITE PROTECT ERROR etc)*
;* If the file was suffixed with ,S,R then it would be opened for reading if   *
;* it existed.								       *
;*******************************************************************************

50$	ldy entfnd		;Get the index to the file channel that was found
	lda pattyp,y		;Check to see if the file is a partition type
	and #typmsk
	cmp #partyp
	beq 55$			;	branch if it is

;********************************************************************************
;* Filename was found, but it's NOT a partition file type.  Since it COULD be a	*
;* filename about to be OPENED for reading, shift from where you're at now.	*
;********************************************************************************

	ldx filtbl,y		;Get the position of the 1st char past the '/' in the
	bra 52$			;LAST Filename that was not found

51$	ldx partition		;Get the pointer to the 1st character past the '/'
	beq file_not_found	;	error if the 1st filename was not found

52$	lda cmdsiz		;Get the max length of the command/filename buffer
	inc a			;+1						[900718]
	pha			;						[900718]
	sta limit		;Save it for trcmbf
	ldy #bfcnt		;Index for CMDBUF
	rmb0 bit_flag		;If not reset our flags for NEW PARTITION IN USE and
	rmb1 bit_flag		;'/' encountered then

; Y = Pointer to CMDBUF [BUFTAB]
; X = Number of bytes to move

	jsr trcmbf		;Start of the command buffer
	pla			;Get the number characters in the cmd buffer	[900718]
	clc			; -1						 "
	sbc partition		;Get the actual length of this filename		 "
	tax			;Place a delimiter after it			 "
	beq endcmd		;						 "
	lda #0			;End of filename flag				 "
	sta cmdbuf,x		;						 "
	stx cmd_buf_ptr 	;Show the end of the last parameter		[900718]
	lda tempsa
	sta sa			;Restore org. sa address
	bra open		;No perform a regular open command

;25$	bra file_not_found	;						[901127]

55$	jsr setup_partition	;Added to reduce ROM size			[900725]
	jsr initdr
	bra 5$			;Go find 1st file name again

;.end
	.page
	.subttl	 OPCHNL	 v900415

; OPEN CHANNEL
;
; Open a read channel with 2 buffers.  Will insert SA in LINTAB and
; init all pointers.  Relative Side Sectors and pointers are set.

opnrch	lda #2		;Get two data buffers
	jsr getrch
	jsr intpnt	;Reset the pointers
	lda type	;Get this file's type
	pha
	asl a		;shift to make room for drive
	ora drvnum	;Insert drive number (0 or 1)
	sta filtyp,x	;Save this file's type + drive no.
	jsr strdbl	;Read in up to the two sectors
	ldx lindx
	lda track	;Is this the last sector to be read?
	bne 10$		;	no
	lda sector	;	yes- set the end of data pointer
	sta lstchr,x
10$	pla		;Get the file type back
	cmp #reltyp	;Is it relative?
	bne or30	;No then branch
	phx
	lda sa		;Yes get the current sa
	jsr getlintab	;Set this file up as read or write
	ora #bit6
	sta lintab,x
	plx
	lda rec		;Get the record size
	sta record_size,x	;Save it
;	lda #1		;							[910108]
;	sta temp
	jsr getbuf	;Get the side sector buffer
	bmi gberr	;	error if none available

	ldx lindx	;Save the pointer to the
	sta side_sector,x	;Side sector buffer
	bbs5 bit_flag_2,20$	;branch if this is a big relative file	[901127]
	ldy trkss	;Get the side sectors track #
	sty track	;Make it the current track number
	ldy secss	;Same for the sector
	sty sector
	jsr seth	;Set up the side sector header
	jsr rdss	;Now go and read it in
	bra orow	;Branch around side sector stuff

20$
;	pla		;Discard side sector buffer number
	lda trkss	;Get the side sector track #
	sta ssstrk,x	;Save it
	lda secss	;Same for the sector
	sta ssssec,x
	lda #255	;Set the flag for no GROUP
	sta sssgrp,x	;Resident in memory


orow	ldx lindx
	lda #2		;Set the index value to the next record
	sta next_record,x
	lda #0		;Reset the buffer pointer to the start of buffer
	jsr setpnt
	jsr rd40	;Set up the 1st record
	bra gethdr	;Go restore the T & S back to normal

	.page
;**********************************************************
;*	     Handle PRG, SEQ, USR, DEL file types	  *
;**********************************************************
;* Note: I recoded the next section of code from:	  *
;*							  *
;* OR30	  JSR RDBYT	;Get the next byte, place in DATA *
;*	  LDX LINDX	;Get the index			  *
;*	  STA CHNDAT,X	;Set up 1st byte to be xmitted.	  *
;*	  LDA #RDYTLK	;Show ready to talk with NO eoi	  *
;*	  STA CHNRDY,X					  *
;*	  RTS						  *
;*							  *
;* WHY: Assume for now that you have a ONE BYTE FILE.	  *
;*	When this ABOVE section of code was called it	  *
;*	JSR'd to RDBYT 1st. To get the 1st byte of the	  *
;*	file, if this was the last byte in the file then  *
;*	it would set the EOI flag. When we returned back  *
;*	to here it forced a RDYTLK with NO EOI!!	  *
;*							  *
;* FIX: I now set the channel to talk with NO EOI, then	  *
;*	when the RDBYT routine is called, if it finds out *
;*	this is the last byte of the file it will clear	  *
;*	BIT 3 requesting an EOI handshake		  *
;*				 1/14/1990   Dennis Jarvis*
;**********************************************************

or30	lda #rdytlk	;Show ready to talk with no EOI
	sta chnrdy,x
	jsr rdbyt	;Get the first byte, and set the EOI flag if
			;this was the last byte in the file
	ldx lindx	;Get the index for this file
	sta chndat,x	;Save the first data byte
	rts

	.page
; Initialize variables for open chanl
;  lstjob, sets active buffer#, lstchr, buffer pointers in buftab = 2

intpnt	ldx lindx	;Get the current channel number for primary buffer
	lda drvnum	;Get the current drive number
	ldy buf0,x	;Get the current buffer number for the 1st buffer
	sta lstjob,y	;Save it as the LaST JOBs drive number for 1st buffer
	ldy buf1,x	;Get the current buffer number for the 2nd buffer
	sta lstjob,y	;And for the 2nd buffer
	sta jobs,y	;Clear the last job's status flag
	lda buf0,x	;Get the job number (buffer) and * 2 so that
	asl a		;Y points to the LSB in BUFTAB for this job number
	tay
	lda #2		;Point to the 1st char. past the
	sta buftab,y	;T & S links in the buffer
	lda buf1,x	;Make the 2nd buffer inactive
	ora #bit7
	sta buf1,x
	asl a		;Now drop bit 7 and move over to the secondary buffer
	tay		;Now move it's buffer pointer to the 1st char
	lda #2		;Past the Track and Sector links
	sta buftab,y
	lda #0		;Show no blocks used so far by this file
	sta nbkl,x
	sta nbkh,x
;	lda #0		;Set the flag for the I.P. to use all of the buffer	[901114] FAB
	sta lstchr,x
	rts

	.page
; Open a write channel with 2 buffers
;

opnwch
	jsr intts	;Get the 1st track and sector to start writing to

opnwch1			;    (Entered by partition routine)
	lda #2		;Get two buffers for writing
	jsr getwch
	jsr sethdr	;Set up the HeaDeR to the 1st Buffer
	jsr intpnt	;Reset the pointers
;	ldx lindx	; (???? X should already = lindx)			[910610]
	lda type	;Get the file type
	pha		;Save it for later
	asl a		;shift 1 bit left
	ora drvnum	;Add in the drive number (0 or 1)
	sta filtyp,x	;Save the file type + drive #
	pla		;Get the file type back
	cmp #reltyp	;Is it a relative file?
	beq 10$		;	Yes then branch
	lda #rdylst	;We're now ready to listen
	sta chnrdy,x
	rts

	.page
; Handle REL type
;

10$	phx
	lda sa
	jsr getlintab	;Drop off the Read/ Write status
	and #$7f	;Flag, and make it as being both
	ora #bit6	;Read and Write
	sta lintab,x	;Save it back
	plx
	lda rec		;Get the size of this record
	sta record_size,x	;Save it
;	lda #1		;							[910108]
;	sta temp
	jsr getbuf	;Get the side sector buffer
	bmi gberr	;	error if none available
	ldx lindx
	sta side_sector,x	;save the Side Sector buffer #
	jsr clrbuf	;Fill the buffer with zero's
	jsr nxtts	;Find the available NeXt T&S on this disk
	lda track	;Save the TRAck and SECtor
	sta trkss	;number for this Side Sector
	lda sector
	sta secss
	ldx lindx
	lda side_sector,x	;Set up the header to this side
	jsr seth	;sector
	lda #0		;SET the Side Sector Pointer
	jsr setssp	;to the start of the buffer
	lda #0		;Set the link for the track
	jsr putss	;Number to the next side_sector to zero
	lda #ssioff+1	;Place the index over to the
	jsr putss	;Next side sector into the Sector link
	lda #0		;Go and get this side_sector number
	jsr putss
	lda rec		;Get the record size
	jsr putss	;Place it into the buffer
	lda track
	jsr putss
	lda sector
	jsr putss
	lda #ssioff
	jsr setssp
	jsr gethdr	; get first track and sector
	lda track
	jsr putss
	lda sector
	jsr putss
	jsr wrtss	; write it out
	bbr5 bit_flag_2,20$	;branch if not big relative file	[901127]
	jsr owbrel	; yes

20$	lda #2
	jsr setpnt
	ldx lindx	; set next_record for null buffer
	sec
	lda #0
	sbc record_size,x
	sta next_record,x
	jsr nulbuf	; null records
	jsr nullnk
	jsr wrtout	; write out the data sector
	jsr mapout	; write the bam
	bra orow

	.page
owbrel	ldx lindx	;Get the channel number
	lda side_sector,x	; get side_sector buffer #
	jsr clrbuf	; clear that buffer
	jsr setssp	; set side sector pointer
	lda trkss
	jsr putss	; set track link
	lda secss
	jsr putss	; set sector link
	lda #254
	jsr putss	; set super side_sector id
	lda trkss
	jsr putss	; set track side_sector link for group 0
	lda secss
	jsr putss	; set sector side_sector link for group 0
	jsr nxtts	; get next track and sector
	ldx lindx	;Get the channel number
	lda track
	sta ssstrk,x	; save sss track
	sta trkss
	lda sector
	sta ssssec,x	; save sss sector
	sta secss
	lda #255
	sta sssgrp,x	; no resident side_sector
	jsr wrtsss	; write the super side sector
	bra gethdr


; Put byte into side sector
;

putss	pha
	ldx lindx
	lda side_sector,x
	bra putb1


;.end
	.page
	.subttl	 ROUTINES-2  v910525

;*		FLOPPY DISK CONTROLLER ERRORS
;*
;*	 IP  FDC  DESCRIPTION
;*	 --  ---  -----------
;*	  0  (0)  no error
;*	 20  (2)  can't find block header
;*	 23  (5)  checksum error in data
;*	 25  (7)  write-verify error
;*	 26  (8)  write w/ write protect on
;*	 27  (9)  crc error in header
;*
;*		Information description
;*		-----------------------
;*	 1   files scratched
;*	 2   selected partition
;*	 3   files locked			 Added 900731
;*	 4   files unlocked			 Added 900731
;*	 5   files restored			 Added 900731
;*	 6   disk changed			 Added 910604
;*	
;*		Parameter errors
;*		----------------
;*	 30  general syntax
;*	 31  invalid command
;*	 32  long line
;*	 33  invalid filname
;*	 34  no filenames given
;*
;*		Relative file errors
;*		--------------------
;*	 50  record not present
;*	 51  overflow in record
;*	 52  file too large
;*	 53  big relative files disabled
;*
;*		Open routine errors
;*		-------------------
;*	 60  file open for write
;*	 61  file not open
;*	 62  file not found
;*	 63  file exists
;*	 64  file type mismatch
;*
;*		Sector management errors
;*		------------------------
;*	 65  no block
;*	 66  illegal track or sector
;*	 67  illegal system t or s
;*
;*		General channel/block errors
;*		----------------------------
;*	 02  channel selected
;*	 70  no channels available
;*	 71  bam corrupted error ***********
;*	 72  disk full
;*	 73  cbdos v1.0
;*	 74  drive not ready
;*	 75  format error
;*	 76  controller error					(unused)
;*	 77  slected partition illegal
;*	 78  directory full					(new)

	.page
;* Error Message Table
;*
;*	leading error numbers,
;*	text with 1st & last chars or'ed with $80,
;*	tokens for key words are less than $10 (and'ed w/ $80)
;*
;* For example,		$20,$61,$65,$a0,'EXAMPLE',$9d
;*    would result in:
;*			20,EXAMPLE ERROR,??,??
;*			61,EXAMPLE ERROR,??,??
;*			65,EXAMPLE ERROR,??,??
;*
;* Or,			$20,$61,$65,$9d,'EXAMPL','E'+$80
;*    would result in:
;*			20, WRITE EXAMPLE,??,??
;*			61, WRITE EXAMPLE,??,??
;*			65, WRITE EXAMPLE,??,??
;*
;* NOTE: Any value less than $20 in the text string will be regarded as a
;*	  token value and not text. A value of $1f in place of the letter L
;*	  above would result in the text 'RECORD' being inserted there.

errtab	.byte $00,'O'+$80,'K'+$80			;'ok'
	.byte $01,$9a,'S SCRATCHE','D'+$80		;'files scratched'
	.byte $02,$a0,'SELECTED PARTITIO','N'+$80	;'selected partition'
	.byte $03,$9a,'S LOCKE','D'+$80			;'files locked'
	.byte $04,$9a,'S UNLOCKE','D'+$80		;'files unlocked'
	.byte $05,$9a,'S RESTORE','D'+$80		;'files restored'
	.byte $06,'D'+$80,'ISK CHANGE','D'+$80		;'disk changed'			[910610]

; Currently file tokens/errors 6 thru 26 are unused and can be added at any time

	.byte $1a,'F'+$80,'IL','E'+$80			;'file'
	.byte $1b,'O'+$80,'PE','N'+$80			;'open'
	.byte $1c,'N'+$80,'O','T'+$80			;'not'
	.byte $1d,'E'+$80,'RRO','R'+$80			;'error'
	.byte $1e,'W'+$80,'RIT','E'+$80			;'write'
	.byte $1f,'R'+$80,'ECOR','D'+$80		;'record'
	.byte $20,$23,$27,'R'+$80,'EAD ',$9d		;'read error'
	.byte $25,$9e,$20,$9d				;'write error'
	.byte $26,$9e,' PROTECT O','N'+$80		;'write protect on'
	.byte $30,'S'+$80,'YNTAX ',$9d			;'syntax error'
	.byte $31,'I'+$80,'NVALID COMMAND ',$9d		;'invalid command error'
	.byte $32,'L'+$80,'INE TO LONG ',$9d		;'line too long error'
	.byte $33,'I'+$80,'LLEGAL ',$1a,'NAME SYNTA','X'+$80 ;'illegal filename syntax'
	.byte $34,'M'+$80,'ISSING ',$1a,'NAM','E'+$80	;'missing filename'

;	.byte $30,$31,$32,$33,$34,'S'+$80,'YNTAX ',$9d	;'syntax error'
;* NOTE: Error numbers $36 thru $39 are currently free

;* NOTE: Error numbers $40 thru $49 are currently being used by the CMD hard
;*	 drive people

	.byte $50,$9f,$20,$1c,' PRESEN','T'+$80		;'record not present'
	.byte $51,'O'+$80,'VERFLOW IN ',$9f		;'overflow in record'
	.byte $52,$9a,' TOO LARG','E'+$80		;'file too large'
							;'big relative files disabled'
	.byte $53,'B'+$80,'IG RELATIVE ',$1a,'S DISABLE','D'+$80
	.byte $60,$9e,$20,$1a,$20,$9b			;'write file open'
	.byte $61,$9a,$20,$1c,$20,$9b			;'file not open'
	.byte $62,$9a,$20,$1c,' FOUN','D'+$80		;'file not found'
	.byte $63,$9a,' EXIST','S'+$80			;'file exists'
	.byte $64,$9a,' TYPE MISMATC','H'+$80		;'file type mismatch'
	.byte $65,'N'+$80,'O BLOC','K'+$80		;'no block'
	.byte $66					;'illegal track or sector'
	.byte 'I'+$80,'LLEGAL TRACK OR SECTO','R'+$80
	.byte $67					;'illegal system track or sector'
	.byte 'I'+$80,'LLEGAL SYSTEM TRACK OR SECTO','R'+$80

; Error number $68, and $69 are free

	.byte $70,'N'+$80,'O CHANNE','L'+$80		;'no channel'
	.byte $71,'B'+$80,'AM CORRUPTE','D'+$80		;'bam corrupted'
	.byte $72,'D'+$80,'ISK FUL','L'+$80		;'disk full'
	.byte $73,'C'+$80,'BM C65 1565 V0.9B.91111','9'+$80		;	[910123] FAB
	.byte $74,'D'+$80,'RIVE ',$1c,' READ','Y'+$80	;'drive not ready'
	.byte $75,'F'+$80,'ORMAT ',$9d			;'format error'
;	.byte $76,'C'+$80,'ONTROLLER ',$9d		;'controller error'	[910610] unused
	.byte $77,'S'+$80,'ELECTED PARTITION ILLEGA','L'+$80
	.byte $78,'D'+$80,'IRECTORY FUL','L'+$80	;'directory full'
;	.byte $79,$9a,' CORRUPTE','D'+$80		;'file corrupted'	[910610] removed
;	.byte $7a,'P'+$80,'PATH NOT FOUN','D'+$80	;'path not found'	[910501]
etend

	.page
error	pha			;controller entry...
	stx jobnum		; a=err#, x=job#
	txa
	asl a
	tax
	lda hdrs,x		;recall trk,sec
	sta track
	lda hdrs+1,x
	sta sector
	pla

error_1				;Entry point by the BACKUP command
	and #$0f		;convert controller errors to DOS errors
	beq 20$
	cmp #12			;Format error?					[900526]
	beq 11$			;	Yes then error
	cmp #15			;Drive not ready?
	bne 30$			;	No then branch

10$	lda #nodriv
	   .byte $2c
11$	lda #fmterr
	bra 40$

20$	lda #6			;code=16-->14
30$	ora #$20
	dec a
	dec a

40$	pha
	lda cmdnum		;Is this the command for
	bne 50$			;	Nope then branch
;	lda #$ff
	dec cmdnum		;Clear the CoMmanD NUMber being executed	[911021] FAB
	pla
	jsr errmsg		;Retrieve error number & put it into the buffer
	jsr initdr		;INIT the disk
	bra cmder3

50$	pla

	.page
cmder2	jsr errmsg		;Place the error # in A into the buffer
cmder3
;	jsr clrcb		;Clear cmdbuf					[901127]
	jsr bamclean		;Mark drive's BAM as clean to prevent it from being written back
	jsr erron		;Turn on the error led
	jsr freich		;Free internal channel
	lda #0			;Reset the command buffer pointer
	sta cmd_buf_ptr 	;Back to the start of the buffer
	ldx tos			;Pop all calls
	txs
	lda orgsa		;Get the original SA
	and #$0f		;Strip off the command bits (OPEN, CLOSE, etc.)
	sta sa			; and save the true SA
	cmp #15			;Is it the command channel?
	beq background		;	Yes then branch (rts)
	bit bit_flag_1		;Are we currently an active...			[900622]
	bvs lsnerr		;	LISTENER?	Yes then branch
	bmi tlkerr		;	TALKER?		Yes then branch

;* This section of code will only be executed if you have a FDC error
;* caused by such errors as doing a directory whenever the diskette has
;* been removed from the disk drive, or other hardware induced errors.

	lda sa			;See if this SA has an active channel assigned to it
	jsr getlintab
	cmp #$ff
	beq background		;	no
	and #$0f		;	yes- make it the active channel
	sta lindx
	bra tlerr

tlkerr	jsr fndrch		;talker err recovery
	bra tlerr		;finish

lsnerr	jsr fndwch		;listn error recovery

tlerr	jsr typfil		;What kind of file is it?
	cmp #reltyp		;A RELative TYPe?
	bcs do_rts		;	Yes, branch as we're done
	jsr frechn		;	No,  it's a DEL, SEQ, PRG, or USR
				;		so close down the channel
				;		then we're done
	bra background		;Emulate background task			[900609]

	.page
hexdec	ldz #0			;MSB = 0
hexdec_1
	stz nh			;Save MSB for now
	sta nl			;Save LSB for now
	ldx #9
	stx nfl
	lda nh			;FROM HERE
	bne 10$
	lda nl
	beq 6$
	cmp #10
	bcs 10$
6$	lda #'0'
	sta (err_buf_ptr),y
	iny
10$	ldz #'0'+bit7
20$	lda nl			;Get LSB
	cmp numtbl-1,x
	lda nh
	sbc numtbl,x		;Do MSB
	bcc 30$			;Branch if overflow
	sta nh
	lda nl
	sbc numtbl-1,x
	sta nl			;Now LSB
	inz
	bne 20$
30$	tza
	dex
	beq 60$
	cmp #'0'+bit7		;Possible leading zero?
	beq 40$			;Yes then branch
	sta nfl
40$	bit nfl			;Has a non zero digit been already printed?
	bpl 70$			;Yes then branch
60$	and #$7f
	sta (err_buf_ptr),y
	iny
70$	dex
	bpl 10$
do_rts	rts

numtbl	.word 1,10,100,1000,10000

	.page
;* Convert a Binary Coded Decimal number to DECimal
;*

okerr	jsr erroff		;transfer error message to error buffer
	lda #0			;'OK'
errts0	ldy #0
	sty track
	sty sector

errmsg	ldy #0
	pha
	lda drvnum
	asl a
	tax
	lda errbuftbl,x
	sta err_buf_ptr
	lda errbuftbl+1,x
	sta err_buf_ptr+1
	pla
	tax
	lsr a			;Convert BCD to decimal and place into the
	lsr a			;error message buffer
	lsr a
	lsr a
	and #$0f
	ora #$30
	sta (err_buf_ptr),y	;						[900314]
	sta chndat+errchn
	iny
	txa
	and #$0f
	ora #$30
	sta (err_buf_ptr),y	;						[900314]
	iny
	lda #','
	sta (err_buf_ptr),y
	iny
	txa			;error # in .x
	jsr ermove		;move message
	lda #','
	sta (err_buf_ptr),y
	iny
	lda track
	jsr hexdec		;convert track #
	lda #','
	sta (err_buf_ptr),y
	iny
	lda sector		;convert sector #
	bbs2 bit_flag,10$
	jsr hexdec
	bra 20$

10$	ldz #1			;Show 256 + SECTOR
	jsr hexdec_1
20$	dey
	lda drvnum
	asl a
	tax
	tya
	clc
	adc errbuftbl,x
	sta lstchr+errchn
	inc err_buf_ptr		;set last char
	lda #rdytlk
	sta chnrdy+errchn
	rts

	.page
ermove	tax			;save err#
	lda r0			;save r0 (phw)
	pha
	lda r0+1		;Sorry PHW or PHD does not work in the pc BSO version!
	pha
	lda #<errtab		;point r0 to error table
	sta r0
	lda #>errtab
	sta r0+1
	txa			;get error #
	ldx #0			;.x=0 for indirect

10$	cmp (r0,x)		;?error # = table entry?
	beq 50$			;	yes, send message
	pha			;save error #
	jsr eadv2		;check & advance ptr
	bcc 30$			;	more #'s to check
20$	jsr eadv2		;advance past this message
	bcc 20$

30$	lda r0+1		;check ptr
	cmp #>etend
	bcc 40$			;	<, continue
	bne 45$			;	>, quit
	lda #<etend
	cmp r0
	bcc 45$			;	past end of table, quit
40$	pla			;restore error # & check next entry
	bra 10$
45$	pla			;pop error # & quit
	bra 90$			;Bomb out error number invalid (not found)
				;Fred do you want to generate an error message????

50$	jsr eadv1		;Skip over the rest of the error numbers (<128) until
	bcc 50$			;You get to the 1st. char. of the error message or token+128

55$	jsr 60$			;If it's not a token insert it as a char. else insert
				;the tokenized text here
	jsr eadv1		;Continue until you get to the last byte in the message
	bcc 55$

	jsr 60$			;Insert the last byte (token or text it does not matter)
90$	pla			;all finished, restore r0
	sta r0+1
	pla
	sta r0
	rts

60$	cmp #$20		;(max token #)+1
	bcc ermove		;If it's a token then place it into the buffer
	sta (err_buf_ptr),y	;place the char. into the active buffer
	iny
	rts

	.page
eadv1	inw r0			;err advance/check
ea10	lda (r0,x)		;get current entry
	asl a			;.c=1 is end or beginning
	lda (r0,x)
	and #$7f		;mask off bit7
	rts



eadv2	jsr ea10		;check table entry
	inw r0
	rts



do_DiskInit			;						[910313]
	lda tos
	pha
	jsr DiskInit
	pla
	sta tos			;						[910314] FAB
	rts

	.page
DiskInit			;dskint.
	lda #0
	sta bmpnt
	ldy #2
	sty bmpnt+1

10$	sta $0000,y		;Fill base page with zeros
	sta found-$0100,y
	iny
	bne 10$

20$	sta (bmpnt),y		;Fill all DOS buffers with zeros
	iny
	bne 20$
	inc bmpnt+1
	ldx bmpnt+1
	cpx #>dosver+1		;	reset everything up through last page used by vars
	bcc 20$

	lda #$80		;reset last access flag				[910129] FAB
	sta last_drive
	jsr inttab		;restore all buffers, etc.
	lda #1
	sta drvnum
	jsr reset		;Reset partition stuff for drive 1
	lda #cbmver
	jsr errts0		;Show dos version for drive 1
	lda err_buf_ptr
	sta save_err
	lda err_buf_ptr+1
	sta save_err+1
	lda lstchr+errchn
	sta save_lstchr_ptr
	lda chndat+errchn
	sta save_chn_data
	lda chnrdy+errchn	;						[900801]
	sta save_chn_rdy
	dec drvnum		;Move to drive 0, fall into 'message'


message				;Entered by user commands to soft reset drive
	jsr reset		;Reset device address and partition stuff
	lda #cbmver		;dos version number for 'U:'
	sta erword,x		;user cmd					[910313]
	jsr errts0		;transfer message
	ldx drvnum
	jsr setup_err		;????						[901127]
	bra background		;						[901127]

	.page
; Initialize all tables

inttab	ldx #0
	ldy #0
5$	lda #0			;Initialize buffer pointer table
	sta buftab,x
	inx
	lda bufind,y
	sta buftab,x
	inx
	iny
	cpy #bfcnt+1		;						[900314]
	bne 5$

	lda #$ff		;Set all SA's free				[900414]
	ldx #maxsa+maxsa+2-1	;						[910325] FAB
10$	sta lintab,x
	dex
	bpl 10$

	ldx #mxchns-1
20$	sta buf0,x		;Set buffers as unused
	sta buf1,x
	sta side_sector,x
	dex
	bpl 20$

	lda #bfcnt		;Set buffer pointers				[900314]
	sta buf0+cmdchn
	lda #bfcnt+1
	sta buf0+errchn
	lda #errchn
	sta lintab+errsa
	sta lintab+errsa+maxsa+1
	lda #cmdchn+$80
	sta lintab+cmdsa
	sta lintab+cmdsa+maxsa+1

	lda #<lxint		;Lindx 0 to 10 free				[900314]
	sta linuse
	lda #>lxint
	sta linuse+1

	lda #rdylst
	sta chnrdy+cmdchn
	lda #rdytlk
	sta chnrdy+errchn

	lda #0
	sta bufuse
	sta bufuse+1		;						[900314]
	lda #bit7+bit6		;Lock out BAMBUF0/1D0
	sta bufuse+2
	bra usrint_1		;Initialize user jump table

	.page
reset	lda #<cmdbuf		;Set pointer to command buffer
	sta cmd_buf_ptr
	lda #>cmdbuf
	sta cmd_buf_ptr+1
	lda drvnum		;						[900703]
	asl a
	tax
	lda errbuftbl,x		;Set pointer to error buffer
	dec a
	sta err_buf_ptr
	lda errbuftbl+1,x
	sta err_buf_ptr+1	;						[900703]
5$	lda #numdefault		;Our default address
	ldx drvnum
	beq 10$			;If for drive 0 branch
	inc a			;If drive 1 then device address = default+1
10$	sta cbdosaddress,x
	lda #sskew		;Set up Data Sector SKEW rate
	sta datasecinc		;						[910313]
	sta secinc
	lda #dskew		;Set up Directory SKEW rate
	sta dirsecinc
	lda #bit7		;Init track 0
	sta curtrk,x
	lda drivemask,x
	tsb dchange		;Required for INIT DRIVE routine
	lda #fmt1581		;Get disk format method
	sta fmttyp		;Set up disk format method
	lda #dosversion
	sta dosver		;Set up dos version number
	smb5 bit_flag_2		;Default to big relative file scheme		[901127]


setdef	lda #sysio
	sta iobyte
	ldx drvnum
	lda #1
	sta startrk,x		; logical starting track
	sta cbm_startrk,x	; for the new period command			[910528]
	lda #systrack
setdef_1			;						[910528]
	ldy #sysdirsec
	sty dirst,x		; starting directory sector
	sta dirtrk,x		; directory track
	sta system_track,x	; system track
	lda #81
	sta maxtrk,x
	sta cbm_maxtrk,x	; for the new period command			[910528]
	rts

errbuftbl
	.word errbuf_d0		;Address of error message buffer for drive 0	[900703]
	.word errbuf_d1		;				     drive 1

;.end
	.page
	.subttl	 TABLES	 v900804

; Command search table
;

cmdtbl				;List of command channel commands

	.byte 'V'		;VAL command MUST ALWAYS be 1st in this list!
;	       -		; (see ERROR to see why)
;	       0		Value left in CMDNUM

	.byte 'DI/MBUPC'
;	       --------
;	       12345678		Value left in CMDNUM

	.byte '.'		;							[910528]
;	       -
;	       9

parsed_commands	= *-cmdtbl	;Where the parsed commands end

	.byte 'RSNF'
;	       ----
;	       ABCD		Value left in CMDNUM

cmdtblend

new_partition_open	= cmdtblend-cmdtbl	;Psuedo value for CMDNUM		[901213]
ldcmd			= new_partition_open+1	;Psuedo value for CMDNUM
ncmds			= cmdtblend-cmdtbl	;# of commands that exist in the real world

	.page
;	Jump table low
;

cjumpl				;CMDNUM
	.byte <validate_bam	;0
	.byte <backup		;1
	.byte <intdrv		;2
	.byte <part		;3
	.byte <mem		;4
	.byte <block		;5
	.byte <user		;6
	.byte <record		;7
	.byte <dskcpy		;8
	.byte <period		;9				[910528]
	.byte <rename		;A
	.byte <scratch		;B
	.byte <new		;C
	.byte <file_commands	;D

;
;	Jump table high
;

cjumph				;CMDNUM
	.byte >validate_bam	;   0
	.byte >backup		;   1
	.byte >intdrv		;   2
	.byte >part		;   3
	.byte >mem		;   4
	.byte >block		;   5  0
	.byte >user		;   6  1
	.byte >record		;   7  2
	.byte >dskcpy		;   8  3
	.byte >period		;   9  4			[910528]
	.byte >rename		;   A  5
	.byte >scratch		;   B  6
	.byte >new		;   C  7
	.byte >file_commands	;   D  8

	.page
;			Structure Images for Commands
;
;    COMMAND+DRIVE:FILE_STREAM_1=FILE_STREAM_2
;
;			OR
;
;    COMMAND+DRIVE:FILE_STREAM_1,FILE_STREAM_1,FILE_STREAM_1 ... etc.
;
;	  File Stream 1
;		|
;	       ____
;	       |  |
;	       |  | ___________ File Stream 2
;	       |  | |
;	       |  | |---
;	       |  | |  |
;	       |  | |  |
;	       ---- ----
;	       pgdf pgdf <-
;	       1111 2222 <- See TAG CMD for these flags p1 thru r2
;
;	STRUCT 7654 3210 Bit pattern
;
;	P = No pattern matching allowed
;	G = Only one filename allowed
;	D = You have to specify a drive number
;	F = You have to specify a filename
;
; NOTES: The struct and parsed_commands are used as follows:
;	The parsexq routine checks the parsed_commands variable to see
;	if the current command in the command buffer needs to be parsed and
;	if it does it will call tagcmd which will parse the command for the
;	number of filenames, drives etc. Once it has parsed the command buffer
;	it will take this value, and AND it with STRUCT (CMDNUM).  Please NOTE
;	the -1 on STRUCT, this is to allow the COPY command not to be parsed
;	but to allow itself to preprocess the begining of the command
;	buffer, then to call TAG30 (tagcmd) to check to parameters to ensure
;	they are correct.

	.page
struct	= *-parsed_commands+2				;Where structure images start	[911028] FAB

	.byte %01010001	; diskcopy  1 filename		8
	.byte %11111111	; period			9	UNUSED			[910725]
	.byte %01010101	; rename			A	now allow RO
	.byte %00011100	; scratch			B
	.byte %10011110	; new				C
	.byte %00011100	; New file commands		D
	.byte %10011000	; SELECT_PARTITION		E	PSEUDO			[900624]
	.byte %00011100	; load				F	PSEUDO			[900804]

modlst	.byte 'RWAMF'	; mode table	Read, Write, Append, Modify, Free
;	       01234	;		Value left in MODE using the above table

	.page
;	File type table
;

tplst	.byte 'DSPULCJF'
typlst	.byte 'DSPURCDF'	; del, seq, prg, usr, rel, djj, fab
tp1lst	.byte 'EERSEBJA'
tp2lst	.byte 'LQGRLMJB'

ntypes	= tp1lst-typlst

;
;	Error flag vars for bit
;
				; N V Z	 Processor status flags
er00	.byte 0			; 0 0 1
er0	.byte $3f		; 0 0 0
er1	.byte $7f		; 0 1 0
er2	.byte $bf		; 1 0 0
er3	.byte $ff		; 1 1 0

	.page
;	Table for user commands
;

ublock	.word ublkrd		;1	  A
	.word ublkwt		;2	  B
	.word userbuffer0	;3	  C				[911010]
	.word userbuffer0+3	;4	  D	(was unnew)		"
	.word userbuffer0+6	;5	  E	(was compress)		"
	.word userbuffer0+9	;6	  F				"
	.word userbuffer0+12	;7	  G				"
	.word userbuffer0+15	;8	  H				"
	.word message		;9	  I				[910313]
	.word do_DiskInit	;10	  J				[910313]
	.word userbuffer1	;11	  K				[911010]
	.word userbuffer1+3	;12	  L				"
	.word userbuffer1+6	;13	  M				"
	.word unnew		;14	  N				"
	.word compress		;15	  O				"


;.end
	.page
	.subttl	 RELATIVE FILE SUBROUTINES  v901029

;***********************************
;* GET_NEXT_RECORD
;***********************************

get_next_record			;nxtrec.
	lda #ovrflo
	jsr clrflg
	lda #lrf
	jsr tstflg_1
	bne nxtr40
	inc recl,x		;goto next record #
	bne 10$
	inc rech,x

10$	lda next_record,x
	beq nxtr45		;there is a next record so branch
	jsr getpnt_1		;get pointer
	ldx lindx		;test if same buffer
	cmp next_record,x
	bcc 20$			;	yes bt<nr

	jsr nrbuf		;	no- next buffer

	ldx lindx
20$	lda next_record,x
	jsr setpnt		;advance to next rec
	lda (buftab,x)		;read 1st data byte
	sta data		;save for read channel
	lda #ovrflo
	jsr clrflg		;clear the overflow flag
	jsr addnr		;advance next_record

nxout	pha			;<<< entry from Position
	bcc nxtr30		;no block boundary

	lda #0
	jsr drdbyt		;check track link
	bne nxtr30		;not last block
	pla
	cmp #2
	beq nxtr50

nxtr45	lda #lrf
	jsr setflg

nxtr40	jsr getpre
	lda buftab,x
	sta lstchr,y
	lda #cr
	sta data
	rts

nxtr50	jsr nxtr35
	ldx lindx
	lda #0
	sta next_record,x
	rts

nxtr30	pla
nxtr35	ldx lindx
	sta next_record,x
	bra setlst

	.page
;*************************************************************************************
;  NRBUF	Next Records BUFfer
;*************************************************************************************

nrbuf	jsr setdrn		;read trk,sec link
	jsr rdlnk
	jsr gaflgs		;test if dirty
	bvc 10$			;	clean, don't write out

	jsr wrtout		;	dirty, write out
	jsr dblbuf		;	toggle active buffer
	lda #2			;	Move past link bytes
	jsr setpnt
	jsr test_write_mode	;test if lstjob is a write

;*************************************************************************************
;  Corrects rel bug a,b,c reported many times in different mags such as Transactor...
;*************************************************************************************
;	bne nrbu20		;(was branch to rts)
	bne 20$			;Not a write, buffer ok
	beq rdab		;read in needed buffer

10$	jsr dblbuf		;toggle act buf
	jsr test_write_mode	;was lstjob a wrt?
	bne 20$			;not a write
	jsr rdab		;read in needed buffer			was beq	[911018] FAB

20$	jsr rdlnk		;read trk,sec link to do a read ahead
	lda track		;test if last buffer
	beq relput_rts		;	yes, no dbl buff to do

	jsr dblbuf		;start read job on the
	jsr rdab		;inactive buffer
	bra dblbuf

relput_rts
	rts

	.page
;**********************************
;* RELPUT
;**********************************

relput	jsr sdirty		;write data to buffer
	jsr getact
	asl a
	tax
	lda data
	sta (buftab,x)
	ldy lindx
	lda buftab,x		;inc the pointer
	inc a
	bne 10$
	lda next_record,y
	beq 20$
	lda #2
10$	cmp next_record,y	;test if next_record=pointer
	bne 30$			;	no, set new pointer

20$	lda #ovrflo		;	yes, set overflow
	bra setflg

30$	inc buftab,x		;write back new pointer
	bne relput_rts		;test if =0
	bra nrbuf		;prepare nxt buffer

	.page
;*********************************
;* WRITE_RELATIVE
;*********************************

write_relative			;wrtrel.
	lda #0
	jsr sta_erword		;everything's okay we send something			[911025] DJJ
	lda #lrf+ovrflo		;check all flags
	jsr tstflg
	bne 40$			;	some flag is set

10$	lda data		;ready to put data
	jsr relput
	bbr4 bit_flag_1,30$	;	EOI?  branch if not				[900622]
	rts

20$	lda #ovrflo
	jsr tstflg
	beq 30$			;	no rec overflow
	lda #recovf		;Allow user to send all of the 'PRINT' statement
	jsr sta_erword		;he does not receive the error until he sends		[910313]
				;an UNLSTN command.

30$	jsr clrec		;clear rest of record
	jsr rd40
	jsr lda_erword		;Any errors occur?
	beq okerr		;	no
	bra cmderr		;	yes

40$	and #lrf
	bne 50$			;last rec, add
	bbr4 bit_flag_1,20$	;EOI?  branch if not					[900622]
	rts

50$	lda data
	pha
	jsr addrel		;add to file
	pla
	sta data
	lda #lrf
	jsr clrflg
	bra 10$

	.page
;*************************************************************************
;*  CLREC	Clear Record: fill the remainder of a record with zero's
;*		until an overflow occurs.
;*************************************************************************

clrec	lda #ovrflo		;put 0's into rest of record
	jsr tstflg
	bne clrec_rts
	lda #0
	sta data
	jsr relput
	bra clrec

;*************************************************************************
;*  Set DIRTY flag in BUF0 [LBUSED]
;*************************************************************************

sdirty	lda #dyfile
	jsr setflg
	jsr gaflgs
	ora #dyfile		;Set buffer dirty flag
	ldx lbused
	sta buf0,x
clrec_rts
	rts



;*************************************************************************
;*  Clear DIRTY flag in BUF0 [LBUSED]
;*************************************************************************

cdirty	jsr gaflgs
	and #$ff-dyfile		;Clear buffer dirty flag
	ldx lbused
	sta buf0,x
	rts

	.page
;*************************************************************************
;* ReaD RELative byte get next sector if required
;*************************************************************************

rdrel	lda #lrf
	jsr tstflg
	bne rd05		;no record error

	jsr getpre
	lda buftab,x
	cmp lstchr,y
	beq rd40

	inc buftab,x
	bne rd20

	jsr nrbuf
rd15	jsr getpre
rd20	lda (buftab,x)
rd25	sta chndat,y
	lda #rndrdy
	sta chnrdy,y
	lda buftab,x
	cmp lstchr,y
	bne 10$
	lda #rndeoi
	sta chnrdy,y
10$	rts

rd40	jsr get_next_record
	jsr getpre
	lda data
	bra rd25

rd05	ldx lindx		;no record char set up
	lda #cr
	sta chndat,x
	lda #rndeoi		;set EOI to generate a RNF error
	sta chnrdy,x
	bra record_not_found

	.page
;**********************************
;* SETLST
;**********************************

setlst	ldx lindx
	lda next_record,x
	sta r1
	dec r1
	cmp #2
	bne 10$
	lda #$ff
	sta r1

10$	lda record_size,x
	sta r2
	jsr getpnt
	ldx lindx
	cmp r1
	bcc 30$
	beq 30$

	jsr dblbuf
	jsr fndlst
	bcc 20$

	ldx lindx
	sta lstchr,x
	bra dblbuf

20$	jsr dblbuf
	lda #$ff
	sta r1

30$	jsr fndlst
	bcs 40$
	jsr getpnt

40$	ldx lindx
	sta lstchr,x
	rts

	.page
;*********************************
;* FNDLST
;*********************************

fndlst	jsr set00
	ldy r1			;offset to start at
10$	lda (dirbuf),y
	bne 30$
	dey
	cpy #2			;Exhaused all of the pointers?
	bcc 20$			;	yes
	dec r2			;limit counter
	bne 10$

20$	dec r2			;not found here
	clc
	rts

30$	tya			;found the end char, return the pointer in A & Y
	sec
	rts

	.page
;********************************************************
;*		  FiND RELative file			*
;*		     version 2.8			*
;*							*
;* inputs:						*
;*  recl	- 1 byte = lo record #			*
;*  rech	- 1 byte = hi record #			*
;*  record_size - 1 byte = record size			*
;*  recptr	- 1 byte = 1st byte wanted from record	*
;*							*
;* outputs:						*
;*  ssnum	- 1 byte = side sector #		*
;*  ssind	- 1 byte = index into side_sector	*
;*  relptr	- 1 byte = ptr to first byte wanted	*
;*							*
;* Corrected split sector bug  9/29/89 Dennis Jarvis	*
;********************************************************

fndrel	jsr mulply		;result = rn*rs+rp
	jsr div254		;divide by 254
	lda accum+1		;save remainder
	sta relptr
	jsr div120		;divide by 120
	inc relptr
	inc relptr
	bbs5 bit_flag_2,10$	;branch if big relative file			[901127]
	lda result		;save quotient
	sta ssnum
	lda accum+1		;save remainder
	asl a			;calc index into side_sector
	clc
	adc #16			;skip link table
	sta ssind
	rts


10$	lda accum+1
	asl a
	clc
	adc #16
	sta ssind
	jsr div006
	lda accum+1
	sta ssnum
	lda result
	sta grpnum
	rts

	.page
; MULTIPLY
;
; result = recnum*rs+recptr
; destroys .a, .x

mulply	jsr zerres		;result=0
	sta accum+3		;a = 0
	ldx lindx		;get index
	lda recl,x
	sta accum+1
	lda rech,x
	sta accum+2
	bne 10$			;adjust for rec #1 &...
	lda accum+1		;...#0 = 1st rec
	beq 20$

10$	lda accum+1
	sec
	sbc #1
	sta accum+1
	bcs 20$
	dec accum+2
20$	lda record_size,x	;copy record size
	sta temp

30$	lsr temp		;do an add?
	bcc 40$			;no
	jsr addres		;result = result+accum+1,2,3

40$	jsr accx2		;2*(accum+1,2,3)
	lda temp		;done ?
	bne 30$			;no
	lda recptr		;add in last bit
	clc
	adc result
	sta result
	bcc 50$			;skip no carry
	inc result+1
	bne 50$
	inc result+2
50$	rts

	.page
; DIVIDE
;
; result = quotient, accum+1 = remainder
;
; destroys .a, .x, .y

div254	lda #254		;divide by 254
	   .byte $2c

div120	lda #120		;divide by 120
	   .byte $2c

div006	lda #6			;divide by 6
	sta temp		;8 bit divisor
	lda #0
	sta accum+1		;clear partial dividend
	sta accum+2
	ldx #24			;24 bit dividend

10$	asl result
	rol result+1
	rol result+2
	rol accum+1
	rol accum+2
	lda accum+1
	sec
	sbc temp
	tay			;save result
	lda accum+2
	sbc #0			;ripple the carry
	bcc 20$			;branch if temp > dividend
	inc result
	sta accum+2
	sty accum+1
20$	dex
	bne 10$
	rts

	.page
; ZERO RESULT
;

zerres	lda #0
	sta result
	sta result+1
	sta result+2
	rts

;
; multiply accum by 2
;

accx2	clc
	rol accum+1
	rol accum+2
	rol accum+3
	rts

;
; ADD ACCUM TO RESULT
;
; result = result+accum+1,2,3
;

addres	clc
	ldx #$fd
10$	lda result+3,x		;use non zero page locations
	adc accum+4,x
	sta result+3,x
	inx
	bne 10$

;	ldx #0			;						[901114] FAB
;11$	lda result,x
;	adc accum+1,x
;	sta result,x
;	inx
;	cpx #$03
;	bcc 11$
;	ldx #0
rdsss_rts
	rts

	.page
; READ/WRITE THE SUPER SIDE SECTOR
;

rdsss	ldx lindx		;Check to see if the Super Side
	lda #254		;Sector GRouP is resident in RAM?
	cmp sssgrp,x
;	bne rdsss_rts		;No then exit					[901114] FAB
	beq rdsss_rts

rdsssa	lda #read		;Read super side sector
	   .byte $2c
wrtsss	lda #write		;Write super side sector
	pha
	jsr setdrn		; set drive
	ldx lindx
	lda ssstrk,x		; set track
	sta track
	lda ssssec,x		; set sector
	sta sector
	lda #255		;Mark the group NOT resident
	sta sssgrp,x		;Just in case there's an error in DOJOB!
	lda side_sector,x	;get side_sector buffer #
	sta jobnum
	jsr seth		;Set the job header
	pla			;Get the job
	jsr dojob		;Do the job
	ldx lindx		;Job executed okay so mark
	lda #254		;the super side sector as resident
	sta sssgrp,x
rdlg_rts
	rts

	.page
; READ LAST GROUP
;

rdlg	lda #$5a		;Get the HIGRouP number HIGRP
	sta grpnum		;save it
	jsr rdss1		;Go read it in
	beq rdlg_rts		;If available branch
10$	dec grpnum		;Try the next lower group
	lda grpnum		;The the number
	jsr read_side_sector_1c	;Go read it in
;	beq rdlg_rts		;If it's already there branch			[901114] FAB
	bne 10$			;						"
	rts			;						"

	.page
;  READ SIDE SECTOR 1 OF GROUP N
;

rdss1	ldx lindx		;Acc = group # desired
	cmp sssgrp,x		;Is it resident
	beq rdlg_rts		;yes then branch
	pha			;save desired group #
	jsr rdsss		;ReaD in the Super Side Sector
rdss1d	jsr setdrn		;set the drive #
	lda #3
	jsr ssdir		;point to the first group
	pla			;restore desired group #

read_side_sector_1c		;rdss1c.
	tax			;save desired group #
	asl a			;*2
	tay
	lda (dirbuf),y		;get the track
	bne read_side_sector_1b	;does exist
	ora #255		;does not exist (return code)
	rts

read_side_sector_1b		;rdss1b.
	sta track
	iny
	lda (dirbuf),y		;get the sector
	sta sector
	phx			;restore desired group #
	lda #255		;Show the group as not beoing
	ldx lindx		;Resident incase of an error
	sta sssgrp,x		;in DOJOB
	lda side_sector,x	;get side_sector buffer #
	sta jobnum
	jsr seth		;set the job header
	lda #read
	jsr dojob		;read the side_sector in
	ldx lindx
	pla			;get the group # back
	sta sssgrp,x		;mark the group as resident
	lda #0			;return code
	rts

;.end
	.page
	.subttl	 COMPRESS  900220

compress
	lda bufind		;Set up buffer #0 as the target buffer
	sta dirbuf+1		;where the new dir sector is going to be built
	jsr fillbuffer
	inc t0			;Point to the sector link for the target sector
				;so that the 1st 'INC T0' in ADDENT moves the
				;pointer to the file status byte
	ldy drvnum
	lda dirtrk,y
	sta track
	lda dirst,y		;Set the DIRectory SecTor
	sta sector
	lda #1
	jsr seth
	bra 10$

5$	lda track		;Is this the last directory sector?
	beq 50$			;	yes

10$	lda #0			;Buffer 0
	sta jobnum
	jsr seth
	jsr doread		;Read in the directory sector
	lda #0			;Point to the T and S links to
	sta dirbuf		;The next directory sector
	tay			;Point to the track link
	lda (dirbuf),y
	sta track		;Is this the last directory sector?
	beq 20$			;	yes
	iny			;	no- get the sector
	lda (dirbuf),y
	sta sector
	jsr frets		;	    free this directory track and sector

20$	lda #2
	sta dirbuf		;Move to file status byte
30$	ldy #0
	lda (dirbuf),y		;Is this is a splat file?
	bpl 40$			;Yes then branch

;  Bug:  When the diskette contains a splat file, this code will treat it the same
;  way it does a scratched file.  When the file was opened it claimed two sectors on
;  the disk (allocated in the bam by INTTS routine).  When this directory sector is
;  compressed, this code will leave the two sectors allocated.

	jsr addent		;Add it to the new directory

40$	lda #32
	clc
	adc dirbuf
	sta dirbuf
	bcc 30$			;branch if we're not done with the last filename
	bcs 5$			;else read the next directory sector

50$	lda #0			;Last sector
	sta t0
	tay
	sta (t0),y
	iny
	sty jobnum
	lda #$ff
	sta (t0),y
	jmp dowrit

	.page
addent	ldy #0			;Start at the file status byte in the name to be xfered
	ldx #30			;
10$	inc t0
	lda t0			;If this was the last filename
	cmp #1			;That can fit into this buffer
	beq 20$			;Branch to go get another one

	phy
	lda (dirbuf),y
	ldy #0
	sta (t0),y
	ply			;Restore index into souce fname
	iny			;Bump by one
	dex			;-1 on destination location
	bne 10$

	inc t0
	inc t0
	lda t0
	cmp #1
	bne 15$
	dec t0
15$	rts

20$	lda track		;Save the Track and sector of
	pha			;This directory sector
	lda sector
	pha
	ldy drvnum		;						[900415]
	lda dirtrk,y		;Set up the T and S of the 1st
	sta track		;Directory sector
;	lda dirsec,y
	lda dirst,y		;Was dirsec (bug)				[910512]
	sta sector
	jsr nxtds		;Scan the directory track until one is found
	ldy #0			;Place the links to the next
	lda sector		;Directory sector in the current
	sta (t0),y		;Directory sector that is in RAM
	dec t0
	lda track
	sta (t0),y
	lda #1
	sta jobnum
	jsr dowrit		;Write the current directory track in RAM to disk
	lda #1			;Set up the T and S links to the next directory sector
	jsr seth		;(the one just allocated by NXTDS)
	pla
	sta sector
	pla
	sta track
	jsr fillbuffer
	lda #1			;Point to the SECTOR link
	sta t0
	ldx #30			;Reset the number of bytes to be xfered for each filename
	bra 10$

	.page
; ***************************************************************************************
; *    Fill buffer 1 with zero's and exit with T0 pointing to the start of buffer 1	*
; ***************************************************************************************

fillbuffer
	lda bufind+1		;Set up the address of this
	sta t0+1		;Buffer (Y) in T0
	lda #0
	sta t0
	tay
10$	sta (t0),y
	iny
	bne 10$
	rts

;.end
	.page
	.subttl  Extra Stuff ????

; Called by FormatDisk if verification is required (IOBYTE=bit7 set)		[911008] FAB

VerifyDisk
;	smb0 bit_flag_2		;Want errors returned to me
	lda #$ff		;Seek track zero
	ldx cdrive
	sta curtrk,x
	jsr InitCtlr		;Init drive
	lda #$ff
	ldx cdrive		;Force a future bump
	sta curtrk,x		;(have to- head is now at track 80, DOS thinks it's at 1)
	ldz #rds		;read sector command

; FOR track = 1 to 80 .........................

	lda #0			;Start at track 0
5$	sta track1

; FOR side = 0 TO 1 ...........................

	ldx #0			;Start on side 0
10$	stx sider1
	lda sidemask,x		;	flip it for 1581 compatibility
	ora cdrive		;	add drive#
	ora #motor		;	add motor
	sta control		;Select drive (no need to decouple or busywait)

; FOR sector = 1 TO 10 ........................

	lda #1			;Start on sector 1
20$	sta sector1

	stz command		;READ a sector
	jsr CheckEr		;	busywait & check for errors
	  bcs 99$		;	there was an error, and caller wants control back

	lda sector1		;NEXT sector .............................
	inc a
	cmp #10+1
	bcc 20$

	ldx sider1		;NEXT side ...............................
	inx
	cpx #1+1
	bcc 10$

	lda track1		;NEXT track ..............................
	inc a
	cmp #80			;	done?
	bcs 30$			;		yes

	tax
	lda #stout
	sta command		;Step
	jsr SettleHead		;	busywait & delay 24ms
	txa
	bra 5$			;Continue until done

; Diskette verification done

30$ ;	rmb0 bit_flag_2		;Clear error return flag
	clc			;good return
99$	rts			;error return (error # in .a)

;99$	rmb0 bit_flag_2		;Clear error return flag
;	sec			;error return (error # in .a)
;	rts


;.end
	.page
	.subttl C65 DOS Cross Reference Listing
	.end
